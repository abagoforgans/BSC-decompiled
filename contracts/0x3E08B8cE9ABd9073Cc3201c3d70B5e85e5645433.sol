contract main {




// =====================  Runtime code  =====================


#
#  - add(uint256 arg1, address arg2, bool arg3)
#
const BONUS_MULTIPLIER = 1


address owner;
address frogAddress;
address wbnbAddress;
address routerAddress;
address fundsAddress;
uint256 bonusEndBlock;
uint256 frogPerBlock;
uint256 halvingPeriod;
array of struct poolInfo;
mapping of struct userInfo;
uint256 totalAllocPoint;
uint256 startBlock;

function poolLength() payable {
    return poolInfo.length
}

function poolInfo(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 < poolInfo.length
    return poolInfo[arg1].field_0, poolInfo[arg1].field_256, poolInfo[arg1].field_512, poolInfo[arg1].field_768
}

function totalAllocPoint() payable {
    return totalAllocPoint
}

function bonusEndBlock() payable {
    return bonusEndBlock
}

function frog() payable {
    return frogAddress
}

function startBlock() payable {
    return startBlock
}

function halvingPeriod() payable {
    return halvingPeriod
}

function wbnb() payable {
    return wbnbAddress
}

function owner() payable {
    return owner
}

function userInfo(uint256 arg1, address arg2) payable {
    require calldata.size - 4 >= 64
    return userInfo[arg1][arg2].field_0, userInfo[arg1][arg2].field_256
}

function frogPerBlock() payable {
    return frogPerBlock
}

function funds() payable {
    return fundsAddress
}

function router() payable {
    return routerAddress
}

function _fallback() payable {
    revert
}

function fundsUpdate(address arg1) payable {
    require calldata.size - 4 >= 32
    if fundsAddress != msg.sender:
        revert with 0, 'funds: wut?'
    fundsAddress = arg1
}

function renounceOwnership() payable {
    if owner != msg.sender:
        revert with 0, 'wOwnable: caller is not the owne'
    emit OwnershipTransferred(owner, 0);
    owner = 0
}

function getCurrentHalvFactor() payable {
    if startBlock > block.number:
        revert with 0, 'SafeMath: subtraction overflow'
    if not halvingPeriod:
        revert with 0, 'SafeMath: division by zero'
    return 2^(block.number - startBlock / halvingPeriod)
}

function getHalvFactor(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if startBlock > arg1:
        revert with 0, 'SafeMath: subtraction overflow'
    if not halvingPeriod:
        revert with 0, 'SafeMath: division by zero'
    return 2^(arg1 - startBlock / halvingPeriod)
}

function getCurrentRewardPerBlock() payable {
    if block.number <= startBlock:
        return 0
    if startBlock > block.number:
        revert with 0, 'SafeMath: subtraction overflow'
    if not halvingPeriod:
        revert with 0, 'SafeMath: division by zero'
    require 2^(block.number - startBlock / halvingPeriod)
    return (frogPerBlock / 2^(block.number - startBlock / halvingPeriod) / 10^18)
}

function getRewardPerBlock(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if block.number <= startBlock:
        return 0
    if startBlock > arg1:
        revert with 0, 'SafeMath: subtraction overflow'
    if not halvingPeriod:
        revert with 0, 'SafeMath: division by zero'
    require 2^(arg1 - startBlock / halvingPeriod)
    return (frogPerBlock / 2^(arg1 - startBlock / halvingPeriod) / 10^18)
}

function transferOwnership(address arg1) payable {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'wOwnable: caller is not the owne'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    38,
                    0xfe4f776e61626c653a206e6577206f776e657220697320746865207a65726f20616464726573,
                    mem[202 len 26]
    emit OwnershipTransferred(owner, arg1);
    owner = arg1
}

function getMultiplier(uint256 arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    if arg2 <= bonusEndBlock:
        if arg1 > arg2:
            revert with 0, 'SafeMath: subtraction overflow'
        if not arg2 - arg1:
            return 0
        if arg2 - arg1 / arg2 - arg1 != 1:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
    else:
        if arg1 >= bonusEndBlock:
            if arg1 > arg2:
                revert with 0, 'SafeMath: subtraction overflow'
        else:
            if bonusEndBlock > arg2:
                revert with 0, 'SafeMath: subtraction overflow'
            if arg1 > bonusEndBlock:
                revert with 0, 'SafeMath: subtraction overflow'
            if not bonusEndBlock - arg1:
                if arg2 - bonusEndBlock < 0:
                    revert with 0, 'SafeMath: addition overflow'
                return (arg2 - bonusEndBlock)
            if bonusEndBlock - arg1 / bonusEndBlock - arg1 != 1:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
            if arg2 < bonusEndBlock:
                revert with 0, 'SafeMath: addition overflow'
    return (arg2 - arg1)
}

function emergencyWithdraw(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 < poolInfo.length
    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
        revert with 0, 'Address: call to non-contract'
    if not ext_code.hash(poolInfo[arg1].field_0):
        revert with 0, 'Address: call to non-contract'
    mem[260 len 64] = unknown_0xa9059cbb(?????), msg.sender, userInfo[arg1][msg.sender].field_32
    call poolInfo[arg1].field_0 with:
       funct uint32(msg.sender)
         gas gas_remaining wei
        args userInfo[arg1][msg.sender].field_0, mem[324 len 4]
    if not return_data.size:
        if not ext_call.success:
            revert with unknown_0xa9059cbb(?????), msg.sender, userInfo[arg1][msg.sender].field_0
        if not unknown_0xa9059cbb(?????), Mask(224, 32, msg.sender) >> 32:
            revert with 0, 32, 42, 0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565, mem[370 len 22]
    else:
        mem[292 len return_data.size] = ext_call.return_data[0 len return_data.size]
        if not ext_call.success:
            if return_data.size:
                revert with ext_call.return_data[0 len return_data.size]
            revert with 0, 'SafeERC20: low-level call failed'
        if return_data.size:
            require return_data.size >= 32
            if not mem[292]:
                revert with 0, 
                            32,
                            42,
                            0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                            mem[ceil32(return_data.size) + 371 len 22]
    emit EmergencyWithdraw(userInfo[arg1][msg.sender].field_0, msg.sender, arg1);
    userInfo[arg1][msg.sender].field_0 = 0
    userInfo[arg1][msg.sender].field_256 = 0
}

function pendingFrog(uint256 arg1, address arg2) payable {
    require calldata.size - 4 >= 64
    require arg1 < poolInfo.length
    require ext_code.size(poolInfo[arg1].field_0)
    staticcall poolInfo[arg1].field_0.0x70a08231 with:
            gas gas_remaining wei
           args this.address
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if block.number <= poolInfo[arg1].field_512:
        if not userInfo[arg1][address(arg2)].field_0:
            if userInfo[arg1][address(arg2)].field_256 > 0:
                revert with 0, 'SafeMath: subtraction overflow'
            return -userInfo[arg1][address(arg2)].field_256
        if poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0 / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        33,
                        0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[197 len 31]
        if userInfo[arg1][address(arg2)].field_256 > poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0 / 10^12:
            revert with 0, 'SafeMath: subtraction overflow'
        return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0 / 10^12) - userInfo[arg1][address(arg2)].field_256)
    if not ext_call.return_data[0]:
        if not userInfo[arg1][address(arg2)].field_0:
            if userInfo[arg1][address(arg2)].field_256 > 0:
                revert with 0, 'SafeMath: subtraction overflow'
            return -userInfo[arg1][address(arg2)].field_256
        if poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0 / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        33,
                        0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[197 len 31]
        if userInfo[arg1][address(arg2)].field_256 > poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0 / 10^12:
            revert with 0, 'SafeMath: subtraction overflow'
        return ((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0 / 10^12) - userInfo[arg1][address(arg2)].field_256)
    if block.number <= bonusEndBlock:
        if poolInfo[arg1].field_512 > block.number:
            revert with 0, 'SafeMath: subtraction overflow'
        if not block.number - poolInfo[arg1].field_512:
            if startBlock > block.number:
                revert with 0, 'SafeMath: subtraction overflow'
            if not halvingPeriod:
                revert with 0, 'SafeMath: division by zero'
            if not totalAllocPoint:
                revert with 0, 'SafeMath: division by zero'
            if not 2^(block.number - startBlock / halvingPeriod):
                revert with 0, 'SafeMath: division by zero'
            if not 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod):
                if not ext_call.return_data[0]:
                    revert with 0, 'SafeMath: division by zero'
                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[581 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            if 10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) != 10^12:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
            if not ext_call.return_data[0]:
                revert with 0, 'SafeMath: division by zero'
            if (10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256
            if (10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[581 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return (((10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
        if block.number - poolInfo[arg1].field_512 / block.number - poolInfo[arg1].field_512 != 1:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
        if startBlock > block.number:
            revert with 0, 'SafeMath: subtraction overflow'
        if not halvingPeriod:
            revert with 0, 'SafeMath: division by zero'
        if not block.number - poolInfo[arg1].field_512:
            if not totalAllocPoint:
                revert with 0, 'SafeMath: division by zero'
            if not 2^(block.number - startBlock / halvingPeriod):
                revert with 0, 'SafeMath: division by zero'
            if not 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod):
                if not ext_call.return_data[0]:
                    revert with 0, 'SafeMath: division by zero'
                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[581 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            if 10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) != 10^12:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
            if not ext_call.return_data[0]:
                revert with 0, 'SafeMath: division by zero'
            if (10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256
            if (10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[581 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return (((10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
        if (block.number * frogPerBlock) - (poolInfo[arg1].field_512 * frogPerBlock) / block.number - poolInfo[arg1].field_512 != frogPerBlock:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
        if not (block.number * frogPerBlock) - (poolInfo[arg1].field_512 * frogPerBlock):
            if not totalAllocPoint:
                revert with 0, 'SafeMath: division by zero'
            if not 2^(block.number - startBlock / halvingPeriod):
                revert with 0, 'SafeMath: division by zero'
            if not 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod):
                if not ext_call.return_data[0]:
                    revert with 0, 'SafeMath: division by zero'
                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[581 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            if 10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) != 10^12:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
            if not ext_call.return_data[0]:
                revert with 0, 'SafeMath: division by zero'
            if (10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256
            if (10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[581 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return (((10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
        if (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / (block.number * frogPerBlock) - (poolInfo[arg1].field_512 * frogPerBlock) != poolInfo[arg1].field_256:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
        if not totalAllocPoint:
            revert with 0, 'SafeMath: division by zero'
        if not 2^(block.number - startBlock / halvingPeriod):
            revert with 0, 'SafeMath: division by zero'
        if not (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod):
            if not ext_call.return_data[0]:
                revert with 0, 'SafeMath: division by zero'
            if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256
            if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[581 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
        if 10^12 * (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) != 10^12:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
        if not ext_call.return_data[0]:
            revert with 0, 'SafeMath: division by zero'
        if (10^12 * (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
            revert with 0, 'SafeMath: addition overflow'
        if not userInfo[arg1][address(arg2)].field_0:
            if userInfo[arg1][address(arg2)].field_256 > 0:
                revert with 0, 'SafeMath: subtraction overflow'
            return -userInfo[arg1][address(arg2)].field_256
        if (10^12 * (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]) + poolInfo[arg1].field_768:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[581 len 31]
    else:
        if poolInfo[arg1].field_512 >= bonusEndBlock:
            if poolInfo[arg1].field_512 > block.number:
                revert with 0, 'SafeMath: subtraction overflow'
            if startBlock > block.number:
                revert with 0, 'SafeMath: subtraction overflow'
            if not halvingPeriod:
                revert with 0, 'SafeMath: division by zero'
            if not block.number - poolInfo[arg1].field_512:
                if not totalAllocPoint:
                    revert with 0, 'SafeMath: division by zero'
                if not 2^(block.number - startBlock / halvingPeriod):
                    revert with 0, 'SafeMath: division by zero'
                if not 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod):
                    if not ext_call.return_data[0]:
                        revert with 0, 'SafeMath: division by zero'
                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256
                    if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[581 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                if 10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) != 10^12:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                if not ext_call.return_data[0]:
                    revert with 0, 'SafeMath: division by zero'
                if (10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                if (10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[581 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            if (block.number * frogPerBlock) - (poolInfo[arg1].field_512 * frogPerBlock) / block.number - poolInfo[arg1].field_512 != frogPerBlock:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
            if not (block.number * frogPerBlock) - (poolInfo[arg1].field_512 * frogPerBlock):
                if not totalAllocPoint:
                    revert with 0, 'SafeMath: division by zero'
                if not 2^(block.number - startBlock / halvingPeriod):
                    revert with 0, 'SafeMath: division by zero'
                if not 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod):
                    if not ext_call.return_data[0]:
                        revert with 0, 'SafeMath: division by zero'
                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256
                    if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[581 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                if 10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) != 10^12:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                if not ext_call.return_data[0]:
                    revert with 0, 'SafeMath: division by zero'
                if (10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                if (10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[581 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            if (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / (block.number * frogPerBlock) - (poolInfo[arg1].field_512 * frogPerBlock) != poolInfo[arg1].field_256:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
            if not totalAllocPoint:
                revert with 0, 'SafeMath: division by zero'
            if not 2^(block.number - startBlock / halvingPeriod):
                revert with 0, 'SafeMath: division by zero'
            if not (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod):
                if not ext_call.return_data[0]:
                    revert with 0, 'SafeMath: division by zero'
                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[581 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            if 10^12 * (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) != 10^12:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
            if not ext_call.return_data[0]:
                revert with 0, 'SafeMath: division by zero'
            if (10^12 * (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256
            if (10^12 * (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[581 len 31]
        else:
            if bonusEndBlock > block.number:
                revert with 0, 'SafeMath: subtraction overflow'
            if poolInfo[arg1].field_512 > bonusEndBlock:
                revert with 0, 'SafeMath: subtraction overflow'
            if not bonusEndBlock - poolInfo[arg1].field_512:
                if block.number - bonusEndBlock < 0:
                    revert with 0, 'SafeMath: addition overflow'
                if startBlock > block.number:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not halvingPeriod:
                    revert with 0, 'SafeMath: division by zero'
                if not block.number - bonusEndBlock:
                    if not totalAllocPoint:
                        revert with 0, 'SafeMath: division by zero'
                    if not 2^(block.number - startBlock / halvingPeriod):
                        revert with 0, 'SafeMath: division by zero'
                    if not 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod):
                        if not ext_call.return_data[0]:
                            revert with 0, 'SafeMath: division by zero'
                        if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256
                        if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[645 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                    if 10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) != 10^12:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[581 len 31]
                    if not ext_call.return_data[0]:
                        revert with 0, 'SafeMath: division by zero'
                    if (10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256
                    if (10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[645 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return (((10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                if (block.number * frogPerBlock) - (bonusEndBlock * frogPerBlock) / block.number - bonusEndBlock != frogPerBlock:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                if not (block.number * frogPerBlock) - (bonusEndBlock * frogPerBlock):
                    if not totalAllocPoint:
                        revert with 0, 'SafeMath: division by zero'
                    if not 2^(block.number - startBlock / halvingPeriod):
                        revert with 0, 'SafeMath: division by zero'
                    if not 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod):
                        if not ext_call.return_data[0]:
                            revert with 0, 'SafeMath: division by zero'
                        if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256
                        if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[645 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                    if 10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) != 10^12:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[581 len 31]
                    if not ext_call.return_data[0]:
                        revert with 0, 'SafeMath: division by zero'
                    if (10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256
                    if (10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[645 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return (((10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                if (block.number * frogPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * frogPerBlock * poolInfo[arg1].field_256) / (block.number * frogPerBlock) - (bonusEndBlock * frogPerBlock) != poolInfo[arg1].field_256:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                if not totalAllocPoint:
                    revert with 0, 'SafeMath: division by zero'
                if not 2^(block.number - startBlock / halvingPeriod):
                    revert with 0, 'SafeMath: division by zero'
                if not (block.number * frogPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod):
                    if not ext_call.return_data[0]:
                        revert with 0, 'SafeMath: division by zero'
                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256
                    if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[645 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                if 10^12 * (block.number * frogPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / (block.number * frogPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) != 10^12:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[581 len 31]
                if not ext_call.return_data[0]:
                    revert with 0, 'SafeMath: division by zero'
                if (10^12 * (block.number * frogPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                if (10^12 * (block.number * frogPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * frogPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[645 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * frogPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((10^12 * (block.number * frogPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            if bonusEndBlock - poolInfo[arg1].field_512 / bonusEndBlock - poolInfo[arg1].field_512 != 1:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
            if block.number < bonusEndBlock:
                revert with 0, 'SafeMath: addition overflow'
            if startBlock > block.number:
                revert with 0, 'SafeMath: subtraction overflow'
            if not halvingPeriod:
                revert with 0, 'SafeMath: division by zero'
            if not block.number - poolInfo[arg1].field_512:
                if not totalAllocPoint:
                    revert with 0, 'SafeMath: division by zero'
                if not 2^(block.number - startBlock / halvingPeriod):
                    revert with 0, 'SafeMath: division by zero'
                if not 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod):
                    if not ext_call.return_data[0]:
                        revert with 0, 'SafeMath: division by zero'
                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256
                    if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[645 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                if 10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) != 10^12:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[581 len 31]
                if not ext_call.return_data[0]:
                    revert with 0, 'SafeMath: division by zero'
                if (10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                if (10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[645 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            if (block.number * frogPerBlock) - (poolInfo[arg1].field_512 * frogPerBlock) / block.number - poolInfo[arg1].field_512 != frogPerBlock:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
            if not (block.number * frogPerBlock) - (poolInfo[arg1].field_512 * frogPerBlock):
                if not totalAllocPoint:
                    revert with 0, 'SafeMath: division by zero'
                if not 2^(block.number - startBlock / halvingPeriod):
                    revert with 0, 'SafeMath: division by zero'
                if not 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod):
                    if not ext_call.return_data[0]:
                        revert with 0, 'SafeMath: division by zero'
                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256
                    if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[645 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                if 10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) != 10^12:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[581 len 31]
                if not ext_call.return_data[0]:
                    revert with 0, 'SafeMath: division by zero'
                if (10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                if (10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[645 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            if (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / (block.number * frogPerBlock) - (poolInfo[arg1].field_512 * frogPerBlock) != poolInfo[arg1].field_256:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
            if not totalAllocPoint:
                revert with 0, 'SafeMath: division by zero'
            if not 2^(block.number - startBlock / halvingPeriod):
                revert with 0, 'SafeMath: division by zero'
            if not (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod):
                if not ext_call.return_data[0]:
                    revert with 0, 'SafeMath: division by zero'
                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                if (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[645 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            if 10^12 * (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) != 10^12:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[581 len 31]
            if not ext_call.return_data[0]:
                revert with 0, 'SafeMath: division by zero'
            if (10^12 * (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256
            if (10^12 * (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != (10^12 * (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]) + poolInfo[arg1].field_768:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[645 len 31]
    ('eq', ('div', ('add', ('mul', ('div', ('mul', 1000000000000, ('div', ('div', ('add', ('mul', 'number', ('stor', ('name', 'frogPerBlock', 6)), ('field', 256, ('stor', ('array', ('mul', 4, ('param', 'arg1')), ('name', 'poolInfo', 8))))), ('mul', -1, ('field', 512, ('stor', ('array', ('mul', 4, ('param', 'arg1')), ('name', 'poolInfo', 8)))), ('stor', ('name', 'frogPerBlock', 6)), ('field', 256, ('stor', ('array', ('mul', 4, ('param', 'arg1')), ('name', 'poolInfo', 8)))))), ('stor', ('name', 'totalAllocPoint', 10))), ('exp', 2, ('div', ('add', 'number', ('mul', -1, ('stor', ('name', 'startBlock', 11)))), ('stor', ('name', 'halvingPeriod', 7)))))), ('ext_call.return_data', 0, 32)), ('field', 0, ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('map', ('param', 'arg1'), ('name', 'userInfo', 9)))))), ('mul', ('field', 768, ('stor', ('array', ('mul', 4, ('param', 'arg1')), ('name', 'poolInfo', 8)))), ('field', 0, ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('map', ('param', 'arg1'), ('name', 'userInfo', 9))))))), ('field', 0, ('stor', ('map', ('mask_shl', 160, 0, 0, ('param', 'arg2')), ('map', ('param', 'arg1'), ('name', 'userInfo', 9)))))), ('add', ('div', ('mul', 1000000000000, ('div', ('div', ('add', ('mul', 'number', ('stor', ('name', 'frogPerBlock', 6)), ('field', 256, ('stor', ('array', ('mul', 4, ('param', 'arg1')), ('name', 'poolInfo', 8))))), ('mul', -1, ('field', 512, ('stor', ('array', ('mul', 4, ('param', 'arg1')), ('name', 'poolInfo', 8)))), ('stor', ('name', 'frogPerBlock', 6)), ('field', 256, ('stor', ('array', ('mul', 4, ('param', 'arg1')), ('name', 'poolInfo', 8)))))), ('stor', ('name', 'totalAllocPoint', 10))), ('exp', 2, ('div', ('add', 'number', ('mul', -1, ('stor', ('name', 'startBlock', 11)))), ('stor', ('name', 'halvingPeriod', 7)))))), ('ext_call.return_data', 0, 32)), ('field', 768, ('stor', ('array', ('mul', 4, ('param', 'arg1')), ('name', 'poolInfo', 8))))))
    if userInfo[arg1][address(arg2)].field_256 > (10^12 * (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12:
        revert with 0, 'SafeMath: subtraction overflow'
    return (((10^12 * (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) + (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
}

function updatePool(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 < poolInfo.length
    if block.number > poolInfo[arg1].field_512:
        require ext_code.size(poolInfo[arg1].field_0)
        staticcall poolInfo[arg1].field_0.0x70a08231 with:
                gas gas_remaining wei
               args this.address
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if ext_call.return_data[0]:
            mem[96] = 30
            mem[128] = 'SafeMath: subtraction overflow'
            if block.number <= bonusEndBlock:
                if poolInfo[arg1].field_512 > block.number:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not block.number - poolInfo[arg1].field_512:
                    if startBlock > block.number:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not halvingPeriod:
                        revert with 0, 'SafeMath: division by zero'
                    if not totalAllocPoint:
                        revert with 0, 'SafeMath: division by zero'
                    if not 2^(block.number - startBlock / halvingPeriod):
                        revert with 0, 'SafeMath: division by zero'
                    require ext_code.size(frogAddress)
                    call frogAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args this.address, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod)
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require ext_code.size(frogAddress)
                    call frogAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args this.address, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[544] = wbnbAddress
                    if block.timestamp + 1800 < block.timestamp:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[576] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                    mem[580] = 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                    mem[612] = 0
                    mem[676] = fundsAddress
                    mem[708] = block.timestamp + 1800
                    mem[644] = 160
                    mem[740] = 2
                    mem[772 len 0] = None
                    require ext_code.size(routerAddress)
                    call routerAddress.swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                         gas gas_remaining wei
                        args 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20, 0, 160, fundsAddress, block.timestamp + 1800, 2, mem[772 len 64]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[576 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = ceil32(return_data.size) + 576
                    require return_data.size >= 32
                    _1360 = mem[576 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32
                    require mem[576 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 <= 4294967296
                    require mem[576 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 32 <= return_data.size
                    require mem[mem[576 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 576] <= 4294967296 and mem[576 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + (32 * mem[mem[576 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 576]) + 32 <= return_data.size
                    mem[ceil32(return_data.size) + 576] = mem[mem[576 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 576]
                    _1387 = mem[_1360 + 576]
                    mem[ceil32(return_data.size) + 608 len floor32(mem[_1360 + 576])] = mem[_1360 + 608 len floor32(mem[_1360 + 576])]
                    if not 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod):
                        if not ext_call.return_data[0]:
                            revert with 0, 'SafeMath: division by zero'
                        if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                    else:
                        if 10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) != 10^12:
                            revert with 0, 
                                        32,
                                        33,
                                        0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[(32 * _1387) + ceil32(return_data.size) + 709 len 31]
                        if not ext_call.return_data[0]:
                            revert with 0, 'SafeMath: division by zero'
                        if (10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]
                else:
                    if block.number - poolInfo[arg1].field_512 / block.number - poolInfo[arg1].field_512 != 1:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                    if startBlock > block.number:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not halvingPeriod:
                        revert with 0, 'SafeMath: division by zero'
                    if not block.number - poolInfo[arg1].field_512:
                        if not totalAllocPoint:
                            revert with 0, 'SafeMath: division by zero'
                        if not 2^(block.number - startBlock / halvingPeriod):
                            revert with 0, 'SafeMath: division by zero'
                        require ext_code.size(frogAddress)
                        call frogAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args this.address, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod)
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require ext_code.size(frogAddress)
                        call frogAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args this.address, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[544] = wbnbAddress
                        if block.timestamp + 1800 < block.timestamp:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[576] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                        mem[580] = 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                        mem[612] = 0
                        mem[676] = fundsAddress
                        mem[708] = block.timestamp + 1800
                        mem[644] = 160
                        mem[740] = 2
                        mem[772 len 0] = None
                        require ext_code.size(routerAddress)
                        call routerAddress.swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                             gas gas_remaining wei
                            args 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20, 0, 160, fundsAddress, block.timestamp + 1800, 2, mem[772 len 64]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[576 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = ceil32(return_data.size) + 576
                        require return_data.size >= 32
                        _1358 = mem[576 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32
                        require mem[576 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 <= 4294967296
                        require mem[576 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 32 <= return_data.size
                        require mem[mem[576 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 576] <= 4294967296 and mem[576 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + (32 * mem[mem[576 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 576]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 576] = mem[mem[576 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 576]
                        _1386 = mem[_1358 + 576]
                        mem[ceil32(return_data.size) + 608 len floor32(mem[_1358 + 576])] = mem[_1358 + 608 len floor32(mem[_1358 + 576])]
                        if not 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod):
                            if not ext_call.return_data[0]:
                                revert with 0, 'SafeMath: division by zero'
                            if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                        else:
                            if 10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) != 10^12:
                                revert with 0, 
                                            32,
                                            33,
                                            0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[(32 * _1386) + ceil32(return_data.size) + 709 len 31]
                            if not ext_call.return_data[0]:
                                revert with 0, 'SafeMath: division by zero'
                            if (10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]
                    else:
                        if (block.number * frogPerBlock) - (poolInfo[arg1].field_512 * frogPerBlock) / block.number - poolInfo[arg1].field_512 != frogPerBlock:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                        if not (block.number * frogPerBlock) - (poolInfo[arg1].field_512 * frogPerBlock):
                            if not totalAllocPoint:
                                revert with 0, 'SafeMath: division by zero'
                            if not 2^(block.number - startBlock / halvingPeriod):
                                revert with 0, 'SafeMath: division by zero'
                            require ext_code.size(frogAddress)
                            call frogAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args this.address, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod)
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(frogAddress)
                            call frogAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args this.address, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[544] = wbnbAddress
                            if block.timestamp + 1800 < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[576] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                            mem[580] = 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                            mem[612] = 0
                            mem[676] = fundsAddress
                            mem[708] = block.timestamp + 1800
                            mem[644] = 160
                            mem[740] = 2
                            mem[772 len 0] = None
                            require ext_code.size(routerAddress)
                            call routerAddress.swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20, 0, 160, fundsAddress, block.timestamp + 1800, 2, mem[772 len 64]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[576 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = ceil32(return_data.size) + 576
                            require return_data.size >= 32
                            _1356 = mem[576 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32
                            require mem[576 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 <= 4294967296
                            require mem[576 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 32 <= return_data.size
                            require mem[mem[576 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 576] <= 4294967296 and mem[576 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + (32 * mem[mem[576 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 576]) + 32 <= return_data.size
                            mem[ceil32(return_data.size) + 576] = mem[mem[576 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 576]
                            _1385 = mem[_1356 + 576]
                            mem[ceil32(return_data.size) + 608 len floor32(mem[_1356 + 576])] = mem[_1356 + 608 len floor32(mem[_1356 + 576])]
                            if not 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod):
                                if not ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: division by zero'
                                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                            else:
                                if 10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) != 10^12:
                                    revert with 0, 
                                                32,
                                                33,
                                                0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[(32 * _1385) + ceil32(return_data.size) + 709 len 31]
                                if not ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: division by zero'
                                if (10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]
                        else:
                            if (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / (block.number * frogPerBlock) - (poolInfo[arg1].field_512 * frogPerBlock) != poolInfo[arg1].field_256:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                            if not totalAllocPoint:
                                revert with 0, 'SafeMath: division by zero'
                            if not 2^(block.number - startBlock / halvingPeriod):
                                revert with 0, 'SafeMath: division by zero'
                            require ext_code.size(frogAddress)
                            call frogAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args this.address, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod)
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(frogAddress)
                            call frogAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args this.address, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[544] = wbnbAddress
                            if block.timestamp + 1800 < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[576] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                            mem[580] = (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                            mem[612] = 0
                            mem[676] = fundsAddress
                            mem[708] = block.timestamp + 1800
                            mem[644] = 160
                            mem[740] = 2
                            mem[772 len 0] = None
                            require ext_code.size(routerAddress)
                            call routerAddress.swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20, 0, 160, fundsAddress, block.timestamp + 1800, 2, mem[772 len 64]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[576 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = ceil32(return_data.size) + 576
                            require return_data.size >= 32
                            _1354 = mem[576 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32
                            require mem[576 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 <= 4294967296
                            require mem[576 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 32 <= return_data.size
                            require mem[mem[576 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 576] <= 4294967296 and mem[576 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + (32 * mem[mem[576 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 576]) + 32 <= return_data.size
                            mem[ceil32(return_data.size) + 576] = mem[mem[576 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 576]
                            _1384 = mem[_1354 + 576]
                            mem[ceil32(return_data.size) + 608 len floor32(mem[_1354 + 576])] = mem[_1354 + 608 len floor32(mem[_1354 + 576])]
                            if not (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod):
                                if not ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: division by zero'
                                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                            else:
                                if 10^12 * (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) != 10^12:
                                    revert with 0, 
                                                32,
                                                33,
                                                0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[(32 * _1384) + ceil32(return_data.size) + 709 len 31]
                                if not ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: division by zero'
                                if (10^12 * (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[arg1].field_768 += 10^12 * (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]
            else:
                if poolInfo[arg1].field_512 >= bonusEndBlock:
                    if poolInfo[arg1].field_512 > block.number:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if startBlock > block.number:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not halvingPeriod:
                        revert with 0, 'SafeMath: division by zero'
                    if not block.number - poolInfo[arg1].field_512:
                        if not totalAllocPoint:
                            revert with 0, 'SafeMath: division by zero'
                        if not 2^(block.number - startBlock / halvingPeriod):
                            revert with 0, 'SafeMath: division by zero'
                        require ext_code.size(frogAddress)
                        call frogAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args this.address, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod)
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require ext_code.size(frogAddress)
                        call frogAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args this.address, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[544] = wbnbAddress
                        if block.timestamp + 1800 < block.timestamp:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[576] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                        mem[580] = 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                        mem[612] = 0
                        mem[676] = fundsAddress
                        mem[708] = block.timestamp + 1800
                        mem[644] = 160
                        mem[740] = 2
                        mem[772 len 0] = None
                        require ext_code.size(routerAddress)
                        call routerAddress.swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                             gas gas_remaining wei
                            args 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20, 0, 160, fundsAddress, block.timestamp + 1800, 2, mem[772 len 64]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[576 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = ceil32(return_data.size) + 576
                        require return_data.size >= 32
                        _1352 = mem[576 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32
                        require mem[576 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 <= 4294967296
                        require mem[576 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 32 <= return_data.size
                        require mem[mem[576 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 576] <= 4294967296 and mem[576 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + (32 * mem[mem[576 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 576]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 576] = mem[mem[576 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 576]
                        _1383 = mem[_1352 + 576]
                        mem[ceil32(return_data.size) + 608 len floor32(mem[_1352 + 576])] = mem[_1352 + 608 len floor32(mem[_1352 + 576])]
                        if not 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod):
                            if not ext_call.return_data[0]:
                                revert with 0, 'SafeMath: division by zero'
                            if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                        else:
                            if 10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) != 10^12:
                                revert with 0, 
                                            32,
                                            33,
                                            0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[(32 * _1383) + ceil32(return_data.size) + 709 len 31]
                            if not ext_call.return_data[0]:
                                revert with 0, 'SafeMath: division by zero'
                            if (10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]
                    else:
                        if (block.number * frogPerBlock) - (poolInfo[arg1].field_512 * frogPerBlock) / block.number - poolInfo[arg1].field_512 != frogPerBlock:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                        if not (block.number * frogPerBlock) - (poolInfo[arg1].field_512 * frogPerBlock):
                            if not totalAllocPoint:
                                revert with 0, 'SafeMath: division by zero'
                            if not 2^(block.number - startBlock / halvingPeriod):
                                revert with 0, 'SafeMath: division by zero'
                            require ext_code.size(frogAddress)
                            call frogAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args this.address, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod)
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(frogAddress)
                            call frogAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args this.address, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[544] = wbnbAddress
                            if block.timestamp + 1800 < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[576] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                            mem[580] = 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                            mem[612] = 0
                            mem[676] = fundsAddress
                            mem[708] = block.timestamp + 1800
                            mem[644] = 160
                            mem[740] = 2
                            mem[772 len 0] = None
                            require ext_code.size(routerAddress)
                            call routerAddress.swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20, 0, 160, fundsAddress, block.timestamp + 1800, 2, mem[772 len 64]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[576 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = ceil32(return_data.size) + 576
                            require return_data.size >= 32
                            _1350 = mem[576 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32
                            require mem[576 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 <= 4294967296
                            require mem[576 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 32 <= return_data.size
                            require mem[mem[576 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 576] <= 4294967296 and mem[576 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + (32 * mem[mem[576 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 576]) + 32 <= return_data.size
                            mem[ceil32(return_data.size) + 576] = mem[mem[576 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 576]
                            _1382 = mem[_1350 + 576]
                            mem[ceil32(return_data.size) + 608 len floor32(mem[_1350 + 576])] = mem[_1350 + 608 len floor32(mem[_1350 + 576])]
                            if not 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod):
                                if not ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: division by zero'
                                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                            else:
                                if 10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) != 10^12:
                                    revert with 0, 
                                                32,
                                                33,
                                                0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[(32 * _1382) + ceil32(return_data.size) + 709 len 31]
                                if not ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: division by zero'
                                if (10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]
                        else:
                            if (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / (block.number * frogPerBlock) - (poolInfo[arg1].field_512 * frogPerBlock) != poolInfo[arg1].field_256:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                            if not totalAllocPoint:
                                revert with 0, 'SafeMath: division by zero'
                            if not 2^(block.number - startBlock / halvingPeriod):
                                revert with 0, 'SafeMath: division by zero'
                            require ext_code.size(frogAddress)
                            call frogAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args this.address, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod)
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(frogAddress)
                            call frogAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args this.address, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[544] = wbnbAddress
                            if block.timestamp + 1800 < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[576] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                            mem[580] = (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                            mem[612] = 0
                            mem[676] = fundsAddress
                            mem[708] = block.timestamp + 1800
                            mem[644] = 160
                            mem[740] = 2
                            mem[772 len 0] = None
                            require ext_code.size(routerAddress)
                            call routerAddress.swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20, 0, 160, fundsAddress, block.timestamp + 1800, 2, mem[772 len 64]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[576 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = ceil32(return_data.size) + 576
                            require return_data.size >= 32
                            _1348 = mem[576 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32
                            require mem[576 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 <= 4294967296
                            require mem[576 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 32 <= return_data.size
                            require mem[mem[576 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 576] <= 4294967296 and mem[576 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + (32 * mem[mem[576 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 576]) + 32 <= return_data.size
                            mem[ceil32(return_data.size) + 576] = mem[mem[576 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 576]
                            _1381 = mem[_1348 + 576]
                            mem[ceil32(return_data.size) + 608 len floor32(mem[_1348 + 576])] = mem[_1348 + 608 len floor32(mem[_1348 + 576])]
                            if not (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod):
                                if not ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: division by zero'
                                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                            else:
                                if 10^12 * (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) != 10^12:
                                    revert with 0, 
                                                32,
                                                33,
                                                0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[(32 * _1381) + ceil32(return_data.size) + 709 len 31]
                                if not ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: division by zero'
                                if (10^12 * (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[arg1].field_768 += 10^12 * (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]
                else:
                    if bonusEndBlock > block.number:
                        revert with 0, 'SafeMath: subtraction overflow'
                    mem[160] = 30
                    mem[192] = 'SafeMath: subtraction overflow'
                    if poolInfo[arg1].field_512 > bonusEndBlock:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not bonusEndBlock - poolInfo[arg1].field_512:
                        if block.number - bonusEndBlock < 0:
                            revert with 0, 'SafeMath: addition overflow'
                        if startBlock > block.number:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not halvingPeriod:
                            revert with 0, 'SafeMath: division by zero'
                        if not block.number - bonusEndBlock:
                            if not totalAllocPoint:
                                revert with 0, 'SafeMath: division by zero'
                            if not 2^(block.number - startBlock / halvingPeriod):
                                revert with 0, 'SafeMath: division by zero'
                            require ext_code.size(frogAddress)
                            call frogAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args this.address, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod)
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(frogAddress)
                            call frogAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args this.address, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[608] = wbnbAddress
                            if block.timestamp + 1800 < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[640] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                            mem[644] = 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                            mem[676] = 0
                            mem[740] = fundsAddress
                            mem[772] = block.timestamp + 1800
                            mem[708] = 160
                            mem[804] = 2
                            mem[836 len 0] = None
                            require ext_code.size(routerAddress)
                            call routerAddress.swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20, 0, 160, fundsAddress, block.timestamp + 1800, 2, mem[836 len 64]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[640 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = ceil32(return_data.size) + 640
                            require return_data.size >= 32
                            _1346 = mem[640 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32
                            require mem[640 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 <= 4294967296
                            require mem[640 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 32 <= return_data.size
                            require mem[mem[640 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 640] <= 4294967296 and mem[640 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + (32 * mem[mem[640 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 640]) + 32 <= return_data.size
                            mem[ceil32(return_data.size) + 640] = mem[mem[640 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 640]
                            _1380 = mem[_1346 + 640]
                            mem[ceil32(return_data.size) + 672 len floor32(mem[_1346 + 640])] = mem[_1346 + 672 len floor32(mem[_1346 + 640])]
                            if not 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod):
                                if not ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: division by zero'
                                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                            else:
                                if 10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) != 10^12:
                                    revert with 0, 
                                                32,
                                                33,
                                                0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[(32 * _1380) + ceil32(return_data.size) + 773 len 31]
                                if not ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: division by zero'
                                if (10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]
                        else:
                            if (block.number * frogPerBlock) - (bonusEndBlock * frogPerBlock) / block.number - bonusEndBlock != frogPerBlock:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                            if not (block.number * frogPerBlock) - (bonusEndBlock * frogPerBlock):
                                if not totalAllocPoint:
                                    revert with 0, 'SafeMath: division by zero'
                                if not 2^(block.number - startBlock / halvingPeriod):
                                    revert with 0, 'SafeMath: division by zero'
                                require ext_code.size(frogAddress)
                                call frogAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args this.address, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod)
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(frogAddress)
                                call frogAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args this.address, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[608] = wbnbAddress
                                if block.timestamp + 1800 < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[640] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                mem[644] = 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                                mem[676] = 0
                                mem[740] = fundsAddress
                                mem[772] = block.timestamp + 1800
                                mem[708] = 160
                                mem[804] = 2
                                mem[836 len 0] = None
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20, 0, 160, fundsAddress, block.timestamp + 1800, 2, mem[836 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[640 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(return_data.size) + 640
                                require return_data.size >= 32
                                _1344 = mem[640 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32
                                require mem[640 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 <= 4294967296
                                require mem[640 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 32 <= return_data.size
                                require mem[mem[640 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 640] <= 4294967296 and mem[640 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + (32 * mem[mem[640 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 640]) + 32 <= return_data.size
                                mem[ceil32(return_data.size) + 640] = mem[mem[640 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 640]
                                _1379 = mem[_1344 + 640]
                                mem[ceil32(return_data.size) + 672 len floor32(mem[_1344 + 640])] = mem[_1344 + 672 len floor32(mem[_1344 + 640])]
                                if not 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod):
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: division by zero'
                                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                else:
                                    if 10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) != 10^12:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * _1379) + ceil32(return_data.size) + 773 len 31]
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: division by zero'
                                    if (10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]
                            else:
                                if (block.number * frogPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * frogPerBlock * poolInfo[arg1].field_256) / (block.number * frogPerBlock) - (bonusEndBlock * frogPerBlock) != poolInfo[arg1].field_256:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                if not totalAllocPoint:
                                    revert with 0, 'SafeMath: division by zero'
                                if not 2^(block.number - startBlock / halvingPeriod):
                                    revert with 0, 'SafeMath: division by zero'
                                require ext_code.size(frogAddress)
                                call frogAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args this.address, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod)
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(frogAddress)
                                call frogAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args this.address, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[608] = wbnbAddress
                                if block.timestamp + 1800 < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[640] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                mem[644] = (block.number * frogPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                                mem[676] = 0
                                mem[740] = fundsAddress
                                mem[772] = block.timestamp + 1800
                                mem[708] = 160
                                mem[804] = 2
                                mem[836 len 0] = None
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args (block.number * frogPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20, 0, 160, fundsAddress, block.timestamp + 1800, 2, mem[836 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[640 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(return_data.size) + 640
                                require return_data.size >= 32
                                _1342 = mem[640 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32
                                require mem[640 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 <= 4294967296
                                require mem[640 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 32 <= return_data.size
                                require mem[mem[640 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 640] <= 4294967296 and mem[640 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + (32 * mem[mem[640 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 640]) + 32 <= return_data.size
                                mem[ceil32(return_data.size) + 640] = mem[mem[640 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 640]
                                _1378 = mem[_1342 + 640]
                                mem[ceil32(return_data.size) + 672 len floor32(mem[_1342 + 640])] = mem[_1342 + 672 len floor32(mem[_1342 + 640])]
                                if not (block.number * frogPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod):
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: division by zero'
                                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                else:
                                    if 10^12 * (block.number * frogPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / (block.number * frogPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) != 10^12:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * _1378) + ceil32(return_data.size) + 773 len 31]
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: division by zero'
                                    if (10^12 * (block.number * frogPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_768 += 10^12 * (block.number * frogPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]
                    else:
                        if bonusEndBlock - poolInfo[arg1].field_512 / bonusEndBlock - poolInfo[arg1].field_512 != 1:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                        if block.number < bonusEndBlock:
                            revert with 0, 'SafeMath: addition overflow'
                        if startBlock > block.number:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not halvingPeriod:
                            revert with 0, 'SafeMath: division by zero'
                        if not block.number - poolInfo[arg1].field_512:
                            if not totalAllocPoint:
                                revert with 0, 'SafeMath: division by zero'
                            if not 2^(block.number - startBlock / halvingPeriod):
                                revert with 0, 'SafeMath: division by zero'
                            require ext_code.size(frogAddress)
                            call frogAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args this.address, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod)
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(frogAddress)
                            call frogAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args this.address, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[608] = wbnbAddress
                            if block.timestamp + 1800 < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[640] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                            mem[644] = 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                            mem[676] = 0
                            mem[740] = fundsAddress
                            mem[772] = block.timestamp + 1800
                            mem[708] = 160
                            mem[804] = 2
                            mem[836 len 0] = None
                            require ext_code.size(routerAddress)
                            call routerAddress.swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20, 0, 160, fundsAddress, block.timestamp + 1800, 2, mem[836 len 64]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[640 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = ceil32(return_data.size) + 640
                            require return_data.size >= 32
                            _1340 = mem[640 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32
                            require mem[640 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 <= 4294967296
                            require mem[640 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 32 <= return_data.size
                            require mem[mem[640 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 640] <= 4294967296 and mem[640 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + (32 * mem[mem[640 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 640]) + 32 <= return_data.size
                            mem[ceil32(return_data.size) + 640] = mem[mem[640 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 640]
                            _1377 = mem[_1340 + 640]
                            mem[ceil32(return_data.size) + 672 len floor32(mem[_1340 + 640])] = mem[_1340 + 672 len floor32(mem[_1340 + 640])]
                            if not 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod):
                                if not ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: division by zero'
                                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                            else:
                                if 10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) != 10^12:
                                    revert with 0, 
                                                32,
                                                33,
                                                0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[(32 * _1377) + ceil32(return_data.size) + 773 len 31]
                                if not ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: division by zero'
                                if (10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]
                        else:
                            if (block.number * frogPerBlock) - (poolInfo[arg1].field_512 * frogPerBlock) / block.number - poolInfo[arg1].field_512 != frogPerBlock:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                            if not (block.number * frogPerBlock) - (poolInfo[arg1].field_512 * frogPerBlock):
                                if not totalAllocPoint:
                                    revert with 0, 'SafeMath: division by zero'
                                if not 2^(block.number - startBlock / halvingPeriod):
                                    revert with 0, 'SafeMath: division by zero'
                                require ext_code.size(frogAddress)
                                call frogAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args this.address, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod)
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(frogAddress)
                                call frogAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args this.address, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[608] = wbnbAddress
                                if block.timestamp + 1800 < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[640] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                mem[644] = 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                                mem[676] = 0
                                mem[740] = fundsAddress
                                mem[772] = block.timestamp + 1800
                                mem[708] = 160
                                mem[804] = 2
                                mem[836 len 0] = None
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20, 0, 160, fundsAddress, block.timestamp + 1800, 2, mem[836 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[640 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(return_data.size) + 640
                                require return_data.size >= 32
                                _1338 = mem[640 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32
                                require mem[640 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 <= 4294967296
                                require mem[640 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 32 <= return_data.size
                                require mem[mem[640 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 640] <= 4294967296 and mem[640 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + (32 * mem[mem[640 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 640]) + 32 <= return_data.size
                                mem[ceil32(return_data.size) + 640] = mem[mem[640 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 640]
                                _1376 = mem[_1338 + 640]
                                mem[ceil32(return_data.size) + 672 len floor32(mem[_1338 + 640])] = mem[_1338 + 672 len floor32(mem[_1338 + 640])]
                                if not 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod):
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: division by zero'
                                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                else:
                                    if 10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) != 10^12:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * _1376) + ceil32(return_data.size) + 773 len 31]
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: division by zero'
                                    if (10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]
                            else:
                                if (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / (block.number * frogPerBlock) - (poolInfo[arg1].field_512 * frogPerBlock) != poolInfo[arg1].field_256:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                if not totalAllocPoint:
                                    revert with 0, 'SafeMath: division by zero'
                                if not 2^(block.number - startBlock / halvingPeriod):
                                    revert with 0, 'SafeMath: division by zero'
                                require ext_code.size(frogAddress)
                                call frogAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args this.address, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod)
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(frogAddress)
                                call frogAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args this.address, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[608] = wbnbAddress
                                if block.timestamp + 1800 < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[640] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                mem[644] = (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                                mem[676] = 0
                                mem[740] = fundsAddress
                                mem[772] = block.timestamp + 1800
                                mem[708] = 160
                                mem[804] = 2
                                mem[836 len 0] = None
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20, 0, 160, fundsAddress, block.timestamp + 1800, 2, mem[836 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[640 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(return_data.size) + 640
                                require return_data.size >= 32
                                _1336 = mem[640 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32
                                require mem[640 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 <= 4294967296
                                require mem[640 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 32 <= return_data.size
                                require mem[mem[640 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 640] <= 4294967296 and mem[640 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + (32 * mem[mem[640 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 640]) + 32 <= return_data.size
                                mem[ceil32(return_data.size) + 640] = mem[mem[640 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 640]
                                _1375 = mem[_1336 + 640]
                                mem[ceil32(return_data.size) + 672 len floor32(mem[_1336 + 640])] = mem[_1336 + 672 len floor32(mem[_1336 + 640])]
                                if not (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod):
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: division by zero'
                                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                else:
                                    if 10^12 * (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) != 10^12:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * _1375) + ceil32(return_data.size) + 773 len 31]
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: division by zero'
                                    if (10^12 * (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_768 += 10^12 * (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]
        poolInfo[arg1].field_512 = block.number
}

function massUpdatePools() payable {
    mem[64] = 96
    idx = 0
    while idx < poolInfo.length:
        mem[0] = 8
        if block.number <= poolInfo[idx].field_512:
            idx = idx + 1
            continue 
        mem[mem[64] + 4] = this.address
        require ext_code.size(poolInfo[idx].field_0)
        staticcall poolInfo[idx].field_0.0x70a08231 with:
                gas gas_remaining wei
               args this.address
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if not ext_call.return_data[0]:
            poolInfo[idx].field_512 = block.number
            idx = idx + 1
            continue 
        if block.number <= bonusEndBlock:
            _1142 = mem[64]
            mem[64] = mem[64] + 64
            mem[_1142] = 30
            mem[_1142 + 32] = 'SafeMath: subtraction overflow'
            if poolInfo[idx].field_512 > block.number:
                _1145 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _1145 + 68] = mem[idx + _1142 + 32]
                    idx = idx + 32
                    continue 
                mem[_1145 + 68] = mem[_1145 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _1145 + -mem[64] + 100
            if not block.number - poolInfo[idx].field_512:
                _1179 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1179] = 30
                mem[_1179 + 32] = 'SafeMath: subtraction overflow'
                if startBlock > block.number:
                    _1186 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _1186 + 68] = mem[idx + _1179 + 32]
                        idx = idx + 32
                        continue 
                    mem[_1186 + 68] = mem[_1186 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _1186 + -mem[64] + 100
                _1203 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1203] = 26
                mem[_1203 + 32] = 'SafeMath: division by zero'
                if not halvingPeriod:
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                    idx = 32
                    while idx < 26:
                        mem[idx + mem[64] + 68] = mem[idx + _1203 + 32]
                        idx = idx + 32
                        continue 
                else:
                    _1290 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1290] = 26
                    mem[_1290 + 32] = 'SafeMath: division by zero'
                    if not totalAllocPoint:
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                        idx = 32
                        while idx < 26:
                            mem[idx + mem[64] + 68] = mem[idx + _1290 + 32]
                            idx = idx + 32
                            continue 
                    else:
                        _1370 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1370] = 26
                        mem[_1370 + 32] = 'SafeMath: division by zero'
                        if not 2^(block.number - startBlock / halvingPeriod):
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _1370 + 32]
                                idx = idx + 32
                                continue 
                        else:
                            _1467 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1467] = 26
                            mem[_1467 + 32] = 'SafeMath: division by zero'
                            require ext_code.size(frogAddress)
                            call frogAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args this.address, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod)
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64] + 4] = this.address
                            mem[mem[64] + 36] = 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                            require ext_code.size(frogAddress)
                            call frogAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args this.address, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _1629 = mem[64]
                            mem[mem[64]] = 2
                            mem[64] = mem[64] + 96
                            require mem[_1629]
                            mem[_1629 + 32] = frogAddress
                            require 1 < mem[_1629]
                            mem[_1629 + 64] = wbnbAddress
                            if block.timestamp + 1800 < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[_1629 + 96] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                            mem[_1629 + 100] = 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                            mem[_1629 + 132] = 0
                            mem[_1629 + 196] = fundsAddress
                            mem[_1629 + 228] = block.timestamp + 1800
                            mem[_1629 + 164] = 160
                            mem[_1629 + 260] = mem[_1629]
                            s = 0
                            while s < 32 * mem[_1629]:
                                mem[s + _1629 + 292] = mem[s + _1629 + 32]
                                s = s + 32
                                continue 
                            require ext_code.size(routerAddress)
                            call routerAddress.swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20, 0, 160, fundsAddress, block.timestamp + 1800, mem[_1629 + 260 len (32 * mem[_1629]) + 32]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_1629 + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = _1629 + ceil32(return_data.size) + 96
                            require return_data.size >= 32
                            _2496 = mem[_1629 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32
                            require mem[_1629 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 <= 4294967296
                            require mem[_1629 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 32 <= return_data.size
                            require mem[_1629 + mem[_1629 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 96] <= 4294967296 and mem[_1629 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + (32 * mem[_1629 + mem[_1629 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 96]) + 32 <= return_data.size
                            mem[_1629 + ceil32(return_data.size) + 96] = mem[_1629 + mem[_1629 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 96]
                            _2523 = mem[_1629 + _2496 + 96]
                            s = 0
                            while s < 32 * _2523:
                                mem[s + _1629 + ceil32(return_data.size) + 128] = mem[s + _1629 + _2496 + 128]
                                s = s + 32
                                continue 
                            if not 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod):
                                mem[64] = (32 * _2523) + _1629 + ceil32(return_data.size) + 192
                                mem[(32 * _2523) + _1629 + ceil32(return_data.size) + 128] = 26
                                mem[(32 * _2523) + _1629 + ceil32(return_data.size) + 160] = 'SafeMath: division by zero'
                                if ext_call.return_data[0]:
                                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                    poolInfo[idx].field_512 = block.number
                                    idx = idx + 1
                                    continue 
                            else:
                                if 10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) != 10^12:
                                    revert with 0, 
                                                32,
                                                33,
                                                0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[(32 * _2523) + _1629 + ceil32(return_data.size) + 229 len 31]
                                mem[64] = (32 * _2523) + _1629 + ceil32(return_data.size) + 192
                                mem[(32 * _2523) + _1629 + ceil32(return_data.size) + 128] = 26
                                mem[(32 * _2523) + _1629 + ceil32(return_data.size) + 160] = 'SafeMath: division by zero'
                                if ext_call.return_data[0]:
                                    if (10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]
                                    poolInfo[idx].field_512 = block.number
                                    idx = idx + 1
                                    continue 
                            ('iszero', ('ext_call.return_data', 0, 32))
                            mem[(32 * _2523) + _1629 + ceil32(return_data.size) + 192] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[(32 * _2523) + _1629 + ceil32(return_data.size) + 196] = 32
                            idx = 32
                            while idx < 26:
                                mem[idx + (32 * _2523) + _1629 + ceil32(return_data.size) + 260] = mem[idx + (32 * _2523) + _1629 + ceil32(return_data.size) + 160]
                                idx = idx + 32
                                continue 
            else:
                if block.number - poolInfo[idx].field_512 / block.number - poolInfo[idx].field_512 != 1:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _1182 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1182] = 30
                mem[_1182 + 32] = 'SafeMath: subtraction overflow'
                if startBlock > block.number:
                    _1192 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _1192 + 68] = mem[idx + _1182 + 32]
                        idx = idx + 32
                        continue 
                    mem[_1192 + 68] = mem[_1192 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _1192 + -mem[64] + 100
                _1210 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1210] = 26
                mem[_1210 + 32] = 'SafeMath: division by zero'
                if not halvingPeriod:
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                    idx = 32
                    while idx < 26:
                        mem[idx + mem[64] + 68] = mem[idx + _1210 + 32]
                        idx = idx + 32
                        continue 
                else:
                    if not block.number - poolInfo[idx].field_512:
                        _1303 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1303] = 26
                        mem[_1303 + 32] = 'SafeMath: division by zero'
                        if not totalAllocPoint:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _1303 + 32]
                                idx = idx + 32
                                continue 
                        else:
                            _1383 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1383] = 26
                            mem[_1383 + 32] = 'SafeMath: division by zero'
                            if not 2^(block.number - startBlock / halvingPeriod):
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _1383 + 32]
                                    idx = idx + 32
                                    continue 
                            else:
                                _1484 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1484] = 26
                                mem[_1484 + 32] = 'SafeMath: division by zero'
                                require ext_code.size(frogAddress)
                                call frogAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args this.address, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod)
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[mem[64] + 4] = this.address
                                mem[mem[64] + 36] = 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                                require ext_code.size(frogAddress)
                                call frogAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args this.address, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _1648 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                require mem[_1648]
                                mem[_1648 + 32] = frogAddress
                                require 1 < mem[_1648]
                                mem[_1648 + 64] = wbnbAddress
                                if block.timestamp + 1800 < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[_1648 + 96] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                mem[_1648 + 100] = 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                                mem[_1648 + 132] = 0
                                mem[_1648 + 196] = fundsAddress
                                mem[_1648 + 228] = block.timestamp + 1800
                                mem[_1648 + 164] = 160
                                mem[_1648 + 260] = mem[_1648]
                                s = 0
                                while s < 32 * mem[_1648]:
                                    mem[s + _1648 + 292] = mem[s + _1648 + 32]
                                    s = s + 32
                                    continue 
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20, 0, 160, fundsAddress, block.timestamp + 1800, mem[_1648 + 260 len (32 * mem[_1648]) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[_1648 + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = _1648 + ceil32(return_data.size) + 96
                                require return_data.size >= 32
                                _2494 = mem[_1648 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32
                                require mem[_1648 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 <= 4294967296
                                require mem[_1648 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 32 <= return_data.size
                                require mem[_1648 + mem[_1648 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 96] <= 4294967296 and mem[_1648 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + (32 * mem[_1648 + mem[_1648 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 96]) + 32 <= return_data.size
                                mem[_1648 + ceil32(return_data.size) + 96] = mem[_1648 + mem[_1648 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 96]
                                _2522 = mem[_1648 + _2494 + 96]
                                s = 0
                                while s < 32 * _2522:
                                    mem[s + _1648 + ceil32(return_data.size) + 128] = mem[s + _1648 + _2494 + 128]
                                    s = s + 32
                                    continue 
                                if not 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod):
                                    mem[64] = (32 * _2522) + _1648 + ceil32(return_data.size) + 192
                                    mem[(32 * _2522) + _1648 + ceil32(return_data.size) + 128] = 26
                                    mem[(32 * _2522) + _1648 + ceil32(return_data.size) + 160] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                else:
                                    if 10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) != 10^12:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * _2522) + _1648 + ceil32(return_data.size) + 229 len 31]
                                    mem[64] = (32 * _2522) + _1648 + ceil32(return_data.size) + 192
                                    mem[(32 * _2522) + _1648 + ceil32(return_data.size) + 128] = 26
                                    mem[(32 * _2522) + _1648 + ceil32(return_data.size) + 160] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                ('iszero', ('ext_call.return_data', 0, 32))
                                mem[(32 * _2522) + _1648 + ceil32(return_data.size) + 192] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[(32 * _2522) + _1648 + ceil32(return_data.size) + 196] = 32
                                idx = 32
                                while idx < 26:
                                    mem[idx + (32 * _2522) + _1648 + ceil32(return_data.size) + 260] = mem[idx + (32 * _2522) + _1648 + ceil32(return_data.size) + 160]
                                    idx = idx + 32
                                    continue 
                    else:
                        if (block.number * frogPerBlock) - (poolInfo[idx].field_512 * frogPerBlock) / block.number - poolInfo[idx].field_512 != frogPerBlock:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if not (block.number * frogPerBlock) - (poolInfo[idx].field_512 * frogPerBlock):
                            _1312 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1312] = 26
                            mem[_1312 + 32] = 'SafeMath: division by zero'
                            if not totalAllocPoint:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _1312 + 32]
                                    idx = idx + 32
                                    continue 
                            else:
                                _1394 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1394] = 26
                                mem[_1394 + 32] = 'SafeMath: division by zero'
                                if not 2^(block.number - startBlock / halvingPeriod):
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _1394 + 32]
                                        idx = idx + 32
                                        continue 
                                else:
                                    _1503 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_1503] = 26
                                    mem[_1503 + 32] = 'SafeMath: division by zero'
                                    require ext_code.size(frogAddress)
                                    call frogAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args this.address, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[mem[64] + 4] = this.address
                                    mem[mem[64] + 36] = 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                                    require ext_code.size(frogAddress)
                                    call frogAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args this.address, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _1666 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    require mem[_1666]
                                    mem[_1666 + 32] = frogAddress
                                    require 1 < mem[_1666]
                                    mem[_1666 + 64] = wbnbAddress
                                    if block.timestamp + 1800 < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[_1666 + 96] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_1666 + 100] = 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                                    mem[_1666 + 132] = 0
                                    mem[_1666 + 196] = fundsAddress
                                    mem[_1666 + 228] = block.timestamp + 1800
                                    mem[_1666 + 164] = 160
                                    mem[_1666 + 260] = mem[_1666]
                                    s = 0
                                    while s < 32 * mem[_1666]:
                                        mem[s + _1666 + 292] = mem[s + _1666 + 32]
                                        s = s + 32
                                        continue 
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20, 0, 160, fundsAddress, block.timestamp + 1800, mem[_1666 + 260 len (32 * mem[_1666]) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_1666 + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _1666 + ceil32(return_data.size) + 96
                                    require return_data.size >= 32
                                    _2492 = mem[_1666 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32
                                    require mem[_1666 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 <= 4294967296
                                    require mem[_1666 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 32 <= return_data.size
                                    require mem[_1666 + mem[_1666 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 96] <= 4294967296 and mem[_1666 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + (32 * mem[_1666 + mem[_1666 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 96]) + 32 <= return_data.size
                                    mem[_1666 + ceil32(return_data.size) + 96] = mem[_1666 + mem[_1666 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 96]
                                    _2521 = mem[_1666 + _2492 + 96]
                                    s = 0
                                    while s < 32 * _2521:
                                        mem[s + _1666 + ceil32(return_data.size) + 128] = mem[s + _1666 + _2492 + 128]
                                        s = s + 32
                                        continue 
                                    if not 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod):
                                        mem[64] = (32 * _2521) + _1666 + ceil32(return_data.size) + 192
                                        mem[(32 * _2521) + _1666 + ceil32(return_data.size) + 128] = 26
                                        mem[(32 * _2521) + _1666 + ceil32(return_data.size) + 160] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                    else:
                                        if 10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) != 10^12:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * _2521) + _1666 + ceil32(return_data.size) + 229 len 31]
                                        mem[64] = (32 * _2521) + _1666 + ceil32(return_data.size) + 192
                                        mem[(32 * _2521) + _1666 + ceil32(return_data.size) + 128] = 26
                                        mem[(32 * _2521) + _1666 + ceil32(return_data.size) + 160] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                    ('iszero', ('ext_call.return_data', 0, 32))
                                    mem[(32 * _2521) + _1666 + ceil32(return_data.size) + 192] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[(32 * _2521) + _1666 + ceil32(return_data.size) + 196] = 32
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + (32 * _2521) + _1666 + ceil32(return_data.size) + 260] = mem[idx + (32 * _2521) + _1666 + ceil32(return_data.size) + 160]
                                        idx = idx + 32
                                        continue 
                        else:
                            if (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / (block.number * frogPerBlock) - (poolInfo[idx].field_512 * frogPerBlock) != poolInfo[idx].field_256:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _1324 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1324] = 26
                            mem[_1324 + 32] = 'SafeMath: division by zero'
                            if not totalAllocPoint:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _1324 + 32]
                                    idx = idx + 32
                                    continue 
                            else:
                                _1411 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1411] = 26
                                mem[_1411 + 32] = 'SafeMath: division by zero'
                                if not 2^(block.number - startBlock / halvingPeriod):
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _1411 + 32]
                                        idx = idx + 32
                                        continue 
                                else:
                                    _1521 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_1521] = 26
                                    mem[_1521 + 32] = 'SafeMath: division by zero'
                                    require ext_code.size(frogAddress)
                                    call frogAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args this.address, (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[mem[64] + 4] = this.address
                                    mem[mem[64] + 36] = (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                                    require ext_code.size(frogAddress)
                                    call frogAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args this.address, (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _1679 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    require mem[_1679]
                                    mem[_1679 + 32] = frogAddress
                                    require 1 < mem[_1679]
                                    mem[_1679 + 64] = wbnbAddress
                                    if block.timestamp + 1800 < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[_1679 + 96] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_1679 + 100] = (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                                    mem[_1679 + 132] = 0
                                    mem[_1679 + 196] = fundsAddress
                                    mem[_1679 + 228] = block.timestamp + 1800
                                    mem[_1679 + 164] = 160
                                    mem[_1679 + 260] = mem[_1679]
                                    s = 0
                                    while s < 32 * mem[_1679]:
                                        mem[s + _1679 + 292] = mem[s + _1679 + 32]
                                        s = s + 32
                                        continue 
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20, 0, 160, fundsAddress, block.timestamp + 1800, mem[_1679 + 260 len (32 * mem[_1679]) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_1679 + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _1679 + ceil32(return_data.size) + 96
                                    require return_data.size >= 32
                                    _2490 = mem[_1679 + 96 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32
                                    require mem[_1679 + 96 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 <= 4294967296
                                    require mem[_1679 + 96 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 32 <= return_data.size
                                    require mem[_1679 + mem[_1679 + 96 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 96] <= 4294967296 and mem[_1679 + 96 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + (32 * mem[_1679 + mem[_1679 + 96 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 96]) + 32 <= return_data.size
                                    mem[_1679 + ceil32(return_data.size) + 96] = mem[_1679 + mem[_1679 + 96 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 96]
                                    _2520 = mem[_1679 + _2490 + 96]
                                    s = 0
                                    while s < 32 * _2520:
                                        mem[s + _1679 + ceil32(return_data.size) + 128] = mem[s + _1679 + _2490 + 128]
                                        s = s + 32
                                        continue 
                                    if not (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod):
                                        mem[64] = (32 * _2520) + _1679 + ceil32(return_data.size) + 192
                                        mem[(32 * _2520) + _1679 + ceil32(return_data.size) + 128] = 26
                                        mem[(32 * _2520) + _1679 + ceil32(return_data.size) + 160] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                    else:
                                        if 10^12 * (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) != 10^12:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * _2520) + _1679 + ceil32(return_data.size) + 229 len 31]
                                        mem[64] = (32 * _2520) + _1679 + ceil32(return_data.size) + 192
                                        mem[(32 * _2520) + _1679 + ceil32(return_data.size) + 128] = 26
                                        mem[(32 * _2520) + _1679 + ceil32(return_data.size) + 160] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (10^12 * (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 10^12 * (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                    ('iszero', ('ext_call.return_data', 0, 32))
                                    mem[(32 * _2520) + _1679 + ceil32(return_data.size) + 192] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[(32 * _2520) + _1679 + ceil32(return_data.size) + 196] = 32
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + (32 * _2520) + _1679 + ceil32(return_data.size) + 260] = mem[idx + (32 * _2520) + _1679 + ceil32(return_data.size) + 160]
                                        idx = idx + 32
                                        continue 
        else:
            if poolInfo[idx].field_512 >= bonusEndBlock:
                _1144 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1144] = 30
                mem[_1144 + 32] = 'SafeMath: subtraction overflow'
                if poolInfo[idx].field_512 > block.number:
                    _1151 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _1151 + 68] = mem[idx + _1144 + 32]
                        idx = idx + 32
                        continue 
                    mem[_1151 + 68] = mem[_1151 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _1151 + -mem[64] + 100
                _1170 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1170] = 30
                mem[_1170 + 32] = 'SafeMath: subtraction overflow'
                if startBlock > block.number:
                    _1174 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _1174 + 68] = mem[idx + _1170 + 32]
                        idx = idx + 32
                        continue 
                    mem[_1174 + 68] = mem[_1174 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _1174 + -mem[64] + 100
                _1183 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1183] = 26
                mem[_1183 + 32] = 'SafeMath: division by zero'
                if not halvingPeriod:
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                    idx = 32
                    while idx < 26:
                        mem[idx + mem[64] + 68] = mem[idx + _1183 + 32]
                        idx = idx + 32
                        continue 
                else:
                    if not block.number - poolInfo[idx].field_512:
                        _1269 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1269] = 26
                        mem[_1269 + 32] = 'SafeMath: division by zero'
                        if not totalAllocPoint:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _1269 + 32]
                                idx = idx + 32
                                continue 
                        else:
                            _1321 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1321] = 26
                            mem[_1321 + 32] = 'SafeMath: division by zero'
                            if not 2^(block.number - startBlock / halvingPeriod):
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _1321 + 32]
                                    idx = idx + 32
                                    continue 
                            else:
                                _1408 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1408] = 26
                                mem[_1408 + 32] = 'SafeMath: division by zero'
                                require ext_code.size(frogAddress)
                                call frogAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args this.address, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod)
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[mem[64] + 4] = this.address
                                mem[mem[64] + 36] = 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                                require ext_code.size(frogAddress)
                                call frogAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args this.address, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _1574 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                require mem[_1574]
                                mem[_1574 + 32] = frogAddress
                                require 1 < mem[_1574]
                                mem[_1574 + 64] = wbnbAddress
                                if block.timestamp + 1800 < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[_1574 + 96] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                mem[_1574 + 100] = 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                                mem[_1574 + 132] = 0
                                mem[_1574 + 196] = fundsAddress
                                mem[_1574 + 228] = block.timestamp + 1800
                                mem[_1574 + 164] = 160
                                mem[_1574 + 260] = mem[_1574]
                                s = 0
                                while s < 32 * mem[_1574]:
                                    mem[s + _1574 + 292] = mem[s + _1574 + 32]
                                    s = s + 32
                                    continue 
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20, 0, 160, fundsAddress, block.timestamp + 1800, mem[_1574 + 260 len (32 * mem[_1574]) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[_1574 + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = _1574 + ceil32(return_data.size) + 96
                                require return_data.size >= 32
                                _2488 = mem[_1574 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32
                                require mem[_1574 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 <= 4294967296
                                require mem[_1574 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 32 <= return_data.size
                                require mem[_1574 + mem[_1574 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 96] <= 4294967296 and mem[_1574 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + (32 * mem[_1574 + mem[_1574 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 96]) + 32 <= return_data.size
                                mem[_1574 + ceil32(return_data.size) + 96] = mem[_1574 + mem[_1574 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 96]
                                _2519 = mem[_1574 + _2488 + 96]
                                s = 0
                                while s < 32 * _2519:
                                    mem[s + _1574 + ceil32(return_data.size) + 128] = mem[s + _1574 + _2488 + 128]
                                    s = s + 32
                                    continue 
                                if not 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod):
                                    mem[64] = (32 * _2519) + _1574 + ceil32(return_data.size) + 192
                                    mem[(32 * _2519) + _1574 + ceil32(return_data.size) + 128] = 26
                                    mem[(32 * _2519) + _1574 + ceil32(return_data.size) + 160] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                else:
                                    if 10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) != 10^12:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * _2519) + _1574 + ceil32(return_data.size) + 229 len 31]
                                    mem[64] = (32 * _2519) + _1574 + ceil32(return_data.size) + 192
                                    mem[(32 * _2519) + _1574 + ceil32(return_data.size) + 128] = 26
                                    mem[(32 * _2519) + _1574 + ceil32(return_data.size) + 160] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                ('iszero', ('ext_call.return_data', 0, 32))
                                mem[(32 * _2519) + _1574 + ceil32(return_data.size) + 192] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[(32 * _2519) + _1574 + ceil32(return_data.size) + 196] = 32
                                idx = 32
                                while idx < 26:
                                    mem[idx + (32 * _2519) + _1574 + ceil32(return_data.size) + 260] = mem[idx + (32 * _2519) + _1574 + ceil32(return_data.size) + 160]
                                    idx = idx + 32
                                    continue 
                    else:
                        if (block.number * frogPerBlock) - (poolInfo[idx].field_512 * frogPerBlock) / block.number - poolInfo[idx].field_512 != frogPerBlock:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if not (block.number * frogPerBlock) - (poolInfo[idx].field_512 * frogPerBlock):
                            _1274 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1274] = 26
                            mem[_1274 + 32] = 'SafeMath: division by zero'
                            if not totalAllocPoint:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _1274 + 32]
                                    idx = idx + 32
                                    continue 
                            else:
                                _1333 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1333] = 26
                                mem[_1333 + 32] = 'SafeMath: division by zero'
                                if not 2^(block.number - startBlock / halvingPeriod):
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _1333 + 32]
                                        idx = idx + 32
                                        continue 
                                else:
                                    _1425 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_1425] = 26
                                    mem[_1425 + 32] = 'SafeMath: division by zero'
                                    require ext_code.size(frogAddress)
                                    call frogAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args this.address, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[mem[64] + 4] = this.address
                                    mem[mem[64] + 36] = 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                                    require ext_code.size(frogAddress)
                                    call frogAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args this.address, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _1589 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    require mem[_1589]
                                    mem[_1589 + 32] = frogAddress
                                    require 1 < mem[_1589]
                                    mem[_1589 + 64] = wbnbAddress
                                    if block.timestamp + 1800 < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[_1589 + 96] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_1589 + 100] = 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                                    mem[_1589 + 132] = 0
                                    mem[_1589 + 196] = fundsAddress
                                    mem[_1589 + 228] = block.timestamp + 1800
                                    mem[_1589 + 164] = 160
                                    mem[_1589 + 260] = mem[_1589]
                                    s = 0
                                    while s < 32 * mem[_1589]:
                                        mem[s + _1589 + 292] = mem[s + _1589 + 32]
                                        s = s + 32
                                        continue 
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20, 0, 160, fundsAddress, block.timestamp + 1800, mem[_1589 + 260 len (32 * mem[_1589]) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_1589 + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _1589 + ceil32(return_data.size) + 96
                                    require return_data.size >= 32
                                    _2486 = mem[_1589 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32
                                    require mem[_1589 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 <= 4294967296
                                    require mem[_1589 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 32 <= return_data.size
                                    require mem[_1589 + mem[_1589 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 96] <= 4294967296 and mem[_1589 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + (32 * mem[_1589 + mem[_1589 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 96]) + 32 <= return_data.size
                                    mem[_1589 + ceil32(return_data.size) + 96] = mem[_1589 + mem[_1589 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 96]
                                    _2518 = mem[_1589 + _2486 + 96]
                                    s = 0
                                    while s < 32 * _2518:
                                        mem[s + _1589 + ceil32(return_data.size) + 128] = mem[s + _1589 + _2486 + 128]
                                        s = s + 32
                                        continue 
                                    if not 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod):
                                        mem[64] = (32 * _2518) + _1589 + ceil32(return_data.size) + 192
                                        mem[(32 * _2518) + _1589 + ceil32(return_data.size) + 128] = 26
                                        mem[(32 * _2518) + _1589 + ceil32(return_data.size) + 160] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                    else:
                                        if 10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) != 10^12:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * _2518) + _1589 + ceil32(return_data.size) + 229 len 31]
                                        mem[64] = (32 * _2518) + _1589 + ceil32(return_data.size) + 192
                                        mem[(32 * _2518) + _1589 + ceil32(return_data.size) + 128] = 26
                                        mem[(32 * _2518) + _1589 + ceil32(return_data.size) + 160] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                    ('iszero', ('ext_call.return_data', 0, 32))
                                    mem[(32 * _2518) + _1589 + ceil32(return_data.size) + 192] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[(32 * _2518) + _1589 + ceil32(return_data.size) + 196] = 32
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + (32 * _2518) + _1589 + ceil32(return_data.size) + 260] = mem[idx + (32 * _2518) + _1589 + ceil32(return_data.size) + 160]
                                        idx = idx + 32
                                        continue 
                        else:
                            if (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / (block.number * frogPerBlock) - (poolInfo[idx].field_512 * frogPerBlock) != poolInfo[idx].field_256:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _1278 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1278] = 26
                            mem[_1278 + 32] = 'SafeMath: division by zero'
                            if not totalAllocPoint:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _1278 + 32]
                                    idx = idx + 32
                                    continue 
                            else:
                                _1345 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1345] = 26
                                mem[_1345 + 32] = 'SafeMath: division by zero'
                                if not 2^(block.number - startBlock / halvingPeriod):
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _1345 + 32]
                                        idx = idx + 32
                                        continue 
                                else:
                                    _1441 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_1441] = 26
                                    mem[_1441 + 32] = 'SafeMath: division by zero'
                                    require ext_code.size(frogAddress)
                                    call frogAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args this.address, (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[mem[64] + 4] = this.address
                                    mem[mem[64] + 36] = (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                                    require ext_code.size(frogAddress)
                                    call frogAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args this.address, (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _1607 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    require mem[_1607]
                                    mem[_1607 + 32] = frogAddress
                                    require 1 < mem[_1607]
                                    mem[_1607 + 64] = wbnbAddress
                                    if block.timestamp + 1800 < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[_1607 + 96] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_1607 + 100] = (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                                    mem[_1607 + 132] = 0
                                    mem[_1607 + 196] = fundsAddress
                                    mem[_1607 + 228] = block.timestamp + 1800
                                    mem[_1607 + 164] = 160
                                    mem[_1607 + 260] = mem[_1607]
                                    s = 0
                                    while s < 32 * mem[_1607]:
                                        mem[s + _1607 + 292] = mem[s + _1607 + 32]
                                        s = s + 32
                                        continue 
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20, 0, 160, fundsAddress, block.timestamp + 1800, mem[_1607 + 260 len (32 * mem[_1607]) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_1607 + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _1607 + ceil32(return_data.size) + 96
                                    require return_data.size >= 32
                                    _2484 = mem[_1607 + 96 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32
                                    require mem[_1607 + 96 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 <= 4294967296
                                    require mem[_1607 + 96 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 32 <= return_data.size
                                    require mem[_1607 + mem[_1607 + 96 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 96] <= 4294967296 and mem[_1607 + 96 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + (32 * mem[_1607 + mem[_1607 + 96 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 96]) + 32 <= return_data.size
                                    mem[_1607 + ceil32(return_data.size) + 96] = mem[_1607 + mem[_1607 + 96 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 96]
                                    _2517 = mem[_1607 + _2484 + 96]
                                    s = 0
                                    while s < 32 * _2517:
                                        mem[s + _1607 + ceil32(return_data.size) + 128] = mem[s + _1607 + _2484 + 128]
                                        s = s + 32
                                        continue 
                                    if not (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod):
                                        mem[64] = (32 * _2517) + _1607 + ceil32(return_data.size) + 192
                                        mem[(32 * _2517) + _1607 + ceil32(return_data.size) + 128] = 26
                                        mem[(32 * _2517) + _1607 + ceil32(return_data.size) + 160] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                    else:
                                        if 10^12 * (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) != 10^12:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * _2517) + _1607 + ceil32(return_data.size) + 229 len 31]
                                        mem[64] = (32 * _2517) + _1607 + ceil32(return_data.size) + 192
                                        mem[(32 * _2517) + _1607 + ceil32(return_data.size) + 128] = 26
                                        mem[(32 * _2517) + _1607 + ceil32(return_data.size) + 160] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (10^12 * (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 10^12 * (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                    ('iszero', ('ext_call.return_data', 0, 32))
                                    mem[(32 * _2517) + _1607 + ceil32(return_data.size) + 192] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[(32 * _2517) + _1607 + ceil32(return_data.size) + 196] = 32
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + (32 * _2517) + _1607 + ceil32(return_data.size) + 260] = mem[idx + (32 * _2517) + _1607 + ceil32(return_data.size) + 160]
                                        idx = idx + 32
                                        continue 
            else:
                _1143 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1143] = 30
                mem[_1143 + 32] = 'SafeMath: subtraction overflow'
                if bonusEndBlock > block.number:
                    _1148 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _1148 + 68] = mem[idx + _1143 + 32]
                        idx = idx + 32
                        continue 
                    mem[_1148 + 68] = mem[_1148 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _1148 + -mem[64] + 100
                _1159 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1159] = 30
                mem[_1159 + 32] = 'SafeMath: subtraction overflow'
                if poolInfo[idx].field_512 > bonusEndBlock:
                    _1167 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _1167 + 68] = mem[idx + _1159 + 32]
                        idx = idx + 32
                        continue 
                    mem[_1167 + 68] = mem[_1167 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _1167 + -mem[64] + 100
                if not bonusEndBlock - poolInfo[idx].field_512:
                    if block.number - bonusEndBlock < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    _1226 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1226] = 30
                    mem[_1226 + 32] = 'SafeMath: subtraction overflow'
                    if startBlock > block.number:
                        _1236 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _1236 + 68] = mem[idx + _1226 + 32]
                            idx = idx + 32
                            continue 
                        mem[_1236 + 68] = mem[_1236 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _1236 + -mem[64] + 100
                    _1254 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1254] = 26
                    mem[_1254 + 32] = 'SafeMath: division by zero'
                    if not halvingPeriod:
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                        idx = 32
                        while idx < 26:
                            mem[idx + mem[64] + 68] = mem[idx + _1254 + 32]
                            idx = idx + 32
                            continue 
                    else:
                        if not block.number - bonusEndBlock:
                            _1403 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1403] = 26
                            mem[_1403 + 32] = 'SafeMath: division by zero'
                            if not totalAllocPoint:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _1403 + 32]
                                    idx = idx + 32
                                    continue 
                            else:
                                _1516 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1516] = 26
                                mem[_1516 + 32] = 'SafeMath: division by zero'
                                if not 2^(block.number - startBlock / halvingPeriod):
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _1516 + 32]
                                        idx = idx + 32
                                        continue 
                                else:
                                    _1623 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_1623] = 26
                                    mem[_1623 + 32] = 'SafeMath: division by zero'
                                    require ext_code.size(frogAddress)
                                    call frogAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args this.address, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[mem[64] + 4] = this.address
                                    mem[mem[64] + 36] = 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                                    require ext_code.size(frogAddress)
                                    call frogAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args this.address, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _1746 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    require mem[_1746]
                                    mem[_1746 + 32] = frogAddress
                                    require 1 < mem[_1746]
                                    mem[_1746 + 64] = wbnbAddress
                                    if block.timestamp + 1800 < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[_1746 + 96] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_1746 + 100] = 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                                    mem[_1746 + 132] = 0
                                    mem[_1746 + 196] = fundsAddress
                                    mem[_1746 + 228] = block.timestamp + 1800
                                    mem[_1746 + 164] = 160
                                    mem[_1746 + 260] = mem[_1746]
                                    s = 0
                                    while s < 32 * mem[_1746]:
                                        mem[s + _1746 + 292] = mem[s + _1746 + 32]
                                        s = s + 32
                                        continue 
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20, 0, 160, fundsAddress, block.timestamp + 1800, mem[_1746 + 260 len (32 * mem[_1746]) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_1746 + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _1746 + ceil32(return_data.size) + 96
                                    require return_data.size >= 32
                                    _2482 = mem[_1746 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32
                                    require mem[_1746 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 <= 4294967296
                                    require mem[_1746 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 32 <= return_data.size
                                    require mem[_1746 + mem[_1746 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 96] <= 4294967296 and mem[_1746 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + (32 * mem[_1746 + mem[_1746 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 96]) + 32 <= return_data.size
                                    mem[_1746 + ceil32(return_data.size) + 96] = mem[_1746 + mem[_1746 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 96]
                                    _2516 = mem[_1746 + _2482 + 96]
                                    s = 0
                                    while s < 32 * _2516:
                                        mem[s + _1746 + ceil32(return_data.size) + 128] = mem[s + _1746 + _2482 + 128]
                                        s = s + 32
                                        continue 
                                    if not 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod):
                                        mem[64] = (32 * _2516) + _1746 + ceil32(return_data.size) + 192
                                        mem[(32 * _2516) + _1746 + ceil32(return_data.size) + 128] = 26
                                        mem[(32 * _2516) + _1746 + ceil32(return_data.size) + 160] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                    else:
                                        if 10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) != 10^12:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * _2516) + _1746 + ceil32(return_data.size) + 229 len 31]
                                        mem[64] = (32 * _2516) + _1746 + ceil32(return_data.size) + 192
                                        mem[(32 * _2516) + _1746 + ceil32(return_data.size) + 128] = 26
                                        mem[(32 * _2516) + _1746 + ceil32(return_data.size) + 160] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                    ('iszero', ('ext_call.return_data', 0, 32))
                                    mem[(32 * _2516) + _1746 + ceil32(return_data.size) + 192] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[(32 * _2516) + _1746 + ceil32(return_data.size) + 196] = 32
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + (32 * _2516) + _1746 + ceil32(return_data.size) + 260] = mem[idx + (32 * _2516) + _1746 + ceil32(return_data.size) + 160]
                                        idx = idx + 32
                                        continue 
                        else:
                            if (block.number * frogPerBlock) - (bonusEndBlock * frogPerBlock) / block.number - bonusEndBlock != frogPerBlock:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not (block.number * frogPerBlock) - (bonusEndBlock * frogPerBlock):
                                _1422 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1422] = 26
                                mem[_1422 + 32] = 'SafeMath: division by zero'
                                if not totalAllocPoint:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _1422 + 32]
                                        idx = idx + 32
                                        continue 
                                else:
                                    _1534 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_1534] = 26
                                    mem[_1534 + 32] = 'SafeMath: division by zero'
                                    if not 2^(block.number - startBlock / halvingPeriod):
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _1534 + 32]
                                            idx = idx + 32
                                            continue 
                                    else:
                                        _1640 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_1640] = 26
                                        mem[_1640 + 32] = 'SafeMath: division by zero'
                                        require ext_code.size(frogAddress)
                                        call frogAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args this.address, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[mem[64] + 4] = this.address
                                        mem[mem[64] + 36] = 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                                        require ext_code.size(frogAddress)
                                        call frogAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args this.address, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _1758 = mem[64]
                                        mem[mem[64]] = 2
                                        mem[64] = mem[64] + 96
                                        require mem[_1758]
                                        mem[_1758 + 32] = frogAddress
                                        require 1 < mem[_1758]
                                        mem[_1758 + 64] = wbnbAddress
                                        if block.timestamp + 1800 < block.timestamp:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[_1758 + 96] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                        mem[_1758 + 100] = 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                                        mem[_1758 + 132] = 0
                                        mem[_1758 + 196] = fundsAddress
                                        mem[_1758 + 228] = block.timestamp + 1800
                                        mem[_1758 + 164] = 160
                                        mem[_1758 + 260] = mem[_1758]
                                        s = 0
                                        while s < 32 * mem[_1758]:
                                            mem[s + _1758 + 292] = mem[s + _1758 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                             gas gas_remaining wei
                                            args 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20, 0, 160, fundsAddress, block.timestamp + 1800, mem[_1758 + 260 len (32 * mem[_1758]) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[_1758 + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = _1758 + ceil32(return_data.size) + 96
                                        require return_data.size >= 32
                                        _2480 = mem[_1758 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32
                                        require mem[_1758 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 <= 4294967296
                                        require mem[_1758 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 32 <= return_data.size
                                        require mem[_1758 + mem[_1758 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 96] <= 4294967296 and mem[_1758 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + (32 * mem[_1758 + mem[_1758 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 96]) + 32 <= return_data.size
                                        mem[_1758 + ceil32(return_data.size) + 96] = mem[_1758 + mem[_1758 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 96]
                                        _2515 = mem[_1758 + _2480 + 96]
                                        s = 0
                                        while s < 32 * _2515:
                                            mem[s + _1758 + ceil32(return_data.size) + 128] = mem[s + _1758 + _2480 + 128]
                                            s = s + 32
                                            continue 
                                        if not 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod):
                                            mem[64] = (32 * _2515) + _1758 + ceil32(return_data.size) + 192
                                            mem[(32 * _2515) + _1758 + ceil32(return_data.size) + 128] = 26
                                            mem[(32 * _2515) + _1758 + ceil32(return_data.size) + 160] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if 10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) != 10^12:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * _2515) + _1758 + ceil32(return_data.size) + 229 len 31]
                                            mem[64] = (32 * _2515) + _1758 + ceil32(return_data.size) + 192
                                            mem[(32 * _2515) + _1758 + ceil32(return_data.size) + 128] = 26
                                            mem[(32 * _2515) + _1758 + ceil32(return_data.size) + 160] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                        ('iszero', ('ext_call.return_data', 0, 32))
                                        mem[(32 * _2515) + _1758 + ceil32(return_data.size) + 192] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[(32 * _2515) + _1758 + ceil32(return_data.size) + 196] = 32
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + (32 * _2515) + _1758 + ceil32(return_data.size) + 260] = mem[idx + (32 * _2515) + _1758 + ceil32(return_data.size) + 160]
                                            idx = idx + 32
                                            continue 
                            else:
                                if (block.number * frogPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * frogPerBlock * poolInfo[idx].field_256) / (block.number * frogPerBlock) - (bonusEndBlock * frogPerBlock) != poolInfo[idx].field_256:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _1437 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1437] = 26
                                mem[_1437 + 32] = 'SafeMath: division by zero'
                                if not totalAllocPoint:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _1437 + 32]
                                        idx = idx + 32
                                        continue 
                                else:
                                    _1549 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_1549] = 26
                                    mem[_1549 + 32] = 'SafeMath: division by zero'
                                    if not 2^(block.number - startBlock / halvingPeriod):
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _1549 + 32]
                                            idx = idx + 32
                                            continue 
                                    else:
                                        _1657 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_1657] = 26
                                        mem[_1657 + 32] = 'SafeMath: division by zero'
                                        require ext_code.size(frogAddress)
                                        call frogAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args this.address, (block.number * frogPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[mem[64] + 4] = this.address
                                        mem[mem[64] + 36] = (block.number * frogPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                                        require ext_code.size(frogAddress)
                                        call frogAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args this.address, (block.number * frogPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _1771 = mem[64]
                                        mem[mem[64]] = 2
                                        mem[64] = mem[64] + 96
                                        require mem[_1771]
                                        mem[_1771 + 32] = frogAddress
                                        require 1 < mem[_1771]
                                        mem[_1771 + 64] = wbnbAddress
                                        if block.timestamp + 1800 < block.timestamp:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[_1771 + 96] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                        mem[_1771 + 100] = (block.number * frogPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                                        mem[_1771 + 132] = 0
                                        mem[_1771 + 196] = fundsAddress
                                        mem[_1771 + 228] = block.timestamp + 1800
                                        mem[_1771 + 164] = 160
                                        mem[_1771 + 260] = mem[_1771]
                                        s = 0
                                        while s < 32 * mem[_1771]:
                                            mem[s + _1771 + 292] = mem[s + _1771 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                             gas gas_remaining wei
                                            args (block.number * frogPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20, 0, 160, fundsAddress, block.timestamp + 1800, mem[_1771 + 260 len (32 * mem[_1771]) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[_1771 + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = _1771 + ceil32(return_data.size) + 96
                                        require return_data.size >= 32
                                        _2478 = mem[_1771 + 96 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32
                                        require mem[_1771 + 96 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 <= 4294967296
                                        require mem[_1771 + 96 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 32 <= return_data.size
                                        require mem[_1771 + mem[_1771 + 96 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 96] <= 4294967296 and mem[_1771 + 96 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + (32 * mem[_1771 + mem[_1771 + 96 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 96]) + 32 <= return_data.size
                                        mem[_1771 + ceil32(return_data.size) + 96] = mem[_1771 + mem[_1771 + 96 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 96]
                                        _2514 = mem[_1771 + _2478 + 96]
                                        s = 0
                                        while s < 32 * _2514:
                                            mem[s + _1771 + ceil32(return_data.size) + 128] = mem[s + _1771 + _2478 + 128]
                                            s = s + 32
                                            continue 
                                        if not (block.number * frogPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod):
                                            mem[64] = (32 * _2514) + _1771 + ceil32(return_data.size) + 192
                                            mem[(32 * _2514) + _1771 + ceil32(return_data.size) + 128] = 26
                                            mem[(32 * _2514) + _1771 + ceil32(return_data.size) + 160] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if 10^12 * (block.number * frogPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / (block.number * frogPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) != 10^12:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * _2514) + _1771 + ceil32(return_data.size) + 229 len 31]
                                            mem[64] = (32 * _2514) + _1771 + ceil32(return_data.size) + 192
                                            mem[(32 * _2514) + _1771 + ceil32(return_data.size) + 128] = 26
                                            mem[(32 * _2514) + _1771 + ceil32(return_data.size) + 160] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (10^12 * (block.number * frogPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 10^12 * (block.number * frogPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                        ('iszero', ('ext_call.return_data', 0, 32))
                                        mem[(32 * _2514) + _1771 + ceil32(return_data.size) + 192] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[(32 * _2514) + _1771 + ceil32(return_data.size) + 196] = 32
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + (32 * _2514) + _1771 + ceil32(return_data.size) + 260] = mem[idx + (32 * _2514) + _1771 + ceil32(return_data.size) + 160]
                                            idx = idx + 32
                                            continue 
                else:
                    if bonusEndBlock - poolInfo[idx].field_512 / bonusEndBlock - poolInfo[idx].field_512 != 1:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if block.number < bonusEndBlock:
                        revert with 0, 'SafeMath: addition overflow'
                    _1231 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1231] = 30
                    mem[_1231 + 32] = 'SafeMath: subtraction overflow'
                    if startBlock > block.number:
                        _1245 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _1245 + 68] = mem[idx + _1231 + 32]
                            idx = idx + 32
                            continue 
                        mem[_1245 + 68] = mem[_1245 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _1245 + -mem[64] + 100
                    _1257 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1257] = 26
                    mem[_1257 + 32] = 'SafeMath: division by zero'
                    if not halvingPeriod:
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                        idx = 32
                        while idx < 26:
                            mem[idx + mem[64] + 68] = mem[idx + _1257 + 32]
                            idx = idx + 32
                            continue 
                    else:
                        if not block.number - poolInfo[idx].field_512:
                            _1421 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1421] = 26
                            mem[_1421 + 32] = 'SafeMath: division by zero'
                            if not totalAllocPoint:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _1421 + 32]
                                    idx = idx + 32
                                    continue 
                            else:
                                _1529 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1529] = 26
                                mem[_1529 + 32] = 'SafeMath: division by zero'
                                if not 2^(block.number - startBlock / halvingPeriod):
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _1529 + 32]
                                        idx = idx + 32
                                        continue 
                                else:
                                    _1635 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_1635] = 26
                                    mem[_1635 + 32] = 'SafeMath: division by zero'
                                    require ext_code.size(frogAddress)
                                    call frogAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args this.address, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[mem[64] + 4] = this.address
                                    mem[mem[64] + 36] = 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                                    require ext_code.size(frogAddress)
                                    call frogAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args this.address, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _1756 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    require mem[_1756]
                                    mem[_1756 + 32] = frogAddress
                                    require 1 < mem[_1756]
                                    mem[_1756 + 64] = wbnbAddress
                                    if block.timestamp + 1800 < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[_1756 + 96] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_1756 + 100] = 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                                    mem[_1756 + 132] = 0
                                    mem[_1756 + 196] = fundsAddress
                                    mem[_1756 + 228] = block.timestamp + 1800
                                    mem[_1756 + 164] = 160
                                    mem[_1756 + 260] = mem[_1756]
                                    s = 0
                                    while s < 32 * mem[_1756]:
                                        mem[s + _1756 + 292] = mem[s + _1756 + 32]
                                        s = s + 32
                                        continue 
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20, 0, 160, fundsAddress, block.timestamp + 1800, mem[_1756 + 260 len (32 * mem[_1756]) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_1756 + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _1756 + ceil32(return_data.size) + 96
                                    require return_data.size >= 32
                                    _2476 = mem[_1756 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32
                                    require mem[_1756 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 <= 4294967296
                                    require mem[_1756 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 32 <= return_data.size
                                    require mem[_1756 + mem[_1756 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 96] <= 4294967296 and mem[_1756 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + (32 * mem[_1756 + mem[_1756 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 96]) + 32 <= return_data.size
                                    mem[_1756 + ceil32(return_data.size) + 96] = mem[_1756 + mem[_1756 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 96]
                                    _2513 = mem[_1756 + _2476 + 96]
                                    s = 0
                                    while s < 32 * _2513:
                                        mem[s + _1756 + ceil32(return_data.size) + 128] = mem[s + _1756 + _2476 + 128]
                                        s = s + 32
                                        continue 
                                    if not 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod):
                                        mem[64] = (32 * _2513) + _1756 + ceil32(return_data.size) + 192
                                        mem[(32 * _2513) + _1756 + ceil32(return_data.size) + 128] = 26
                                        mem[(32 * _2513) + _1756 + ceil32(return_data.size) + 160] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                    else:
                                        if 10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) != 10^12:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * _2513) + _1756 + ceil32(return_data.size) + 229 len 31]
                                        mem[64] = (32 * _2513) + _1756 + ceil32(return_data.size) + 192
                                        mem[(32 * _2513) + _1756 + ceil32(return_data.size) + 128] = 26
                                        mem[(32 * _2513) + _1756 + ceil32(return_data.size) + 160] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                    ('iszero', ('ext_call.return_data', 0, 32))
                                    mem[(32 * _2513) + _1756 + ceil32(return_data.size) + 192] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[(32 * _2513) + _1756 + ceil32(return_data.size) + 196] = 32
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + (32 * _2513) + _1756 + ceil32(return_data.size) + 260] = mem[idx + (32 * _2513) + _1756 + ceil32(return_data.size) + 160]
                                        idx = idx + 32
                                        continue 
                        else:
                            if (block.number * frogPerBlock) - (poolInfo[idx].field_512 * frogPerBlock) / block.number - poolInfo[idx].field_512 != frogPerBlock:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not (block.number * frogPerBlock) - (poolInfo[idx].field_512 * frogPerBlock):
                                _1436 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1436] = 26
                                mem[_1436 + 32] = 'SafeMath: division by zero'
                                if not totalAllocPoint:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _1436 + 32]
                                        idx = idx + 32
                                        continue 
                                else:
                                    _1545 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_1545] = 26
                                    mem[_1545 + 32] = 'SafeMath: division by zero'
                                    if not 2^(block.number - startBlock / halvingPeriod):
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _1545 + 32]
                                            idx = idx + 32
                                            continue 
                                    else:
                                        _1653 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_1653] = 26
                                        mem[_1653 + 32] = 'SafeMath: division by zero'
                                        require ext_code.size(frogAddress)
                                        call frogAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args this.address, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[mem[64] + 4] = this.address
                                        mem[mem[64] + 36] = 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                                        require ext_code.size(frogAddress)
                                        call frogAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args this.address, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _1768 = mem[64]
                                        mem[mem[64]] = 2
                                        mem[64] = mem[64] + 96
                                        require mem[_1768]
                                        mem[_1768 + 32] = frogAddress
                                        require 1 < mem[_1768]
                                        mem[_1768 + 64] = wbnbAddress
                                        if block.timestamp + 1800 < block.timestamp:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[_1768 + 96] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                        mem[_1768 + 100] = 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                                        mem[_1768 + 132] = 0
                                        mem[_1768 + 196] = fundsAddress
                                        mem[_1768 + 228] = block.timestamp + 1800
                                        mem[_1768 + 164] = 160
                                        mem[_1768 + 260] = mem[_1768]
                                        s = 0
                                        while s < 32 * mem[_1768]:
                                            mem[s + _1768 + 292] = mem[s + _1768 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                             gas gas_remaining wei
                                            args 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20, 0, 160, fundsAddress, block.timestamp + 1800, mem[_1768 + 260 len (32 * mem[_1768]) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[_1768 + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = _1768 + ceil32(return_data.size) + 96
                                        require return_data.size >= 32
                                        _2474 = mem[_1768 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32
                                        require mem[_1768 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 <= 4294967296
                                        require mem[_1768 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 32 <= return_data.size
                                        require mem[_1768 + mem[_1768 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 96] <= 4294967296 and mem[_1768 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + (32 * mem[_1768 + mem[_1768 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 96]) + 32 <= return_data.size
                                        mem[_1768 + ceil32(return_data.size) + 96] = mem[_1768 + mem[_1768 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 96]
                                        _2512 = mem[_1768 + _2474 + 96]
                                        s = 0
                                        while s < 32 * _2512:
                                            mem[s + _1768 + ceil32(return_data.size) + 128] = mem[s + _1768 + _2474 + 128]
                                            s = s + 32
                                            continue 
                                        if not 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod):
                                            mem[64] = (32 * _2512) + _1768 + ceil32(return_data.size) + 192
                                            mem[(32 * _2512) + _1768 + ceil32(return_data.size) + 128] = 26
                                            mem[(32 * _2512) + _1768 + ceil32(return_data.size) + 160] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if 10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) != 10^12:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * _2512) + _1768 + ceil32(return_data.size) + 229 len 31]
                                            mem[64] = (32 * _2512) + _1768 + ceil32(return_data.size) + 192
                                            mem[(32 * _2512) + _1768 + ceil32(return_data.size) + 128] = 26
                                            mem[(32 * _2512) + _1768 + ceil32(return_data.size) + 160] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                        ('iszero', ('ext_call.return_data', 0, 32))
                                        mem[(32 * _2512) + _1768 + ceil32(return_data.size) + 192] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[(32 * _2512) + _1768 + ceil32(return_data.size) + 196] = 32
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + (32 * _2512) + _1768 + ceil32(return_data.size) + 260] = mem[idx + (32 * _2512) + _1768 + ceil32(return_data.size) + 160]
                                            idx = idx + 32
                                            continue 
                            else:
                                if (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / (block.number * frogPerBlock) - (poolInfo[idx].field_512 * frogPerBlock) != poolInfo[idx].field_256:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _1453 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1453] = 26
                                mem[_1453 + 32] = 'SafeMath: division by zero'
                                if not totalAllocPoint:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _1453 + 32]
                                        idx = idx + 32
                                        continue 
                                else:
                                    _1560 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_1560] = 26
                                    mem[_1560 + 32] = 'SafeMath: division by zero'
                                    if not 2^(block.number - startBlock / halvingPeriod):
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _1560 + 32]
                                            idx = idx + 32
                                            continue 
                                    else:
                                        _1669 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_1669] = 26
                                        mem[_1669 + 32] = 'SafeMath: division by zero'
                                        require ext_code.size(frogAddress)
                                        call frogAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args this.address, (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[mem[64] + 4] = this.address
                                        mem[mem[64] + 36] = (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                                        require ext_code.size(frogAddress)
                                        call frogAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args this.address, (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _1779 = mem[64]
                                        mem[mem[64]] = 2
                                        mem[64] = mem[64] + 96
                                        require mem[_1779]
                                        mem[_1779 + 32] = frogAddress
                                        require 1 < mem[_1779]
                                        mem[_1779 + 64] = wbnbAddress
                                        if block.timestamp + 1800 < block.timestamp:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[_1779 + 96] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                        mem[_1779 + 100] = (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                                        mem[_1779 + 132] = 0
                                        mem[_1779 + 196] = fundsAddress
                                        mem[_1779 + 228] = block.timestamp + 1800
                                        mem[_1779 + 164] = 160
                                        mem[_1779 + 260] = mem[_1779]
                                        s = 0
                                        while s < 32 * mem[_1779]:
                                            mem[s + _1779 + 292] = mem[s + _1779 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                             gas gas_remaining wei
                                            args (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20, 0, 160, fundsAddress, block.timestamp + 1800, mem[_1779 + 260 len (32 * mem[_1779]) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[_1779 + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = _1779 + ceil32(return_data.size) + 96
                                        require return_data.size >= 32
                                        _2472 = mem[_1779 + 96 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32
                                        require mem[_1779 + 96 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 <= 4294967296
                                        require mem[_1779 + 96 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 32 <= return_data.size
                                        require mem[_1779 + mem[_1779 + 96 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 96] <= 4294967296 and mem[_1779 + 96 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + (32 * mem[_1779 + mem[_1779 + 96 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 96]) + 32 <= return_data.size
                                        mem[_1779 + ceil32(return_data.size) + 96] = mem[_1779 + mem[_1779 + 96 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 96]
                                        _2511 = mem[_1779 + _2472 + 96]
                                        s = 0
                                        while s < 32 * _2511:
                                            mem[s + _1779 + ceil32(return_data.size) + 128] = mem[s + _1779 + _2472 + 128]
                                            s = s + 32
                                            continue 
                                        if not (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod):
                                            mem[64] = (32 * _2511) + _1779 + ceil32(return_data.size) + 192
                                            mem[(32 * _2511) + _1779 + ceil32(return_data.size) + 128] = 26
                                            mem[(32 * _2511) + _1779 + ceil32(return_data.size) + 160] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if 10^12 * (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) != 10^12:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * _2511) + _1779 + ceil32(return_data.size) + 229 len 31]
                                            mem[64] = (32 * _2511) + _1779 + ceil32(return_data.size) + 192
                                            mem[(32 * _2511) + _1779 + ceil32(return_data.size) + 128] = 26
                                            mem[(32 * _2511) + _1779 + ceil32(return_data.size) + 160] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (10^12 * (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 10^12 * (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                        ('iszero', ('ext_call.return_data', 0, 32))
                                        mem[(32 * _2511) + _1779 + ceil32(return_data.size) + 192] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[(32 * _2511) + _1779 + ceil32(return_data.size) + 196] = 32
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + (32 * _2511) + _1779 + ceil32(return_data.size) + 260] = mem[idx + (32 * _2511) + _1779 + ceil32(return_data.size) + 160]
                                            idx = idx + 32
                                            continue 
        revert with 0, 'SafeMath: division by zero'
}

function set(uint256 arg1, uint256 arg2, bool arg3) payable {
    mem[64] = 96
    require calldata.size - 4 >= 96
    if owner != msg.sender:
        revert with 0, 'wOwnable: caller is not the owne'
    if arg3:
        idx = 0
        while idx < poolInfo.length:
            mem[0] = 8
            if block.number <= poolInfo[idx].field_512:
                idx = idx + 1
                continue 
            mem[mem[64] + 4] = this.address
            require ext_code.size(poolInfo[idx].field_0)
            staticcall poolInfo[idx].field_0.0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if not ext_call.return_data[0]:
                poolInfo[idx].field_512 = block.number
                idx = idx + 1
                continue 
            if block.number <= bonusEndBlock:
                _1185 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1185] = 30
                mem[_1185 + 32] = 'SafeMath: subtraction overflow'
                if poolInfo[idx].field_512 > block.number:
                    _1189 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _1189 + 68] = mem[idx + _1185 + 32]
                        idx = idx + 32
                        continue 
                    mem[_1189 + 68] = mem[_1189 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _1189 + -mem[64] + 100
                if not block.number - poolInfo[idx].field_512:
                    _1223 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1223] = 30
                    mem[_1223 + 32] = 'SafeMath: subtraction overflow'
                    if startBlock > block.number:
                        _1230 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _1230 + 68] = mem[idx + _1223 + 32]
                            idx = idx + 32
                            continue 
                        mem[_1230 + 68] = mem[_1230 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _1230 + -mem[64] + 100
                    _1247 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1247] = 26
                    mem[_1247 + 32] = 'SafeMath: division by zero'
                    if not halvingPeriod:
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                        idx = 32
                        while idx < 26:
                            mem[idx + mem[64] + 68] = mem[idx + _1247 + 32]
                            idx = idx + 32
                            continue 
                    else:
                        _1334 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1334] = 26
                        mem[_1334 + 32] = 'SafeMath: division by zero'
                        if not totalAllocPoint:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _1334 + 32]
                                idx = idx + 32
                                continue 
                        else:
                            _1414 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1414] = 26
                            mem[_1414 + 32] = 'SafeMath: division by zero'
                            if not 2^(block.number - startBlock / halvingPeriod):
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _1414 + 32]
                                    idx = idx + 32
                                    continue 
                            else:
                                _1511 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1511] = 26
                                mem[_1511 + 32] = 'SafeMath: division by zero'
                                require ext_code.size(frogAddress)
                                call frogAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args this.address, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod)
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[mem[64] + 4] = this.address
                                mem[mem[64] + 36] = 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                                require ext_code.size(frogAddress)
                                call frogAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args this.address, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _1673 = mem[64]
                                mem[mem[64]] = 2
                                mem[64] = mem[64] + 96
                                require mem[_1673]
                                mem[_1673 + 32] = frogAddress
                                require 1 < mem[_1673]
                                mem[_1673 + 64] = wbnbAddress
                                if block.timestamp + 1800 < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[_1673 + 96] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                mem[_1673 + 100] = 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                                mem[_1673 + 132] = 0
                                mem[_1673 + 196] = fundsAddress
                                mem[_1673 + 228] = block.timestamp + 1800
                                mem[_1673 + 164] = 160
                                mem[_1673 + 260] = mem[_1673]
                                s = 0
                                while s < 32 * mem[_1673]:
                                    mem[s + _1673 + 292] = mem[s + _1673 + 32]
                                    s = s + 32
                                    continue 
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20, 0, 160, fundsAddress, block.timestamp + 1800, mem[_1673 + 260 len (32 * mem[_1673]) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[_1673 + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = _1673 + ceil32(return_data.size) + 96
                                require return_data.size >= 32
                                _2544 = mem[_1673 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32
                                require mem[_1673 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 <= 4294967296
                                require mem[_1673 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 32 <= return_data.size
                                require mem[_1673 + mem[_1673 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 96] <= 4294967296 and mem[_1673 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + (32 * mem[_1673 + mem[_1673 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 96]) + 32 <= return_data.size
                                mem[_1673 + ceil32(return_data.size) + 96] = mem[_1673 + mem[_1673 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 96]
                                _2571 = mem[_1673 + _2544 + 96]
                                s = 0
                                while s < 32 * _2571:
                                    mem[s + _1673 + ceil32(return_data.size) + 128] = mem[s + _1673 + _2544 + 128]
                                    s = s + 32
                                    continue 
                                if not 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod):
                                    mem[64] = (32 * _2571) + _1673 + ceil32(return_data.size) + 192
                                    mem[(32 * _2571) + _1673 + ceil32(return_data.size) + 128] = 26
                                    mem[(32 * _2571) + _1673 + ceil32(return_data.size) + 160] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                else:
                                    if 10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) != 10^12:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * _2571) + _1673 + ceil32(return_data.size) + 229 len 31]
                                    mem[64] = (32 * _2571) + _1673 + ceil32(return_data.size) + 192
                                    mem[(32 * _2571) + _1673 + ceil32(return_data.size) + 128] = 26
                                    mem[(32 * _2571) + _1673 + ceil32(return_data.size) + 160] = 'SafeMath: division by zero'
                                    if ext_call.return_data[0]:
                                        if (10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]
                                        poolInfo[idx].field_512 = block.number
                                        idx = idx + 1
                                        continue 
                                ('iszero', ('ext_call.return_data', 0, 32))
                                mem[(32 * _2571) + _1673 + ceil32(return_data.size) + 192] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[(32 * _2571) + _1673 + ceil32(return_data.size) + 196] = 32
                                idx = 32
                                while idx < 26:
                                    mem[idx + (32 * _2571) + _1673 + ceil32(return_data.size) + 260] = mem[idx + (32 * _2571) + _1673 + ceil32(return_data.size) + 160]
                                    idx = idx + 32
                                    continue 
                else:
                    if block.number - poolInfo[idx].field_512 / block.number - poolInfo[idx].field_512 != 1:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _1226 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1226] = 30
                    mem[_1226 + 32] = 'SafeMath: subtraction overflow'
                    if startBlock > block.number:
                        _1236 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _1236 + 68] = mem[idx + _1226 + 32]
                            idx = idx + 32
                            continue 
                        mem[_1236 + 68] = mem[_1236 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _1236 + -mem[64] + 100
                    _1254 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1254] = 26
                    mem[_1254 + 32] = 'SafeMath: division by zero'
                    if not halvingPeriod:
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                        idx = 32
                        while idx < 26:
                            mem[idx + mem[64] + 68] = mem[idx + _1254 + 32]
                            idx = idx + 32
                            continue 
                    else:
                        if not block.number - poolInfo[idx].field_512:
                            _1347 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1347] = 26
                            mem[_1347 + 32] = 'SafeMath: division by zero'
                            if not totalAllocPoint:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _1347 + 32]
                                    idx = idx + 32
                                    continue 
                            else:
                                _1427 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1427] = 26
                                mem[_1427 + 32] = 'SafeMath: division by zero'
                                if not 2^(block.number - startBlock / halvingPeriod):
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _1427 + 32]
                                        idx = idx + 32
                                        continue 
                                else:
                                    _1528 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_1528] = 26
                                    mem[_1528 + 32] = 'SafeMath: division by zero'
                                    require ext_code.size(frogAddress)
                                    call frogAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args this.address, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[mem[64] + 4] = this.address
                                    mem[mem[64] + 36] = 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                                    require ext_code.size(frogAddress)
                                    call frogAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args this.address, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _1692 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    require mem[_1692]
                                    mem[_1692 + 32] = frogAddress
                                    require 1 < mem[_1692]
                                    mem[_1692 + 64] = wbnbAddress
                                    if block.timestamp + 1800 < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[_1692 + 96] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_1692 + 100] = 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                                    mem[_1692 + 132] = 0
                                    mem[_1692 + 196] = fundsAddress
                                    mem[_1692 + 228] = block.timestamp + 1800
                                    mem[_1692 + 164] = 160
                                    mem[_1692 + 260] = mem[_1692]
                                    s = 0
                                    while s < 32 * mem[_1692]:
                                        mem[s + _1692 + 292] = mem[s + _1692 + 32]
                                        s = s + 32
                                        continue 
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20, 0, 160, fundsAddress, block.timestamp + 1800, mem[_1692 + 260 len (32 * mem[_1692]) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_1692 + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _1692 + ceil32(return_data.size) + 96
                                    require return_data.size >= 32
                                    _2542 = mem[_1692 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32
                                    require mem[_1692 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 <= 4294967296
                                    require mem[_1692 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 32 <= return_data.size
                                    require mem[_1692 + mem[_1692 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 96] <= 4294967296 and mem[_1692 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + (32 * mem[_1692 + mem[_1692 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 96]) + 32 <= return_data.size
                                    mem[_1692 + ceil32(return_data.size) + 96] = mem[_1692 + mem[_1692 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 96]
                                    _2570 = mem[_1692 + _2542 + 96]
                                    s = 0
                                    while s < 32 * _2570:
                                        mem[s + _1692 + ceil32(return_data.size) + 128] = mem[s + _1692 + _2542 + 128]
                                        s = s + 32
                                        continue 
                                    if not 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod):
                                        mem[64] = (32 * _2570) + _1692 + ceil32(return_data.size) + 192
                                        mem[(32 * _2570) + _1692 + ceil32(return_data.size) + 128] = 26
                                        mem[(32 * _2570) + _1692 + ceil32(return_data.size) + 160] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                    else:
                                        if 10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) != 10^12:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * _2570) + _1692 + ceil32(return_data.size) + 229 len 31]
                                        mem[64] = (32 * _2570) + _1692 + ceil32(return_data.size) + 192
                                        mem[(32 * _2570) + _1692 + ceil32(return_data.size) + 128] = 26
                                        mem[(32 * _2570) + _1692 + ceil32(return_data.size) + 160] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                    ('iszero', ('ext_call.return_data', 0, 32))
                                    mem[(32 * _2570) + _1692 + ceil32(return_data.size) + 192] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[(32 * _2570) + _1692 + ceil32(return_data.size) + 196] = 32
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + (32 * _2570) + _1692 + ceil32(return_data.size) + 260] = mem[idx + (32 * _2570) + _1692 + ceil32(return_data.size) + 160]
                                        idx = idx + 32
                                        continue 
                        else:
                            if (block.number * frogPerBlock) - (poolInfo[idx].field_512 * frogPerBlock) / block.number - poolInfo[idx].field_512 != frogPerBlock:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not (block.number * frogPerBlock) - (poolInfo[idx].field_512 * frogPerBlock):
                                _1356 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1356] = 26
                                mem[_1356 + 32] = 'SafeMath: division by zero'
                                if not totalAllocPoint:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _1356 + 32]
                                        idx = idx + 32
                                        continue 
                                else:
                                    _1438 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_1438] = 26
                                    mem[_1438 + 32] = 'SafeMath: division by zero'
                                    if not 2^(block.number - startBlock / halvingPeriod):
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _1438 + 32]
                                            idx = idx + 32
                                            continue 
                                    else:
                                        _1547 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_1547] = 26
                                        mem[_1547 + 32] = 'SafeMath: division by zero'
                                        require ext_code.size(frogAddress)
                                        call frogAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args this.address, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[mem[64] + 4] = this.address
                                        mem[mem[64] + 36] = 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                                        require ext_code.size(frogAddress)
                                        call frogAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args this.address, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _1710 = mem[64]
                                        mem[mem[64]] = 2
                                        mem[64] = mem[64] + 96
                                        require mem[_1710]
                                        mem[_1710 + 32] = frogAddress
                                        require 1 < mem[_1710]
                                        mem[_1710 + 64] = wbnbAddress
                                        if block.timestamp + 1800 < block.timestamp:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[_1710 + 96] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                        mem[_1710 + 100] = 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                                        mem[_1710 + 132] = 0
                                        mem[_1710 + 196] = fundsAddress
                                        mem[_1710 + 228] = block.timestamp + 1800
                                        mem[_1710 + 164] = 160
                                        mem[_1710 + 260] = mem[_1710]
                                        s = 0
                                        while s < 32 * mem[_1710]:
                                            mem[s + _1710 + 292] = mem[s + _1710 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                             gas gas_remaining wei
                                            args 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20, 0, 160, fundsAddress, block.timestamp + 1800, mem[_1710 + 260 len (32 * mem[_1710]) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[_1710 + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = _1710 + ceil32(return_data.size) + 96
                                        require return_data.size >= 32
                                        _2540 = mem[_1710 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32
                                        require mem[_1710 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 <= 4294967296
                                        require mem[_1710 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 32 <= return_data.size
                                        require mem[_1710 + mem[_1710 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 96] <= 4294967296 and mem[_1710 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + (32 * mem[_1710 + mem[_1710 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 96]) + 32 <= return_data.size
                                        mem[_1710 + ceil32(return_data.size) + 96] = mem[_1710 + mem[_1710 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 96]
                                        _2569 = mem[_1710 + _2540 + 96]
                                        s = 0
                                        while s < 32 * _2569:
                                            mem[s + _1710 + ceil32(return_data.size) + 128] = mem[s + _1710 + _2540 + 128]
                                            s = s + 32
                                            continue 
                                        if not 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod):
                                            mem[64] = (32 * _2569) + _1710 + ceil32(return_data.size) + 192
                                            mem[(32 * _2569) + _1710 + ceil32(return_data.size) + 128] = 26
                                            mem[(32 * _2569) + _1710 + ceil32(return_data.size) + 160] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if 10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) != 10^12:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * _2569) + _1710 + ceil32(return_data.size) + 229 len 31]
                                            mem[64] = (32 * _2569) + _1710 + ceil32(return_data.size) + 192
                                            mem[(32 * _2569) + _1710 + ceil32(return_data.size) + 128] = 26
                                            mem[(32 * _2569) + _1710 + ceil32(return_data.size) + 160] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                        ('iszero', ('ext_call.return_data', 0, 32))
                                        mem[(32 * _2569) + _1710 + ceil32(return_data.size) + 192] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[(32 * _2569) + _1710 + ceil32(return_data.size) + 196] = 32
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + (32 * _2569) + _1710 + ceil32(return_data.size) + 260] = mem[idx + (32 * _2569) + _1710 + ceil32(return_data.size) + 160]
                                            idx = idx + 32
                                            continue 
                            else:
                                if (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / (block.number * frogPerBlock) - (poolInfo[idx].field_512 * frogPerBlock) != poolInfo[idx].field_256:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _1368 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1368] = 26
                                mem[_1368 + 32] = 'SafeMath: division by zero'
                                if not totalAllocPoint:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _1368 + 32]
                                        idx = idx + 32
                                        continue 
                                else:
                                    _1455 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_1455] = 26
                                    mem[_1455 + 32] = 'SafeMath: division by zero'
                                    if not 2^(block.number - startBlock / halvingPeriod):
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _1455 + 32]
                                            idx = idx + 32
                                            continue 
                                    else:
                                        _1565 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_1565] = 26
                                        mem[_1565 + 32] = 'SafeMath: division by zero'
                                        require ext_code.size(frogAddress)
                                        call frogAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args this.address, (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[mem[64] + 4] = this.address
                                        mem[mem[64] + 36] = (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                                        require ext_code.size(frogAddress)
                                        call frogAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args this.address, (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _1723 = mem[64]
                                        mem[mem[64]] = 2
                                        mem[64] = mem[64] + 96
                                        require mem[_1723]
                                        mem[_1723 + 32] = frogAddress
                                        require 1 < mem[_1723]
                                        mem[_1723 + 64] = wbnbAddress
                                        if block.timestamp + 1800 < block.timestamp:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[_1723 + 96] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                        mem[_1723 + 100] = (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                                        mem[_1723 + 132] = 0
                                        mem[_1723 + 196] = fundsAddress
                                        mem[_1723 + 228] = block.timestamp + 1800
                                        mem[_1723 + 164] = 160
                                        mem[_1723 + 260] = mem[_1723]
                                        s = 0
                                        while s < 32 * mem[_1723]:
                                            mem[s + _1723 + 292] = mem[s + _1723 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                             gas gas_remaining wei
                                            args (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20, 0, 160, fundsAddress, block.timestamp + 1800, mem[_1723 + 260 len (32 * mem[_1723]) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[_1723 + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = _1723 + ceil32(return_data.size) + 96
                                        require return_data.size >= 32
                                        _2538 = mem[_1723 + 96 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32
                                        require mem[_1723 + 96 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 <= 4294967296
                                        require mem[_1723 + 96 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 32 <= return_data.size
                                        require mem[_1723 + mem[_1723 + 96 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 96] <= 4294967296 and mem[_1723 + 96 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + (32 * mem[_1723 + mem[_1723 + 96 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 96]) + 32 <= return_data.size
                                        mem[_1723 + ceil32(return_data.size) + 96] = mem[_1723 + mem[_1723 + 96 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 96]
                                        _2568 = mem[_1723 + _2538 + 96]
                                        s = 0
                                        while s < 32 * _2568:
                                            mem[s + _1723 + ceil32(return_data.size) + 128] = mem[s + _1723 + _2538 + 128]
                                            s = s + 32
                                            continue 
                                        if not (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod):
                                            mem[64] = (32 * _2568) + _1723 + ceil32(return_data.size) + 192
                                            mem[(32 * _2568) + _1723 + ceil32(return_data.size) + 128] = 26
                                            mem[(32 * _2568) + _1723 + ceil32(return_data.size) + 160] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if 10^12 * (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) != 10^12:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * _2568) + _1723 + ceil32(return_data.size) + 229 len 31]
                                            mem[64] = (32 * _2568) + _1723 + ceil32(return_data.size) + 192
                                            mem[(32 * _2568) + _1723 + ceil32(return_data.size) + 128] = 26
                                            mem[(32 * _2568) + _1723 + ceil32(return_data.size) + 160] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (10^12 * (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 10^12 * (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                        ('iszero', ('ext_call.return_data', 0, 32))
                                        mem[(32 * _2568) + _1723 + ceil32(return_data.size) + 192] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[(32 * _2568) + _1723 + ceil32(return_data.size) + 196] = 32
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + (32 * _2568) + _1723 + ceil32(return_data.size) + 260] = mem[idx + (32 * _2568) + _1723 + ceil32(return_data.size) + 160]
                                            idx = idx + 32
                                            continue 
            else:
                if poolInfo[idx].field_512 >= bonusEndBlock:
                    _1188 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1188] = 30
                    mem[_1188 + 32] = 'SafeMath: subtraction overflow'
                    if poolInfo[idx].field_512 > block.number:
                        _1195 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _1195 + 68] = mem[idx + _1188 + 32]
                            idx = idx + 32
                            continue 
                        mem[_1195 + 68] = mem[_1195 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _1195 + -mem[64] + 100
                    _1214 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1214] = 30
                    mem[_1214 + 32] = 'SafeMath: subtraction overflow'
                    if startBlock > block.number:
                        _1218 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _1218 + 68] = mem[idx + _1214 + 32]
                            idx = idx + 32
                            continue 
                        mem[_1218 + 68] = mem[_1218 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _1218 + -mem[64] + 100
                    _1227 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1227] = 26
                    mem[_1227 + 32] = 'SafeMath: division by zero'
                    if not halvingPeriod:
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                        idx = 32
                        while idx < 26:
                            mem[idx + mem[64] + 68] = mem[idx + _1227 + 32]
                            idx = idx + 32
                            continue 
                    else:
                        if not block.number - poolInfo[idx].field_512:
                            _1313 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_1313] = 26
                            mem[_1313 + 32] = 'SafeMath: division by zero'
                            if not totalAllocPoint:
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                mem[mem[64] + 68] = 'SafeMath: division by zero'
                                idx = 32
                                while idx < 26:
                                    mem[idx + mem[64] + 68] = mem[idx + _1313 + 32]
                                    idx = idx + 32
                                    continue 
                            else:
                                _1365 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1365] = 26
                                mem[_1365 + 32] = 'SafeMath: division by zero'
                                if not 2^(block.number - startBlock / halvingPeriod):
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _1365 + 32]
                                        idx = idx + 32
                                        continue 
                                else:
                                    _1452 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_1452] = 26
                                    mem[_1452 + 32] = 'SafeMath: division by zero'
                                    require ext_code.size(frogAddress)
                                    call frogAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args this.address, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod)
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[mem[64] + 4] = this.address
                                    mem[mem[64] + 36] = 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                                    require ext_code.size(frogAddress)
                                    call frogAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args this.address, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _1618 = mem[64]
                                    mem[mem[64]] = 2
                                    mem[64] = mem[64] + 96
                                    require mem[_1618]
                                    mem[_1618 + 32] = frogAddress
                                    require 1 < mem[_1618]
                                    mem[_1618 + 64] = wbnbAddress
                                    if block.timestamp + 1800 < block.timestamp:
                                        revert with 0, 'SafeMath: addition overflow'
                                    mem[_1618 + 96] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[_1618 + 100] = 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                                    mem[_1618 + 132] = 0
                                    mem[_1618 + 196] = fundsAddress
                                    mem[_1618 + 228] = block.timestamp + 1800
                                    mem[_1618 + 164] = 160
                                    mem[_1618 + 260] = mem[_1618]
                                    s = 0
                                    while s < 32 * mem[_1618]:
                                        mem[s + _1618 + 292] = mem[s + _1618 + 32]
                                        s = s + 32
                                        continue 
                                    require ext_code.size(routerAddress)
                                    call routerAddress.swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20, 0, 160, fundsAddress, block.timestamp + 1800, mem[_1618 + 260 len (32 * mem[_1618]) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[_1618 + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = _1618 + ceil32(return_data.size) + 96
                                    require return_data.size >= 32
                                    _2536 = mem[_1618 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32
                                    require mem[_1618 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 <= 4294967296
                                    require mem[_1618 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 32 <= return_data.size
                                    require mem[_1618 + mem[_1618 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 96] <= 4294967296 and mem[_1618 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + (32 * mem[_1618 + mem[_1618 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 96]) + 32 <= return_data.size
                                    mem[_1618 + ceil32(return_data.size) + 96] = mem[_1618 + mem[_1618 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 96]
                                    _2567 = mem[_1618 + _2536 + 96]
                                    s = 0
                                    while s < 32 * _2567:
                                        mem[s + _1618 + ceil32(return_data.size) + 128] = mem[s + _1618 + _2536 + 128]
                                        s = s + 32
                                        continue 
                                    if not 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod):
                                        mem[64] = (32 * _2567) + _1618 + ceil32(return_data.size) + 192
                                        mem[(32 * _2567) + _1618 + ceil32(return_data.size) + 128] = 26
                                        mem[(32 * _2567) + _1618 + ceil32(return_data.size) + 160] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                    else:
                                        if 10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) != 10^12:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * _2567) + _1618 + ceil32(return_data.size) + 229 len 31]
                                        mem[64] = (32 * _2567) + _1618 + ceil32(return_data.size) + 192
                                        mem[(32 * _2567) + _1618 + ceil32(return_data.size) + 128] = 26
                                        mem[(32 * _2567) + _1618 + ceil32(return_data.size) + 160] = 'SafeMath: division by zero'
                                        if ext_call.return_data[0]:
                                            if (10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]
                                            poolInfo[idx].field_512 = block.number
                                            idx = idx + 1
                                            continue 
                                    ('iszero', ('ext_call.return_data', 0, 32))
                                    mem[(32 * _2567) + _1618 + ceil32(return_data.size) + 192] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[(32 * _2567) + _1618 + ceil32(return_data.size) + 196] = 32
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + (32 * _2567) + _1618 + ceil32(return_data.size) + 260] = mem[idx + (32 * _2567) + _1618 + ceil32(return_data.size) + 160]
                                        idx = idx + 32
                                        continue 
                        else:
                            if (block.number * frogPerBlock) - (poolInfo[idx].field_512 * frogPerBlock) / block.number - poolInfo[idx].field_512 != frogPerBlock:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            if not (block.number * frogPerBlock) - (poolInfo[idx].field_512 * frogPerBlock):
                                _1318 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1318] = 26
                                mem[_1318 + 32] = 'SafeMath: division by zero'
                                if not totalAllocPoint:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _1318 + 32]
                                        idx = idx + 32
                                        continue 
                                else:
                                    _1377 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_1377] = 26
                                    mem[_1377 + 32] = 'SafeMath: division by zero'
                                    if not 2^(block.number - startBlock / halvingPeriod):
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _1377 + 32]
                                            idx = idx + 32
                                            continue 
                                    else:
                                        _1469 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_1469] = 26
                                        mem[_1469 + 32] = 'SafeMath: division by zero'
                                        require ext_code.size(frogAddress)
                                        call frogAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args this.address, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[mem[64] + 4] = this.address
                                        mem[mem[64] + 36] = 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                                        require ext_code.size(frogAddress)
                                        call frogAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args this.address, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _1633 = mem[64]
                                        mem[mem[64]] = 2
                                        mem[64] = mem[64] + 96
                                        require mem[_1633]
                                        mem[_1633 + 32] = frogAddress
                                        require 1 < mem[_1633]
                                        mem[_1633 + 64] = wbnbAddress
                                        if block.timestamp + 1800 < block.timestamp:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[_1633 + 96] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                        mem[_1633 + 100] = 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                                        mem[_1633 + 132] = 0
                                        mem[_1633 + 196] = fundsAddress
                                        mem[_1633 + 228] = block.timestamp + 1800
                                        mem[_1633 + 164] = 160
                                        mem[_1633 + 260] = mem[_1633]
                                        s = 0
                                        while s < 32 * mem[_1633]:
                                            mem[s + _1633 + 292] = mem[s + _1633 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                             gas gas_remaining wei
                                            args 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20, 0, 160, fundsAddress, block.timestamp + 1800, mem[_1633 + 260 len (32 * mem[_1633]) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[_1633 + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = _1633 + ceil32(return_data.size) + 96
                                        require return_data.size >= 32
                                        _2534 = mem[_1633 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32
                                        require mem[_1633 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 <= 4294967296
                                        require mem[_1633 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 32 <= return_data.size
                                        require mem[_1633 + mem[_1633 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 96] <= 4294967296 and mem[_1633 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + (32 * mem[_1633 + mem[_1633 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 96]) + 32 <= return_data.size
                                        mem[_1633 + ceil32(return_data.size) + 96] = mem[_1633 + mem[_1633 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 96]
                                        _2566 = mem[_1633 + _2534 + 96]
                                        s = 0
                                        while s < 32 * _2566:
                                            mem[s + _1633 + ceil32(return_data.size) + 128] = mem[s + _1633 + _2534 + 128]
                                            s = s + 32
                                            continue 
                                        if not 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod):
                                            mem[64] = (32 * _2566) + _1633 + ceil32(return_data.size) + 192
                                            mem[(32 * _2566) + _1633 + ceil32(return_data.size) + 128] = 26
                                            mem[(32 * _2566) + _1633 + ceil32(return_data.size) + 160] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if 10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) != 10^12:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * _2566) + _1633 + ceil32(return_data.size) + 229 len 31]
                                            mem[64] = (32 * _2566) + _1633 + ceil32(return_data.size) + 192
                                            mem[(32 * _2566) + _1633 + ceil32(return_data.size) + 128] = 26
                                            mem[(32 * _2566) + _1633 + ceil32(return_data.size) + 160] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                        ('iszero', ('ext_call.return_data', 0, 32))
                                        mem[(32 * _2566) + _1633 + ceil32(return_data.size) + 192] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[(32 * _2566) + _1633 + ceil32(return_data.size) + 196] = 32
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + (32 * _2566) + _1633 + ceil32(return_data.size) + 260] = mem[idx + (32 * _2566) + _1633 + ceil32(return_data.size) + 160]
                                            idx = idx + 32
                                            continue 
                            else:
                                if (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / (block.number * frogPerBlock) - (poolInfo[idx].field_512 * frogPerBlock) != poolInfo[idx].field_256:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                _1322 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1322] = 26
                                mem[_1322 + 32] = 'SafeMath: division by zero'
                                if not totalAllocPoint:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _1322 + 32]
                                        idx = idx + 32
                                        continue 
                                else:
                                    _1389 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_1389] = 26
                                    mem[_1389 + 32] = 'SafeMath: division by zero'
                                    if not 2^(block.number - startBlock / halvingPeriod):
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _1389 + 32]
                                            idx = idx + 32
                                            continue 
                                    else:
                                        _1485 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_1485] = 26
                                        mem[_1485 + 32] = 'SafeMath: division by zero'
                                        require ext_code.size(frogAddress)
                                        call frogAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args this.address, (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[mem[64] + 4] = this.address
                                        mem[mem[64] + 36] = (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                                        require ext_code.size(frogAddress)
                                        call frogAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args this.address, (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _1651 = mem[64]
                                        mem[mem[64]] = 2
                                        mem[64] = mem[64] + 96
                                        require mem[_1651]
                                        mem[_1651 + 32] = frogAddress
                                        require 1 < mem[_1651]
                                        mem[_1651 + 64] = wbnbAddress
                                        if block.timestamp + 1800 < block.timestamp:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[_1651 + 96] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                        mem[_1651 + 100] = (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                                        mem[_1651 + 132] = 0
                                        mem[_1651 + 196] = fundsAddress
                                        mem[_1651 + 228] = block.timestamp + 1800
                                        mem[_1651 + 164] = 160
                                        mem[_1651 + 260] = mem[_1651]
                                        s = 0
                                        while s < 32 * mem[_1651]:
                                            mem[s + _1651 + 292] = mem[s + _1651 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                             gas gas_remaining wei
                                            args (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20, 0, 160, fundsAddress, block.timestamp + 1800, mem[_1651 + 260 len (32 * mem[_1651]) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[_1651 + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = _1651 + ceil32(return_data.size) + 96
                                        require return_data.size >= 32
                                        _2532 = mem[_1651 + 96 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32
                                        require mem[_1651 + 96 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 <= 4294967296
                                        require mem[_1651 + 96 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 32 <= return_data.size
                                        require mem[_1651 + mem[_1651 + 96 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 96] <= 4294967296 and mem[_1651 + 96 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + (32 * mem[_1651 + mem[_1651 + 96 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 96]) + 32 <= return_data.size
                                        mem[_1651 + ceil32(return_data.size) + 96] = mem[_1651 + mem[_1651 + 96 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 96]
                                        _2565 = mem[_1651 + _2532 + 96]
                                        s = 0
                                        while s < 32 * _2565:
                                            mem[s + _1651 + ceil32(return_data.size) + 128] = mem[s + _1651 + _2532 + 128]
                                            s = s + 32
                                            continue 
                                        if not (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod):
                                            mem[64] = (32 * _2565) + _1651 + ceil32(return_data.size) + 192
                                            mem[(32 * _2565) + _1651 + ceil32(return_data.size) + 128] = 26
                                            mem[(32 * _2565) + _1651 + ceil32(return_data.size) + 160] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if 10^12 * (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) != 10^12:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * _2565) + _1651 + ceil32(return_data.size) + 229 len 31]
                                            mem[64] = (32 * _2565) + _1651 + ceil32(return_data.size) + 192
                                            mem[(32 * _2565) + _1651 + ceil32(return_data.size) + 128] = 26
                                            mem[(32 * _2565) + _1651 + ceil32(return_data.size) + 160] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (10^12 * (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 10^12 * (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                        ('iszero', ('ext_call.return_data', 0, 32))
                                        mem[(32 * _2565) + _1651 + ceil32(return_data.size) + 192] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[(32 * _2565) + _1651 + ceil32(return_data.size) + 196] = 32
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + (32 * _2565) + _1651 + ceil32(return_data.size) + 260] = mem[idx + (32 * _2565) + _1651 + ceil32(return_data.size) + 160]
                                            idx = idx + 32
                                            continue 
                else:
                    _1187 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1187] = 30
                    mem[_1187 + 32] = 'SafeMath: subtraction overflow'
                    if bonusEndBlock > block.number:
                        _1192 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _1192 + 68] = mem[idx + _1187 + 32]
                            idx = idx + 32
                            continue 
                        mem[_1192 + 68] = mem[_1192 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _1192 + -mem[64] + 100
                    _1203 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1203] = 30
                    mem[_1203 + 32] = 'SafeMath: subtraction overflow'
                    if poolInfo[idx].field_512 > bonusEndBlock:
                        _1211 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _1211 + 68] = mem[idx + _1203 + 32]
                            idx = idx + 32
                            continue 
                        mem[_1211 + 68] = mem[_1211 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _1211 + -mem[64] + 100
                    if not bonusEndBlock - poolInfo[idx].field_512:
                        if block.number - bonusEndBlock < 0:
                            revert with 0, 'SafeMath: addition overflow'
                        _1270 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1270] = 30
                        mem[_1270 + 32] = 'SafeMath: subtraction overflow'
                        if startBlock > block.number:
                            _1280 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _1280 + 68] = mem[idx + _1270 + 32]
                                idx = idx + 32
                                continue 
                            mem[_1280 + 68] = mem[_1280 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _1280 + -mem[64] + 100
                        _1298 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1298] = 26
                        mem[_1298 + 32] = 'SafeMath: division by zero'
                        if not halvingPeriod:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _1298 + 32]
                                idx = idx + 32
                                continue 
                        else:
                            if not block.number - bonusEndBlock:
                                _1447 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1447] = 26
                                mem[_1447 + 32] = 'SafeMath: division by zero'
                                if not totalAllocPoint:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _1447 + 32]
                                        idx = idx + 32
                                        continue 
                                else:
                                    _1560 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_1560] = 26
                                    mem[_1560 + 32] = 'SafeMath: division by zero'
                                    if not 2^(block.number - startBlock / halvingPeriod):
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _1560 + 32]
                                            idx = idx + 32
                                            continue 
                                    else:
                                        _1667 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_1667] = 26
                                        mem[_1667 + 32] = 'SafeMath: division by zero'
                                        require ext_code.size(frogAddress)
                                        call frogAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args this.address, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[mem[64] + 4] = this.address
                                        mem[mem[64] + 36] = 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                                        require ext_code.size(frogAddress)
                                        call frogAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args this.address, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _1790 = mem[64]
                                        mem[mem[64]] = 2
                                        mem[64] = mem[64] + 96
                                        require mem[_1790]
                                        mem[_1790 + 32] = frogAddress
                                        require 1 < mem[_1790]
                                        mem[_1790 + 64] = wbnbAddress
                                        if block.timestamp + 1800 < block.timestamp:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[_1790 + 96] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                        mem[_1790 + 100] = 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                                        mem[_1790 + 132] = 0
                                        mem[_1790 + 196] = fundsAddress
                                        mem[_1790 + 228] = block.timestamp + 1800
                                        mem[_1790 + 164] = 160
                                        mem[_1790 + 260] = mem[_1790]
                                        s = 0
                                        while s < 32 * mem[_1790]:
                                            mem[s + _1790 + 292] = mem[s + _1790 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                             gas gas_remaining wei
                                            args 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20, 0, 160, fundsAddress, block.timestamp + 1800, mem[_1790 + 260 len (32 * mem[_1790]) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[_1790 + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = _1790 + ceil32(return_data.size) + 96
                                        require return_data.size >= 32
                                        _2530 = mem[_1790 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32
                                        require mem[_1790 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 <= 4294967296
                                        require mem[_1790 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 32 <= return_data.size
                                        require mem[_1790 + mem[_1790 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 96] <= 4294967296 and mem[_1790 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + (32 * mem[_1790 + mem[_1790 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 96]) + 32 <= return_data.size
                                        mem[_1790 + ceil32(return_data.size) + 96] = mem[_1790 + mem[_1790 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 96]
                                        _2564 = mem[_1790 + _2530 + 96]
                                        s = 0
                                        while s < 32 * _2564:
                                            mem[s + _1790 + ceil32(return_data.size) + 128] = mem[s + _1790 + _2530 + 128]
                                            s = s + 32
                                            continue 
                                        if not 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod):
                                            mem[64] = (32 * _2564) + _1790 + ceil32(return_data.size) + 192
                                            mem[(32 * _2564) + _1790 + ceil32(return_data.size) + 128] = 26
                                            mem[(32 * _2564) + _1790 + ceil32(return_data.size) + 160] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if 10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) != 10^12:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * _2564) + _1790 + ceil32(return_data.size) + 229 len 31]
                                            mem[64] = (32 * _2564) + _1790 + ceil32(return_data.size) + 192
                                            mem[(32 * _2564) + _1790 + ceil32(return_data.size) + 128] = 26
                                            mem[(32 * _2564) + _1790 + ceil32(return_data.size) + 160] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                        ('iszero', ('ext_call.return_data', 0, 32))
                                        mem[(32 * _2564) + _1790 + ceil32(return_data.size) + 192] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[(32 * _2564) + _1790 + ceil32(return_data.size) + 196] = 32
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + (32 * _2564) + _1790 + ceil32(return_data.size) + 260] = mem[idx + (32 * _2564) + _1790 + ceil32(return_data.size) + 160]
                                            idx = idx + 32
                                            continue 
                            else:
                                if (block.number * frogPerBlock) - (bonusEndBlock * frogPerBlock) / block.number - bonusEndBlock != frogPerBlock:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not (block.number * frogPerBlock) - (bonusEndBlock * frogPerBlock):
                                    _1466 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_1466] = 26
                                    mem[_1466 + 32] = 'SafeMath: division by zero'
                                    if not totalAllocPoint:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _1466 + 32]
                                            idx = idx + 32
                                            continue 
                                    else:
                                        _1578 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_1578] = 26
                                        mem[_1578 + 32] = 'SafeMath: division by zero'
                                        if not 2^(block.number - startBlock / halvingPeriod):
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _1578 + 32]
                                                idx = idx + 32
                                                continue 
                                        else:
                                            _1684 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_1684] = 26
                                            mem[_1684 + 32] = 'SafeMath: division by zero'
                                            require ext_code.size(frogAddress)
                                            call frogAddress.0x40c10f19 with:
                                                 gas gas_remaining wei
                                                args this.address, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[mem[64] + 4] = this.address
                                            mem[mem[64] + 36] = 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                                            require ext_code.size(frogAddress)
                                            call frogAddress.0x40c10f19 with:
                                                 gas gas_remaining wei
                                                args this.address, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _1802 = mem[64]
                                            mem[mem[64]] = 2
                                            mem[64] = mem[64] + 96
                                            require mem[_1802]
                                            mem[_1802 + 32] = frogAddress
                                            require 1 < mem[_1802]
                                            mem[_1802 + 64] = wbnbAddress
                                            if block.timestamp + 1800 < block.timestamp:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[_1802 + 96] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                            mem[_1802 + 100] = 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                                            mem[_1802 + 132] = 0
                                            mem[_1802 + 196] = fundsAddress
                                            mem[_1802 + 228] = block.timestamp + 1800
                                            mem[_1802 + 164] = 160
                                            mem[_1802 + 260] = mem[_1802]
                                            s = 0
                                            while s < 32 * mem[_1802]:
                                                mem[s + _1802 + 292] = mem[s + _1802 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(routerAddress)
                                            call routerAddress.swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                 gas gas_remaining wei
                                                args 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20, 0, 160, fundsAddress, block.timestamp + 1800, mem[_1802 + 260 len (32 * mem[_1802]) + 32]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[_1802 + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = _1802 + ceil32(return_data.size) + 96
                                            require return_data.size >= 32
                                            _2528 = mem[_1802 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32
                                            require mem[_1802 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 <= 4294967296
                                            require mem[_1802 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 32 <= return_data.size
                                            require mem[_1802 + mem[_1802 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 96] <= 4294967296 and mem[_1802 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + (32 * mem[_1802 + mem[_1802 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 96]) + 32 <= return_data.size
                                            mem[_1802 + ceil32(return_data.size) + 96] = mem[_1802 + mem[_1802 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 96]
                                            _2563 = mem[_1802 + _2528 + 96]
                                            s = 0
                                            while s < 32 * _2563:
                                                mem[s + _1802 + ceil32(return_data.size) + 128] = mem[s + _1802 + _2528 + 128]
                                                s = s + 32
                                                continue 
                                            if not 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod):
                                                mem[64] = (32 * _2563) + _1802 + ceil32(return_data.size) + 192
                                                mem[(32 * _2563) + _1802 + ceil32(return_data.size) + 128] = 26
                                                mem[(32 * _2563) + _1802 + ceil32(return_data.size) + 160] = 'SafeMath: division by zero'
                                                if ext_call.return_data[0]:
                                                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                    poolInfo[idx].field_512 = block.number
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                if 10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) != 10^12:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * _2563) + _1802 + ceil32(return_data.size) + 229 len 31]
                                                mem[64] = (32 * _2563) + _1802 + ceil32(return_data.size) + 192
                                                mem[(32 * _2563) + _1802 + ceil32(return_data.size) + 128] = 26
                                                mem[(32 * _2563) + _1802 + ceil32(return_data.size) + 160] = 'SafeMath: division by zero'
                                                if ext_call.return_data[0]:
                                                    if (10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]
                                                    poolInfo[idx].field_512 = block.number
                                                    idx = idx + 1
                                                    continue 
                                            ('iszero', ('ext_call.return_data', 0, 32))
                                            mem[(32 * _2563) + _1802 + ceil32(return_data.size) + 192] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _2563) + _1802 + ceil32(return_data.size) + 196] = 32
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + (32 * _2563) + _1802 + ceil32(return_data.size) + 260] = mem[idx + (32 * _2563) + _1802 + ceil32(return_data.size) + 160]
                                                idx = idx + 32
                                                continue 
                                else:
                                    if (block.number * frogPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * frogPerBlock * poolInfo[idx].field_256) / (block.number * frogPerBlock) - (bonusEndBlock * frogPerBlock) != poolInfo[idx].field_256:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _1481 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_1481] = 26
                                    mem[_1481 + 32] = 'SafeMath: division by zero'
                                    if not totalAllocPoint:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _1481 + 32]
                                            idx = idx + 32
                                            continue 
                                    else:
                                        _1593 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_1593] = 26
                                        mem[_1593 + 32] = 'SafeMath: division by zero'
                                        if not 2^(block.number - startBlock / halvingPeriod):
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _1593 + 32]
                                                idx = idx + 32
                                                continue 
                                        else:
                                            _1701 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_1701] = 26
                                            mem[_1701 + 32] = 'SafeMath: division by zero'
                                            require ext_code.size(frogAddress)
                                            call frogAddress.0x40c10f19 with:
                                                 gas gas_remaining wei
                                                args this.address, (block.number * frogPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[mem[64] + 4] = this.address
                                            mem[mem[64] + 36] = (block.number * frogPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                                            require ext_code.size(frogAddress)
                                            call frogAddress.0x40c10f19 with:
                                                 gas gas_remaining wei
                                                args this.address, (block.number * frogPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _1815 = mem[64]
                                            mem[mem[64]] = 2
                                            mem[64] = mem[64] + 96
                                            require mem[_1815]
                                            mem[_1815 + 32] = frogAddress
                                            require 1 < mem[_1815]
                                            mem[_1815 + 64] = wbnbAddress
                                            if block.timestamp + 1800 < block.timestamp:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[_1815 + 96] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                            mem[_1815 + 100] = (block.number * frogPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                                            mem[_1815 + 132] = 0
                                            mem[_1815 + 196] = fundsAddress
                                            mem[_1815 + 228] = block.timestamp + 1800
                                            mem[_1815 + 164] = 160
                                            mem[_1815 + 260] = mem[_1815]
                                            s = 0
                                            while s < 32 * mem[_1815]:
                                                mem[s + _1815 + 292] = mem[s + _1815 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(routerAddress)
                                            call routerAddress.swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                 gas gas_remaining wei
                                                args (block.number * frogPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20, 0, 160, fundsAddress, block.timestamp + 1800, mem[_1815 + 260 len (32 * mem[_1815]) + 32]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[_1815 + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = _1815 + ceil32(return_data.size) + 96
                                            require return_data.size >= 32
                                            _2526 = mem[_1815 + 96 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32
                                            require mem[_1815 + 96 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 <= 4294967296
                                            require mem[_1815 + 96 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 32 <= return_data.size
                                            require mem[_1815 + mem[_1815 + 96 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 96] <= 4294967296 and mem[_1815 + 96 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + (32 * mem[_1815 + mem[_1815 + 96 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 96]) + 32 <= return_data.size
                                            mem[_1815 + ceil32(return_data.size) + 96] = mem[_1815 + mem[_1815 + 96 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 96]
                                            _2562 = mem[_1815 + _2526 + 96]
                                            s = 0
                                            while s < 32 * _2562:
                                                mem[s + _1815 + ceil32(return_data.size) + 128] = mem[s + _1815 + _2526 + 128]
                                                s = s + 32
                                                continue 
                                            if not (block.number * frogPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod):
                                                mem[64] = (32 * _2562) + _1815 + ceil32(return_data.size) + 192
                                                mem[(32 * _2562) + _1815 + ceil32(return_data.size) + 128] = 26
                                                mem[(32 * _2562) + _1815 + ceil32(return_data.size) + 160] = 'SafeMath: division by zero'
                                                if ext_call.return_data[0]:
                                                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                    poolInfo[idx].field_512 = block.number
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                if 10^12 * (block.number * frogPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / (block.number * frogPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) != 10^12:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * _2562) + _1815 + ceil32(return_data.size) + 229 len 31]
                                                mem[64] = (32 * _2562) + _1815 + ceil32(return_data.size) + 192
                                                mem[(32 * _2562) + _1815 + ceil32(return_data.size) + 128] = 26
                                                mem[(32 * _2562) + _1815 + ceil32(return_data.size) + 160] = 'SafeMath: division by zero'
                                                if ext_call.return_data[0]:
                                                    if (10^12 * (block.number * frogPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 10^12 * (block.number * frogPerBlock * poolInfo[idx].field_256) - (bonusEndBlock * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]
                                                    poolInfo[idx].field_512 = block.number
                                                    idx = idx + 1
                                                    continue 
                                            ('iszero', ('ext_call.return_data', 0, 32))
                                            mem[(32 * _2562) + _1815 + ceil32(return_data.size) + 192] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _2562) + _1815 + ceil32(return_data.size) + 196] = 32
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + (32 * _2562) + _1815 + ceil32(return_data.size) + 260] = mem[idx + (32 * _2562) + _1815 + ceil32(return_data.size) + 160]
                                                idx = idx + 32
                                                continue 
                    else:
                        if bonusEndBlock - poolInfo[idx].field_512 / bonusEndBlock - poolInfo[idx].field_512 != 1:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if block.number < bonusEndBlock:
                            revert with 0, 'SafeMath: addition overflow'
                        _1275 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1275] = 30
                        mem[_1275 + 32] = 'SafeMath: subtraction overflow'
                        if startBlock > block.number:
                            _1289 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _1289 + 68] = mem[idx + _1275 + 32]
                                idx = idx + 32
                                continue 
                            mem[_1289 + 68] = mem[_1289 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _1289 + -mem[64] + 100
                        _1301 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_1301] = 26
                        mem[_1301 + 32] = 'SafeMath: division by zero'
                        if not halvingPeriod:
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                            idx = 32
                            while idx < 26:
                                mem[idx + mem[64] + 68] = mem[idx + _1301 + 32]
                                idx = idx + 32
                                continue 
                        else:
                            if not block.number - poolInfo[idx].field_512:
                                _1465 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_1465] = 26
                                mem[_1465 + 32] = 'SafeMath: division by zero'
                                if not totalAllocPoint:
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    mem[mem[64] + 68] = 'SafeMath: division by zero'
                                    idx = 32
                                    while idx < 26:
                                        mem[idx + mem[64] + 68] = mem[idx + _1465 + 32]
                                        idx = idx + 32
                                        continue 
                                else:
                                    _1573 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_1573] = 26
                                    mem[_1573 + 32] = 'SafeMath: division by zero'
                                    if not 2^(block.number - startBlock / halvingPeriod):
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _1573 + 32]
                                            idx = idx + 32
                                            continue 
                                    else:
                                        _1679 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_1679] = 26
                                        mem[_1679 + 32] = 'SafeMath: division by zero'
                                        require ext_code.size(frogAddress)
                                        call frogAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args this.address, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod)
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[mem[64] + 4] = this.address
                                        mem[mem[64] + 36] = 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                                        require ext_code.size(frogAddress)
                                        call frogAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args this.address, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        _1800 = mem[64]
                                        mem[mem[64]] = 2
                                        mem[64] = mem[64] + 96
                                        require mem[_1800]
                                        mem[_1800 + 32] = frogAddress
                                        require 1 < mem[_1800]
                                        mem[_1800 + 64] = wbnbAddress
                                        if block.timestamp + 1800 < block.timestamp:
                                            revert with 0, 'SafeMath: addition overflow'
                                        mem[_1800 + 96] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                        mem[_1800 + 100] = 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                                        mem[_1800 + 132] = 0
                                        mem[_1800 + 196] = fundsAddress
                                        mem[_1800 + 228] = block.timestamp + 1800
                                        mem[_1800 + 164] = 160
                                        mem[_1800 + 260] = mem[_1800]
                                        s = 0
                                        while s < 32 * mem[_1800]:
                                            mem[s + _1800 + 292] = mem[s + _1800 + 32]
                                            s = s + 32
                                            continue 
                                        require ext_code.size(routerAddress)
                                        call routerAddress.swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                             gas gas_remaining wei
                                            args 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20, 0, 160, fundsAddress, block.timestamp + 1800, mem[_1800 + 260 len (32 * mem[_1800]) + 32]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        mem[_1800 + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        mem[64] = _1800 + ceil32(return_data.size) + 96
                                        require return_data.size >= 32
                                        _2524 = mem[_1800 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32
                                        require mem[_1800 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 <= 4294967296
                                        require mem[_1800 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 32 <= return_data.size
                                        require mem[_1800 + mem[_1800 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 96] <= 4294967296 and mem[_1800 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + (32 * mem[_1800 + mem[_1800 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 96]) + 32 <= return_data.size
                                        mem[_1800 + ceil32(return_data.size) + 96] = mem[_1800 + mem[_1800 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 96]
                                        _2561 = mem[_1800 + _2524 + 96]
                                        s = 0
                                        while s < 32 * _2561:
                                            mem[s + _1800 + ceil32(return_data.size) + 128] = mem[s + _1800 + _2524 + 128]
                                            s = s + 32
                                            continue 
                                        if not 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod):
                                            mem[64] = (32 * _2561) + _1800 + ceil32(return_data.size) + 192
                                            mem[(32 * _2561) + _1800 + ceil32(return_data.size) + 128] = 26
                                            mem[(32 * _2561) + _1800 + ceil32(return_data.size) + 160] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                        else:
                                            if 10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) != 10^12:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * _2561) + _1800 + ceil32(return_data.size) + 229 len 31]
                                            mem[64] = (32 * _2561) + _1800 + ceil32(return_data.size) + 192
                                            mem[(32 * _2561) + _1800 + ceil32(return_data.size) + 128] = 26
                                            mem[(32 * _2561) + _1800 + ceil32(return_data.size) + 160] = 'SafeMath: division by zero'
                                            if ext_call.return_data[0]:
                                                if (10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]
                                                poolInfo[idx].field_512 = block.number
                                                idx = idx + 1
                                                continue 
                                        ('iszero', ('ext_call.return_data', 0, 32))
                                        mem[(32 * _2561) + _1800 + ceil32(return_data.size) + 192] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[(32 * _2561) + _1800 + ceil32(return_data.size) + 196] = 32
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + (32 * _2561) + _1800 + ceil32(return_data.size) + 260] = mem[idx + (32 * _2561) + _1800 + ceil32(return_data.size) + 160]
                                            idx = idx + 32
                                            continue 
                            else:
                                if (block.number * frogPerBlock) - (poolInfo[idx].field_512 * frogPerBlock) / block.number - poolInfo[idx].field_512 != frogPerBlock:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                if not (block.number * frogPerBlock) - (poolInfo[idx].field_512 * frogPerBlock):
                                    _1480 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_1480] = 26
                                    mem[_1480 + 32] = 'SafeMath: division by zero'
                                    if not totalAllocPoint:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _1480 + 32]
                                            idx = idx + 32
                                            continue 
                                    else:
                                        _1589 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_1589] = 26
                                        mem[_1589 + 32] = 'SafeMath: division by zero'
                                        if not 2^(block.number - startBlock / halvingPeriod):
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _1589 + 32]
                                                idx = idx + 32
                                                continue 
                                        else:
                                            _1697 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_1697] = 26
                                            mem[_1697 + 32] = 'SafeMath: division by zero'
                                            require ext_code.size(frogAddress)
                                            call frogAddress.0x40c10f19 with:
                                                 gas gas_remaining wei
                                                args this.address, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[mem[64] + 4] = this.address
                                            mem[mem[64] + 36] = 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                                            require ext_code.size(frogAddress)
                                            call frogAddress.0x40c10f19 with:
                                                 gas gas_remaining wei
                                                args this.address, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _1812 = mem[64]
                                            mem[mem[64]] = 2
                                            mem[64] = mem[64] + 96
                                            require mem[_1812]
                                            mem[_1812 + 32] = frogAddress
                                            require 1 < mem[_1812]
                                            mem[_1812 + 64] = wbnbAddress
                                            if block.timestamp + 1800 < block.timestamp:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[_1812 + 96] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                            mem[_1812 + 100] = 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                                            mem[_1812 + 132] = 0
                                            mem[_1812 + 196] = fundsAddress
                                            mem[_1812 + 228] = block.timestamp + 1800
                                            mem[_1812 + 164] = 160
                                            mem[_1812 + 260] = mem[_1812]
                                            s = 0
                                            while s < 32 * mem[_1812]:
                                                mem[s + _1812 + 292] = mem[s + _1812 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(routerAddress)
                                            call routerAddress.swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                 gas gas_remaining wei
                                                args 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20, 0, 160, fundsAddress, block.timestamp + 1800, mem[_1812 + 260 len (32 * mem[_1812]) + 32]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[_1812 + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = _1812 + ceil32(return_data.size) + 96
                                            require return_data.size >= 32
                                            _2522 = mem[_1812 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32
                                            require mem[_1812 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 <= 4294967296
                                            require mem[_1812 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 32 <= return_data.size
                                            require mem[_1812 + mem[_1812 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 96] <= 4294967296 and mem[_1812 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + (32 * mem[_1812 + mem[_1812 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 96]) + 32 <= return_data.size
                                            mem[_1812 + ceil32(return_data.size) + 96] = mem[_1812 + mem[_1812 + 96 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 96]
                                            _2560 = mem[_1812 + _2522 + 96]
                                            s = 0
                                            while s < 32 * _2560:
                                                mem[s + _1812 + ceil32(return_data.size) + 128] = mem[s + _1812 + _2522 + 128]
                                                s = s + 32
                                                continue 
                                            if not 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod):
                                                mem[64] = (32 * _2560) + _1812 + ceil32(return_data.size) + 192
                                                mem[(32 * _2560) + _1812 + ceil32(return_data.size) + 128] = 26
                                                mem[(32 * _2560) + _1812 + ceil32(return_data.size) + 160] = 'SafeMath: division by zero'
                                                if ext_call.return_data[0]:
                                                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                    poolInfo[idx].field_512 = block.number
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                if 10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) != 10^12:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * _2560) + _1812 + ceil32(return_data.size) + 229 len 31]
                                                mem[64] = (32 * _2560) + _1812 + ceil32(return_data.size) + 192
                                                mem[(32 * _2560) + _1812 + ceil32(return_data.size) + 128] = 26
                                                mem[(32 * _2560) + _1812 + ceil32(return_data.size) + 160] = 'SafeMath: division by zero'
                                                if ext_call.return_data[0]:
                                                    if (10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]
                                                    poolInfo[idx].field_512 = block.number
                                                    idx = idx + 1
                                                    continue 
                                            ('iszero', ('ext_call.return_data', 0, 32))
                                            mem[(32 * _2560) + _1812 + ceil32(return_data.size) + 192] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _2560) + _1812 + ceil32(return_data.size) + 196] = 32
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + (32 * _2560) + _1812 + ceil32(return_data.size) + 260] = mem[idx + (32 * _2560) + _1812 + ceil32(return_data.size) + 160]
                                                idx = idx + 32
                                                continue 
                                else:
                                    if (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / (block.number * frogPerBlock) - (poolInfo[idx].field_512 * frogPerBlock) != poolInfo[idx].field_256:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                                    _1497 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_1497] = 26
                                    mem[_1497 + 32] = 'SafeMath: division by zero'
                                    if not totalAllocPoint:
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        mem[mem[64] + 68] = 'SafeMath: division by zero'
                                        idx = 32
                                        while idx < 26:
                                            mem[idx + mem[64] + 68] = mem[idx + _1497 + 32]
                                            idx = idx + 32
                                            continue 
                                    else:
                                        _1604 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_1604] = 26
                                        mem[_1604 + 32] = 'SafeMath: division by zero'
                                        if not 2^(block.number - startBlock / halvingPeriod):
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            mem[mem[64] + 68] = 'SafeMath: division by zero'
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + mem[64] + 68] = mem[idx + _1604 + 32]
                                                idx = idx + 32
                                                continue 
                                        else:
                                            _1713 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_1713] = 26
                                            mem[_1713 + 32] = 'SafeMath: division by zero'
                                            require ext_code.size(frogAddress)
                                            call frogAddress.0x40c10f19 with:
                                                 gas gas_remaining wei
                                                args this.address, (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod)
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[mem[64] + 4] = this.address
                                            mem[mem[64] + 36] = (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                                            require ext_code.size(frogAddress)
                                            call frogAddress.0x40c10f19 with:
                                                 gas gas_remaining wei
                                                args this.address, (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _1823 = mem[64]
                                            mem[mem[64]] = 2
                                            mem[64] = mem[64] + 96
                                            require mem[_1823]
                                            mem[_1823 + 32] = frogAddress
                                            require 1 < mem[_1823]
                                            mem[_1823 + 64] = wbnbAddress
                                            if block.timestamp + 1800 < block.timestamp:
                                                revert with 0, 'SafeMath: addition overflow'
                                            mem[_1823 + 96] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                            mem[_1823 + 100] = (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                                            mem[_1823 + 132] = 0
                                            mem[_1823 + 196] = fundsAddress
                                            mem[_1823 + 228] = block.timestamp + 1800
                                            mem[_1823 + 164] = 160
                                            mem[_1823 + 260] = mem[_1823]
                                            s = 0
                                            while s < 32 * mem[_1823]:
                                                mem[s + _1823 + 292] = mem[s + _1823 + 32]
                                                s = s + 32
                                                continue 
                                            require ext_code.size(routerAddress)
                                            call routerAddress.swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                                 gas gas_remaining wei
                                                args (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20, 0, 160, fundsAddress, block.timestamp + 1800, mem[_1823 + 260 len (32 * mem[_1823]) + 32]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            mem[_1823 + 96 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                            mem[64] = _1823 + ceil32(return_data.size) + 96
                                            require return_data.size >= 32
                                            _2520 = mem[_1823 + 96 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32
                                            require mem[_1823 + 96 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 <= 4294967296
                                            require mem[_1823 + 96 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 32 <= return_data.size
                                            require mem[_1823 + mem[_1823 + 96 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 96] <= 4294967296 and mem[_1823 + 96 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + (32 * mem[_1823 + mem[_1823 + 96 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 96]) + 32 <= return_data.size
                                            mem[_1823 + ceil32(return_data.size) + 96] = mem[_1823 + mem[_1823 + 96 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 96]
                                            _2559 = mem[_1823 + _2520 + 96]
                                            s = 0
                                            while s < 32 * _2559:
                                                mem[s + _1823 + ceil32(return_data.size) + 128] = mem[s + _1823 + _2520 + 128]
                                                s = s + 32
                                                continue 
                                            if not (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod):
                                                mem[64] = (32 * _2559) + _1823 + ceil32(return_data.size) + 192
                                                mem[(32 * _2559) + _1823 + ceil32(return_data.size) + 128] = 26
                                                mem[(32 * _2559) + _1823 + ceil32(return_data.size) + 160] = 'SafeMath: division by zero'
                                                if ext_call.return_data[0]:
                                                    if (0 / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                                    poolInfo[idx].field_512 = block.number
                                                    idx = idx + 1
                                                    continue 
                                            else:
                                                if 10^12 * (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) != 10^12:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * _2559) + _1823 + ceil32(return_data.size) + 229 len 31]
                                                mem[64] = (32 * _2559) + _1823 + ceil32(return_data.size) + 192
                                                mem[(32 * _2559) + _1823 + ceil32(return_data.size) + 128] = 26
                                                mem[(32 * _2559) + _1823 + ceil32(return_data.size) + 160] = 'SafeMath: division by zero'
                                                if ext_call.return_data[0]:
                                                    if (10^12 * (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]) + poolInfo[idx].field_768 < poolInfo[idx].field_768:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    poolInfo[idx].field_768 += 10^12 * (block.number * frogPerBlock * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * frogPerBlock * poolInfo[idx].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]
                                                    poolInfo[idx].field_512 = block.number
                                                    idx = idx + 1
                                                    continue 
                                            ('iszero', ('ext_call.return_data', 0, 32))
                                            mem[(32 * _2559) + _1823 + ceil32(return_data.size) + 192] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[(32 * _2559) + _1823 + ceil32(return_data.size) + 196] = 32
                                            idx = 32
                                            while idx < 26:
                                                mem[idx + (32 * _2559) + _1823 + ceil32(return_data.size) + 260] = mem[idx + (32 * _2559) + _1823 + ceil32(return_data.size) + 160]
                                                idx = idx + 32
                                                continue 
            revert with 0, 'SafeMath: division by zero'
    require arg1 < poolInfo.length
    if poolInfo[arg1].field_256 > totalAllocPoint:
        revert with 0, 'SafeMath: subtraction overflow'
    if arg2 < 0:
        revert with 0, 'SafeMath: addition overflow'
    totalAllocPoint = arg2 + totalAllocPoint - poolInfo[arg1].field_256
    require arg1 < poolInfo.length
    poolInfo[arg1].field_256 = arg2
}

function deposit(uint256 arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    require arg1 < poolInfo.length
    mem[32] = sha3(arg1, 9)
    mem[0] = 8
    if block.number <= poolInfo[arg1].field_512:
        if not userInfo[arg1][msg.sender].field_0:
            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                revert with 0, 'Address: call to non-contract'
            if not ext_code.hash(poolInfo[arg1].field_0):
                revert with 0, 'Address: call to non-contract'
            mem[292 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg2) >> 32
            mem[416 len 4] = 0
            call poolInfo[arg1].field_0 with:
                 gas gas_remaining wei
                args Mask(224, 32, arg2) << 480, mem[388 len 4]
            if not return_data.size:
                if not ext_call.success:
                    revert with unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2
                if not unknown_0x23b872dd(?????), Mask(224, 32, msg.sender) >> 32:
                    revert with 0, 
                                32,
                                42,
                                0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                mem[402 len 14],
                                0,
                                mem[420 len 4]
                if arg2 + userInfo[arg1][msg.sender].field_0 < userInfo[arg1][msg.sender].field_0:
                    revert with 0, 'SafeMath: addition overflow'
                userInfo[arg1][msg.sender].field_0 += arg2
                if not arg2 + userInfo[arg1][msg.sender].field_0:
                    userInfo[arg1][msg.sender].field_256 = 0
                else:
                    if (arg2 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) / arg2 + userInfo[arg1][msg.sender].field_0 != poolInfo[arg1].field_768:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[393 len 23], 0, mem[420 len 4]
                    userInfo[arg1][msg.sender].field_256 = (arg2 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) / 10^12
            else:
                mem[324 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not ext_call.success:
                    if return_data.size:
                        revert with ext_call.return_data[0 len return_data.size]
                    revert with 0, 'SafeERC20: low-level call failed'
                if return_data.size:
                    require return_data.size >= 32
                    if not mem[324]:
                        revert with 0, 
                                    32,
                                    42,
                                    0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                    mem[ceil32(return_data.size) + 403 len 22]
                if arg2 + userInfo[arg1][msg.sender].field_0 < userInfo[arg1][msg.sender].field_0:
                    revert with 0, 'SafeMath: addition overflow'
                userInfo[arg1][msg.sender].field_0 += arg2
                if not arg2 + userInfo[arg1][msg.sender].field_0:
                    userInfo[arg1][msg.sender].field_256 = 0
                else:
                    if (arg2 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) / arg2 + userInfo[arg1][msg.sender].field_0 != poolInfo[arg1].field_768:
                        revert with 0, 
                                    32,
                                    33,
                                    0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[ceil32(return_data.size) + 394 len 31]
                    userInfo[arg1][msg.sender].field_256 = (arg2 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) / 10^12
        else:
            if not userInfo[arg1][msg.sender].field_0:
                if userInfo[arg1][msg.sender].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                require ext_code.size(frogAddress)
                staticcall frogAddress.0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_code.size(frogAddress)
                if -userInfo[arg1][msg.sender].field_256 <= ext_call.return_data[0]:
                    call frogAddress.0xa9059cbb with:
                         gas gas_remaining wei
                        args msg.sender, -userInfo[arg1][msg.sender].field_256
                else:
                    call frogAddress.0xa9059cbb with:
                         gas gas_remaining wei
                        args msg.sender, ext_call.return_data[0]
            else:
                if poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / userInfo[arg1][msg.sender].field_0 != poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][msg.sender].field_256 > poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                require ext_code.size(frogAddress)
                staticcall frogAddress.0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_code.size(frogAddress)
                if (poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12) - userInfo[arg1][msg.sender].field_256 <= ext_call.return_data[0]:
                    call frogAddress.0xa9059cbb with:
                         gas gas_remaining wei
                        args msg.sender, (poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12) - userInfo[arg1][msg.sender].field_256
                else:
                    call frogAddress.0xa9059cbb with:
                         gas gas_remaining wei
                        args msg.sender, ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                revert with 0, 'Address: call to non-contract'
            if not ext_code.hash(poolInfo[arg1].field_0):
                revert with 0, 'Address: call to non-contract'
            mem[420 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg2) >> 32
            mem[544 len 4] = 0
            call poolInfo[arg1].field_0 with:
                 gas gas_remaining wei
                args Mask(224, 32, arg2) << 480, mem[516 len 4]
            if not return_data.size:
                require not ext_call.success
                revert with 'SafeMath: division by zero'
            mem[452 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not ext_call.success:
                if return_data.size:
                    revert with ext_call.return_data[0 len return_data.size]
                revert with 0, 'SafeERC20: low-level call failed'
            if return_data.size:
                require return_data.size >= 32
                if not mem[452]:
                    revert with 0, 
                                32,
                                42,
                                0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                mem[ceil32(return_data.size) + 531 len 22]
            if arg2 + userInfo[arg1][msg.sender].field_0 < userInfo[arg1][msg.sender].field_0:
                revert with 0, 'SafeMath: addition overflow'
            userInfo[arg1][msg.sender].field_0 += arg2
            if not arg2 + userInfo[arg1][msg.sender].field_0:
                userInfo[arg1][msg.sender].field_256 = 0
            else:
                if (arg2 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) / arg2 + userInfo[arg1][msg.sender].field_0 != poolInfo[arg1].field_768:
                    revert with 0, 
                                32,
                                33,
                                0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[ceil32(return_data.size) + 522 len 31]
                userInfo[arg1][msg.sender].field_256 = (arg2 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) / 10^12
    else:
        require ext_code.size(poolInfo[arg1].field_0)
        staticcall poolInfo[arg1].field_0.0x70a08231 with:
                gas gas_remaining wei
               args this.address
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if not ext_call.return_data[0]:
            poolInfo[arg1].field_512 = block.number
            if not userInfo[arg1][msg.sender].field_0:
                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                    revert with 0, 'Address: call to non-contract'
                if not ext_code.hash(poolInfo[arg1].field_0):
                    revert with 0, 'Address: call to non-contract'
                mem[292 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg2) >> 32
                mem[416 len 4] = 0
                call poolInfo[arg1].field_0 with:
                     gas gas_remaining wei
                    args Mask(224, 32, arg2) << 480, mem[388 len 4]
                if not return_data.size:
                    if not ext_call.success:
                        revert with unknown_0x23b872dd(?????), msg.sender, address(this.address), arg2
                    if not unknown_0x23b872dd(?????), Mask(224, 32, msg.sender) >> 32:
                        revert with 0, 
                                    32,
                                    42,
                                    0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                    mem[402 len 14],
                                    0,
                                    mem[420 len 4]
                    if arg2 + userInfo[arg1][msg.sender].field_0 < userInfo[arg1][msg.sender].field_0:
                        revert with 0, 'SafeMath: addition overflow'
                    userInfo[arg1][msg.sender].field_0 += arg2
                    if not arg2 + userInfo[arg1][msg.sender].field_0:
                        userInfo[arg1][msg.sender].field_256 = 0
                    else:
                        if (arg2 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) / arg2 + userInfo[arg1][msg.sender].field_0 != poolInfo[arg1].field_768:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[393 len 23], 0, mem[420 len 4]
                        userInfo[arg1][msg.sender].field_256 = (arg2 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) / 10^12
                else:
                    mem[324 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not ext_call.success:
                        if return_data.size:
                            revert with ext_call.return_data[0 len return_data.size]
                        revert with 0, 'SafeERC20: low-level call failed'
                    if return_data.size:
                        require return_data.size >= 32
                        if not mem[324]:
                            revert with 0, 
                                        32,
                                        42,
                                        0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                        mem[ceil32(return_data.size) + 403 len 22]
                    if arg2 + userInfo[arg1][msg.sender].field_0 < userInfo[arg1][msg.sender].field_0:
                        revert with 0, 'SafeMath: addition overflow'
                    userInfo[arg1][msg.sender].field_0 += arg2
                    if not arg2 + userInfo[arg1][msg.sender].field_0:
                        userInfo[arg1][msg.sender].field_256 = 0
                    else:
                        if (arg2 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) / arg2 + userInfo[arg1][msg.sender].field_0 != poolInfo[arg1].field_768:
                            revert with 0, 
                                        32,
                                        33,
                                        0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[ceil32(return_data.size) + 394 len 31]
                        userInfo[arg1][msg.sender].field_256 = (arg2 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) / 10^12
            else:
                if not userInfo[arg1][msg.sender].field_0:
                    if userInfo[arg1][msg.sender].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    require ext_code.size(frogAddress)
                    staticcall frogAddress.0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_code.size(frogAddress)
                    if -userInfo[arg1][msg.sender].field_256 <= ext_call.return_data[0]:
                        call frogAddress.0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, -userInfo[arg1][msg.sender].field_256
                    else:
                        call frogAddress.0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, ext_call.return_data[0]
                else:
                    if poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / userInfo[arg1][msg.sender].field_0 != poolInfo[arg1].field_768:
                        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                    32,
                                    33,
                                    0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[197 len 31]
                    if userInfo[arg1][msg.sender].field_256 > poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    require ext_code.size(frogAddress)
                    staticcall frogAddress.0x70a08231 with:
                            gas gas_remaining wei
                           args this.address
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    require ext_code.size(frogAddress)
                    if (poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12) - userInfo[arg1][msg.sender].field_256 <= ext_call.return_data[0]:
                        call frogAddress.0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, (poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12) - userInfo[arg1][msg.sender].field_256
                    else:
                        call frogAddress.0xa9059cbb with:
                             gas gas_remaining wei
                            args msg.sender, ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                    revert with 0, 'Address: call to non-contract'
                if not ext_code.hash(poolInfo[arg1].field_0):
                    revert with 0, 'Address: call to non-contract'
                mem[420 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg2) >> 32
                mem[544 len 4] = 0
                call poolInfo[arg1].field_0 with:
                     gas gas_remaining wei
                    args Mask(224, 32, arg2) << 480, mem[516 len 4]
                if not return_data.size:
                    require not ext_call.success
                    revert with 'SafeMath: division by zero'
                mem[452 len return_data.size] = ext_call.return_data[0 len return_data.size]
                if not ext_call.success:
                    if return_data.size:
                        revert with ext_call.return_data[0 len return_data.size]
                    revert with 0, 'SafeERC20: low-level call failed'
                if return_data.size:
                    require return_data.size >= 32
                    if not mem[452]:
                        revert with 0, 
                                    32,
                                    42,
                                    0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                    mem[ceil32(return_data.size) + 531 len 22]
                if arg2 + userInfo[arg1][msg.sender].field_0 < userInfo[arg1][msg.sender].field_0:
                    revert with 0, 'SafeMath: addition overflow'
                userInfo[arg1][msg.sender].field_0 += arg2
                if not arg2 + userInfo[arg1][msg.sender].field_0:
                    userInfo[arg1][msg.sender].field_256 = 0
                else:
                    if (arg2 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) / arg2 + userInfo[arg1][msg.sender].field_0 != poolInfo[arg1].field_768:
                        revert with 0, 
                                    32,
                                    33,
                                    0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                    mem[ceil32(return_data.size) + 522 len 31]
                    userInfo[arg1][msg.sender].field_256 = (arg2 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) / 10^12
        else:
            mem[96] = 30
            mem[128] = 'SafeMath: subtraction overflow'
            if block.number <= bonusEndBlock:
                if poolInfo[arg1].field_512 > block.number:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not block.number - poolInfo[arg1].field_512:
                    mem[160] = 30
                    mem[192] = 'SafeMath: subtraction overflow'
                    if startBlock > block.number:
                        revert with 0, 'SafeMath: subtraction overflow'
                    mem[224] = 26
                    mem[256] = 'SafeMath: division by zero'
                    if not halvingPeriod:
                        revert with 0, 'SafeMath: division by zero'
                    mem[288] = 26
                    mem[320] = 'SafeMath: division by zero'
                    if not totalAllocPoint:
                        revert with 0, 'SafeMath: division by zero'
                    mem[352] = 26
                    mem[384] = 'SafeMath: division by zero'
                    if not 2^(block.number - startBlock / halvingPeriod):
                        revert with 0, 'SafeMath: division by zero'
                    mem[416] = 26
                    mem[448] = 'SafeMath: division by zero'
                    require ext_code.size(frogAddress)
                    call frogAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args this.address, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod)
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require ext_code.size(frogAddress)
                    call frogAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args this.address, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[480] = 2
                    mem[512] = frogAddress
                    mem[544] = wbnbAddress
                    if block.timestamp + 1800 < block.timestamp:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[576] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                    mem[580] = 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                    mem[612] = 0
                    mem[676] = fundsAddress
                    mem[708] = block.timestamp + 1800
                    mem[644] = 160
                    mem[740] = 2
                    mem[772 len 0] = None
                    require ext_code.size(routerAddress)
                    call routerAddress.swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                         gas gas_remaining wei
                        args 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20, 0, 160, fundsAddress, block.timestamp + 1800, 2, mem[772 len 64]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[576 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = ceil32(return_data.size) + 576
                    require return_data.size >= 32
                    _15289 = mem[576 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32
                    require mem[576 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 <= 4294967296
                    require mem[576 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 32 <= return_data.size
                    require mem[mem[576 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 576] <= 4294967296 and mem[576 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + (32 * mem[mem[576 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 576]) + 32 <= return_data.size
                    mem[ceil32(return_data.size) + 576] = mem[mem[576 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 576]
                    _15436 = mem[_15289 + 576]
                    mem[ceil32(return_data.size) + 608 len floor32(mem[_15289 + 576])] = mem[_15289 + 608 len floor32(mem[_15289 + 576])]
                    if not 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod):
                        if not ext_call.return_data[0]:
                            revert with 0, 'SafeMath: division by zero'
                        if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[arg1].field_512 = block.number
                        if not userInfo[arg1][msg.sender].field_0:
                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                revert with 0, 'Address: call to non-contract'
                            if not ext_code.hash(poolInfo[arg1].field_0):
                                revert with 0, 'Address: call to non-contract'
                            mem[(32 * _15436) + ceil32(return_data.size) + 868 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg2) >> 32
                            mem[(32 * _15436) + ceil32(return_data.size) + 992 len 4] = 0
                            call poolInfo[arg1].field_0 with:
                                 gas gas_remaining wei
                                args Mask(224, 32, arg2) << 480, mem[(32 * _15436) + ceil32(return_data.size) + 964 len 4]
                            if not return_data.size:
                                require not ext_call.success
                                revert with 'SafeMath: subtraction overflow'
                            mem[(32 * _15436) + ceil32(return_data.size) + 900 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                if return_data.size:
                                    revert with ext_call.return_data[0 len return_data.size]
                                revert with 0, 'SafeERC20: low-level call failed'
                            if return_data.size:
                                require return_data.size >= 32
                                if not mem[(32 * _15436) + ceil32(return_data.size) + 900]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[(32 * _15436) + ceil32(return_data.size) + ceil32(return_data.size) + 979 len 22]
                            if arg2 + userInfo[arg1][msg.sender].field_0 < userInfo[arg1][msg.sender].field_0:
                                revert with 0, 'SafeMath: addition overflow'
                            userInfo[arg1][msg.sender].field_0 += arg2
                            if not arg2 + userInfo[arg1][msg.sender].field_0:
                                userInfo[arg1][msg.sender].field_256 = 0
                            else:
                                if (arg2 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) / arg2 + userInfo[arg1][msg.sender].field_0 != poolInfo[arg1].field_768:
                                    revert with 0, 
                                                32,
                                                33,
                                                0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[(32 * _15436) + ceil32(return_data.size) + ceil32(return_data.size) + 970 len 31]
                                userInfo[arg1][msg.sender].field_256 = (arg2 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) / 10^12
                        else:
                            if not userInfo[arg1][msg.sender].field_0:
                                if userInfo[arg1][msg.sender].field_256 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                require ext_code.size(frogAddress)
                                staticcall frogAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(frogAddress)
                                if -userInfo[arg1][msg.sender].field_256 <= ext_call.return_data[0]:
                                    call frogAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, -userInfo[arg1][msg.sender].field_256
                                else:
                                    call frogAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, ext_call.return_data[0]
                            else:
                                if poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / userInfo[arg1][msg.sender].field_0 != poolInfo[arg1].field_768:
                                    revert with 0, 
                                                32,
                                                33,
                                                0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[(32 * _15436) + ceil32(return_data.size) + 773 len 31]
                                if userInfo[arg1][msg.sender].field_256 > poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                require ext_code.size(frogAddress)
                                staticcall frogAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(frogAddress)
                                if (poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12) - userInfo[arg1][msg.sender].field_256 <= ext_call.return_data[0]:
                                    call frogAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, (poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12) - userInfo[arg1][msg.sender].field_256
                                else:
                                    call frogAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                revert with 0, 'Address: call to non-contract'
                            if not ext_code.hash(poolInfo[arg1].field_0):
                                revert with 0, 'Address: call to non-contract'
                            mem[(32 * _15436) + ceil32(return_data.size) + 996 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg2) >> 32
                            mem[(32 * _15436) + ceil32(return_data.size) + 1120 len 4] = 0
                            call poolInfo[arg1].field_0 with:
                                 gas gas_remaining wei
                                args Mask(224, 32, arg2) << 480, mem[(32 * _15436) + ceil32(return_data.size) + 1092 len 4]
                            if not return_data.size:
                                require not ext_call.success
                                revert with 'SafeMath: subtraction overflow'
                            mem[(32 * _15436) + ceil32(return_data.size) + 1028 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                if return_data.size:
                                    revert with ext_call.return_data[0 len return_data.size]
                                revert with 0, 'SafeERC20: low-level call failed'
                            if return_data.size:
                                require return_data.size >= 32
                                if not mem[(32 * _15436) + ceil32(return_data.size) + 1028]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[(32 * _15436) + ceil32(return_data.size) + ceil32(return_data.size) + 1107 len 22]
                            if arg2 + userInfo[arg1][msg.sender].field_0 < userInfo[arg1][msg.sender].field_0:
                                revert with 0, 'SafeMath: addition overflow'
                            userInfo[arg1][msg.sender].field_0 += arg2
                            if not arg2 + userInfo[arg1][msg.sender].field_0:
                                userInfo[arg1][msg.sender].field_256 = 0
                            else:
                                if (arg2 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) / arg2 + userInfo[arg1][msg.sender].field_0 != poolInfo[arg1].field_768:
                                    revert with 0, 
                                                32,
                                                33,
                                                0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[(32 * _15436) + ceil32(return_data.size) + ceil32(return_data.size) + 1098 len 31]
                                userInfo[arg1][msg.sender].field_256 = (arg2 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) / 10^12
                    else:
                        if 10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) != 10^12:
                            revert with 0, 
                                        32,
                                        33,
                                        0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[(32 * _15436) + ceil32(return_data.size) + 709 len 31]
                        if not ext_call.return_data[0]:
                            revert with 0, 'SafeMath: division by zero'
                        if (10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]
                        poolInfo[arg1].field_512 = block.number
                        if not userInfo[arg1][msg.sender].field_0:
                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                revert with 0, 'Address: call to non-contract'
                            if not ext_code.hash(poolInfo[arg1].field_0):
                                revert with 0, 'Address: call to non-contract'
                            mem[(32 * _15436) + ceil32(return_data.size) + 868 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg2) >> 32
                            mem[(32 * _15436) + ceil32(return_data.size) + 992 len 4] = 0
                            call poolInfo[arg1].field_0 with:
                                 gas gas_remaining wei
                                args Mask(224, 32, arg2) << 480, mem[(32 * _15436) + ceil32(return_data.size) + 964 len 4]
                            if not return_data.size:
                                require not ext_call.success
                                revert with 'SafeMath: subtraction overflow'
                            mem[(32 * _15436) + ceil32(return_data.size) + 900 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                if return_data.size:
                                    revert with ext_call.return_data[0 len return_data.size]
                                revert with 0, 'SafeERC20: low-level call failed'
                            if return_data.size:
                                require return_data.size >= 32
                                if not mem[(32 * _15436) + ceil32(return_data.size) + 900]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[(32 * _15436) + ceil32(return_data.size) + ceil32(return_data.size) + 979 len 22]
                            if arg2 + userInfo[arg1][msg.sender].field_0 < userInfo[arg1][msg.sender].field_0:
                                revert with 0, 'SafeMath: addition overflow'
                            userInfo[arg1][msg.sender].field_0 += arg2
                            if not arg2 + userInfo[arg1][msg.sender].field_0:
                                userInfo[arg1][msg.sender].field_256 = 0
                            else:
                                if (arg2 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) / arg2 + userInfo[arg1][msg.sender].field_0 != poolInfo[arg1].field_768:
                                    revert with 0, 
                                                32,
                                                33,
                                                0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[(32 * _15436) + ceil32(return_data.size) + ceil32(return_data.size) + 970 len 31]
                                userInfo[arg1][msg.sender].field_256 = (arg2 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) / 10^12
                        else:
                            if not userInfo[arg1][msg.sender].field_0:
                                if userInfo[arg1][msg.sender].field_256 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                require ext_code.size(frogAddress)
                                staticcall frogAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(frogAddress)
                                if -userInfo[arg1][msg.sender].field_256 <= ext_call.return_data[0]:
                                    call frogAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, -userInfo[arg1][msg.sender].field_256
                                else:
                                    call frogAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                    revert with 0, 'Address: call to non-contract'
                                if not ext_code.hash(poolInfo[arg1].field_0):
                                    revert with 0, 'Address: call to non-contract'
                                mem[(32 * _15436) + ceil32(return_data.size) + 996 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg2) >> 32
                                mem[(32 * _15436) + ceil32(return_data.size) + 1120 len 4] = 0
                            else:
                                if poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / userInfo[arg1][msg.sender].field_0 != poolInfo[arg1].field_768:
                                    revert with 0, 
                                                32,
                                                33,
                                                0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[(32 * _15436) + ceil32(return_data.size) + 773 len 31]
                                if userInfo[arg1][msg.sender].field_256 > poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                require ext_code.size(frogAddress)
                                staticcall frogAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(frogAddress)
                                if (poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12) - userInfo[arg1][msg.sender].field_256 <= ext_call.return_data[0]:
                                    call frogAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, (poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12) - userInfo[arg1][msg.sender].field_256
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                        revert with 0, 'Address: call to non-contract'
                                    if not ext_code.hash(poolInfo[arg1].field_0):
                                        revert with 0, 'Address: call to non-contract'
                                    mem[(32 * _15436) + ceil32(return_data.size) + 996 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg2) >> 32
                                    mem[(32 * _15436) + ceil32(return_data.size) + 1120 len 4] = 0
                                else:
                                    call frogAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                        revert with 0, 'Address: call to non-contract'
                                    if not ext_code.hash(poolInfo[arg1].field_0):
                                        revert with 0, 'Address: call to non-contract'
                                    mem[(32 * _15436) + ceil32(return_data.size) + 996 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg2) >> 32
                                    mem[(32 * _15436) + ceil32(return_data.size) + 1120 len 4] = 0
                                    mem[(32 * _15436) + ceil32(return_data.size) + 1092 len 0] = 0
                            call poolInfo[arg1].field_0 with:
                                 gas gas_remaining wei
                                args Mask(224, 32, arg2) << 480, mem[(32 * _15436) + ceil32(return_data.size) + 1092 len 4]
                            if not return_data.size:
                                require not ext_call.success
                                revert with 'SafeMath: subtraction overflow'
                            mem[(32 * _15436) + ceil32(return_data.size) + 1028 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                if return_data.size:
                                    revert with ext_call.return_data[0 len return_data.size]
                                revert with 0, 'SafeERC20: low-level call failed'
                            if return_data.size:
                                require return_data.size >= 32
                                if not mem[(32 * _15436) + ceil32(return_data.size) + 1028]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[(32 * _15436) + ceil32(return_data.size) + ceil32(return_data.size) + 1107 len 22]
                            if arg2 + userInfo[arg1][msg.sender].field_0 < userInfo[arg1][msg.sender].field_0:
                                revert with 0, 'SafeMath: addition overflow'
                            userInfo[arg1][msg.sender].field_0 += arg2
                            if not arg2 + userInfo[arg1][msg.sender].field_0:
                                userInfo[arg1][msg.sender].field_256 = 0
                            else:
                                if (arg2 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) / arg2 + userInfo[arg1][msg.sender].field_0 != poolInfo[arg1].field_768:
                                    revert with 0, 
                                                32,
                                                33,
                                                0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[(32 * _15436) + ceil32(return_data.size) + ceil32(return_data.size) + 1098 len 31]
                                userInfo[arg1][msg.sender].field_256 = (arg2 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) / 10^12
                else:
                    if block.number - poolInfo[arg1].field_512 / block.number - poolInfo[arg1].field_512 != 1:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                    mem[160] = 30
                    mem[192] = 'SafeMath: subtraction overflow'
                    if startBlock > block.number:
                        revert with 0, 'SafeMath: subtraction overflow'
                    mem[224] = 26
                    mem[256] = 'SafeMath: division by zero'
                    if not halvingPeriod:
                        revert with 0, 'SafeMath: division by zero'
                    if not block.number - poolInfo[arg1].field_512:
                        mem[288] = 26
                        mem[320] = 'SafeMath: division by zero'
                        if not totalAllocPoint:
                            revert with 0, 'SafeMath: division by zero'
                        mem[352] = 26
                        mem[384] = 'SafeMath: division by zero'
                        if not 2^(block.number - startBlock / halvingPeriod):
                            revert with 0, 'SafeMath: division by zero'
                        mem[416] = 26
                        mem[448] = 'SafeMath: division by zero'
                        require ext_code.size(frogAddress)
                        call frogAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args this.address, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod)
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require ext_code.size(frogAddress)
                        call frogAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args this.address, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[480] = 2
                        mem[512] = frogAddress
                        mem[544] = wbnbAddress
                        if block.timestamp + 1800 < block.timestamp:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[576] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                        mem[580] = 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                        mem[612] = 0
                        mem[676] = fundsAddress
                        mem[708] = block.timestamp + 1800
                        mem[644] = 160
                        mem[740] = 2
                        mem[772 len 0] = None
                        require ext_code.size(routerAddress)
                        call routerAddress.swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                             gas gas_remaining wei
                            args 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20, 0, 160, fundsAddress, block.timestamp + 1800, 2, mem[772 len 64]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[576 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = ceil32(return_data.size) + 576
                        require return_data.size >= 32
                        _15287 = mem[576 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32
                        require mem[576 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 <= 4294967296
                        require mem[576 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 32 <= return_data.size
                        require mem[mem[576 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 576] <= 4294967296 and mem[576 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + (32 * mem[mem[576 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 576]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 576] = mem[mem[576 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 576]
                        _15435 = mem[_15287 + 576]
                        mem[ceil32(return_data.size) + 608 len floor32(mem[_15287 + 576])] = mem[_15287 + 608 len floor32(mem[_15287 + 576])]
                        if not 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod):
                            if not ext_call.return_data[0]:
                                revert with 0, 'SafeMath: division by zero'
                            if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[arg1].field_512 = block.number
                            if not userInfo[arg1][msg.sender].field_0:
                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                    revert with 0, 'Address: call to non-contract'
                                if not ext_code.hash(poolInfo[arg1].field_0):
                                    revert with 0, 'Address: call to non-contract'
                                mem[(32 * _15435) + ceil32(return_data.size) + 868 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg2) >> 32
                                mem[(32 * _15435) + ceil32(return_data.size) + 992 len 4] = 0
                                call poolInfo[arg1].field_0 with:
                                     gas gas_remaining wei
                                    args Mask(224, 32, arg2) << 480, mem[(32 * _15435) + ceil32(return_data.size) + 964 len 4]
                                if not return_data.size:
                                    require not ext_call.success
                                    revert with 'SafeMath: subtraction overflow'
                                mem[(32 * _15435) + ceil32(return_data.size) + 900 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if return_data.size:
                                    require return_data.size >= 32
                                    if not mem[(32 * _15435) + ceil32(return_data.size) + 900]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[(32 * _15435) + ceil32(return_data.size) + ceil32(return_data.size) + 979 len 22]
                                if arg2 + userInfo[arg1][msg.sender].field_0 < userInfo[arg1][msg.sender].field_0:
                                    revert with 0, 'SafeMath: addition overflow'
                                userInfo[arg1][msg.sender].field_0 += arg2
                                if not arg2 + userInfo[arg1][msg.sender].field_0:
                                    userInfo[arg1][msg.sender].field_256 = 0
                                else:
                                    if (arg2 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) / arg2 + userInfo[arg1][msg.sender].field_0 != poolInfo[arg1].field_768:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * _15435) + ceil32(return_data.size) + ceil32(return_data.size) + 970 len 31]
                                    userInfo[arg1][msg.sender].field_256 = (arg2 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) / 10^12
                            else:
                                if not userInfo[arg1][msg.sender].field_0:
                                    if userInfo[arg1][msg.sender].field_256 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require ext_code.size(frogAddress)
                                    staticcall frogAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(frogAddress)
                                    if -userInfo[arg1][msg.sender].field_256 <= ext_call.return_data[0]:
                                        call frogAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, -userInfo[arg1][msg.sender].field_256
                                    else:
                                        call frogAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, ext_call.return_data[0]
                                else:
                                    if poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / userInfo[arg1][msg.sender].field_0 != poolInfo[arg1].field_768:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * _15435) + ceil32(return_data.size) + 773 len 31]
                                    if userInfo[arg1][msg.sender].field_256 > poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require ext_code.size(frogAddress)
                                    staticcall frogAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(frogAddress)
                                    if (poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12) - userInfo[arg1][msg.sender].field_256 <= ext_call.return_data[0]:
                                        call frogAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, (poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12) - userInfo[arg1][msg.sender].field_256
                                    else:
                                        call frogAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                    revert with 0, 'Address: call to non-contract'
                                if not ext_code.hash(poolInfo[arg1].field_0):
                                    revert with 0, 'Address: call to non-contract'
                                mem[(32 * _15435) + ceil32(return_data.size) + 996 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg2) >> 32
                                mem[(32 * _15435) + ceil32(return_data.size) + 1120 len 4] = 0
                                call poolInfo[arg1].field_0 with:
                                     gas gas_remaining wei
                                    args Mask(224, 32, arg2) << 480, mem[(32 * _15435) + ceil32(return_data.size) + 1092 len 4]
                                if not return_data.size:
                                    require not ext_call.success
                                    revert with 'SafeMath: subtraction overflow'
                                mem[(32 * _15435) + ceil32(return_data.size) + 1028 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if return_data.size:
                                    require return_data.size >= 32
                                    if not mem[(32 * _15435) + ceil32(return_data.size) + 1028]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[(32 * _15435) + ceil32(return_data.size) + ceil32(return_data.size) + 1107 len 22]
                                if arg2 + userInfo[arg1][msg.sender].field_0 < userInfo[arg1][msg.sender].field_0:
                                    revert with 0, 'SafeMath: addition overflow'
                                userInfo[arg1][msg.sender].field_0 += arg2
                                if not arg2 + userInfo[arg1][msg.sender].field_0:
                                    userInfo[arg1][msg.sender].field_256 = 0
                                else:
                                    if (arg2 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) / arg2 + userInfo[arg1][msg.sender].field_0 != poolInfo[arg1].field_768:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * _15435) + ceil32(return_data.size) + ceil32(return_data.size) + 1098 len 31]
                                    userInfo[arg1][msg.sender].field_256 = (arg2 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) / 10^12
                        else:
                            if 10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) != 10^12:
                                revert with 0, 
                                            32,
                                            33,
                                            0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[(32 * _15435) + ceil32(return_data.size) + 709 len 31]
                            if not ext_call.return_data[0]:
                                revert with 0, 'SafeMath: division by zero'
                            if (10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]
                            poolInfo[arg1].field_512 = block.number
                            if not userInfo[arg1][msg.sender].field_0:
                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                    revert with 0, 'Address: call to non-contract'
                                if not ext_code.hash(poolInfo[arg1].field_0):
                                    revert with 0, 'Address: call to non-contract'
                                mem[(32 * _15435) + ceil32(return_data.size) + 868 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg2) >> 32
                                mem[(32 * _15435) + ceil32(return_data.size) + 992 len 4] = 0
                                mem[(32 * _15435) + ceil32(return_data.size) + 964 len 0] = 0
                                call poolInfo[arg1].field_0 with:
                                     gas gas_remaining wei
                                    args Mask(224, 32, arg2) << 480, mem[(32 * _15435) + ceil32(return_data.size) + 964 len 4]
                                if not return_data.size:
                                    require not ext_call.success
                                    revert with 'SafeMath: subtraction overflow'
                                mem[(32 * _15435) + ceil32(return_data.size) + 900 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if return_data.size:
                                    require return_data.size >= 32
                                    if not mem[(32 * _15435) + ceil32(return_data.size) + 900]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[(32 * _15435) + ceil32(return_data.size) + ceil32(return_data.size) + 979 len 22]
                                if arg2 + userInfo[arg1][msg.sender].field_0 < userInfo[arg1][msg.sender].field_0:
                                    revert with 0, 'SafeMath: addition overflow'
                                userInfo[arg1][msg.sender].field_0 += arg2
                                if not arg2 + userInfo[arg1][msg.sender].field_0:
                                    userInfo[arg1][msg.sender].field_256 = 0
                                else:
                                    if (arg2 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) / arg2 + userInfo[arg1][msg.sender].field_0 != poolInfo[arg1].field_768:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * _15435) + ceil32(return_data.size) + ceil32(return_data.size) + 970 len 31]
                                    userInfo[arg1][msg.sender].field_256 = (arg2 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) / 10^12
                            else:
                                if not userInfo[arg1][msg.sender].field_0:
                                    if userInfo[arg1][msg.sender].field_256 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require ext_code.size(frogAddress)
                                    staticcall frogAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(frogAddress)
                                    if -userInfo[arg1][msg.sender].field_256 <= ext_call.return_data[0]:
                                        call frogAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, -userInfo[arg1][msg.sender].field_256
                                    else:
                                        call frogAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                        revert with 0, 'Address: call to non-contract'
                                    if not ext_code.hash(poolInfo[arg1].field_0):
                                        revert with 0, 'Address: call to non-contract'
                                    mem[(32 * _15435) + ceil32(return_data.size) + 996 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg2) >> 32
                                    mem[(32 * _15435) + ceil32(return_data.size) + 1120 len 4] = 0
                                else:
                                    if poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / userInfo[arg1][msg.sender].field_0 != poolInfo[arg1].field_768:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * _15435) + ceil32(return_data.size) + 773 len 31]
                                    if userInfo[arg1][msg.sender].field_256 > poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require ext_code.size(frogAddress)
                                    staticcall frogAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(frogAddress)
                                    if (poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12) - userInfo[arg1][msg.sender].field_256 <= ext_call.return_data[0]:
                                        call frogAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, (poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12) - userInfo[arg1][msg.sender].field_256
                                    else:
                                        call frogAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                        revert with 0, 'Address: call to non-contract'
                                    if not ext_code.hash(poolInfo[arg1].field_0):
                                        revert with 0, 'Address: call to non-contract'
                                    mem[(32 * _15435) + ceil32(return_data.size) + 996 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg2) >> 32
                                    mem[(32 * _15435) + ceil32(return_data.size) + 1120 len 4] = 0
                                    mem[(32 * _15435) + ceil32(return_data.size) + 1092 len 0] = 0
                                call poolInfo[arg1].field_0 with:
                                     gas gas_remaining wei
                                    args Mask(224, 32, arg2) << 480, mem[(32 * _15435) + ceil32(return_data.size) + 1092 len 4]
                                if not return_data.size:
                                    require not ext_call.success
                                    revert with 'SafeMath: subtraction overflow'
                                mem[(32 * _15435) + ceil32(return_data.size) + 1028 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if return_data.size:
                                    require return_data.size >= 32
                                    if not mem[(32 * _15435) + ceil32(return_data.size) + 1028]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[(32 * _15435) + ceil32(return_data.size) + ceil32(return_data.size) + 1107 len 22]
                                if arg2 + userInfo[arg1][msg.sender].field_0 < userInfo[arg1][msg.sender].field_0:
                                    revert with 0, 'SafeMath: addition overflow'
                                userInfo[arg1][msg.sender].field_0 += arg2
                                if not arg2 + userInfo[arg1][msg.sender].field_0:
                                    userInfo[arg1][msg.sender].field_256 = 0
                                else:
                                    if (arg2 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) / arg2 + userInfo[arg1][msg.sender].field_0 != poolInfo[arg1].field_768:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * _15435) + ceil32(return_data.size) + ceil32(return_data.size) + 1098 len 31]
                                    userInfo[arg1][msg.sender].field_256 = (arg2 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) / 10^12
                    else:
                        if (block.number * frogPerBlock) - (poolInfo[arg1].field_512 * frogPerBlock) / block.number - poolInfo[arg1].field_512 != frogPerBlock:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                        if not (block.number * frogPerBlock) - (poolInfo[arg1].field_512 * frogPerBlock):
                            mem[288] = 26
                            mem[320] = 'SafeMath: division by zero'
                            if not totalAllocPoint:
                                revert with 0, 'SafeMath: division by zero'
                            mem[352] = 26
                            mem[384] = 'SafeMath: division by zero'
                            if not 2^(block.number - startBlock / halvingPeriod):
                                revert with 0, 'SafeMath: division by zero'
                            mem[416] = 26
                            mem[448] = 'SafeMath: division by zero'
                            require ext_code.size(frogAddress)
                            call frogAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args this.address, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod)
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(frogAddress)
                            call frogAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args this.address, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[480] = 2
                            mem[512] = frogAddress
                            mem[544] = wbnbAddress
                            if block.timestamp + 1800 < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[576] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                            mem[580] = 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                            mem[612] = 0
                            mem[676] = fundsAddress
                            mem[708] = block.timestamp + 1800
                            mem[644] = 160
                            mem[740] = 2
                            mem[772 len 0] = None
                            require ext_code.size(routerAddress)
                            call routerAddress.swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20, 0, 160, fundsAddress, block.timestamp + 1800, 2, mem[772 len 64]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[576 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = ceil32(return_data.size) + 576
                            require return_data.size >= 32
                            _15285 = mem[576 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32
                            require mem[576 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 <= 4294967296
                            require mem[576 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 32 <= return_data.size
                            require mem[mem[576 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 576] <= 4294967296 and mem[576 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + (32 * mem[mem[576 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 576]) + 32 <= return_data.size
                            mem[ceil32(return_data.size) + 576] = mem[mem[576 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 576]
                            _15434 = mem[_15285 + 576]
                            mem[ceil32(return_data.size) + 608 len floor32(mem[_15285 + 576])] = mem[_15285 + 608 len floor32(mem[_15285 + 576])]
                            if 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod):
                                if 10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) != 10^12:
                                    revert with 0, 
                                                32,
                                                33,
                                                0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[(32 * _15434) + ceil32(return_data.size) + 709 len 31]
                                if not ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: division by zero'
                                if (10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]
                                poolInfo[arg1].field_512 = block.number
                                if not userInfo[arg1][msg.sender].field_0:
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                        revert with 0, 'Address: call to non-contract'
                                    if not ext_code.hash(poolInfo[arg1].field_0):
                                        revert with 0, 'Address: call to non-contract'
                                    mem[(32 * _15434) + ceil32(return_data.size) + 868 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg2) >> 32
                                    mem[(32 * _15434) + ceil32(return_data.size) + 992 len 4] = 0
                                    call poolInfo[arg1].field_0 with:
                                         gas gas_remaining wei
                                        args Mask(224, 32, arg2) << 480, mem[(32 * _15434) + ceil32(return_data.size) + 964 len 4]
                                    if not return_data.size:
                                        require not ext_call.success
                                        revert with 'SafeMath: subtraction overflow'
                                    mem[(32 * _15434) + ceil32(return_data.size) + 900 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if not ext_call.success:
                                        if return_data.size:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if return_data.size:
                                        require return_data.size >= 32
                                        if not mem[(32 * _15434) + ceil32(return_data.size) + 900]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[(32 * _15434) + ceil32(return_data.size) + ceil32(return_data.size) + 979 len 22]
                                    if arg2 + userInfo[arg1][msg.sender].field_0 < userInfo[arg1][msg.sender].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    userInfo[arg1][msg.sender].field_0 += arg2
                                    if not arg2 + userInfo[arg1][msg.sender].field_0:
                                        userInfo[arg1][msg.sender].field_256 = 0
                                    else:
                                        if (arg2 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) / arg2 + userInfo[arg1][msg.sender].field_0 != poolInfo[arg1].field_768:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * _15434) + ceil32(return_data.size) + ceil32(return_data.size) + 970 len 31]
                                        userInfo[arg1][msg.sender].field_256 = (arg2 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) / 10^12
                                else:
                                    if not userInfo[arg1][msg.sender].field_0:
                                        if userInfo[arg1][msg.sender].field_256 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require ext_code.size(frogAddress)
                                        staticcall frogAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(frogAddress)
                                        if -userInfo[arg1][msg.sender].field_256 <= ext_call.return_data[0]:
                                            call frogAddress.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, -userInfo[arg1][msg.sender].field_256
                                        else:
                                            call frogAddress.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, ext_call.return_data[0]
                                    else:
                                        if poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / userInfo[arg1][msg.sender].field_0 != poolInfo[arg1].field_768:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * _15434) + ceil32(return_data.size) + 773 len 31]
                                        if userInfo[arg1][msg.sender].field_256 > poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require ext_code.size(frogAddress)
                                        staticcall frogAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(frogAddress)
                                        if (poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12) - userInfo[arg1][msg.sender].field_256 <= ext_call.return_data[0]:
                                            call frogAddress.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, (poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12) - userInfo[arg1][msg.sender].field_256
                                        else:
                                            call frogAddress.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                        revert with 0, 'Address: call to non-contract'
                                    if not ext_code.hash(poolInfo[arg1].field_0):
                                        revert with 0, 'Address: call to non-contract'
                                    mem[(32 * _15434) + ceil32(return_data.size) + 996 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg2) >> 32
                                    mem[(32 * _15434) + ceil32(return_data.size) + 1120 len 4] = 0
                                    call poolInfo[arg1].field_0 with:
                                         gas gas_remaining wei
                                        args Mask(224, 32, arg2) << 480, mem[(32 * _15434) + ceil32(return_data.size) + 1092 len 4]
                                    if not return_data.size:
                                        require not ext_call.success
                                        revert with 'SafeMath: subtraction overflow'
                                    mem[(32 * _15434) + ceil32(return_data.size) + 1028 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if not ext_call.success:
                                        if return_data.size:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if return_data.size:
                                        require return_data.size >= 32
                                        if not mem[(32 * _15434) + ceil32(return_data.size) + 1028]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[(32 * _15434) + ceil32(return_data.size) + ceil32(return_data.size) + 1107 len 22]
                                    if arg2 + userInfo[arg1][msg.sender].field_0 < userInfo[arg1][msg.sender].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    userInfo[arg1][msg.sender].field_0 += arg2
                                    if not arg2 + userInfo[arg1][msg.sender].field_0:
                                        userInfo[arg1][msg.sender].field_256 = 0
                                    else:
                                        if (arg2 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) / arg2 + userInfo[arg1][msg.sender].field_0 != poolInfo[arg1].field_768:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * _15434) + ceil32(return_data.size) + ceil32(return_data.size) + 1098 len 31]
                                        userInfo[arg1][msg.sender].field_256 = (arg2 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) / 10^12
                            else:
                                if not ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: division by zero'
                                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[arg1].field_512 = block.number
                                if not userInfo[arg1][msg.sender].field_0:
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                        revert with 0, 'Address: call to non-contract'
                                    if not ext_code.hash(poolInfo[arg1].field_0):
                                        revert with 0, 'Address: call to non-contract'
                                    mem[(32 * _15434) + ceil32(return_data.size) + 868 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg2) >> 32
                                    mem[(32 * _15434) + ceil32(return_data.size) + 992 len 4] = 0
                                    call poolInfo[arg1].field_0 with:
                                         gas gas_remaining wei
                                        args Mask(224, 32, arg2) << 480, mem[(32 * _15434) + ceil32(return_data.size) + 964 len 4]
                                    if not return_data.size:
                                        require not ext_call.success
                                        revert with 'SafeMath: subtraction overflow'
                                    mem[(32 * _15434) + ceil32(return_data.size) + 900 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if not ext_call.success:
                                        if return_data.size:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if return_data.size:
                                        require return_data.size >= 32
                                        if not mem[(32 * _15434) + ceil32(return_data.size) + 900]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[(32 * _15434) + ceil32(return_data.size) + ceil32(return_data.size) + 979 len 22]
                                    if arg2 + userInfo[arg1][msg.sender].field_0 < userInfo[arg1][msg.sender].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    userInfo[arg1][msg.sender].field_0 += arg2
                                    if not arg2 + userInfo[arg1][msg.sender].field_0:
                                        userInfo[arg1][msg.sender].field_256 = 0
                                    else:
                                        if (arg2 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) / arg2 + userInfo[arg1][msg.sender].field_0 != poolInfo[arg1].field_768:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * _15434) + ceil32(return_data.size) + ceil32(return_data.size) + 970 len 31]
                                        userInfo[arg1][msg.sender].field_256 = (arg2 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) / 10^12
                                else:
                                    if not userInfo[arg1][msg.sender].field_0:
                                        if userInfo[arg1][msg.sender].field_256 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require ext_code.size(frogAddress)
                                        staticcall frogAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(frogAddress)
                                        if -userInfo[arg1][msg.sender].field_256 <= ext_call.return_data[0]:
                                            call frogAddress.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, -userInfo[arg1][msg.sender].field_256
                                        else:
                                            call frogAddress.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                            revert with 0, 'Address: call to non-contract'
                                        if not ext_code.hash(poolInfo[arg1].field_0):
                                            revert with 0, 'Address: call to non-contract'
                                        mem[(32 * _15434) + ceil32(return_data.size) + 996 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg2) >> 32
                                        mem[(32 * _15434) + ceil32(return_data.size) + 1120 len 4] = 0
                                    else:
                                        if poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / userInfo[arg1][msg.sender].field_0 != poolInfo[arg1].field_768:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * _15434) + ceil32(return_data.size) + 773 len 31]
                                        if userInfo[arg1][msg.sender].field_256 > poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require ext_code.size(frogAddress)
                                        staticcall frogAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(frogAddress)
                                        if (poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12) - userInfo[arg1][msg.sender].field_256 > ext_call.return_data[0]:
                                            call frogAddress.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                                revert with 0, 'Address: call to non-contract'
                                            if not ext_code.hash(poolInfo[arg1].field_0):
                                                revert with 0, 'Address: call to non-contract'
                                            mem[(32 * _15434) + ceil32(return_data.size) + 996 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg2) >> 32
                                            mem[(32 * _15434) + ceil32(return_data.size) + 1120 len 4] = 0
                                        else:
                                            call frogAddress.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, (poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12) - userInfo[arg1][msg.sender].field_256
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                                revert with 0, 'Address: call to non-contract'
                                            if not ext_code.hash(poolInfo[arg1].field_0):
                                                revert with 0, 'Address: call to non-contract'
                                            mem[(32 * _15434) + ceil32(return_data.size) + 996 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg2) >> 32
                                            mem[(32 * _15434) + ceil32(return_data.size) + 1120 len 4] = 0
                                            mem[(32 * _15434) + ceil32(return_data.size) + 1092 len 0] = 0
                                    call poolInfo[arg1].field_0 with:
                                         gas gas_remaining wei
                                        args Mask(224, 32, arg2) << 480, mem[(32 * _15434) + ceil32(return_data.size) + 1092 len 4]
                                    if not return_data.size:
                                        require not ext_call.success
                                        revert with 'SafeMath: subtraction overflow'
                                    mem[(32 * _15434) + ceil32(return_data.size) + 1028 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if not ext_call.success:
                                        if return_data.size:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if return_data.size:
                                        require return_data.size >= 32
                                        if not mem[(32 * _15434) + ceil32(return_data.size) + 1028]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[(32 * _15434) + ceil32(return_data.size) + ceil32(return_data.size) + 1107 len 22]
                                    if arg2 + userInfo[arg1][msg.sender].field_0 < userInfo[arg1][msg.sender].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    userInfo[arg1][msg.sender].field_0 += arg2
                                    if not arg2 + userInfo[arg1][msg.sender].field_0:
                                        userInfo[arg1][msg.sender].field_256 = 0
                                    else:
                                        if (arg2 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) / arg2 + userInfo[arg1][msg.sender].field_0 != poolInfo[arg1].field_768:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * _15434) + ceil32(return_data.size) + ceil32(return_data.size) + 1098 len 31]
                                        userInfo[arg1][msg.sender].field_256 = (arg2 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) / 10^12
                        else:
                            if (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / (block.number * frogPerBlock) - (poolInfo[arg1].field_512 * frogPerBlock) != poolInfo[arg1].field_256:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                            mem[288] = 26
                            mem[320] = 'SafeMath: division by zero'
                            if not totalAllocPoint:
                                revert with 0, 'SafeMath: division by zero'
                            mem[352] = 26
                            mem[384] = 'SafeMath: division by zero'
                            if not 2^(block.number - startBlock / halvingPeriod):
                                revert with 0, 'SafeMath: division by zero'
                            mem[416] = 26
                            mem[448] = 'SafeMath: division by zero'
                            require ext_code.size(frogAddress)
                            call frogAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args this.address, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod)
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(frogAddress)
                            call frogAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args this.address, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[480] = 2
                            mem[512] = frogAddress
                            mem[544] = wbnbAddress
                            if block.timestamp + 1800 < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[576] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                            mem[580] = (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                            mem[612] = 0
                            mem[676] = fundsAddress
                            mem[708] = block.timestamp + 1800
                            mem[644] = 160
                            mem[740] = 2
                            mem[772 len 0] = None
                            require ext_code.size(routerAddress)
                            call routerAddress.swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20, 0, 160, fundsAddress, block.timestamp + 1800, 2, mem[772 len 64]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[576 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = ceil32(return_data.size) + 576
                            require return_data.size >= 32
                            _15283 = mem[576 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32
                            require mem[576 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 <= 4294967296
                            require mem[576 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 32 <= return_data.size
                            require mem[mem[576 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 576] <= 4294967296 and mem[576 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + (32 * mem[mem[576 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 576]) + 32 <= return_data.size
                            mem[ceil32(return_data.size) + 576] = mem[mem[576 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 576]
                            _15433 = mem[_15283 + 576]
                            mem[ceil32(return_data.size) + 608 len floor32(mem[_15283 + 576])] = mem[_15283 + 608 len floor32(mem[_15283 + 576])]
                            if not (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod):
                                if not ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: division by zero'
                                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                            else:
                                if 10^12 * (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) != 10^12:
                                    revert with 0, 
                                                32,
                                                33,
                                                0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[(32 * _15433) + ceil32(return_data.size) + 709 len 31]
                                if not ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: division by zero'
                                if (10^12 * (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[arg1].field_768 += 10^12 * (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]
                            poolInfo[arg1].field_512 = block.number
                            if not userInfo[arg1][msg.sender].field_0:
                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                    revert with 0, 'Address: call to non-contract'
                                if not ext_code.hash(poolInfo[arg1].field_0):
                                    revert with 0, 'Address: call to non-contract'
                                mem[(32 * _15433) + ceil32(return_data.size) + 868 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg2) >> 32
                                mem[(32 * _15433) + ceil32(return_data.size) + 992 len 4] = 0
                                call poolInfo[arg1].field_0 with:
                                     gas gas_remaining wei
                                    args Mask(224, 32, arg2) << 480, mem[(32 * _15433) + ceil32(return_data.size) + 964 len 4]
                                if not return_data.size:
                                    require not ext_call.success
                                    revert with 'SafeMath: subtraction overflow'
                                mem[(32 * _15433) + ceil32(return_data.size) + 900 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if return_data.size:
                                    require return_data.size >= 32
                                    if not mem[(32 * _15433) + ceil32(return_data.size) + 900]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[(32 * _15433) + ceil32(return_data.size) + ceil32(return_data.size) + 979 len 22]
                                if arg2 + userInfo[arg1][msg.sender].field_0 < userInfo[arg1][msg.sender].field_0:
                                    revert with 0, 'SafeMath: addition overflow'
                                userInfo[arg1][msg.sender].field_0 += arg2
                                if not arg2 + userInfo[arg1][msg.sender].field_0:
                                    userInfo[arg1][msg.sender].field_256 = 0
                                else:
                                    if (arg2 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) / arg2 + userInfo[arg1][msg.sender].field_0 != poolInfo[arg1].field_768:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * _15433) + ceil32(return_data.size) + ceil32(return_data.size) + 970 len 31]
                                    userInfo[arg1][msg.sender].field_256 = (arg2 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) / 10^12
                            else:
                                if not userInfo[arg1][msg.sender].field_0:
                                    if userInfo[arg1][msg.sender].field_256 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require ext_code.size(frogAddress)
                                    staticcall frogAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(frogAddress)
                                    if -userInfo[arg1][msg.sender].field_256 <= ext_call.return_data[0]:
                                        call frogAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, -userInfo[arg1][msg.sender].field_256
                                    else:
                                        call frogAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, ext_call.return_data[0]
                                else:
                                    if poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / userInfo[arg1][msg.sender].field_0 != poolInfo[arg1].field_768:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * _15433) + ceil32(return_data.size) + 773 len 31]
                                    if userInfo[arg1][msg.sender].field_256 > poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require ext_code.size(frogAddress)
                                    staticcall frogAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(frogAddress)
                                    if (poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12) - userInfo[arg1][msg.sender].field_256 <= ext_call.return_data[0]:
                                        call frogAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, (poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12) - userInfo[arg1][msg.sender].field_256
                                    else:
                                        call frogAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                    revert with 0, 'Address: call to non-contract'
                                if not ext_code.hash(poolInfo[arg1].field_0):
                                    revert with 0, 'Address: call to non-contract'
                                mem[(32 * _15433) + ceil32(return_data.size) + 996 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg2) >> 32
                                mem[(32 * _15433) + ceil32(return_data.size) + 1120 len 4] = 0
                                call poolInfo[arg1].field_0 with:
                                     gas gas_remaining wei
                                    args Mask(224, 32, arg2) << 480, mem[(32 * _15433) + ceil32(return_data.size) + 1092 len 4]
                                if not return_data.size:
                                    require not ext_call.success
                                    revert with 'SafeMath: subtraction overflow'
                                mem[(32 * _15433) + ceil32(return_data.size) + 1028 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if return_data.size:
                                    require return_data.size >= 32
                                    if not mem[(32 * _15433) + ceil32(return_data.size) + 1028]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[(32 * _15433) + ceil32(return_data.size) + ceil32(return_data.size) + 1107 len 22]
                                if arg2 + userInfo[arg1][msg.sender].field_0 < userInfo[arg1][msg.sender].field_0:
                                    revert with 0, 'SafeMath: addition overflow'
                                userInfo[arg1][msg.sender].field_0 += arg2
                                if not arg2 + userInfo[arg1][msg.sender].field_0:
                                    userInfo[arg1][msg.sender].field_256 = 0
                                else:
                                    if (arg2 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) / arg2 + userInfo[arg1][msg.sender].field_0 != poolInfo[arg1].field_768:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * _15433) + ceil32(return_data.size) + ceil32(return_data.size) + 1098 len 31]
                                    userInfo[arg1][msg.sender].field_256 = (arg2 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) / 10^12
            else:
                if poolInfo[arg1].field_512 >= bonusEndBlock:
                    if poolInfo[arg1].field_512 > block.number:
                        revert with 0, 'SafeMath: subtraction overflow'
                    mem[160] = 30
                    mem[192] = 'SafeMath: subtraction overflow'
                    if startBlock > block.number:
                        revert with 0, 'SafeMath: subtraction overflow'
                    mem[224] = 26
                    mem[256] = 'SafeMath: division by zero'
                    if not halvingPeriod:
                        revert with 0, 'SafeMath: division by zero'
                    if not block.number - poolInfo[arg1].field_512:
                        mem[288] = 26
                        mem[320] = 'SafeMath: division by zero'
                        if not totalAllocPoint:
                            revert with 0, 'SafeMath: division by zero'
                        mem[352] = 26
                        mem[384] = 'SafeMath: division by zero'
                        if not 2^(block.number - startBlock / halvingPeriod):
                            revert with 0, 'SafeMath: division by zero'
                        mem[416] = 26
                        mem[448] = 'SafeMath: division by zero'
                        require ext_code.size(frogAddress)
                        call frogAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args this.address, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod)
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require ext_code.size(frogAddress)
                        call frogAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args this.address, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[480] = 2
                        mem[512] = frogAddress
                        mem[544] = wbnbAddress
                        if block.timestamp + 1800 < block.timestamp:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[576] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                        mem[580] = 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                        mem[612] = 0
                        mem[676] = fundsAddress
                        mem[708] = block.timestamp + 1800
                        mem[644] = 160
                        mem[740] = 2
                        mem[772 len 0] = None
                        require ext_code.size(routerAddress)
                        call routerAddress.swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                             gas gas_remaining wei
                            args 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20, 0, 160, fundsAddress, block.timestamp + 1800, 2, mem[772 len 64]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[576 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = ceil32(return_data.size) + 576
                        require return_data.size >= 32
                        _15281 = mem[576 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32
                        require mem[576 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 <= 4294967296
                        require mem[576 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 32 <= return_data.size
                        require mem[mem[576 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 576] <= 4294967296 and mem[576 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + (32 * mem[mem[576 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 576]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 576] = mem[mem[576 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 576]
                        _15432 = mem[_15281 + 576]
                        mem[ceil32(return_data.size) + 608 len floor32(mem[_15281 + 576])] = mem[_15281 + 608 len floor32(mem[_15281 + 576])]
                        if 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod):
                            if 10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) != 10^12:
                                revert with 0, 
                                            32,
                                            33,
                                            0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[(32 * _15432) + ceil32(return_data.size) + 709 len 31]
                            if not ext_call.return_data[0]:
                                revert with 0, 'SafeMath: division by zero'
                            if (10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]
                            poolInfo[arg1].field_512 = block.number
                            if not userInfo[arg1][msg.sender].field_0:
                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                    revert with 0, 'Address: call to non-contract'
                                if not ext_code.hash(poolInfo[arg1].field_0):
                                    revert with 0, 'Address: call to non-contract'
                                mem[(32 * _15432) + ceil32(return_data.size) + 868 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg2) >> 32
                                mem[(32 * _15432) + ceil32(return_data.size) + 992 len 4] = 0
                                call poolInfo[arg1].field_0 with:
                                     gas gas_remaining wei
                                    args Mask(224, 32, arg2) << 480, mem[(32 * _15432) + ceil32(return_data.size) + 964 len 4]
                                if not return_data.size:
                                    require not ext_call.success
                                    revert with 'SafeMath: subtraction overflow'
                                mem[(32 * _15432) + ceil32(return_data.size) + 900 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if return_data.size:
                                    require return_data.size >= 32
                                    if not mem[(32 * _15432) + ceil32(return_data.size) + 900]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[(32 * _15432) + ceil32(return_data.size) + ceil32(return_data.size) + 979 len 22]
                                if arg2 + userInfo[arg1][msg.sender].field_0 < userInfo[arg1][msg.sender].field_0:
                                    revert with 0, 'SafeMath: addition overflow'
                                userInfo[arg1][msg.sender].field_0 += arg2
                                if not arg2 + userInfo[arg1][msg.sender].field_0:
                                    userInfo[arg1][msg.sender].field_256 = 0
                                else:
                                    if (arg2 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) / arg2 + userInfo[arg1][msg.sender].field_0 != poolInfo[arg1].field_768:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * _15432) + ceil32(return_data.size) + ceil32(return_data.size) + 970 len 31]
                                    userInfo[arg1][msg.sender].field_256 = (arg2 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) / 10^12
                            else:
                                if not userInfo[arg1][msg.sender].field_0:
                                    if userInfo[arg1][msg.sender].field_256 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require ext_code.size(frogAddress)
                                    staticcall frogAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(frogAddress)
                                    if -userInfo[arg1][msg.sender].field_256 <= ext_call.return_data[0]:
                                        call frogAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, -userInfo[arg1][msg.sender].field_256
                                    else:
                                        call frogAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, ext_call.return_data[0]
                                else:
                                    if poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / userInfo[arg1][msg.sender].field_0 != poolInfo[arg1].field_768:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * _15432) + ceil32(return_data.size) + 773 len 31]
                                    if userInfo[arg1][msg.sender].field_256 > poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require ext_code.size(frogAddress)
                                    staticcall frogAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(frogAddress)
                                    if (poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12) - userInfo[arg1][msg.sender].field_256 <= ext_call.return_data[0]:
                                        call frogAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, (poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12) - userInfo[arg1][msg.sender].field_256
                                    else:
                                        call frogAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                    revert with 0, 'Address: call to non-contract'
                                if not ext_code.hash(poolInfo[arg1].field_0):
                                    revert with 0, 'Address: call to non-contract'
                                mem[(32 * _15432) + ceil32(return_data.size) + 996 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg2) >> 32
                                mem[(32 * _15432) + ceil32(return_data.size) + 1120 len 4] = 0
                                call poolInfo[arg1].field_0 with:
                                     gas gas_remaining wei
                                    args Mask(224, 32, arg2) << 480, mem[(32 * _15432) + ceil32(return_data.size) + 1092 len 4]
                                if not return_data.size:
                                    require not ext_call.success
                                    revert with 'SafeMath: subtraction overflow'
                                mem[(32 * _15432) + ceil32(return_data.size) + 1028 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if return_data.size:
                                    require return_data.size >= 32
                                    if not mem[(32 * _15432) + ceil32(return_data.size) + 1028]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[(32 * _15432) + ceil32(return_data.size) + ceil32(return_data.size) + 1107 len 22]
                                if arg2 + userInfo[arg1][msg.sender].field_0 < userInfo[arg1][msg.sender].field_0:
                                    revert with 0, 'SafeMath: addition overflow'
                                userInfo[arg1][msg.sender].field_0 += arg2
                                if not arg2 + userInfo[arg1][msg.sender].field_0:
                                    userInfo[arg1][msg.sender].field_256 = 0
                                else:
                                    if (arg2 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) / arg2 + userInfo[arg1][msg.sender].field_0 != poolInfo[arg1].field_768:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * _15432) + ceil32(return_data.size) + ceil32(return_data.size) + 1098 len 31]
                                    userInfo[arg1][msg.sender].field_256 = (arg2 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) / 10^12
                        else:
                            if not ext_call.return_data[0]:
                                revert with 0, 'SafeMath: division by zero'
                            if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[arg1].field_512 = block.number
                            if not userInfo[arg1][msg.sender].field_0:
                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                    revert with 0, 'Address: call to non-contract'
                                if not ext_code.hash(poolInfo[arg1].field_0):
                                    revert with 0, 'Address: call to non-contract'
                                mem[(32 * _15432) + ceil32(return_data.size) + 868 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg2) >> 32
                                mem[(32 * _15432) + ceil32(return_data.size) + 992 len 4] = 0
                                call poolInfo[arg1].field_0 with:
                                     gas gas_remaining wei
                                    args Mask(224, 32, arg2) << 480, mem[(32 * _15432) + ceil32(return_data.size) + 964 len 4]
                                if not return_data.size:
                                    require not ext_call.success
                                    revert with 'SafeMath: subtraction overflow'
                                mem[(32 * _15432) + ceil32(return_data.size) + 900 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if return_data.size:
                                    require return_data.size >= 32
                                    if not mem[(32 * _15432) + ceil32(return_data.size) + 900]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[(32 * _15432) + ceil32(return_data.size) + ceil32(return_data.size) + 979 len 22]
                                if arg2 + userInfo[arg1][msg.sender].field_0 < userInfo[arg1][msg.sender].field_0:
                                    revert with 0, 'SafeMath: addition overflow'
                                userInfo[arg1][msg.sender].field_0 += arg2
                                if not arg2 + userInfo[arg1][msg.sender].field_0:
                                    userInfo[arg1][msg.sender].field_256 = 0
                                else:
                                    if (arg2 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) / arg2 + userInfo[arg1][msg.sender].field_0 != poolInfo[arg1].field_768:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * _15432) + ceil32(return_data.size) + ceil32(return_data.size) + 970 len 31]
                                    userInfo[arg1][msg.sender].field_256 = (arg2 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) / 10^12
                            else:
                                if not userInfo[arg1][msg.sender].field_0:
                                    if userInfo[arg1][msg.sender].field_256 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require ext_code.size(frogAddress)
                                    staticcall frogAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(frogAddress)
                                    if -userInfo[arg1][msg.sender].field_256 <= ext_call.return_data[0]:
                                        call frogAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, -userInfo[arg1][msg.sender].field_256
                                    else:
                                        call frogAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                        revert with 0, 'Address: call to non-contract'
                                    if not ext_code.hash(poolInfo[arg1].field_0):
                                        revert with 0, 'Address: call to non-contract'
                                    mem[(32 * _15432) + ceil32(return_data.size) + 996 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg2) >> 32
                                    mem[(32 * _15432) + ceil32(return_data.size) + 1120 len 4] = 0
                                else:
                                    if poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / userInfo[arg1][msg.sender].field_0 != poolInfo[arg1].field_768:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * _15432) + ceil32(return_data.size) + 773 len 31]
                                    if userInfo[arg1][msg.sender].field_256 > poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require ext_code.size(frogAddress)
                                    staticcall frogAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(frogAddress)
                                    if (poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12) - userInfo[arg1][msg.sender].field_256 > ext_call.return_data[0]:
                                        call frogAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                            revert with 0, 'Address: call to non-contract'
                                        if not ext_code.hash(poolInfo[arg1].field_0):
                                            revert with 0, 'Address: call to non-contract'
                                        mem[(32 * _15432) + ceil32(return_data.size) + 996 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg2) >> 32
                                        mem[(32 * _15432) + ceil32(return_data.size) + 1120 len 4] = 0
                                    else:
                                        call frogAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, (poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12) - userInfo[arg1][msg.sender].field_256
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                            revert with 0, 'Address: call to non-contract'
                                        if not ext_code.hash(poolInfo[arg1].field_0):
                                            revert with 0, 'Address: call to non-contract'
                                        mem[(32 * _15432) + ceil32(return_data.size) + 996 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg2) >> 32
                                        mem[(32 * _15432) + ceil32(return_data.size) + 1120 len 4] = 0
                                        mem[(32 * _15432) + ceil32(return_data.size) + 1092 len 0] = 0
                                call poolInfo[arg1].field_0 with:
                                     gas gas_remaining wei
                                    args Mask(224, 32, arg2) << 480, mem[(32 * _15432) + ceil32(return_data.size) + 1092 len 4]
                                if not return_data.size:
                                    require not ext_call.success
                                    revert with 'SafeMath: subtraction overflow'
                                mem[(32 * _15432) + ceil32(return_data.size) + 1028 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if return_data.size:
                                    require return_data.size >= 32
                                    if not mem[(32 * _15432) + ceil32(return_data.size) + 1028]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[(32 * _15432) + ceil32(return_data.size) + ceil32(return_data.size) + 1107 len 22]
                                if arg2 + userInfo[arg1][msg.sender].field_0 < userInfo[arg1][msg.sender].field_0:
                                    revert with 0, 'SafeMath: addition overflow'
                                userInfo[arg1][msg.sender].field_0 += arg2
                                if not arg2 + userInfo[arg1][msg.sender].field_0:
                                    userInfo[arg1][msg.sender].field_256 = 0
                                else:
                                    if (arg2 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) / arg2 + userInfo[arg1][msg.sender].field_0 != poolInfo[arg1].field_768:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * _15432) + ceil32(return_data.size) + ceil32(return_data.size) + 1098 len 31]
                                    userInfo[arg1][msg.sender].field_256 = (arg2 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) / 10^12
                    else:
                        if (block.number * frogPerBlock) - (poolInfo[arg1].field_512 * frogPerBlock) / block.number - poolInfo[arg1].field_512 != frogPerBlock:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                        if not (block.number * frogPerBlock) - (poolInfo[arg1].field_512 * frogPerBlock):
                            mem[288] = 26
                            mem[320] = 'SafeMath: division by zero'
                            if not totalAllocPoint:
                                revert with 0, 'SafeMath: division by zero'
                            mem[352] = 26
                            mem[384] = 'SafeMath: division by zero'
                            if not 2^(block.number - startBlock / halvingPeriod):
                                revert with 0, 'SafeMath: division by zero'
                            mem[416] = 26
                            mem[448] = 'SafeMath: division by zero'
                            require ext_code.size(frogAddress)
                            call frogAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args this.address, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod)
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(frogAddress)
                            call frogAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args this.address, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[480] = 2
                            mem[512] = frogAddress
                            mem[544] = wbnbAddress
                            if block.timestamp + 1800 < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[576] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                            mem[580] = 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                            mem[612] = 0
                            mem[676] = fundsAddress
                            mem[708] = block.timestamp + 1800
                            mem[644] = 160
                            mem[740] = 2
                            mem[772 len 0] = None
                            require ext_code.size(routerAddress)
                            call routerAddress.swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20, 0, 160, fundsAddress, block.timestamp + 1800, 2, mem[772 len 64]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[576 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = ceil32(return_data.size) + 576
                            require return_data.size >= 32
                            _15279 = mem[576 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32
                            require mem[576 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 <= 4294967296
                            require mem[576 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 32 <= return_data.size
                            require mem[mem[576 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 576] <= 4294967296 and mem[576 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + (32 * mem[mem[576 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 576]) + 32 <= return_data.size
                            mem[ceil32(return_data.size) + 576] = mem[mem[576 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 576]
                            _15431 = mem[_15279 + 576]
                            mem[ceil32(return_data.size) + 608 len floor32(mem[_15279 + 576])] = mem[_15279 + 608 len floor32(mem[_15279 + 576])]
                            if not 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod):
                                if not ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: division by zero'
                                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                            else:
                                if 10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) != 10^12:
                                    revert with 0, 
                                                32,
                                                33,
                                                0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[(32 * _15431) + ceil32(return_data.size) + 709 len 31]
                                if not ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: division by zero'
                                if (10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]
                            poolInfo[arg1].field_512 = block.number
                            if not userInfo[arg1][msg.sender].field_0:
                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                    revert with 0, 'Address: call to non-contract'
                                if not ext_code.hash(poolInfo[arg1].field_0):
                                    revert with 0, 'Address: call to non-contract'
                                mem[(32 * _15431) + ceil32(return_data.size) + 868 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg2) >> 32
                                mem[(32 * _15431) + ceil32(return_data.size) + 992 len 4] = 0
                                call poolInfo[arg1].field_0 with:
                                     gas gas_remaining wei
                                    args Mask(224, 32, arg2) << 480, mem[(32 * _15431) + ceil32(return_data.size) + 964 len 4]
                                if not return_data.size:
                                    require not ext_call.success
                                    revert with 'SafeMath: subtraction overflow'
                                mem[(32 * _15431) + ceil32(return_data.size) + 900 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if return_data.size:
                                    require return_data.size >= 32
                                    if not mem[(32 * _15431) + ceil32(return_data.size) + 900]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[(32 * _15431) + ceil32(return_data.size) + ceil32(return_data.size) + 979 len 22]
                                if arg2 + userInfo[arg1][msg.sender].field_0 < userInfo[arg1][msg.sender].field_0:
                                    revert with 0, 'SafeMath: addition overflow'
                                userInfo[arg1][msg.sender].field_0 += arg2
                                if not arg2 + userInfo[arg1][msg.sender].field_0:
                                    userInfo[arg1][msg.sender].field_256 = 0
                                else:
                                    if (arg2 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) / arg2 + userInfo[arg1][msg.sender].field_0 != poolInfo[arg1].field_768:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * _15431) + ceil32(return_data.size) + ceil32(return_data.size) + 970 len 31]
                                    userInfo[arg1][msg.sender].field_256 = (arg2 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) / 10^12
                            else:
                                if not userInfo[arg1][msg.sender].field_0:
                                    if userInfo[arg1][msg.sender].field_256 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require ext_code.size(frogAddress)
                                    staticcall frogAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(frogAddress)
                                    if -userInfo[arg1][msg.sender].field_256 <= ext_call.return_data[0]:
                                        call frogAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, -userInfo[arg1][msg.sender].field_256
                                    else:
                                        call frogAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, ext_call.return_data[0]
                                else:
                                    if poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / userInfo[arg1][msg.sender].field_0 != poolInfo[arg1].field_768:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * _15431) + ceil32(return_data.size) + 773 len 31]
                                    if userInfo[arg1][msg.sender].field_256 > poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require ext_code.size(frogAddress)
                                    staticcall frogAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(frogAddress)
                                    if (poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12) - userInfo[arg1][msg.sender].field_256 <= ext_call.return_data[0]:
                                        call frogAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, (poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12) - userInfo[arg1][msg.sender].field_256
                                    else:
                                        call frogAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                    revert with 0, 'Address: call to non-contract'
                                if not ext_code.hash(poolInfo[arg1].field_0):
                                    revert with 0, 'Address: call to non-contract'
                                mem[(32 * _15431) + ceil32(return_data.size) + 996 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg2) >> 32
                                mem[(32 * _15431) + ceil32(return_data.size) + 1120 len 4] = 0
                                call poolInfo[arg1].field_0 with:
                                     gas gas_remaining wei
                                    args Mask(224, 32, arg2) << 480, mem[(32 * _15431) + ceil32(return_data.size) + 1092 len 4]
                                if not return_data.size:
                                    require not ext_call.success
                                    revert with 'SafeMath: subtraction overflow'
                                mem[(32 * _15431) + ceil32(return_data.size) + 1028 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if return_data.size:
                                    require return_data.size >= 32
                                    if not mem[(32 * _15431) + ceil32(return_data.size) + 1028]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[(32 * _15431) + ceil32(return_data.size) + ceil32(return_data.size) + 1107 len 22]
                                if arg2 + userInfo[arg1][msg.sender].field_0 < userInfo[arg1][msg.sender].field_0:
                                    revert with 0, 'SafeMath: addition overflow'
                                userInfo[arg1][msg.sender].field_0 += arg2
                                if not arg2 + userInfo[arg1][msg.sender].field_0:
                                    userInfo[arg1][msg.sender].field_256 = 0
                                else:
                                    if (arg2 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) / arg2 + userInfo[arg1][msg.sender].field_0 != poolInfo[arg1].field_768:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * _15431) + ceil32(return_data.size) + ceil32(return_data.size) + 1098 len 31]
                                    userInfo[arg1][msg.sender].field_256 = (arg2 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) / 10^12
                        else:
                            if (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / (block.number * frogPerBlock) - (poolInfo[arg1].field_512 * frogPerBlock) != poolInfo[arg1].field_256:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                            mem[288] = 26
                            mem[320] = 'SafeMath: division by zero'
                            if not totalAllocPoint:
                                revert with 0, 'SafeMath: division by zero'
                            mem[352] = 26
                            mem[384] = 'SafeMath: division by zero'
                            if not 2^(block.number - startBlock / halvingPeriod):
                                revert with 0, 'SafeMath: division by zero'
                            mem[416] = 26
                            mem[448] = 'SafeMath: division by zero'
                            require ext_code.size(frogAddress)
                            call frogAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args this.address, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod)
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(frogAddress)
                            call frogAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args this.address, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[480] = 2
                            mem[512] = frogAddress
                            mem[544] = wbnbAddress
                            if block.timestamp + 1800 < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[576] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                            mem[580] = (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                            mem[612] = 0
                            mem[676] = fundsAddress
                            mem[708] = block.timestamp + 1800
                            mem[644] = 160
                            mem[740] = 2
                            mem[772 len 0] = None
                            require ext_code.size(routerAddress)
                            call routerAddress.swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20, 0, 160, fundsAddress, block.timestamp + 1800, 2, mem[772 len 64]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[576 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = ceil32(return_data.size) + 576
                            require return_data.size >= 32
                            _15277 = mem[576 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32
                            require mem[576 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 <= 4294967296
                            require mem[576 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 32 <= return_data.size
                            require mem[mem[576 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 576] <= 4294967296 and mem[576 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + (32 * mem[mem[576 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 576]) + 32 <= return_data.size
                            mem[ceil32(return_data.size) + 576] = mem[mem[576 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 576]
                            _15430 = mem[_15277 + 576]
                            mem[ceil32(return_data.size) + 608 len floor32(mem[_15277 + 576])] = mem[_15277 + 608 len floor32(mem[_15277 + 576])]
                            if not (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod):
                                if not ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: division by zero'
                                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                            else:
                                if 10^12 * (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) != 10^12:
                                    revert with 0, 
                                                32,
                                                33,
                                                0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[(32 * _15430) + ceil32(return_data.size) + 709 len 31]
                                if not ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: division by zero'
                                if (10^12 * (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[arg1].field_768 += 10^12 * (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]
                            poolInfo[arg1].field_512 = block.number
                            if not userInfo[arg1][msg.sender].field_0:
                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                    revert with 0, 'Address: call to non-contract'
                                if not ext_code.hash(poolInfo[arg1].field_0):
                                    revert with 0, 'Address: call to non-contract'
                                mem[(32 * _15430) + ceil32(return_data.size) + 868 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg2) >> 32
                                mem[(32 * _15430) + ceil32(return_data.size) + 992 len 4] = 0
                                call poolInfo[arg1].field_0 with:
                                     gas gas_remaining wei
                                    args Mask(224, 32, arg2) << 480, mem[(32 * _15430) + ceil32(return_data.size) + 964 len 4]
                                if not return_data.size:
                                    require not ext_call.success
                                    revert with 'SafeMath: subtraction overflow'
                                mem[(32 * _15430) + ceil32(return_data.size) + 900 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if return_data.size:
                                    require return_data.size >= 32
                                    if not mem[(32 * _15430) + ceil32(return_data.size) + 900]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[(32 * _15430) + ceil32(return_data.size) + ceil32(return_data.size) + 979 len 22]
                                if arg2 + userInfo[arg1][msg.sender].field_0 < userInfo[arg1][msg.sender].field_0:
                                    revert with 0, 'SafeMath: addition overflow'
                                userInfo[arg1][msg.sender].field_0 += arg2
                                if not arg2 + userInfo[arg1][msg.sender].field_0:
                                    userInfo[arg1][msg.sender].field_256 = 0
                                else:
                                    if (arg2 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) / arg2 + userInfo[arg1][msg.sender].field_0 != poolInfo[arg1].field_768:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * _15430) + ceil32(return_data.size) + ceil32(return_data.size) + 970 len 31]
                                    userInfo[arg1][msg.sender].field_256 = (arg2 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) / 10^12
                            else:
                                if not userInfo[arg1][msg.sender].field_0:
                                    if userInfo[arg1][msg.sender].field_256 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require ext_code.size(frogAddress)
                                    staticcall frogAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(frogAddress)
                                    if -userInfo[arg1][msg.sender].field_256 <= ext_call.return_data[0]:
                                        call frogAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, -userInfo[arg1][msg.sender].field_256
                                    else:
                                        call frogAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, ext_call.return_data[0]
                                else:
                                    if poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / userInfo[arg1][msg.sender].field_0 != poolInfo[arg1].field_768:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * _15430) + ceil32(return_data.size) + 773 len 31]
                                    if userInfo[arg1][msg.sender].field_256 > poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require ext_code.size(frogAddress)
                                    staticcall frogAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(frogAddress)
                                    if (poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12) - userInfo[arg1][msg.sender].field_256 <= ext_call.return_data[0]:
                                        call frogAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, (poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12) - userInfo[arg1][msg.sender].field_256
                                    else:
                                        call frogAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                    revert with 0, 'Address: call to non-contract'
                                if not ext_code.hash(poolInfo[arg1].field_0):
                                    revert with 0, 'Address: call to non-contract'
                                mem[(32 * _15430) + ceil32(return_data.size) + 996 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg2) >> 32
                                mem[(32 * _15430) + ceil32(return_data.size) + 1120 len 4] = 0
                                call poolInfo[arg1].field_0 with:
                                     gas gas_remaining wei
                                    args Mask(224, 32, arg2) << 480, mem[(32 * _15430) + ceil32(return_data.size) + 1092 len 4]
                                if not return_data.size:
                                    require not ext_call.success
                                    revert with 'SafeMath: subtraction overflow'
                                mem[(32 * _15430) + ceil32(return_data.size) + 1028 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if return_data.size:
                                    require return_data.size >= 32
                                    if not mem[(32 * _15430) + ceil32(return_data.size) + 1028]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[(32 * _15430) + ceil32(return_data.size) + ceil32(return_data.size) + 1107 len 22]
                                if arg2 + userInfo[arg1][msg.sender].field_0 < userInfo[arg1][msg.sender].field_0:
                                    revert with 0, 'SafeMath: addition overflow'
                                userInfo[arg1][msg.sender].field_0 += arg2
                                if not arg2 + userInfo[arg1][msg.sender].field_0:
                                    userInfo[arg1][msg.sender].field_256 = 0
                                else:
                                    if (arg2 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) / arg2 + userInfo[arg1][msg.sender].field_0 != poolInfo[arg1].field_768:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * _15430) + ceil32(return_data.size) + ceil32(return_data.size) + 1098 len 31]
                                    userInfo[arg1][msg.sender].field_256 = (arg2 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) / 10^12
                else:
                    if bonusEndBlock > block.number:
                        revert with 0, 'SafeMath: subtraction overflow'
                    mem[160] = 30
                    mem[192] = 'SafeMath: subtraction overflow'
                    if poolInfo[arg1].field_512 > bonusEndBlock:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not bonusEndBlock - poolInfo[arg1].field_512:
                        if block.number - bonusEndBlock < 0:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[224] = 30
                        mem[256] = 'SafeMath: subtraction overflow'
                        if startBlock > block.number:
                            revert with 0, 'SafeMath: subtraction overflow'
                        mem[288] = 26
                        mem[320] = 'SafeMath: division by zero'
                        if not halvingPeriod:
                            revert with 0, 'SafeMath: division by zero'
                        if not block.number - bonusEndBlock:
                            mem[352] = 26
                            mem[384] = 'SafeMath: division by zero'
                            if not totalAllocPoint:
                                revert with 0, 'SafeMath: division by zero'
                            mem[416] = 26
                            mem[448] = 'SafeMath: division by zero'
                            if not 2^(block.number - startBlock / halvingPeriod):
                                revert with 0, 'SafeMath: division by zero'
                            mem[480] = 26
                            mem[512] = 'SafeMath: division by zero'
                            require ext_code.size(frogAddress)
                            call frogAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args this.address, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod)
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(frogAddress)
                            call frogAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args this.address, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[544] = 2
                            mem[576] = frogAddress
                            mem[608] = wbnbAddress
                            if block.timestamp + 1800 < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[640] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                            mem[644] = 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                            mem[676] = 0
                            mem[740] = fundsAddress
                            mem[772] = block.timestamp + 1800
                            mem[708] = 160
                            mem[804] = 2
                            mem[836 len 0] = None
                            require ext_code.size(routerAddress)
                            call routerAddress.swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20, 0, 160, fundsAddress, block.timestamp + 1800, 2, mem[836 len 64]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[640 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = ceil32(return_data.size) + 640
                            require return_data.size >= 32
                            _15275 = mem[640 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32
                            require mem[640 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 <= 4294967296
                            require mem[640 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 32 <= return_data.size
                            require mem[mem[640 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 640] <= 4294967296 and mem[640 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + (32 * mem[mem[640 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 640]) + 32 <= return_data.size
                            mem[ceil32(return_data.size) + 640] = mem[mem[640 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 640]
                            _15429 = mem[_15275 + 640]
                            mem[ceil32(return_data.size) + 672 len floor32(mem[_15275 + 640])] = mem[_15275 + 672 len floor32(mem[_15275 + 640])]
                            if not 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod):
                                if not ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: division by zero'
                                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                            else:
                                if 10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) != 10^12:
                                    revert with 0, 
                                                32,
                                                33,
                                                0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[(32 * _15429) + ceil32(return_data.size) + 773 len 31]
                                if not ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: division by zero'
                                if (10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]
                            poolInfo[arg1].field_512 = block.number
                            if not userInfo[arg1][msg.sender].field_0:
                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                    revert with 0, 'Address: call to non-contract'
                                if not ext_code.hash(poolInfo[arg1].field_0):
                                    revert with 0, 'Address: call to non-contract'
                                mem[(32 * _15429) + ceil32(return_data.size) + 932 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg2) >> 32
                                mem[(32 * _15429) + ceil32(return_data.size) + 1056 len 4] = 0
                                call poolInfo[arg1].field_0 with:
                                     gas gas_remaining wei
                                    args Mask(224, 32, arg2) << 480, mem[(32 * _15429) + ceil32(return_data.size) + 1028 len 4]
                                if not return_data.size:
                                    require not ext_call.success
                                    revert with 'SafeMath: subtraction overflow'
                                mem[(32 * _15429) + ceil32(return_data.size) + 964 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if return_data.size:
                                    require return_data.size >= 32
                                    if not mem[(32 * _15429) + ceil32(return_data.size) + 964]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[(32 * _15429) + ceil32(return_data.size) + ceil32(return_data.size) + 1043 len 22]
                                if arg2 + userInfo[arg1][msg.sender].field_0 < userInfo[arg1][msg.sender].field_0:
                                    revert with 0, 'SafeMath: addition overflow'
                                userInfo[arg1][msg.sender].field_0 += arg2
                                if not arg2 + userInfo[arg1][msg.sender].field_0:
                                    userInfo[arg1][msg.sender].field_256 = 0
                                else:
                                    if (arg2 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) / arg2 + userInfo[arg1][msg.sender].field_0 != poolInfo[arg1].field_768:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * _15429) + ceil32(return_data.size) + ceil32(return_data.size) + 1034 len 31]
                                    userInfo[arg1][msg.sender].field_256 = (arg2 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) / 10^12
                            else:
                                if not userInfo[arg1][msg.sender].field_0:
                                    if userInfo[arg1][msg.sender].field_256 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require ext_code.size(frogAddress)
                                    staticcall frogAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(frogAddress)
                                    if -userInfo[arg1][msg.sender].field_256 <= ext_call.return_data[0]:
                                        call frogAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, -userInfo[arg1][msg.sender].field_256
                                    else:
                                        call frogAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, ext_call.return_data[0]
                                else:
                                    if poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / userInfo[arg1][msg.sender].field_0 != poolInfo[arg1].field_768:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * _15429) + ceil32(return_data.size) + 837 len 31]
                                    if userInfo[arg1][msg.sender].field_256 > poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require ext_code.size(frogAddress)
                                    staticcall frogAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(frogAddress)
                                    if (poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12) - userInfo[arg1][msg.sender].field_256 <= ext_call.return_data[0]:
                                        call frogAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, (poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12) - userInfo[arg1][msg.sender].field_256
                                    else:
                                        call frogAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                    revert with 0, 'Address: call to non-contract'
                                if not ext_code.hash(poolInfo[arg1].field_0):
                                    revert with 0, 'Address: call to non-contract'
                                mem[(32 * _15429) + ceil32(return_data.size) + 1060 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg2) >> 32
                                mem[(32 * _15429) + ceil32(return_data.size) + 1184 len 4] = 0
                                call poolInfo[arg1].field_0 with:
                                     gas gas_remaining wei
                                    args Mask(224, 32, arg2) << 480, mem[(32 * _15429) + ceil32(return_data.size) + 1156 len 4]
                                if not return_data.size:
                                    require not ext_call.success
                                    revert with 'SafeMath: subtraction overflow'
                                mem[(32 * _15429) + ceil32(return_data.size) + 1092 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if return_data.size:
                                    require return_data.size >= 32
                                    if not mem[(32 * _15429) + ceil32(return_data.size) + 1092]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[(32 * _15429) + ceil32(return_data.size) + ceil32(return_data.size) + 1171 len 22]
                                if arg2 + userInfo[arg1][msg.sender].field_0 < userInfo[arg1][msg.sender].field_0:
                                    revert with 0, 'SafeMath: addition overflow'
                                userInfo[arg1][msg.sender].field_0 += arg2
                                if not arg2 + userInfo[arg1][msg.sender].field_0:
                                    userInfo[arg1][msg.sender].field_256 = 0
                                else:
                                    if (arg2 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) / arg2 + userInfo[arg1][msg.sender].field_0 != poolInfo[arg1].field_768:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * _15429) + ceil32(return_data.size) + ceil32(return_data.size) + 1162 len 31]
                                    userInfo[arg1][msg.sender].field_256 = (arg2 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) / 10^12
                        else:
                            if (block.number * frogPerBlock) - (bonusEndBlock * frogPerBlock) / block.number - bonusEndBlock != frogPerBlock:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                            if not (block.number * frogPerBlock) - (bonusEndBlock * frogPerBlock):
                                mem[352] = 26
                                mem[384] = 'SafeMath: division by zero'
                                if not totalAllocPoint:
                                    revert with 0, 'SafeMath: division by zero'
                                mem[416] = 26
                                mem[448] = 'SafeMath: division by zero'
                                if not 2^(block.number - startBlock / halvingPeriod):
                                    revert with 0, 'SafeMath: division by zero'
                                mem[480] = 26
                                mem[512] = 'SafeMath: division by zero'
                                require ext_code.size(frogAddress)
                                call frogAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args this.address, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod)
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(frogAddress)
                                call frogAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args this.address, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[544] = 2
                                mem[576] = frogAddress
                                mem[608] = wbnbAddress
                                if block.timestamp + 1800 < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[640] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                mem[644] = 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                                mem[676] = 0
                                mem[740] = fundsAddress
                                mem[772] = block.timestamp + 1800
                                mem[708] = 160
                                mem[804] = 2
                                mem[836 len 0] = None
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20, 0, 160, fundsAddress, block.timestamp + 1800, 2, mem[836 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[640 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(return_data.size) + 640
                                require return_data.size >= 32
                                _15273 = mem[640 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32
                                require mem[640 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 <= 4294967296
                                require mem[640 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 32 <= return_data.size
                                require mem[mem[640 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 640] <= 4294967296 and mem[640 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + (32 * mem[mem[640 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 640]) + 32 <= return_data.size
                                mem[ceil32(return_data.size) + 640] = mem[mem[640 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 640]
                                _15428 = mem[_15273 + 640]
                                mem[ceil32(return_data.size) + 672 len floor32(mem[_15273 + 640])] = mem[_15273 + 672 len floor32(mem[_15273 + 640])]
                                if not 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod):
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: division by zero'
                                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                else:
                                    if 10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) != 10^12:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * _15428) + ceil32(return_data.size) + 773 len 31]
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: division by zero'
                                    if (10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]
                                poolInfo[arg1].field_512 = block.number
                                if not userInfo[arg1][msg.sender].field_0:
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                        revert with 0, 'Address: call to non-contract'
                                    if not ext_code.hash(poolInfo[arg1].field_0):
                                        revert with 0, 'Address: call to non-contract'
                                    mem[(32 * _15428) + ceil32(return_data.size) + 932 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg2) >> 32
                                    mem[(32 * _15428) + ceil32(return_data.size) + 1056 len 4] = 0
                                    call poolInfo[arg1].field_0 with:
                                         gas gas_remaining wei
                                        args Mask(224, 32, arg2) << 480, mem[(32 * _15428) + ceil32(return_data.size) + 1028 len 4]
                                    if not return_data.size:
                                        require not ext_call.success
                                        revert with 'SafeMath: subtraction overflow'
                                    mem[(32 * _15428) + ceil32(return_data.size) + 964 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if not ext_call.success:
                                        if return_data.size:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if return_data.size:
                                        require return_data.size >= 32
                                        if not mem[(32 * _15428) + ceil32(return_data.size) + 964]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[(32 * _15428) + ceil32(return_data.size) + ceil32(return_data.size) + 1043 len 22]
                                    if arg2 + userInfo[arg1][msg.sender].field_0 < userInfo[arg1][msg.sender].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    userInfo[arg1][msg.sender].field_0 += arg2
                                    if not arg2 + userInfo[arg1][msg.sender].field_0:
                                        userInfo[arg1][msg.sender].field_256 = 0
                                    else:
                                        if (arg2 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) / arg2 + userInfo[arg1][msg.sender].field_0 != poolInfo[arg1].field_768:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * _15428) + ceil32(return_data.size) + ceil32(return_data.size) + 1034 len 31]
                                        userInfo[arg1][msg.sender].field_256 = (arg2 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) / 10^12
                                else:
                                    if not userInfo[arg1][msg.sender].field_0:
                                        if userInfo[arg1][msg.sender].field_256 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require ext_code.size(frogAddress)
                                        staticcall frogAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(frogAddress)
                                        if -userInfo[arg1][msg.sender].field_256 <= ext_call.return_data[0]:
                                            call frogAddress.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, -userInfo[arg1][msg.sender].field_256
                                        else:
                                            call frogAddress.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, ext_call.return_data[0]
                                    else:
                                        if poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / userInfo[arg1][msg.sender].field_0 != poolInfo[arg1].field_768:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * _15428) + ceil32(return_data.size) + 837 len 31]
                                        if userInfo[arg1][msg.sender].field_256 > poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require ext_code.size(frogAddress)
                                        staticcall frogAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(frogAddress)
                                        if (poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12) - userInfo[arg1][msg.sender].field_256 <= ext_call.return_data[0]:
                                            call frogAddress.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, (poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12) - userInfo[arg1][msg.sender].field_256
                                        else:
                                            call frogAddress.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                        revert with 0, 'Address: call to non-contract'
                                    if not ext_code.hash(poolInfo[arg1].field_0):
                                        revert with 0, 'Address: call to non-contract'
                                    mem[(32 * _15428) + ceil32(return_data.size) + 1060 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg2) >> 32
                                    mem[(32 * _15428) + ceil32(return_data.size) + 1184 len 4] = 0
                                    call poolInfo[arg1].field_0 with:
                                         gas gas_remaining wei
                                        args Mask(224, 32, arg2) << 480, mem[(32 * _15428) + ceil32(return_data.size) + 1156 len 4]
                                    if not return_data.size:
                                        require not ext_call.success
                                        revert with 'SafeMath: subtraction overflow'
                                    mem[(32 * _15428) + ceil32(return_data.size) + 1092 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if not ext_call.success:
                                        if return_data.size:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if return_data.size:
                                        require return_data.size >= 32
                                        if not mem[(32 * _15428) + ceil32(return_data.size) + 1092]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[(32 * _15428) + ceil32(return_data.size) + ceil32(return_data.size) + 1171 len 22]
                                    if arg2 + userInfo[arg1][msg.sender].field_0 < userInfo[arg1][msg.sender].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    userInfo[arg1][msg.sender].field_0 += arg2
                                    if not arg2 + userInfo[arg1][msg.sender].field_0:
                                        userInfo[arg1][msg.sender].field_256 = 0
                                    else:
                                        if (arg2 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) / arg2 + userInfo[arg1][msg.sender].field_0 != poolInfo[arg1].field_768:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * _15428) + ceil32(return_data.size) + ceil32(return_data.size) + 1162 len 31]
                                        userInfo[arg1][msg.sender].field_256 = (arg2 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) / 10^12
                            else:
                                if (block.number * frogPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * frogPerBlock * poolInfo[arg1].field_256) / (block.number * frogPerBlock) - (bonusEndBlock * frogPerBlock) != poolInfo[arg1].field_256:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                mem[352] = 26
                                mem[384] = 'SafeMath: division by zero'
                                if not totalAllocPoint:
                                    revert with 0, 'SafeMath: division by zero'
                                mem[416] = 26
                                mem[448] = 'SafeMath: division by zero'
                                if not 2^(block.number - startBlock / halvingPeriod):
                                    revert with 0, 'SafeMath: division by zero'
                                mem[480] = 26
                                mem[512] = 'SafeMath: division by zero'
                                require ext_code.size(frogAddress)
                                call frogAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args this.address, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod)
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(frogAddress)
                                call frogAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args this.address, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[544] = 2
                                mem[576] = frogAddress
                                mem[608] = wbnbAddress
                                if block.timestamp + 1800 < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[640] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                mem[644] = (block.number * frogPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                                mem[676] = 0
                                mem[740] = fundsAddress
                                mem[772] = block.timestamp + 1800
                                mem[708] = 160
                                mem[804] = 2
                                mem[836 len 0] = None
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args (block.number * frogPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20, 0, 160, fundsAddress, block.timestamp + 1800, 2, mem[836 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[640 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(return_data.size) + 640
                                require return_data.size >= 32
                                _15271 = mem[640 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32
                                require mem[640 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 <= 4294967296
                                require mem[640 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 32 <= return_data.size
                                require mem[mem[640 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 640] <= 4294967296 and mem[640 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + (32 * mem[mem[640 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 640]) + 32 <= return_data.size
                                mem[ceil32(return_data.size) + 640] = mem[mem[640 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 640]
                                _15427 = mem[_15271 + 640]
                                mem[ceil32(return_data.size) + 672 len floor32(mem[_15271 + 640])] = mem[_15271 + 672 len floor32(mem[_15271 + 640])]
                                if not (block.number * frogPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod):
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: division by zero'
                                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                else:
                                    if 10^12 * (block.number * frogPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / (block.number * frogPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) != 10^12:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * _15427) + ceil32(return_data.size) + 773 len 31]
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: division by zero'
                                    if (10^12 * (block.number * frogPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_768 += 10^12 * (block.number * frogPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]
                                poolInfo[arg1].field_512 = block.number
                                if not userInfo[arg1][msg.sender].field_0:
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                        revert with 0, 'Address: call to non-contract'
                                    if not ext_code.hash(poolInfo[arg1].field_0):
                                        revert with 0, 'Address: call to non-contract'
                                    mem[(32 * _15427) + ceil32(return_data.size) + 932 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg2) >> 32
                                    mem[(32 * _15427) + ceil32(return_data.size) + 1056 len 4] = 0
                                    call poolInfo[arg1].field_0 with:
                                         gas gas_remaining wei
                                        args Mask(224, 32, arg2) << 480, mem[(32 * _15427) + ceil32(return_data.size) + 1028 len 4]
                                    if not return_data.size:
                                        require not ext_call.success
                                        revert with 'SafeMath: subtraction overflow'
                                    mem[(32 * _15427) + ceil32(return_data.size) + 964 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if not ext_call.success:
                                        if return_data.size:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if return_data.size:
                                        require return_data.size >= 32
                                        if not mem[(32 * _15427) + ceil32(return_data.size) + 964]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[(32 * _15427) + ceil32(return_data.size) + ceil32(return_data.size) + 1043 len 22]
                                    if arg2 + userInfo[arg1][msg.sender].field_0 < userInfo[arg1][msg.sender].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    userInfo[arg1][msg.sender].field_0 += arg2
                                    if not arg2 + userInfo[arg1][msg.sender].field_0:
                                        userInfo[arg1][msg.sender].field_256 = 0
                                    else:
                                        if (arg2 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) / arg2 + userInfo[arg1][msg.sender].field_0 != poolInfo[arg1].field_768:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * _15427) + ceil32(return_data.size) + ceil32(return_data.size) + 1034 len 31]
                                        userInfo[arg1][msg.sender].field_256 = (arg2 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) / 10^12
                                else:
                                    if not userInfo[arg1][msg.sender].field_0:
                                        if userInfo[arg1][msg.sender].field_256 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require ext_code.size(frogAddress)
                                        staticcall frogAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(frogAddress)
                                        if -userInfo[arg1][msg.sender].field_256 <= ext_call.return_data[0]:
                                            call frogAddress.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, -userInfo[arg1][msg.sender].field_256
                                        else:
                                            call frogAddress.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, ext_call.return_data[0]
                                    else:
                                        if poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / userInfo[arg1][msg.sender].field_0 != poolInfo[arg1].field_768:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * _15427) + ceil32(return_data.size) + 837 len 31]
                                        if userInfo[arg1][msg.sender].field_256 > poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require ext_code.size(frogAddress)
                                        staticcall frogAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(frogAddress)
                                        if (poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12) - userInfo[arg1][msg.sender].field_256 <= ext_call.return_data[0]:
                                            call frogAddress.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, (poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12) - userInfo[arg1][msg.sender].field_256
                                        else:
                                            call frogAddress.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                        revert with 0, 'Address: call to non-contract'
                                    if not ext_code.hash(poolInfo[arg1].field_0):
                                        revert with 0, 'Address: call to non-contract'
                                    mem[(32 * _15427) + ceil32(return_data.size) + 1060 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg2) >> 32
                                    mem[(32 * _15427) + ceil32(return_data.size) + 1184 len 4] = 0
                                    call poolInfo[arg1].field_0 with:
                                         gas gas_remaining wei
                                        args Mask(224, 32, arg2) << 480, mem[(32 * _15427) + ceil32(return_data.size) + 1156 len 4]
                                    if not return_data.size:
                                        require not ext_call.success
                                        revert with 'SafeMath: subtraction overflow'
                                    mem[(32 * _15427) + ceil32(return_data.size) + 1092 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if not ext_call.success:
                                        if return_data.size:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if return_data.size:
                                        require return_data.size >= 32
                                        if not mem[(32 * _15427) + ceil32(return_data.size) + 1092]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[(32 * _15427) + ceil32(return_data.size) + ceil32(return_data.size) + 1171 len 22]
                                    if arg2 + userInfo[arg1][msg.sender].field_0 < userInfo[arg1][msg.sender].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    userInfo[arg1][msg.sender].field_0 += arg2
                                    if not arg2 + userInfo[arg1][msg.sender].field_0:
                                        userInfo[arg1][msg.sender].field_256 = 0
                                    else:
                                        if (arg2 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) / arg2 + userInfo[arg1][msg.sender].field_0 != poolInfo[arg1].field_768:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * _15427) + ceil32(return_data.size) + ceil32(return_data.size) + 1162 len 31]
                                        userInfo[arg1][msg.sender].field_256 = (arg2 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) / 10^12
                    else:
                        if bonusEndBlock - poolInfo[arg1].field_512 / bonusEndBlock - poolInfo[arg1].field_512 != 1:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                        if block.number < bonusEndBlock:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[224] = 30
                        mem[256] = 'SafeMath: subtraction overflow'
                        if startBlock > block.number:
                            revert with 0, 'SafeMath: subtraction overflow'
                        mem[288] = 26
                        mem[320] = 'SafeMath: division by zero'
                        if not halvingPeriod:
                            revert with 0, 'SafeMath: division by zero'
                        if not block.number - poolInfo[arg1].field_512:
                            mem[352] = 26
                            mem[384] = 'SafeMath: division by zero'
                            if not totalAllocPoint:
                                revert with 0, 'SafeMath: division by zero'
                            mem[416] = 26
                            mem[448] = 'SafeMath: division by zero'
                            if not 2^(block.number - startBlock / halvingPeriod):
                                revert with 0, 'SafeMath: division by zero'
                            mem[480] = 26
                            mem[512] = 'SafeMath: division by zero'
                            require ext_code.size(frogAddress)
                            call frogAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args this.address, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod)
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(frogAddress)
                            call frogAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args this.address, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[544] = 2
                            mem[576] = frogAddress
                            mem[608] = wbnbAddress
                            if block.timestamp + 1800 < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[640] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                            mem[644] = 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                            mem[676] = 0
                            mem[740] = fundsAddress
                            mem[772] = block.timestamp + 1800
                            mem[708] = 160
                            mem[804] = 2
                            mem[836 len 0] = None
                            require ext_code.size(routerAddress)
                            call routerAddress.swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20, 0, 160, fundsAddress, block.timestamp + 1800, 2, mem[836 len 64]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[640 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = ceil32(return_data.size) + 640
                            require return_data.size >= 32
                            _15269 = mem[640 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32
                            require mem[640 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 <= 4294967296
                            require mem[640 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 32 <= return_data.size
                            require mem[mem[640 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 640] <= 4294967296 and mem[640 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + (32 * mem[mem[640 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 640]) + 32 <= return_data.size
                            mem[ceil32(return_data.size) + 640] = mem[mem[640 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 640]
                            _15426 = mem[_15269 + 640]
                            mem[ceil32(return_data.size) + 672 len floor32(mem[_15269 + 640])] = mem[_15269 + 672 len floor32(mem[_15269 + 640])]
                            if not 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod):
                                if not ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: division by zero'
                                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                            else:
                                if 10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) != 10^12:
                                    revert with 0, 
                                                32,
                                                33,
                                                0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[(32 * _15426) + ceil32(return_data.size) + 773 len 31]
                                if not ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: division by zero'
                                if (10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]
                            poolInfo[arg1].field_512 = block.number
                            if not userInfo[arg1][msg.sender].field_0:
                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                    revert with 0, 'Address: call to non-contract'
                                if not ext_code.hash(poolInfo[arg1].field_0):
                                    revert with 0, 'Address: call to non-contract'
                                mem[(32 * _15426) + ceil32(return_data.size) + 932 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg2) >> 32
                                mem[(32 * _15426) + ceil32(return_data.size) + 1056 len 4] = 0
                                call poolInfo[arg1].field_0 with:
                                     gas gas_remaining wei
                                    args Mask(224, 32, arg2) << 480, mem[(32 * _15426) + ceil32(return_data.size) + 1028 len 4]
                                if not return_data.size:
                                    require not ext_call.success
                                    revert with 'SafeMath: subtraction overflow'
                                mem[(32 * _15426) + ceil32(return_data.size) + 964 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if return_data.size:
                                    require return_data.size >= 32
                                    if not mem[(32 * _15426) + ceil32(return_data.size) + 964]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[(32 * _15426) + ceil32(return_data.size) + ceil32(return_data.size) + 1043 len 22]
                                if arg2 + userInfo[arg1][msg.sender].field_0 < userInfo[arg1][msg.sender].field_0:
                                    revert with 0, 'SafeMath: addition overflow'
                                userInfo[arg1][msg.sender].field_0 += arg2
                                if not arg2 + userInfo[arg1][msg.sender].field_0:
                                    userInfo[arg1][msg.sender].field_256 = 0
                                else:
                                    if (arg2 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) / arg2 + userInfo[arg1][msg.sender].field_0 != poolInfo[arg1].field_768:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * _15426) + ceil32(return_data.size) + ceil32(return_data.size) + 1034 len 31]
                                    userInfo[arg1][msg.sender].field_256 = (arg2 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) / 10^12
                            else:
                                if not userInfo[arg1][msg.sender].field_0:
                                    if userInfo[arg1][msg.sender].field_256 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require ext_code.size(frogAddress)
                                    staticcall frogAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(frogAddress)
                                    if -userInfo[arg1][msg.sender].field_256 <= ext_call.return_data[0]:
                                        call frogAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, -userInfo[arg1][msg.sender].field_256
                                    else:
                                        call frogAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, ext_call.return_data[0]
                                else:
                                    if poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / userInfo[arg1][msg.sender].field_0 != poolInfo[arg1].field_768:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * _15426) + ceil32(return_data.size) + 837 len 31]
                                    if userInfo[arg1][msg.sender].field_256 > poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require ext_code.size(frogAddress)
                                    staticcall frogAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(frogAddress)
                                    if (poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12) - userInfo[arg1][msg.sender].field_256 <= ext_call.return_data[0]:
                                        call frogAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, (poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12) - userInfo[arg1][msg.sender].field_256
                                    else:
                                        call frogAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                    revert with 0, 'Address: call to non-contract'
                                if not ext_code.hash(poolInfo[arg1].field_0):
                                    revert with 0, 'Address: call to non-contract'
                                mem[(32 * _15426) + ceil32(return_data.size) + 1060 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg2) >> 32
                                mem[(32 * _15426) + ceil32(return_data.size) + 1184 len 4] = 0
                                call poolInfo[arg1].field_0 with:
                                     gas gas_remaining wei
                                    args Mask(224, 32, arg2) << 480, mem[(32 * _15426) + ceil32(return_data.size) + 1156 len 4]
                                if not return_data.size:
                                    require not ext_call.success
                                    revert with 'SafeMath: subtraction overflow'
                                mem[(32 * _15426) + ceil32(return_data.size) + 1092 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if return_data.size:
                                    require return_data.size >= 32
                                    if not mem[(32 * _15426) + ceil32(return_data.size) + 1092]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[(32 * _15426) + ceil32(return_data.size) + ceil32(return_data.size) + 1171 len 22]
                                if arg2 + userInfo[arg1][msg.sender].field_0 < userInfo[arg1][msg.sender].field_0:
                                    revert with 0, 'SafeMath: addition overflow'
                                userInfo[arg1][msg.sender].field_0 += arg2
                                if not arg2 + userInfo[arg1][msg.sender].field_0:
                                    userInfo[arg1][msg.sender].field_256 = 0
                                else:
                                    if (arg2 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) / arg2 + userInfo[arg1][msg.sender].field_0 != poolInfo[arg1].field_768:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * _15426) + ceil32(return_data.size) + ceil32(return_data.size) + 1162 len 31]
                                    userInfo[arg1][msg.sender].field_256 = (arg2 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) / 10^12
                        else:
                            if (block.number * frogPerBlock) - (poolInfo[arg1].field_512 * frogPerBlock) / block.number - poolInfo[arg1].field_512 != frogPerBlock:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                            if (block.number * frogPerBlock) - (poolInfo[arg1].field_512 * frogPerBlock):
                                if (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / (block.number * frogPerBlock) - (poolInfo[arg1].field_512 * frogPerBlock) != poolInfo[arg1].field_256:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                mem[352] = 26
                                mem[384] = 'SafeMath: division by zero'
                                if not totalAllocPoint:
                                    revert with 0, 'SafeMath: division by zero'
                                mem[416] = 26
                                mem[448] = 'SafeMath: division by zero'
                                if not 2^(block.number - startBlock / halvingPeriod):
                                    revert with 0, 'SafeMath: division by zero'
                                mem[480] = 26
                                mem[512] = 'SafeMath: division by zero'
                                require ext_code.size(frogAddress)
                                call frogAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args this.address, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod)
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(frogAddress)
                                call frogAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args this.address, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[544] = 2
                                mem[576] = frogAddress
                                mem[608] = wbnbAddress
                                if block.timestamp + 1800 < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[640] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                mem[644] = (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                                mem[676] = 0
                                mem[740] = fundsAddress
                                mem[772] = block.timestamp + 1800
                                mem[708] = 160
                                mem[804] = 2
                                mem[836 len 0] = None
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20, 0, 160, fundsAddress, block.timestamp + 1800, 2, mem[836 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[640 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(return_data.size) + 640
                                require return_data.size >= 32
                                _15265 = mem[640 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32
                                require mem[640 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 <= 4294967296
                                require mem[640 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 32 <= return_data.size
                                require mem[mem[640 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 640] <= 4294967296 and mem[640 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + (32 * mem[mem[640 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 640]) + 32 <= return_data.size
                                mem[ceil32(return_data.size) + 640] = mem[mem[640 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 640]
                                _15424 = mem[_15265 + 640]
                                mem[ceil32(return_data.size) + 672 len floor32(mem[_15265 + 640])] = mem[_15265 + 672 len floor32(mem[_15265 + 640])]
                                if not (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod):
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: division by zero'
                                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                else:
                                    if 10^12 * (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) != 10^12:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * _15424) + ceil32(return_data.size) + 773 len 31]
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: division by zero'
                                    if (10^12 * (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_768 += 10^12 * (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]
                                poolInfo[arg1].field_512 = block.number
                                if not userInfo[arg1][msg.sender].field_0:
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                        revert with 0, 'Address: call to non-contract'
                                    if not ext_code.hash(poolInfo[arg1].field_0):
                                        revert with 0, 'Address: call to non-contract'
                                    mem[(32 * _15424) + ceil32(return_data.size) + 932 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg2) >> 32
                                    mem[(32 * _15424) + ceil32(return_data.size) + 1056 len 4] = 0
                                    call poolInfo[arg1].field_0 with:
                                         gas gas_remaining wei
                                        args Mask(224, 32, arg2) << 480, mem[(32 * _15424) + ceil32(return_data.size) + 1028 len 4]
                                    if not return_data.size:
                                        require not ext_call.success
                                        revert with 'SafeMath: subtraction overflow'
                                    mem[(32 * _15424) + ceil32(return_data.size) + 964 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if not ext_call.success:
                                        if return_data.size:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if return_data.size:
                                        require return_data.size >= 32
                                        if not mem[(32 * _15424) + ceil32(return_data.size) + 964]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[(32 * _15424) + ceil32(return_data.size) + ceil32(return_data.size) + 1043 len 22]
                                    if arg2 + userInfo[arg1][msg.sender].field_0 < userInfo[arg1][msg.sender].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    userInfo[arg1][msg.sender].field_0 += arg2
                                    if not arg2 + userInfo[arg1][msg.sender].field_0:
                                        userInfo[arg1][msg.sender].field_256 = 0
                                    else:
                                        if (arg2 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) / arg2 + userInfo[arg1][msg.sender].field_0 != poolInfo[arg1].field_768:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * _15424) + ceil32(return_data.size) + ceil32(return_data.size) + 1034 len 31]
                                        userInfo[arg1][msg.sender].field_256 = (arg2 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) / 10^12
                                else:
                                    if not userInfo[arg1][msg.sender].field_0:
                                        if userInfo[arg1][msg.sender].field_256 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require ext_code.size(frogAddress)
                                        staticcall frogAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(frogAddress)
                                        if -userInfo[arg1][msg.sender].field_256 <= ext_call.return_data[0]:
                                            call frogAddress.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, -userInfo[arg1][msg.sender].field_256
                                        else:
                                            call frogAddress.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, ext_call.return_data[0]
                                    else:
                                        if poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / userInfo[arg1][msg.sender].field_0 != poolInfo[arg1].field_768:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * _15424) + ceil32(return_data.size) + 837 len 31]
                                        if userInfo[arg1][msg.sender].field_256 > poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require ext_code.size(frogAddress)
                                        staticcall frogAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(frogAddress)
                                        if (poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12) - userInfo[arg1][msg.sender].field_256 <= ext_call.return_data[0]:
                                            call frogAddress.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, (poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12) - userInfo[arg1][msg.sender].field_256
                                        else:
                                            call frogAddress.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                        revert with 0, 'Address: call to non-contract'
                                    if not ext_code.hash(poolInfo[arg1].field_0):
                                        revert with 0, 'Address: call to non-contract'
                                    mem[(32 * _15424) + ceil32(return_data.size) + 1060 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg2) >> 32
                                    mem[(32 * _15424) + ceil32(return_data.size) + 1184 len 4] = 0
                                    call poolInfo[arg1].field_0 with:
                                         gas gas_remaining wei
                                        args Mask(224, 32, arg2) << 480, mem[(32 * _15424) + ceil32(return_data.size) + 1156 len 4]
                                    if not return_data.size:
                                        require not ext_call.success
                                        revert with 'SafeMath: subtraction overflow'
                                    mem[(32 * _15424) + ceil32(return_data.size) + 1092 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    if not ext_call.success:
                                        if return_data.size:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        revert with 0, 'SafeERC20: low-level call failed'
                                    if return_data.size:
                                        require return_data.size >= 32
                                        if not mem[(32 * _15424) + ceil32(return_data.size) + 1092]:
                                            revert with 0, 
                                                        32,
                                                        42,
                                                        0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                        mem[(32 * _15424) + ceil32(return_data.size) + ceil32(return_data.size) + 1171 len 22]
                                    if arg2 + userInfo[arg1][msg.sender].field_0 < userInfo[arg1][msg.sender].field_0:
                                        revert with 0, 'SafeMath: addition overflow'
                                    userInfo[arg1][msg.sender].field_0 += arg2
                                    if not arg2 + userInfo[arg1][msg.sender].field_0:
                                        userInfo[arg1][msg.sender].field_256 = 0
                                    else:
                                        if (arg2 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) / arg2 + userInfo[arg1][msg.sender].field_0 != poolInfo[arg1].field_768:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * _15424) + ceil32(return_data.size) + ceil32(return_data.size) + 1162 len 31]
                                        userInfo[arg1][msg.sender].field_256 = (arg2 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) / 10^12
                            else:
                                mem[352] = 26
                                mem[384] = 'SafeMath: division by zero'
                                if not totalAllocPoint:
                                    revert with 0, 'SafeMath: division by zero'
                                mem[416] = 26
                                mem[448] = 'SafeMath: division by zero'
                                if not 2^(block.number - startBlock / halvingPeriod):
                                    revert with 0, 'SafeMath: division by zero'
                                mem[480] = 26
                                mem[512] = 'SafeMath: division by zero'
                                require ext_code.size(frogAddress)
                                call frogAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args this.address, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod)
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(frogAddress)
                                call frogAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args this.address, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[544] = 2
                                mem[576] = frogAddress
                                mem[608] = wbnbAddress
                                if block.timestamp + 1800 < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[640] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                mem[644] = 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                                mem[676] = 0
                                mem[740] = fundsAddress
                                mem[772] = block.timestamp + 1800
                                mem[708] = 160
                                mem[804] = 2
                                mem[836 len 0] = None
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20, 0, 160, fundsAddress, block.timestamp + 1800, 2, mem[836 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[640 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(return_data.size) + 640
                                require return_data.size >= 32
                                _15267 = mem[640 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32
                                require mem[640 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 <= 4294967296
                                require mem[640 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 32 <= return_data.size
                                require mem[mem[640 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 640] <= 4294967296 and mem[640 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + (32 * mem[mem[640 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 640]) + 32 <= return_data.size
                                mem[ceil32(return_data.size) + 640] = mem[mem[640 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 640]
                                _15425 = mem[_15267 + 640]
                                mem[ceil32(return_data.size) + 672 len floor32(mem[_15267 + 640])] = mem[_15267 + 672 len floor32(mem[_15267 + 640])]
                                if not 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod):
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: division by zero'
                                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                    poolInfo[arg1].field_512 = block.number
                                    if not userInfo[arg1][msg.sender].field_0:
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                            revert with 0, 'Address: call to non-contract'
                                        if not ext_code.hash(poolInfo[arg1].field_0):
                                            revert with 0, 'Address: call to non-contract'
                                        mem[(32 * _15425) + ceil32(return_data.size) + 932 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg2) >> 32
                                        mem[(32 * _15425) + ceil32(return_data.size) + 1056 len 4] = 0
                                        call poolInfo[arg1].field_0 with:
                                             gas gas_remaining wei
                                            args Mask(224, 32, arg2) << 480, mem[(32 * _15425) + ceil32(return_data.size) + 1028 len 4]
                                        if not return_data.size:
                                            require not ext_call.success
                                            revert with 'SafeMath: subtraction overflow'
                                        mem[(32 * _15425) + ceil32(return_data.size) + 964 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            if return_data.size:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if return_data.size:
                                            require return_data.size >= 32
                                            if not mem[(32 * _15425) + ceil32(return_data.size) + 964]:
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[(32 * _15425) + ceil32(return_data.size) + ceil32(return_data.size) + 1043 len 22]
                                        if arg2 + userInfo[arg1][msg.sender].field_0 < userInfo[arg1][msg.sender].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        userInfo[arg1][msg.sender].field_0 += arg2
                                        if not arg2 + userInfo[arg1][msg.sender].field_0:
                                            userInfo[arg1][msg.sender].field_256 = 0
                                        else:
                                            if (arg2 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) / arg2 + userInfo[arg1][msg.sender].field_0 != poolInfo[arg1].field_768:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * _15425) + ceil32(return_data.size) + ceil32(return_data.size) + 1034 len 31]
                                            userInfo[arg1][msg.sender].field_256 = (arg2 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) / 10^12
                                    else:
                                        if not userInfo[arg1][msg.sender].field_0:
                                            if userInfo[arg1][msg.sender].field_256 > 0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require ext_code.size(frogAddress)
                                            staticcall frogAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(frogAddress)
                                            if -userInfo[arg1][msg.sender].field_256 <= ext_call.return_data[0]:
                                                call frogAddress.0xa9059cbb with:
                                                     gas gas_remaining wei
                                                    args msg.sender, -userInfo[arg1][msg.sender].field_256
                                            else:
                                                call frogAddress.0xa9059cbb with:
                                                     gas gas_remaining wei
                                                    args msg.sender, ext_call.return_data[0]
                                        else:
                                            if poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / userInfo[arg1][msg.sender].field_0 != poolInfo[arg1].field_768:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * _15425) + ceil32(return_data.size) + 837 len 31]
                                            if userInfo[arg1][msg.sender].field_256 > poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require ext_code.size(frogAddress)
                                            staticcall frogAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(frogAddress)
                                            if (poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12) - userInfo[arg1][msg.sender].field_256 <= ext_call.return_data[0]:
                                                call frogAddress.0xa9059cbb with:
                                                     gas gas_remaining wei
                                                    args msg.sender, (poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12) - userInfo[arg1][msg.sender].field_256
                                            else:
                                                call frogAddress.0xa9059cbb with:
                                                     gas gas_remaining wei
                                                    args msg.sender, ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                            revert with 0, 'Address: call to non-contract'
                                        if not ext_code.hash(poolInfo[arg1].field_0):
                                            revert with 0, 'Address: call to non-contract'
                                        mem[(32 * _15425) + ceil32(return_data.size) + 1060 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg2) >> 32
                                        mem[(32 * _15425) + ceil32(return_data.size) + 1184 len 4] = 0
                                        call poolInfo[arg1].field_0 with:
                                             gas gas_remaining wei
                                            args Mask(224, 32, arg2) << 480, mem[(32 * _15425) + ceil32(return_data.size) + 1156 len 4]
                                        if not return_data.size:
                                            require not ext_call.success
                                            revert with 'SafeMath: subtraction overflow'
                                        mem[(32 * _15425) + ceil32(return_data.size) + 1092 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            if return_data.size:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if return_data.size:
                                            require return_data.size >= 32
                                            if not mem[(32 * _15425) + ceil32(return_data.size) + 1092]:
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[(32 * _15425) + ceil32(return_data.size) + ceil32(return_data.size) + 1171 len 22]
                                        if arg2 + userInfo[arg1][msg.sender].field_0 < userInfo[arg1][msg.sender].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        userInfo[arg1][msg.sender].field_0 += arg2
                                        if not arg2 + userInfo[arg1][msg.sender].field_0:
                                            userInfo[arg1][msg.sender].field_256 = 0
                                        else:
                                            if (arg2 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) / arg2 + userInfo[arg1][msg.sender].field_0 != poolInfo[arg1].field_768:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * _15425) + ceil32(return_data.size) + ceil32(return_data.size) + 1162 len 31]
                                            userInfo[arg1][msg.sender].field_256 = (arg2 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) / 10^12
                                else:
                                    if 10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) != 10^12:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * _15425) + ceil32(return_data.size) + 773 len 31]
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: division by zero'
                                    if (10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]
                                    poolInfo[arg1].field_512 = block.number
                                    if not userInfo[arg1][msg.sender].field_0:
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                            revert with 0, 'Address: call to non-contract'
                                        if not ext_code.hash(poolInfo[arg1].field_0):
                                            revert with 0, 'Address: call to non-contract'
                                        mem[(32 * _15425) + ceil32(return_data.size) + 932 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg2) >> 32
                                        mem[(32 * _15425) + ceil32(return_data.size) + 1056 len 4] = 0
                                        call poolInfo[arg1].field_0 with:
                                             gas gas_remaining wei
                                            args Mask(224, 32, arg2) << 480, mem[(32 * _15425) + ceil32(return_data.size) + 1028 len 4]
                                        if not return_data.size:
                                            require not ext_call.success
                                            revert with 'SafeMath: subtraction overflow'
                                        mem[(32 * _15425) + ceil32(return_data.size) + 964 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            if return_data.size:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if return_data.size:
                                            require return_data.size >= 32
                                            if not mem[(32 * _15425) + ceil32(return_data.size) + 964]:
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[(32 * _15425) + ceil32(return_data.size) + ceil32(return_data.size) + 1043 len 22]
                                        if arg2 + userInfo[arg1][msg.sender].field_0 < userInfo[arg1][msg.sender].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        userInfo[arg1][msg.sender].field_0 += arg2
                                        if not arg2 + userInfo[arg1][msg.sender].field_0:
                                            userInfo[arg1][msg.sender].field_256 = 0
                                        else:
                                            if (arg2 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) / arg2 + userInfo[arg1][msg.sender].field_0 != poolInfo[arg1].field_768:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * _15425) + ceil32(return_data.size) + ceil32(return_data.size) + 1034 len 31]
                                            userInfo[arg1][msg.sender].field_256 = (arg2 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) / 10^12
                                    else:
                                        if not userInfo[arg1][msg.sender].field_0:
                                            if userInfo[arg1][msg.sender].field_256 > 0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require ext_code.size(frogAddress)
                                            staticcall frogAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(frogAddress)
                                            if -userInfo[arg1][msg.sender].field_256 <= ext_call.return_data[0]:
                                                call frogAddress.0xa9059cbb with:
                                                     gas gas_remaining wei
                                                    args msg.sender, -userInfo[arg1][msg.sender].field_256
                                            else:
                                                call frogAddress.0xa9059cbb with:
                                                     gas gas_remaining wei
                                                    args msg.sender, ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                                revert with 0, 'Address: call to non-contract'
                                            if not ext_code.hash(poolInfo[arg1].field_0):
                                                revert with 0, 'Address: call to non-contract'
                                            mem[(32 * _15425) + ceil32(return_data.size) + 1060 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg2) >> 32
                                            mem[(32 * _15425) + ceil32(return_data.size) + 1184 len 4] = 0
                                        else:
                                            if poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / userInfo[arg1][msg.sender].field_0 != poolInfo[arg1].field_768:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * _15425) + ceil32(return_data.size) + 837 len 31]
                                            if userInfo[arg1][msg.sender].field_256 > poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            require ext_code.size(frogAddress)
                                            staticcall frogAddress.0x70a08231 with:
                                                    gas gas_remaining wei
                                                   args this.address
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            require ext_code.size(frogAddress)
                                            if (poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12) - userInfo[arg1][msg.sender].field_256 > ext_call.return_data[0]:
                                                call frogAddress.0xa9059cbb with:
                                                     gas gas_remaining wei
                                                    args msg.sender, ext_call.return_data[0]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                                    revert with 0, 'Address: call to non-contract'
                                                if not ext_code.hash(poolInfo[arg1].field_0):
                                                    revert with 0, 'Address: call to non-contract'
                                                mem[(32 * _15425) + ceil32(return_data.size) + 1060 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg2) >> 32
                                                mem[(32 * _15425) + ceil32(return_data.size) + 1184 len 4] = 0
                                            else:
                                                call frogAddress.0xa9059cbb with:
                                                     gas gas_remaining wei
                                                    args msg.sender, (poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12) - userInfo[arg1][msg.sender].field_256
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 32
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                                    revert with 0, 'Address: call to non-contract'
                                                if not ext_code.hash(poolInfo[arg1].field_0):
                                                    revert with 0, 'Address: call to non-contract'
                                                mem[(32 * _15425) + ceil32(return_data.size) + 1060 len 96] = unknown_0x23b872dd(?????), msg.sender, address(this.address), Mask(224, 32, arg2) >> 32
                                                mem[(32 * _15425) + ceil32(return_data.size) + 1184 len 4] = 0
                                                mem[(32 * _15425) + ceil32(return_data.size) + 1156 len 0] = 0
                                        call poolInfo[arg1].field_0 with:
                                             gas gas_remaining wei
                                            args Mask(224, 32, arg2) << 480, mem[(32 * _15425) + ceil32(return_data.size) + 1156 len 4]
                                        if not return_data.size:
                                            require not ext_call.success
                                            revert with 'SafeMath: subtraction overflow'
                                        mem[(32 * _15425) + ceil32(return_data.size) + 1092 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                        if not ext_call.success:
                                            if return_data.size:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            revert with 0, 'SafeERC20: low-level call failed'
                                        if return_data.size:
                                            require return_data.size >= 32
                                            if not mem[(32 * _15425) + ceil32(return_data.size) + 1092]:
                                                revert with 0, 
                                                            32,
                                                            42,
                                                            0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                            mem[(32 * _15425) + ceil32(return_data.size) + ceil32(return_data.size) + 1171 len 22]
                                        if arg2 + userInfo[arg1][msg.sender].field_0 < userInfo[arg1][msg.sender].field_0:
                                            revert with 0, 'SafeMath: addition overflow'
                                        userInfo[arg1][msg.sender].field_0 += arg2
                                        if not arg2 + userInfo[arg1][msg.sender].field_0:
                                            userInfo[arg1][msg.sender].field_256 = 0
                                        else:
                                            if (arg2 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) / arg2 + userInfo[arg1][msg.sender].field_0 != poolInfo[arg1].field_768:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * _15425) + ceil32(return_data.size) + ceil32(return_data.size) + 1162 len 31]
                                            userInfo[arg1][msg.sender].field_256 = (arg2 * poolInfo[arg1].field_768) + (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) / 10^12
    emit Deposit(arg2, msg.sender, arg1);
}

function withdraw(uint256 arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    require arg1 < poolInfo.length
    mem[32] = sha3(arg1, 9)
    if arg2 > userInfo[arg1][msg.sender].field_0:
        revert with 0, 'withdraw: not good'
    require arg1 < poolInfo.length
    mem[0] = 8
    if block.number <= poolInfo[arg1].field_512:
        if not userInfo[arg1][msg.sender].field_0:
            if userInfo[arg1][msg.sender].field_256 > 0:
                revert with 0, 'SafeMath: subtraction overflow'
            require ext_code.size(frogAddress)
            staticcall frogAddress.0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(frogAddress)
            if -userInfo[arg1][msg.sender].field_256 <= ext_call.return_data[0]:
                call frogAddress.0xa9059cbb with:
                     gas gas_remaining wei
                    args msg.sender, -userInfo[arg1][msg.sender].field_256
            else:
                call frogAddress.0xa9059cbb with:
                     gas gas_remaining wei
                    args msg.sender, ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if arg2 > userInfo[arg1][msg.sender].field_0:
                revert with 0, 'SafeMath: subtraction overflow'
            userInfo[arg1][msg.sender].field_0 -= arg2
            if userInfo[arg1][msg.sender].field_0 - arg2:
                if (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / userInfo[arg1][msg.sender].field_0 - arg2 != poolInfo[arg1].field_768:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                userInfo[arg1][msg.sender].field_256 = (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / 10^12
                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                    revert with 0, 'Address: call to non-contract'
                if not ext_code.hash(poolInfo[arg1].field_0):
                    revert with 0, 'Address: call to non-contract'
                mem[516 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
            else:
                userInfo[arg1][msg.sender].field_256 = 0
                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                    revert with 0, 'Address: call to non-contract'
                if not ext_code.hash(poolInfo[arg1].field_0):
                    revert with 0, 'Address: call to non-contract'
                mem[516 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                mem[580 len 0] = 0
        else:
            if poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / userInfo[arg1][msg.sender].field_0 != poolInfo[arg1].field_768:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if userInfo[arg1][msg.sender].field_256 > poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            require ext_code.size(frogAddress)
            staticcall frogAddress.0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(frogAddress)
            if (poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12) - userInfo[arg1][msg.sender].field_256 <= ext_call.return_data[0]:
                call frogAddress.0xa9059cbb with:
                     gas gas_remaining wei
                    args msg.sender, (poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12) - userInfo[arg1][msg.sender].field_256
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if arg2 > userInfo[arg1][msg.sender].field_0:
                    revert with 0, 'SafeMath: subtraction overflow'
                userInfo[arg1][msg.sender].field_0 -= arg2
                if userInfo[arg1][msg.sender].field_0 - arg2:
                    if (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / userInfo[arg1][msg.sender].field_0 - arg2 != poolInfo[arg1].field_768:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                    userInfo[arg1][msg.sender].field_256 = (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / 10^12
                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                        revert with 0, 'Address: call to non-contract'
                    if not ext_code.hash(poolInfo[arg1].field_0):
                        revert with 0, 'Address: call to non-contract'
                    mem[516 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                else:
                    userInfo[arg1][msg.sender].field_256 = 0
                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                        revert with 0, 'Address: call to non-contract'
                    if not ext_code.hash(poolInfo[arg1].field_0):
                        revert with 0, 'Address: call to non-contract'
                    mem[516 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                    mem[580 len 0] = 0
            else:
                call frogAddress.0xa9059cbb with:
                     gas gas_remaining wei
                    args msg.sender, ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if arg2 > userInfo[arg1][msg.sender].field_0:
                    revert with 0, 'SafeMath: subtraction overflow'
                userInfo[arg1][msg.sender].field_0 -= arg2
                if not userInfo[arg1][msg.sender].field_0 - arg2:
                    userInfo[arg1][msg.sender].field_256 = 0
                else:
                    if (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / userInfo[arg1][msg.sender].field_0 - arg2 != poolInfo[arg1].field_768:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                    userInfo[arg1][msg.sender].field_256 = (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / 10^12
                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                    revert with 0, 'Address: call to non-contract'
                if not ext_code.hash(poolInfo[arg1].field_0):
                    revert with 0, 'Address: call to non-contract'
                mem[516 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
        call poolInfo[arg1].field_0 with:
           funct uint32(msg.sender)
             gas gas_remaining wei
            args Mask(224, 32, arg2) << 224, mem[580 len 4]
        if not return_data.size:
            require not ext_call.success
            revert with 'SafeMath: division by zero'
        mem[548 len return_data.size] = ext_call.return_data[0 len return_data.size]
        if not ext_call.success:
            if return_data.size:
                revert with ext_call.return_data[0 len return_data.size]
            revert with 0, 'SafeERC20: low-level call failed'
        if return_data.size:
            require return_data.size >= 32
            if not mem[548]:
                revert with 0, 
                            32,
                            42,
                            0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                            mem[ceil32(return_data.size) + 627 len 22]
    else:
        require ext_code.size(poolInfo[arg1].field_0)
        staticcall poolInfo[arg1].field_0.0x70a08231 with:
                gas gas_remaining wei
               args this.address
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if not ext_call.return_data[0]:
            poolInfo[arg1].field_512 = block.number
            if not userInfo[arg1][msg.sender].field_0:
                if userInfo[arg1][msg.sender].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                require ext_code.size(frogAddress)
                staticcall frogAddress.0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_code.size(frogAddress)
                if -userInfo[arg1][msg.sender].field_256 <= ext_call.return_data[0]:
                    call frogAddress.0xa9059cbb with:
                         gas gas_remaining wei
                        args msg.sender, -userInfo[arg1][msg.sender].field_256
                else:
                    call frogAddress.0xa9059cbb with:
                         gas gas_remaining wei
                        args msg.sender, ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                if arg2 > userInfo[arg1][msg.sender].field_0:
                    revert with 0, 'SafeMath: subtraction overflow'
                userInfo[arg1][msg.sender].field_0 -= arg2
                if not userInfo[arg1][msg.sender].field_0 - arg2:
                    userInfo[arg1][msg.sender].field_256 = 0
                else:
                    if (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / userInfo[arg1][msg.sender].field_0 - arg2 != poolInfo[arg1].field_768:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                    userInfo[arg1][msg.sender].field_256 = (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / 10^12
                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                    revert with 0, 'Address: call to non-contract'
                if not ext_code.hash(poolInfo[arg1].field_0):
                    revert with 0, 'Address: call to non-contract'
                mem[516 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
            else:
                if poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / userInfo[arg1][msg.sender].field_0 != poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][msg.sender].field_256 > poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                require ext_code.size(frogAddress)
                staticcall frogAddress.0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_code.size(frogAddress)
                if (poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12) - userInfo[arg1][msg.sender].field_256 <= ext_call.return_data[0]:
                    call frogAddress.0xa9059cbb with:
                         gas gas_remaining wei
                        args msg.sender, (poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12) - userInfo[arg1][msg.sender].field_256
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if arg2 > userInfo[arg1][msg.sender].field_0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    userInfo[arg1][msg.sender].field_0 -= arg2
                    if not userInfo[arg1][msg.sender].field_0 - arg2:
                        userInfo[arg1][msg.sender].field_256 = 0
                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                            revert with 0, 'Address: call to non-contract'
                        if not ext_code.hash(poolInfo[arg1].field_0):
                            revert with 0, 'Address: call to non-contract'
                        mem[516 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                    else:
                        if (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / userInfo[arg1][msg.sender].field_0 - arg2 != poolInfo[arg1].field_768:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                        userInfo[arg1][msg.sender].field_256 = (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / 10^12
                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                            revert with 0, 'Address: call to non-contract'
                        if not ext_code.hash(poolInfo[arg1].field_0):
                            revert with 0, 'Address: call to non-contract'
                        mem[516 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                        mem[580 len 0] = 0
                else:
                    call frogAddress.0xa9059cbb with:
                         gas gas_remaining wei
                        args msg.sender, ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require return_data.size >= 32
                    if arg2 > userInfo[arg1][msg.sender].field_0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    userInfo[arg1][msg.sender].field_0 -= arg2
                    if not userInfo[arg1][msg.sender].field_0 - arg2:
                        userInfo[arg1][msg.sender].field_256 = 0
                    else:
                        if (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / userInfo[arg1][msg.sender].field_0 - arg2 != poolInfo[arg1].field_768:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                        userInfo[arg1][msg.sender].field_256 = (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / 10^12
                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                        revert with 0, 'Address: call to non-contract'
                    if not ext_code.hash(poolInfo[arg1].field_0):
                        revert with 0, 'Address: call to non-contract'
                    mem[516 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                    mem[580 len 0] = 0
            call poolInfo[arg1].field_0 with:
               funct uint32(msg.sender)
                 gas gas_remaining wei
                args Mask(224, 32, arg2) << 224, mem[580 len 4]
            if not return_data.size:
                require not ext_call.success
                revert with 'SafeMath: division by zero'
            mem[548 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not ext_call.success:
                if return_data.size:
                    revert with ext_call.return_data[0 len return_data.size]
                revert with 0, 'SafeERC20: low-level call failed'
            if return_data.size:
                require return_data.size >= 32
                if not mem[548]:
                    revert with 0, 
                                32,
                                42,
                                0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                mem[ceil32(return_data.size) + 627 len 22]
        else:
            mem[96] = 30
            mem[128] = 'SafeMath: subtraction overflow'
            if block.number <= bonusEndBlock:
                if poolInfo[arg1].field_512 > block.number:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not block.number - poolInfo[arg1].field_512:
                    mem[160] = 30
                    mem[192] = 'SafeMath: subtraction overflow'
                    if startBlock > block.number:
                        revert with 0, 'SafeMath: subtraction overflow'
                    mem[224] = 26
                    mem[256] = 'SafeMath: division by zero'
                    if not halvingPeriod:
                        revert with 0, 'SafeMath: division by zero'
                    mem[288] = 26
                    mem[320] = 'SafeMath: division by zero'
                    if not totalAllocPoint:
                        revert with 0, 'SafeMath: division by zero'
                    mem[352] = 26
                    mem[384] = 'SafeMath: division by zero'
                    if not 2^(block.number - startBlock / halvingPeriod):
                        revert with 0, 'SafeMath: division by zero'
                    mem[416] = 26
                    mem[448] = 'SafeMath: division by zero'
                    require ext_code.size(frogAddress)
                    call frogAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args this.address, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod)
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    require ext_code.size(frogAddress)
                    call frogAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args this.address, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[480] = 2
                    mem[512] = frogAddress
                    mem[544] = wbnbAddress
                    if block.timestamp + 1800 < block.timestamp:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[576] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                    mem[580] = 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                    mem[612] = 0
                    mem[676] = fundsAddress
                    mem[708] = block.timestamp + 1800
                    mem[644] = 160
                    mem[740] = 2
                    mem[772 len 0] = None
                    require ext_code.size(routerAddress)
                    call routerAddress.swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                         gas gas_remaining wei
                        args 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20, 0, 160, fundsAddress, block.timestamp + 1800, 2, mem[772 len 64]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[576 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    mem[64] = ceil32(return_data.size) + 576
                    require return_data.size >= 32
                    _17173 = mem[576 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32
                    require mem[576 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 <= 4294967296
                    require mem[576 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 32 <= return_data.size
                    require mem[mem[576 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 576] <= 4294967296 and mem[576 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + (32 * mem[mem[576 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 576]) + 32 <= return_data.size
                    mem[ceil32(return_data.size) + 576] = mem[mem[576 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 576]
                    _17392 = mem[_17173 + 576]
                    mem[ceil32(return_data.size) + 608 len floor32(mem[_17173 + 576])] = mem[_17173 + 608 len floor32(mem[_17173 + 576])]
                    if not 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod):
                        if not ext_call.return_data[0]:
                            revert with 0, 'SafeMath: division by zero'
                        if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[arg1].field_512 = block.number
                        if not userInfo[arg1][msg.sender].field_0:
                            if userInfo[arg1][msg.sender].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            require ext_code.size(frogAddress)
                            staticcall frogAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_code.size(frogAddress)
                            if -userInfo[arg1][msg.sender].field_256 <= ext_call.return_data[0]:
                                call frogAddress.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, -userInfo[arg1][msg.sender].field_256
                            else:
                                call frogAddress.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if arg2 > userInfo[arg1][msg.sender].field_0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            userInfo[arg1][msg.sender].field_0 -= arg2
                            if not userInfo[arg1][msg.sender].field_0 - arg2:
                                userInfo[arg1][msg.sender].field_256 = 0
                            else:
                                if (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / userInfo[arg1][msg.sender].field_0 - arg2 != poolInfo[arg1].field_768:
                                    revert with 0, 
                                                32,
                                                33,
                                                0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[(32 * _17392) + ceil32(return_data.size) + 965 len 31]
                                userInfo[arg1][msg.sender].field_256 = (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / 10^12
                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                revert with 0, 'Address: call to non-contract'
                            if not ext_code.hash(poolInfo[arg1].field_0):
                                revert with 0, 'Address: call to non-contract'
                            mem[(32 * _17392) + ceil32(return_data.size) + 1092 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                        else:
                            if poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / userInfo[arg1][msg.sender].field_0 != poolInfo[arg1].field_768:
                                revert with 0, 
                                            32,
                                            33,
                                            0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[(32 * _17392) + ceil32(return_data.size) + 773 len 31]
                            if userInfo[arg1][msg.sender].field_256 > poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            require ext_code.size(frogAddress)
                            staticcall frogAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_code.size(frogAddress)
                            if (poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12) - userInfo[arg1][msg.sender].field_256 <= ext_call.return_data[0]:
                                call frogAddress.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, (poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12) - userInfo[arg1][msg.sender].field_256
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if arg2 > userInfo[arg1][msg.sender].field_0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                userInfo[arg1][msg.sender].field_0 -= arg2
                                if not userInfo[arg1][msg.sender].field_0 - arg2:
                                    userInfo[arg1][msg.sender].field_256 = 0
                                else:
                                    if (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / userInfo[arg1][msg.sender].field_0 - arg2 != poolInfo[arg1].field_768:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * _17392) + ceil32(return_data.size) + 965 len 31]
                                    userInfo[arg1][msg.sender].field_256 = (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / 10^12
                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                    revert with 0, 'Address: call to non-contract'
                                if not ext_code.hash(poolInfo[arg1].field_0):
                                    revert with 0, 'Address: call to non-contract'
                                mem[(32 * _17392) + ceil32(return_data.size) + 1092 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                            else:
                                call frogAddress.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if arg2 > userInfo[arg1][msg.sender].field_0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                userInfo[arg1][msg.sender].field_0 -= arg2
                                if userInfo[arg1][msg.sender].field_0 - arg2:
                                    if (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / userInfo[arg1][msg.sender].field_0 - arg2 != poolInfo[arg1].field_768:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * _17392) + ceil32(return_data.size) + 965 len 31]
                                    userInfo[arg1][msg.sender].field_256 = (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / 10^12
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                        revert with 0, 'Address: call to non-contract'
                                    if not ext_code.hash(poolInfo[arg1].field_0):
                                        revert with 0, 'Address: call to non-contract'
                                    mem[(32 * _17392) + ceil32(return_data.size) + 1092 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                                else:
                                    userInfo[arg1][msg.sender].field_256 = 0
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                        revert with 0, 'Address: call to non-contract'
                                    if not ext_code.hash(poolInfo[arg1].field_0):
                                        revert with 0, 'Address: call to non-contract'
                                    mem[(32 * _17392) + ceil32(return_data.size) + 1092 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                                    mem[(32 * _17392) + ceil32(return_data.size) + 1156 len 0] = 0
                    else:
                        if 10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) != 10^12:
                            revert with 0, 
                                        32,
                                        33,
                                        0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                        mem[(32 * _17392) + ceil32(return_data.size) + 709 len 31]
                        if not ext_call.return_data[0]:
                            revert with 0, 'SafeMath: division by zero'
                        if (10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]
                        poolInfo[arg1].field_512 = block.number
                        if not userInfo[arg1][msg.sender].field_0:
                            if userInfo[arg1][msg.sender].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            require ext_code.size(frogAddress)
                            staticcall frogAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_code.size(frogAddress)
                            if -userInfo[arg1][msg.sender].field_256 <= ext_call.return_data[0]:
                                call frogAddress.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, -userInfo[arg1][msg.sender].field_256
                            else:
                                call frogAddress.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, ext_call.return_data[0]
                        else:
                            if poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / userInfo[arg1][msg.sender].field_0 != poolInfo[arg1].field_768:
                                revert with 0, 
                                            32,
                                            33,
                                            0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[(32 * _17392) + ceil32(return_data.size) + 773 len 31]
                            if userInfo[arg1][msg.sender].field_256 > poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            require ext_code.size(frogAddress)
                            staticcall frogAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_code.size(frogAddress)
                            if (poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12) - userInfo[arg1][msg.sender].field_256 <= ext_call.return_data[0]:
                                call frogAddress.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, (poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12) - userInfo[arg1][msg.sender].field_256
                            else:
                                call frogAddress.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if arg2 > userInfo[arg1][msg.sender].field_0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        userInfo[arg1][msg.sender].field_0 -= arg2
                        if not userInfo[arg1][msg.sender].field_0 - arg2:
                            userInfo[arg1][msg.sender].field_256 = 0
                        else:
                            if (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / userInfo[arg1][msg.sender].field_0 - arg2 != poolInfo[arg1].field_768:
                                revert with 0, 
                                            32,
                                            33,
                                            0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[(32 * _17392) + ceil32(return_data.size) + 965 len 31]
                            userInfo[arg1][msg.sender].field_256 = (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / 10^12
                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                            revert with 0, 'Address: call to non-contract'
                        if not ext_code.hash(poolInfo[arg1].field_0):
                            revert with 0, 'Address: call to non-contract'
                        mem[(32 * _17392) + ceil32(return_data.size) + 1092 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                    call poolInfo[arg1].field_0 with:
                       funct uint32(msg.sender)
                         gas gas_remaining wei
                        args Mask(224, 32, arg2) << 224, mem[(32 * _17392) + ceil32(return_data.size) + 1156 len 4]
                    if not return_data.size:
                        require not ext_call.success
                        revert with 'SafeMath: subtraction overflow'
                    mem[(32 * _17392) + ceil32(return_data.size) + 1124 len return_data.size] = ext_call.return_data[0 len return_data.size]
                    if not ext_call.success:
                        if return_data.size:
                            revert with ext_call.return_data[0 len return_data.size]
                        revert with 0, 'SafeERC20: low-level call failed'
                    if return_data.size:
                        require return_data.size >= 32
                        if not mem[(32 * _17392) + ceil32(return_data.size) + 1124]:
                            revert with 0, 
                                        32,
                                        42,
                                        0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                        mem[(32 * _17392) + ceil32(return_data.size) + ceil32(return_data.size) + 1203 len 22]
                else:
                    if block.number - poolInfo[arg1].field_512 / block.number - poolInfo[arg1].field_512 != 1:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                    mem[160] = 30
                    mem[192] = 'SafeMath: subtraction overflow'
                    if startBlock > block.number:
                        revert with 0, 'SafeMath: subtraction overflow'
                    mem[224] = 26
                    mem[256] = 'SafeMath: division by zero'
                    if not halvingPeriod:
                        revert with 0, 'SafeMath: division by zero'
                    if not block.number - poolInfo[arg1].field_512:
                        mem[288] = 26
                        mem[320] = 'SafeMath: division by zero'
                        if not totalAllocPoint:
                            revert with 0, 'SafeMath: division by zero'
                        mem[352] = 26
                        mem[384] = 'SafeMath: division by zero'
                        if not 2^(block.number - startBlock / halvingPeriod):
                            revert with 0, 'SafeMath: division by zero'
                        mem[416] = 26
                        mem[448] = 'SafeMath: division by zero'
                        require ext_code.size(frogAddress)
                        call frogAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args this.address, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod)
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require ext_code.size(frogAddress)
                        call frogAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args this.address, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[480] = 2
                        mem[512] = frogAddress
                        mem[544] = wbnbAddress
                        if block.timestamp + 1800 < block.timestamp:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[576] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                        mem[580] = 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                        mem[612] = 0
                        mem[676] = fundsAddress
                        mem[708] = block.timestamp + 1800
                        mem[644] = 160
                        mem[740] = 2
                        mem[772 len 0] = None
                        require ext_code.size(routerAddress)
                        call routerAddress.swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                             gas gas_remaining wei
                            args 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20, 0, 160, fundsAddress, block.timestamp + 1800, 2, mem[772 len 64]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[576 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = ceil32(return_data.size) + 576
                        require return_data.size >= 32
                        _17171 = mem[576 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32
                        require mem[576 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 <= 4294967296
                        require mem[576 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 32 <= return_data.size
                        require mem[mem[576 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 576] <= 4294967296 and mem[576 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + (32 * mem[mem[576 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 576]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 576] = mem[mem[576 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 576]
                        _17391 = mem[_17171 + 576]
                        mem[ceil32(return_data.size) + 608 len floor32(mem[_17171 + 576])] = mem[_17171 + 608 len floor32(mem[_17171 + 576])]
                        if 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod):
                            if 10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) != 10^12:
                                revert with 0, 
                                            32,
                                            33,
                                            0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[(32 * _17391) + ceil32(return_data.size) + 709 len 31]
                            if not ext_call.return_data[0]:
                                revert with 0, 'SafeMath: division by zero'
                            if (10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]
                            poolInfo[arg1].field_512 = block.number
                            if userInfo[arg1][msg.sender].field_0:
                                if poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / userInfo[arg1][msg.sender].field_0 != poolInfo[arg1].field_768:
                                    revert with 0, 
                                                32,
                                                33,
                                                0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[(32 * _17391) + ceil32(return_data.size) + 773 len 31]
                                if userInfo[arg1][msg.sender].field_256 > poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                require ext_code.size(frogAddress)
                                staticcall frogAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(frogAddress)
                                if (poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12) - userInfo[arg1][msg.sender].field_256 <= ext_call.return_data[0]:
                                    call frogAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, (poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12) - userInfo[arg1][msg.sender].field_256
                                else:
                                    call frogAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if arg2 > userInfo[arg1][msg.sender].field_0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                userInfo[arg1][msg.sender].field_0 -= arg2
                                if not userInfo[arg1][msg.sender].field_0 - arg2:
                                    userInfo[arg1][msg.sender].field_256 = 0
                                else:
                                    if (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / userInfo[arg1][msg.sender].field_0 - arg2 != poolInfo[arg1].field_768:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * _17391) + ceil32(return_data.size) + 965 len 31]
                                    userInfo[arg1][msg.sender].field_256 = (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / 10^12
                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                    revert with 0, 'Address: call to non-contract'
                                if not ext_code.hash(poolInfo[arg1].field_0):
                                    revert with 0, 'Address: call to non-contract'
                                mem[(32 * _17391) + ceil32(return_data.size) + 1092 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                            else:
                                if userInfo[arg1][msg.sender].field_256 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                require ext_code.size(frogAddress)
                                staticcall frogAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(frogAddress)
                                if -userInfo[arg1][msg.sender].field_256 > ext_call.return_data[0]:
                                    call frogAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if arg2 > userInfo[arg1][msg.sender].field_0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    userInfo[arg1][msg.sender].field_0 -= arg2
                                    if not userInfo[arg1][msg.sender].field_0 - arg2:
                                        userInfo[arg1][msg.sender].field_256 = 0
                                    else:
                                        if (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / userInfo[arg1][msg.sender].field_0 - arg2 != poolInfo[arg1].field_768:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * _17391) + ceil32(return_data.size) + 965 len 31]
                                        userInfo[arg1][msg.sender].field_256 = (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / 10^12
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                        revert with 0, 'Address: call to non-contract'
                                    if not ext_code.hash(poolInfo[arg1].field_0):
                                        revert with 0, 'Address: call to non-contract'
                                    mem[(32 * _17391) + ceil32(return_data.size) + 1092 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                                else:
                                    call frogAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, -userInfo[arg1][msg.sender].field_256
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if arg2 > userInfo[arg1][msg.sender].field_0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    userInfo[arg1][msg.sender].field_0 -= arg2
                                    if not userInfo[arg1][msg.sender].field_0 - arg2:
                                        userInfo[arg1][msg.sender].field_256 = 0
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                            revert with 0, 'Address: call to non-contract'
                                        if not ext_code.hash(poolInfo[arg1].field_0):
                                            revert with 0, 'Address: call to non-contract'
                                        mem[(32 * _17391) + ceil32(return_data.size) + 1092 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                                    else:
                                        if (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / userInfo[arg1][msg.sender].field_0 - arg2 != poolInfo[arg1].field_768:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * _17391) + ceil32(return_data.size) + 965 len 31]
                                        userInfo[arg1][msg.sender].field_256 = (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / 10^12
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                            revert with 0, 'Address: call to non-contract'
                                        if not ext_code.hash(poolInfo[arg1].field_0):
                                            revert with 0, 'Address: call to non-contract'
                                        mem[(32 * _17391) + ceil32(return_data.size) + 1092 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                                        mem[(32 * _17391) + ceil32(return_data.size) + 1156 len 0] = 0
                        else:
                            if not ext_call.return_data[0]:
                                revert with 0, 'SafeMath: division by zero'
                            if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[arg1].field_512 = block.number
                            if not userInfo[arg1][msg.sender].field_0:
                                if userInfo[arg1][msg.sender].field_256 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                require ext_code.size(frogAddress)
                                staticcall frogAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(frogAddress)
                                if -userInfo[arg1][msg.sender].field_256 <= ext_call.return_data[0]:
                                    call frogAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, -userInfo[arg1][msg.sender].field_256
                                else:
                                    call frogAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if arg2 > userInfo[arg1][msg.sender].field_0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                userInfo[arg1][msg.sender].field_0 -= arg2
                                if not userInfo[arg1][msg.sender].field_0 - arg2:
                                    userInfo[arg1][msg.sender].field_256 = 0
                                else:
                                    if (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / userInfo[arg1][msg.sender].field_0 - arg2 != poolInfo[arg1].field_768:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * _17391) + ceil32(return_data.size) + 965 len 31]
                                    userInfo[arg1][msg.sender].field_256 = (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / 10^12
                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                    revert with 0, 'Address: call to non-contract'
                                if not ext_code.hash(poolInfo[arg1].field_0):
                                    revert with 0, 'Address: call to non-contract'
                                mem[(32 * _17391) + ceil32(return_data.size) + 1092 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                            else:
                                if poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / userInfo[arg1][msg.sender].field_0 != poolInfo[arg1].field_768:
                                    revert with 0, 
                                                32,
                                                33,
                                                0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[(32 * _17391) + ceil32(return_data.size) + 773 len 31]
                                if userInfo[arg1][msg.sender].field_256 > poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                require ext_code.size(frogAddress)
                                staticcall frogAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(frogAddress)
                                if (poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12) - userInfo[arg1][msg.sender].field_256 > ext_call.return_data[0]:
                                    call frogAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if arg2 > userInfo[arg1][msg.sender].field_0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    userInfo[arg1][msg.sender].field_0 -= arg2
                                    if not userInfo[arg1][msg.sender].field_0 - arg2:
                                        userInfo[arg1][msg.sender].field_256 = 0
                                    else:
                                        if (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / userInfo[arg1][msg.sender].field_0 - arg2 != poolInfo[arg1].field_768:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * _17391) + ceil32(return_data.size) + 965 len 31]
                                        userInfo[arg1][msg.sender].field_256 = (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / 10^12
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                        revert with 0, 'Address: call to non-contract'
                                    if not ext_code.hash(poolInfo[arg1].field_0):
                                        revert with 0, 'Address: call to non-contract'
                                    mem[(32 * _17391) + ceil32(return_data.size) + 1092 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                                else:
                                    call frogAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, (poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12) - userInfo[arg1][msg.sender].field_256
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if arg2 > userInfo[arg1][msg.sender].field_0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    userInfo[arg1][msg.sender].field_0 -= arg2
                                    if not userInfo[arg1][msg.sender].field_0 - arg2:
                                        userInfo[arg1][msg.sender].field_256 = 0
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                            revert with 0, 'Address: call to non-contract'
                                        if not ext_code.hash(poolInfo[arg1].field_0):
                                            revert with 0, 'Address: call to non-contract'
                                        mem[(32 * _17391) + ceil32(return_data.size) + 1092 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                                    else:
                                        if (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / userInfo[arg1][msg.sender].field_0 - arg2 != poolInfo[arg1].field_768:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * _17391) + ceil32(return_data.size) + 965 len 31]
                                        userInfo[arg1][msg.sender].field_256 = (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / 10^12
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                            revert with 0, 'Address: call to non-contract'
                                        if not ext_code.hash(poolInfo[arg1].field_0):
                                            revert with 0, 'Address: call to non-contract'
                                        mem[(32 * _17391) + ceil32(return_data.size) + 1092 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                                        mem[(32 * _17391) + ceil32(return_data.size) + 1156 len 0] = 0
                        call poolInfo[arg1].field_0 with:
                           funct uint32(msg.sender)
                             gas gas_remaining wei
                            args Mask(224, 32, arg2) << 224, mem[(32 * _17391) + ceil32(return_data.size) + 1156 len 4]
                        if not return_data.size:
                            require not ext_call.success
                            revert with 'SafeMath: subtraction overflow'
                        mem[(32 * _17391) + ceil32(return_data.size) + 1124 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if return_data.size:
                            require return_data.size >= 32
                            if not mem[(32 * _17391) + ceil32(return_data.size) + 1124]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[(32 * _17391) + ceil32(return_data.size) + ceil32(return_data.size) + 1203 len 22]
                    else:
                        if (block.number * frogPerBlock) - (poolInfo[arg1].field_512 * frogPerBlock) / block.number - poolInfo[arg1].field_512 != frogPerBlock:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                        if not (block.number * frogPerBlock) - (poolInfo[arg1].field_512 * frogPerBlock):
                            mem[288] = 26
                            mem[320] = 'SafeMath: division by zero'
                            if not totalAllocPoint:
                                revert with 0, 'SafeMath: division by zero'
                            mem[352] = 26
                            mem[384] = 'SafeMath: division by zero'
                            if not 2^(block.number - startBlock / halvingPeriod):
                                revert with 0, 'SafeMath: division by zero'
                            mem[416] = 26
                            mem[448] = 'SafeMath: division by zero'
                            require ext_code.size(frogAddress)
                            call frogAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args this.address, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod)
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(frogAddress)
                            call frogAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args this.address, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[480] = 2
                            mem[512] = frogAddress
                            mem[544] = wbnbAddress
                            if block.timestamp + 1800 < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[576] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                            mem[580] = 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                            mem[612] = 0
                            mem[676] = fundsAddress
                            mem[708] = block.timestamp + 1800
                            mem[644] = 160
                            mem[740] = 2
                            mem[772 len 0] = None
                            require ext_code.size(routerAddress)
                            call routerAddress.swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20, 0, 160, fundsAddress, block.timestamp + 1800, 2, mem[772 len 64]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[576 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = ceil32(return_data.size) + 576
                            require return_data.size >= 32
                            _17169 = mem[576 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32
                            require mem[576 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 <= 4294967296
                            require mem[576 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 32 <= return_data.size
                            require mem[mem[576 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 576] <= 4294967296 and mem[576 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + (32 * mem[mem[576 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 576]) + 32 <= return_data.size
                            mem[ceil32(return_data.size) + 576] = mem[mem[576 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 576]
                            _17390 = mem[_17169 + 576]
                            mem[ceil32(return_data.size) + 608 len floor32(mem[_17169 + 576])] = mem[_17169 + 608 len floor32(mem[_17169 + 576])]
                            if not 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod):
                                if not ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: division by zero'
                                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[arg1].field_512 = block.number
                                if not userInfo[arg1][msg.sender].field_0:
                                    if userInfo[arg1][msg.sender].field_256 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require ext_code.size(frogAddress)
                                    staticcall frogAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(frogAddress)
                                    if -userInfo[arg1][msg.sender].field_256 <= ext_call.return_data[0]:
                                        call frogAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, -userInfo[arg1][msg.sender].field_256
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if arg2 > userInfo[arg1][msg.sender].field_0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        userInfo[arg1][msg.sender].field_0 -= arg2
                                        if userInfo[arg1][msg.sender].field_0 - arg2:
                                            if (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / userInfo[arg1][msg.sender].field_0 - arg2 != poolInfo[arg1].field_768:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * _17390) + ceil32(return_data.size) + 965 len 31]
                                            userInfo[arg1][msg.sender].field_256 = (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / 10^12
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                                revert with 0, 'Address: call to non-contract'
                                            if not ext_code.hash(poolInfo[arg1].field_0):
                                                revert with 0, 'Address: call to non-contract'
                                            mem[(32 * _17390) + ceil32(return_data.size) + 1092 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                                        else:
                                            userInfo[arg1][msg.sender].field_256 = 0
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                                revert with 0, 'Address: call to non-contract'
                                            if not ext_code.hash(poolInfo[arg1].field_0):
                                                revert with 0, 'Address: call to non-contract'
                                            mem[(32 * _17390) + ceil32(return_data.size) + 1092 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                                            mem[(32 * _17390) + ceil32(return_data.size) + 1156 len 0] = 0
                                    else:
                                        call frogAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if arg2 > userInfo[arg1][msg.sender].field_0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        userInfo[arg1][msg.sender].field_0 -= arg2
                                        if not userInfo[arg1][msg.sender].field_0 - arg2:
                                            userInfo[arg1][msg.sender].field_256 = 0
                                        else:
                                            if (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / userInfo[arg1][msg.sender].field_0 - arg2 != poolInfo[arg1].field_768:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * _17390) + ceil32(return_data.size) + 965 len 31]
                                            userInfo[arg1][msg.sender].field_256 = (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / 10^12
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                            revert with 0, 'Address: call to non-contract'
                                        if not ext_code.hash(poolInfo[arg1].field_0):
                                            revert with 0, 'Address: call to non-contract'
                                        mem[(32 * _17390) + ceil32(return_data.size) + 1092 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                                else:
                                    if poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / userInfo[arg1][msg.sender].field_0 != poolInfo[arg1].field_768:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * _17390) + ceil32(return_data.size) + 773 len 31]
                                    if userInfo[arg1][msg.sender].field_256 > poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require ext_code.size(frogAddress)
                                    staticcall frogAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(frogAddress)
                                    if (poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12) - userInfo[arg1][msg.sender].field_256 <= ext_call.return_data[0]:
                                        call frogAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, (poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12) - userInfo[arg1][msg.sender].field_256
                                    else:
                                        call frogAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if arg2 > userInfo[arg1][msg.sender].field_0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    userInfo[arg1][msg.sender].field_0 -= arg2
                                    if not userInfo[arg1][msg.sender].field_0 - arg2:
                                        userInfo[arg1][msg.sender].field_256 = 0
                                    else:
                                        if (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / userInfo[arg1][msg.sender].field_0 - arg2 != poolInfo[arg1].field_768:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * _17390) + ceil32(return_data.size) + 965 len 31]
                                        userInfo[arg1][msg.sender].field_256 = (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / 10^12
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                        revert with 0, 'Address: call to non-contract'
                                    if not ext_code.hash(poolInfo[arg1].field_0):
                                        revert with 0, 'Address: call to non-contract'
                                    mem[(32 * _17390) + ceil32(return_data.size) + 1092 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                            else:
                                if 10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) != 10^12:
                                    revert with 0, 
                                                32,
                                                33,
                                                0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[(32 * _17390) + ceil32(return_data.size) + 709 len 31]
                                if not ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: division by zero'
                                if (10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]
                                poolInfo[arg1].field_512 = block.number
                                if not userInfo[arg1][msg.sender].field_0:
                                    if userInfo[arg1][msg.sender].field_256 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require ext_code.size(frogAddress)
                                    staticcall frogAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(frogAddress)
                                    if -userInfo[arg1][msg.sender].field_256 <= ext_call.return_data[0]:
                                        call frogAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, -userInfo[arg1][msg.sender].field_256
                                    else:
                                        call frogAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if arg2 > userInfo[arg1][msg.sender].field_0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    userInfo[arg1][msg.sender].field_0 -= arg2
                                    if not userInfo[arg1][msg.sender].field_0 - arg2:
                                        userInfo[arg1][msg.sender].field_256 = 0
                                    else:
                                        if (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / userInfo[arg1][msg.sender].field_0 - arg2 != poolInfo[arg1].field_768:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * _17390) + ceil32(return_data.size) + 965 len 31]
                                        userInfo[arg1][msg.sender].field_256 = (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / 10^12
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                        revert with 0, 'Address: call to non-contract'
                                    if not ext_code.hash(poolInfo[arg1].field_0):
                                        revert with 0, 'Address: call to non-contract'
                                    mem[(32 * _17390) + ceil32(return_data.size) + 1092 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                                else:
                                    if poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / userInfo[arg1][msg.sender].field_0 != poolInfo[arg1].field_768:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * _17390) + ceil32(return_data.size) + 773 len 31]
                                    if userInfo[arg1][msg.sender].field_256 > poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require ext_code.size(frogAddress)
                                    staticcall frogAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(frogAddress)
                                    if (poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12) - userInfo[arg1][msg.sender].field_256 <= ext_call.return_data[0]:
                                        call frogAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, (poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12) - userInfo[arg1][msg.sender].field_256
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if arg2 > userInfo[arg1][msg.sender].field_0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        userInfo[arg1][msg.sender].field_0 -= arg2
                                        if userInfo[arg1][msg.sender].field_0 - arg2:
                                            if (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / userInfo[arg1][msg.sender].field_0 - arg2 != poolInfo[arg1].field_768:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * _17390) + ceil32(return_data.size) + 965 len 31]
                                            userInfo[arg1][msg.sender].field_256 = (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / 10^12
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                                revert with 0, 'Address: call to non-contract'
                                            if not ext_code.hash(poolInfo[arg1].field_0):
                                                revert with 0, 'Address: call to non-contract'
                                            mem[(32 * _17390) + ceil32(return_data.size) + 1092 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                                        else:
                                            userInfo[arg1][msg.sender].field_256 = 0
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                                revert with 0, 'Address: call to non-contract'
                                            if not ext_code.hash(poolInfo[arg1].field_0):
                                                revert with 0, 'Address: call to non-contract'
                                            mem[(32 * _17390) + ceil32(return_data.size) + 1092 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                                            mem[(32 * _17390) + ceil32(return_data.size) + 1156 len 0] = 0
                                    else:
                                        call frogAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if arg2 > userInfo[arg1][msg.sender].field_0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        userInfo[arg1][msg.sender].field_0 -= arg2
                                        if not userInfo[arg1][msg.sender].field_0 - arg2:
                                            userInfo[arg1][msg.sender].field_256 = 0
                                        else:
                                            if (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / userInfo[arg1][msg.sender].field_0 - arg2 != poolInfo[arg1].field_768:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * _17390) + ceil32(return_data.size) + 965 len 31]
                                            userInfo[arg1][msg.sender].field_256 = (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / 10^12
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                            revert with 0, 'Address: call to non-contract'
                                        if not ext_code.hash(poolInfo[arg1].field_0):
                                            revert with 0, 'Address: call to non-contract'
                                        mem[(32 * _17390) + ceil32(return_data.size) + 1092 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                            call poolInfo[arg1].field_0 with:
                               funct uint32(msg.sender)
                                 gas gas_remaining wei
                                args Mask(224, 32, arg2) << 224, mem[(32 * _17390) + ceil32(return_data.size) + 1156 len 4]
                            if not return_data.size:
                                require not ext_call.success
                                revert with 'SafeMath: subtraction overflow'
                            mem[(32 * _17390) + ceil32(return_data.size) + 1124 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                if return_data.size:
                                    revert with ext_call.return_data[0 len return_data.size]
                                revert with 0, 'SafeERC20: low-level call failed'
                            if return_data.size:
                                require return_data.size >= 32
                                if not mem[(32 * _17390) + ceil32(return_data.size) + 1124]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[(32 * _17390) + ceil32(return_data.size) + ceil32(return_data.size) + 1203 len 22]
                        else:
                            if (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / (block.number * frogPerBlock) - (poolInfo[arg1].field_512 * frogPerBlock) != poolInfo[arg1].field_256:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                            mem[288] = 26
                            mem[320] = 'SafeMath: division by zero'
                            if not totalAllocPoint:
                                revert with 0, 'SafeMath: division by zero'
                            mem[352] = 26
                            mem[384] = 'SafeMath: division by zero'
                            if not 2^(block.number - startBlock / halvingPeriod):
                                revert with 0, 'SafeMath: division by zero'
                            mem[416] = 26
                            mem[448] = 'SafeMath: division by zero'
                            require ext_code.size(frogAddress)
                            call frogAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args this.address, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod)
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(frogAddress)
                            call frogAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args this.address, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[480] = 2
                            mem[512] = frogAddress
                            mem[544] = wbnbAddress
                            if block.timestamp + 1800 < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[576] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                            mem[580] = (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                            mem[612] = 0
                            mem[676] = fundsAddress
                            mem[708] = block.timestamp + 1800
                            mem[644] = 160
                            mem[740] = 2
                            mem[772 len 0] = None
                            require ext_code.size(routerAddress)
                            call routerAddress.swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20, 0, 160, fundsAddress, block.timestamp + 1800, 2, mem[772 len 64]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[576 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = ceil32(return_data.size) + 576
                            require return_data.size >= 32
                            _17167 = mem[576 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32
                            require mem[576 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 <= 4294967296
                            require mem[576 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 32 <= return_data.size
                            require mem[mem[576 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 576] <= 4294967296 and mem[576 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + (32 * mem[mem[576 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 576]) + 32 <= return_data.size
                            mem[ceil32(return_data.size) + 576] = mem[mem[576 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 576]
                            _17389 = mem[_17167 + 576]
                            mem[ceil32(return_data.size) + 608 len floor32(mem[_17167 + 576])] = mem[_17167 + 608 len floor32(mem[_17167 + 576])]
                            if not (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod):
                                if not ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: division by zero'
                                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[arg1].field_512 = block.number
                                if not userInfo[arg1][msg.sender].field_0:
                                    if userInfo[arg1][msg.sender].field_256 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require ext_code.size(frogAddress)
                                    staticcall frogAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(frogAddress)
                                    if -userInfo[arg1][msg.sender].field_256 <= ext_call.return_data[0]:
                                        call frogAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, -userInfo[arg1][msg.sender].field_256
                                    else:
                                        call frogAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, ext_call.return_data[0]
                                else:
                                    if poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / userInfo[arg1][msg.sender].field_0 != poolInfo[arg1].field_768:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * _17389) + ceil32(return_data.size) + 773 len 31]
                                    if userInfo[arg1][msg.sender].field_256 > poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require ext_code.size(frogAddress)
                                    staticcall frogAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(frogAddress)
                                    if (poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12) - userInfo[arg1][msg.sender].field_256 <= ext_call.return_data[0]:
                                        call frogAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, (poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12) - userInfo[arg1][msg.sender].field_256
                                    else:
                                        call frogAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if arg2 > userInfo[arg1][msg.sender].field_0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                userInfo[arg1][msg.sender].field_0 -= arg2
                                if not userInfo[arg1][msg.sender].field_0 - arg2:
                                    userInfo[arg1][msg.sender].field_256 = 0
                                else:
                                    if (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / userInfo[arg1][msg.sender].field_0 - arg2 != poolInfo[arg1].field_768:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * _17389) + ceil32(return_data.size) + 965 len 31]
                                    userInfo[arg1][msg.sender].field_256 = (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / 10^12
                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                    revert with 0, 'Address: call to non-contract'
                                if not ext_code.hash(poolInfo[arg1].field_0):
                                    revert with 0, 'Address: call to non-contract'
                                mem[(32 * _17389) + ceil32(return_data.size) + 1092 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                            else:
                                if 10^12 * (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) != 10^12:
                                    revert with 0, 
                                                32,
                                                33,
                                                0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[(32 * _17389) + ceil32(return_data.size) + 709 len 31]
                                if not ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: division by zero'
                                if (10^12 * (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[arg1].field_768 += 10^12 * (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]
                                poolInfo[arg1].field_512 = block.number
                                if userInfo[arg1][msg.sender].field_0:
                                    if poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / userInfo[arg1][msg.sender].field_0 != poolInfo[arg1].field_768:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * _17389) + ceil32(return_data.size) + 773 len 31]
                                    if userInfo[arg1][msg.sender].field_256 > poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require ext_code.size(frogAddress)
                                    staticcall frogAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(frogAddress)
                                    if (poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12) - userInfo[arg1][msg.sender].field_256 <= ext_call.return_data[0]:
                                        call frogAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, (poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12) - userInfo[arg1][msg.sender].field_256
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if arg2 > userInfo[arg1][msg.sender].field_0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        userInfo[arg1][msg.sender].field_0 -= arg2
                                        if userInfo[arg1][msg.sender].field_0 - arg2:
                                            if (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / userInfo[arg1][msg.sender].field_0 - arg2 != poolInfo[arg1].field_768:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * _17389) + ceil32(return_data.size) + 965 len 31]
                                            userInfo[arg1][msg.sender].field_256 = (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / 10^12
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                                revert with 0, 'Address: call to non-contract'
                                            if not ext_code.hash(poolInfo[arg1].field_0):
                                                revert with 0, 'Address: call to non-contract'
                                            mem[(32 * _17389) + ceil32(return_data.size) + 1092 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                                        else:
                                            userInfo[arg1][msg.sender].field_256 = 0
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                                revert with 0, 'Address: call to non-contract'
                                            if not ext_code.hash(poolInfo[arg1].field_0):
                                                revert with 0, 'Address: call to non-contract'
                                            mem[(32 * _17389) + ceil32(return_data.size) + 1092 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                                            mem[(32 * _17389) + ceil32(return_data.size) + 1156 len 0] = 0
                                    else:
                                        call frogAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if arg2 > userInfo[arg1][msg.sender].field_0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        userInfo[arg1][msg.sender].field_0 -= arg2
                                        if not userInfo[arg1][msg.sender].field_0 - arg2:
                                            userInfo[arg1][msg.sender].field_256 = 0
                                        else:
                                            if (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / userInfo[arg1][msg.sender].field_0 - arg2 != poolInfo[arg1].field_768:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * _17389) + ceil32(return_data.size) + 965 len 31]
                                            userInfo[arg1][msg.sender].field_256 = (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / 10^12
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                            revert with 0, 'Address: call to non-contract'
                                        if not ext_code.hash(poolInfo[arg1].field_0):
                                            revert with 0, 'Address: call to non-contract'
                                        mem[(32 * _17389) + ceil32(return_data.size) + 1092 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                                else:
                                    if userInfo[arg1][msg.sender].field_256 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require ext_code.size(frogAddress)
                                    staticcall frogAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(frogAddress)
                                    if -userInfo[arg1][msg.sender].field_256 <= ext_call.return_data[0]:
                                        call frogAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, -userInfo[arg1][msg.sender].field_256
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if arg2 > userInfo[arg1][msg.sender].field_0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        userInfo[arg1][msg.sender].field_0 -= arg2
                                        if not userInfo[arg1][msg.sender].field_0 - arg2:
                                            userInfo[arg1][msg.sender].field_256 = 0
                                        else:
                                            if (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / userInfo[arg1][msg.sender].field_0 - arg2 != poolInfo[arg1].field_768:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * _17389) + ceil32(return_data.size) + 965 len 31]
                                            userInfo[arg1][msg.sender].field_256 = (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / 10^12
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                            revert with 0, 'Address: call to non-contract'
                                        if not ext_code.hash(poolInfo[arg1].field_0):
                                            revert with 0, 'Address: call to non-contract'
                                        mem[(32 * _17389) + ceil32(return_data.size) + 1092 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                                    else:
                                        call frogAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if arg2 > userInfo[arg1][msg.sender].field_0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        userInfo[arg1][msg.sender].field_0 -= arg2
                                        if not userInfo[arg1][msg.sender].field_0 - arg2:
                                            userInfo[arg1][msg.sender].field_256 = 0
                                        else:
                                            if (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / userInfo[arg1][msg.sender].field_0 - arg2 != poolInfo[arg1].field_768:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * _17389) + ceil32(return_data.size) + 965 len 31]
                                            userInfo[arg1][msg.sender].field_256 = (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / 10^12
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                            revert with 0, 'Address: call to non-contract'
                                        if not ext_code.hash(poolInfo[arg1].field_0):
                                            revert with 0, 'Address: call to non-contract'
                                        mem[(32 * _17389) + ceil32(return_data.size) + 1092 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                                        mem[(32 * _17389) + ceil32(return_data.size) + 1156 len 0] = 0
                            call poolInfo[arg1].field_0 with:
                               funct uint32(msg.sender)
                                 gas gas_remaining wei
                                args Mask(224, 32, arg2) << 224, mem[(32 * _17389) + ceil32(return_data.size) + 1156 len 4]
                            if not return_data.size:
                                require not ext_call.success
                                revert with 'SafeMath: subtraction overflow'
                            mem[(32 * _17389) + ceil32(return_data.size) + 1124 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                if return_data.size:
                                    revert with ext_call.return_data[0 len return_data.size]
                                revert with 0, 'SafeERC20: low-level call failed'
                            if return_data.size:
                                require return_data.size >= 32
                                if not mem[(32 * _17389) + ceil32(return_data.size) + 1124]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[(32 * _17389) + ceil32(return_data.size) + ceil32(return_data.size) + 1203 len 22]
            else:
                if poolInfo[arg1].field_512 >= bonusEndBlock:
                    if poolInfo[arg1].field_512 > block.number:
                        revert with 0, 'SafeMath: subtraction overflow'
                    mem[160] = 30
                    mem[192] = 'SafeMath: subtraction overflow'
                    if startBlock > block.number:
                        revert with 0, 'SafeMath: subtraction overflow'
                    mem[224] = 26
                    mem[256] = 'SafeMath: division by zero'
                    if not halvingPeriod:
                        revert with 0, 'SafeMath: division by zero'
                    if not block.number - poolInfo[arg1].field_512:
                        mem[288] = 26
                        mem[320] = 'SafeMath: division by zero'
                        if not totalAllocPoint:
                            revert with 0, 'SafeMath: division by zero'
                        mem[352] = 26
                        mem[384] = 'SafeMath: division by zero'
                        if not 2^(block.number - startBlock / halvingPeriod):
                            revert with 0, 'SafeMath: division by zero'
                        mem[416] = 26
                        mem[448] = 'SafeMath: division by zero'
                        require ext_code.size(frogAddress)
                        call frogAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args this.address, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod)
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require ext_code.size(frogAddress)
                        call frogAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args this.address, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[480] = 2
                        mem[512] = frogAddress
                        mem[544] = wbnbAddress
                        if block.timestamp + 1800 < block.timestamp:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[576] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                        mem[580] = 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                        mem[612] = 0
                        mem[676] = fundsAddress
                        mem[708] = block.timestamp + 1800
                        mem[644] = 160
                        mem[740] = 2
                        mem[772 len 0] = None
                        require ext_code.size(routerAddress)
                        call routerAddress.swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                             gas gas_remaining wei
                            args 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20, 0, 160, fundsAddress, block.timestamp + 1800, 2, mem[772 len 64]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[576 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = ceil32(return_data.size) + 576
                        require return_data.size >= 32
                        _17165 = mem[576 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32
                        require mem[576 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 <= 4294967296
                        require mem[576 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 32 <= return_data.size
                        require mem[mem[576 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 576] <= 4294967296 and mem[576 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + (32 * mem[mem[576 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 576]) + 32 <= return_data.size
                        mem[ceil32(return_data.size) + 576] = mem[mem[576 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 576]
                        _17388 = mem[_17165 + 576]
                        mem[ceil32(return_data.size) + 608 len floor32(mem[_17165 + 576])] = mem[_17165 + 608 len floor32(mem[_17165 + 576])]
                        if not 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod):
                            if not ext_call.return_data[0]:
                                revert with 0, 'SafeMath: division by zero'
                            if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[arg1].field_512 = block.number
                            if not userInfo[arg1][msg.sender].field_0:
                                if userInfo[arg1][msg.sender].field_256 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                require ext_code.size(frogAddress)
                                staticcall frogAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(frogAddress)
                                if -userInfo[arg1][msg.sender].field_256 <= ext_call.return_data[0]:
                                    call frogAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, -userInfo[arg1][msg.sender].field_256
                                else:
                                    call frogAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if arg2 > userInfo[arg1][msg.sender].field_0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                userInfo[arg1][msg.sender].field_0 -= arg2
                                if not userInfo[arg1][msg.sender].field_0 - arg2:
                                    userInfo[arg1][msg.sender].field_256 = 0
                                else:
                                    if (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / userInfo[arg1][msg.sender].field_0 - arg2 != poolInfo[arg1].field_768:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * _17388) + ceil32(return_data.size) + 965 len 31]
                                    userInfo[arg1][msg.sender].field_256 = (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / 10^12
                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                    revert with 0, 'Address: call to non-contract'
                                if not ext_code.hash(poolInfo[arg1].field_0):
                                    revert with 0, 'Address: call to non-contract'
                                mem[(32 * _17388) + ceil32(return_data.size) + 1092 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                            else:
                                if poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / userInfo[arg1][msg.sender].field_0 != poolInfo[arg1].field_768:
                                    revert with 0, 
                                                32,
                                                33,
                                                0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[(32 * _17388) + ceil32(return_data.size) + 773 len 31]
                                if userInfo[arg1][msg.sender].field_256 > poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                require ext_code.size(frogAddress)
                                staticcall frogAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(frogAddress)
                                if (poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12) - userInfo[arg1][msg.sender].field_256 <= ext_call.return_data[0]:
                                    call frogAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, (poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12) - userInfo[arg1][msg.sender].field_256
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if arg2 > userInfo[arg1][msg.sender].field_0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    userInfo[arg1][msg.sender].field_0 -= arg2
                                    if userInfo[arg1][msg.sender].field_0 - arg2:
                                        if (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / userInfo[arg1][msg.sender].field_0 - arg2 != poolInfo[arg1].field_768:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * _17388) + ceil32(return_data.size) + 965 len 31]
                                        userInfo[arg1][msg.sender].field_256 = (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / 10^12
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                            revert with 0, 'Address: call to non-contract'
                                        if not ext_code.hash(poolInfo[arg1].field_0):
                                            revert with 0, 'Address: call to non-contract'
                                        mem[(32 * _17388) + ceil32(return_data.size) + 1092 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                                    else:
                                        userInfo[arg1][msg.sender].field_256 = 0
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                            revert with 0, 'Address: call to non-contract'
                                        if not ext_code.hash(poolInfo[arg1].field_0):
                                            revert with 0, 'Address: call to non-contract'
                                        mem[(32 * _17388) + ceil32(return_data.size) + 1092 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                                        mem[(32 * _17388) + ceil32(return_data.size) + 1156 len 0] = 0
                                else:
                                    call frogAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if arg2 > userInfo[arg1][msg.sender].field_0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    userInfo[arg1][msg.sender].field_0 -= arg2
                                    if not userInfo[arg1][msg.sender].field_0 - arg2:
                                        userInfo[arg1][msg.sender].field_256 = 0
                                    else:
                                        if (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / userInfo[arg1][msg.sender].field_0 - arg2 != poolInfo[arg1].field_768:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * _17388) + ceil32(return_data.size) + 965 len 31]
                                        userInfo[arg1][msg.sender].field_256 = (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / 10^12
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                        revert with 0, 'Address: call to non-contract'
                                    if not ext_code.hash(poolInfo[arg1].field_0):
                                        revert with 0, 'Address: call to non-contract'
                                    mem[(32 * _17388) + ceil32(return_data.size) + 1092 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                        else:
                            if 10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) != 10^12:
                                revert with 0, 
                                            32,
                                            33,
                                            0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                            mem[(32 * _17388) + ceil32(return_data.size) + 709 len 31]
                            if not ext_call.return_data[0]:
                                revert with 0, 'SafeMath: division by zero'
                            if (10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]
                            poolInfo[arg1].field_512 = block.number
                            if not userInfo[arg1][msg.sender].field_0:
                                if userInfo[arg1][msg.sender].field_256 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                require ext_code.size(frogAddress)
                                staticcall frogAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(frogAddress)
                                if -userInfo[arg1][msg.sender].field_256 <= ext_call.return_data[0]:
                                    call frogAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, -userInfo[arg1][msg.sender].field_256
                                else:
                                    call frogAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                if arg2 > userInfo[arg1][msg.sender].field_0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                userInfo[arg1][msg.sender].field_0 -= arg2
                                if not userInfo[arg1][msg.sender].field_0 - arg2:
                                    userInfo[arg1][msg.sender].field_256 = 0
                                else:
                                    if (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / userInfo[arg1][msg.sender].field_0 - arg2 != poolInfo[arg1].field_768:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * _17388) + ceil32(return_data.size) + 965 len 31]
                                    userInfo[arg1][msg.sender].field_256 = (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / 10^12
                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                    revert with 0, 'Address: call to non-contract'
                                if not ext_code.hash(poolInfo[arg1].field_0):
                                    revert with 0, 'Address: call to non-contract'
                                mem[(32 * _17388) + ceil32(return_data.size) + 1092 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                            else:
                                if poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / userInfo[arg1][msg.sender].field_0 != poolInfo[arg1].field_768:
                                    revert with 0, 
                                                32,
                                                33,
                                                0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[(32 * _17388) + ceil32(return_data.size) + 773 len 31]
                                if userInfo[arg1][msg.sender].field_256 > poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                require ext_code.size(frogAddress)
                                staticcall frogAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(frogAddress)
                                if (poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12) - userInfo[arg1][msg.sender].field_256 <= ext_call.return_data[0]:
                                    call frogAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, (poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12) - userInfo[arg1][msg.sender].field_256
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if arg2 > userInfo[arg1][msg.sender].field_0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    userInfo[arg1][msg.sender].field_0 -= arg2
                                    if not userInfo[arg1][msg.sender].field_0 - arg2:
                                        userInfo[arg1][msg.sender].field_256 = 0
                                    else:
                                        if (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / userInfo[arg1][msg.sender].field_0 - arg2 != poolInfo[arg1].field_768:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * _17388) + ceil32(return_data.size) + 965 len 31]
                                        userInfo[arg1][msg.sender].field_256 = (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / 10^12
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                        revert with 0, 'Address: call to non-contract'
                                    if not ext_code.hash(poolInfo[arg1].field_0):
                                        revert with 0, 'Address: call to non-contract'
                                    mem[(32 * _17388) + ceil32(return_data.size) + 1092 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                                else:
                                    call frogAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if arg2 > userInfo[arg1][msg.sender].field_0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    userInfo[arg1][msg.sender].field_0 -= arg2
                                    if not userInfo[arg1][msg.sender].field_0 - arg2:
                                        userInfo[arg1][msg.sender].field_256 = 0
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                            revert with 0, 'Address: call to non-contract'
                                        if not ext_code.hash(poolInfo[arg1].field_0):
                                            revert with 0, 'Address: call to non-contract'
                                        mem[(32 * _17388) + ceil32(return_data.size) + 1092 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                                    else:
                                        if (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / userInfo[arg1][msg.sender].field_0 - arg2 != poolInfo[arg1].field_768:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * _17388) + ceil32(return_data.size) + 965 len 31]
                                        userInfo[arg1][msg.sender].field_256 = (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / 10^12
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                            revert with 0, 'Address: call to non-contract'
                                        if not ext_code.hash(poolInfo[arg1].field_0):
                                            revert with 0, 'Address: call to non-contract'
                                        mem[(32 * _17388) + ceil32(return_data.size) + 1092 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                                        mem[(32 * _17388) + ceil32(return_data.size) + 1156 len 0] = 0
                        call poolInfo[arg1].field_0 with:
                           funct uint32(msg.sender)
                             gas gas_remaining wei
                            args Mask(224, 32, arg2) << 224, mem[(32 * _17388) + ceil32(return_data.size) + 1156 len 4]
                        if not return_data.size:
                            require not ext_call.success
                            revert with 'SafeMath: subtraction overflow'
                        mem[(32 * _17388) + ceil32(return_data.size) + 1124 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size:
                                revert with ext_call.return_data[0 len return_data.size]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if return_data.size:
                            require return_data.size >= 32
                            if not mem[(32 * _17388) + ceil32(return_data.size) + 1124]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[(32 * _17388) + ceil32(return_data.size) + ceil32(return_data.size) + 1203 len 22]
                    else:
                        if (block.number * frogPerBlock) - (poolInfo[arg1].field_512 * frogPerBlock) / block.number - poolInfo[arg1].field_512 != frogPerBlock:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                        if not (block.number * frogPerBlock) - (poolInfo[arg1].field_512 * frogPerBlock):
                            mem[288] = 26
                            mem[320] = 'SafeMath: division by zero'
                            if not totalAllocPoint:
                                revert with 0, 'SafeMath: division by zero'
                            mem[352] = 26
                            mem[384] = 'SafeMath: division by zero'
                            if not 2^(block.number - startBlock / halvingPeriod):
                                revert with 0, 'SafeMath: division by zero'
                            mem[416] = 26
                            mem[448] = 'SafeMath: division by zero'
                            require ext_code.size(frogAddress)
                            call frogAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args this.address, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod)
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(frogAddress)
                            call frogAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args this.address, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[480] = 2
                            mem[512] = frogAddress
                            mem[544] = wbnbAddress
                            if block.timestamp + 1800 < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[576] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                            mem[580] = 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                            mem[612] = 0
                            mem[676] = fundsAddress
                            mem[708] = block.timestamp + 1800
                            mem[644] = 160
                            mem[740] = 2
                            mem[772 len 0] = None
                            require ext_code.size(routerAddress)
                            call routerAddress.swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20, 0, 160, fundsAddress, block.timestamp + 1800, 2, mem[772 len 64]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[576 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = ceil32(return_data.size) + 576
                            require return_data.size >= 32
                            _17163 = mem[576 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32
                            require mem[576 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 <= 4294967296
                            require mem[576 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 32 <= return_data.size
                            require mem[mem[576 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 576] <= 4294967296 and mem[576 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + (32 * mem[mem[576 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 576]) + 32 <= return_data.size
                            mem[ceil32(return_data.size) + 576] = mem[mem[576 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 576]
                            _17387 = mem[_17163 + 576]
                            mem[ceil32(return_data.size) + 608 len floor32(mem[_17163 + 576])] = mem[_17163 + 608 len floor32(mem[_17163 + 576])]
                            if not 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod):
                                if not ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: division by zero'
                                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[arg1].field_512 = block.number
                                if not userInfo[arg1][msg.sender].field_0:
                                    if userInfo[arg1][msg.sender].field_256 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require ext_code.size(frogAddress)
                                    staticcall frogAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(frogAddress)
                                    if -userInfo[arg1][msg.sender].field_256 <= ext_call.return_data[0]:
                                        call frogAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, -userInfo[arg1][msg.sender].field_256
                                    else:
                                        call frogAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if arg2 > userInfo[arg1][msg.sender].field_0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    userInfo[arg1][msg.sender].field_0 -= arg2
                                    if not userInfo[arg1][msg.sender].field_0 - arg2:
                                        userInfo[arg1][msg.sender].field_256 = 0
                                    else:
                                        if (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / userInfo[arg1][msg.sender].field_0 - arg2 != poolInfo[arg1].field_768:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * _17387) + ceil32(return_data.size) + 965 len 31]
                                        userInfo[arg1][msg.sender].field_256 = (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / 10^12
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                        revert with 0, 'Address: call to non-contract'
                                    if not ext_code.hash(poolInfo[arg1].field_0):
                                        revert with 0, 'Address: call to non-contract'
                                    mem[(32 * _17387) + ceil32(return_data.size) + 1092 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                                else:
                                    if poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / userInfo[arg1][msg.sender].field_0 != poolInfo[arg1].field_768:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * _17387) + ceil32(return_data.size) + 773 len 31]
                                    if userInfo[arg1][msg.sender].field_256 > poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require ext_code.size(frogAddress)
                                    staticcall frogAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(frogAddress)
                                    if (poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12) - userInfo[arg1][msg.sender].field_256 <= ext_call.return_data[0]:
                                        call frogAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, (poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12) - userInfo[arg1][msg.sender].field_256
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if arg2 > userInfo[arg1][msg.sender].field_0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        userInfo[arg1][msg.sender].field_0 -= arg2
                                        if not userInfo[arg1][msg.sender].field_0 - arg2:
                                            userInfo[arg1][msg.sender].field_256 = 0
                                        else:
                                            if (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / userInfo[arg1][msg.sender].field_0 - arg2 != poolInfo[arg1].field_768:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * _17387) + ceil32(return_data.size) + 965 len 31]
                                            userInfo[arg1][msg.sender].field_256 = (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / 10^12
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                            revert with 0, 'Address: call to non-contract'
                                        if not ext_code.hash(poolInfo[arg1].field_0):
                                            revert with 0, 'Address: call to non-contract'
                                        mem[(32 * _17387) + ceil32(return_data.size) + 1092 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                                    else:
                                        call frogAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if arg2 > userInfo[arg1][msg.sender].field_0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        userInfo[arg1][msg.sender].field_0 -= arg2
                                        if userInfo[arg1][msg.sender].field_0 - arg2:
                                            if (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / userInfo[arg1][msg.sender].field_0 - arg2 != poolInfo[arg1].field_768:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * _17387) + ceil32(return_data.size) + 965 len 31]
                                            userInfo[arg1][msg.sender].field_256 = (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / 10^12
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                                revert with 0, 'Address: call to non-contract'
                                            if not ext_code.hash(poolInfo[arg1].field_0):
                                                revert with 0, 'Address: call to non-contract'
                                            mem[(32 * _17387) + ceil32(return_data.size) + 1092 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                                        else:
                                            userInfo[arg1][msg.sender].field_256 = 0
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                                revert with 0, 'Address: call to non-contract'
                                            if not ext_code.hash(poolInfo[arg1].field_0):
                                                revert with 0, 'Address: call to non-contract'
                                            mem[(32 * _17387) + ceil32(return_data.size) + 1092 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                                            mem[(32 * _17387) + ceil32(return_data.size) + 1156 len 0] = 0
                            else:
                                if 10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) != 10^12:
                                    revert with 0, 
                                                32,
                                                33,
                                                0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[(32 * _17387) + ceil32(return_data.size) + 709 len 31]
                                if not ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: division by zero'
                                if (10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]
                                poolInfo[arg1].field_512 = block.number
                                if userInfo[arg1][msg.sender].field_0:
                                    if poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / userInfo[arg1][msg.sender].field_0 != poolInfo[arg1].field_768:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * _17387) + ceil32(return_data.size) + 773 len 31]
                                    if userInfo[arg1][msg.sender].field_256 > poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require ext_code.size(frogAddress)
                                    staticcall frogAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(frogAddress)
                                    if (poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12) - userInfo[arg1][msg.sender].field_256 <= ext_call.return_data[0]:
                                        call frogAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, (poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12) - userInfo[arg1][msg.sender].field_256
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if arg2 > userInfo[arg1][msg.sender].field_0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        userInfo[arg1][msg.sender].field_0 -= arg2
                                        if userInfo[arg1][msg.sender].field_0 - arg2:
                                            if (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / userInfo[arg1][msg.sender].field_0 - arg2 != poolInfo[arg1].field_768:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * _17387) + ceil32(return_data.size) + 965 len 31]
                                            userInfo[arg1][msg.sender].field_256 = (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / 10^12
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                                revert with 0, 'Address: call to non-contract'
                                            if not ext_code.hash(poolInfo[arg1].field_0):
                                                revert with 0, 'Address: call to non-contract'
                                            mem[(32 * _17387) + ceil32(return_data.size) + 1092 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                                        else:
                                            userInfo[arg1][msg.sender].field_256 = 0
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                                revert with 0, 'Address: call to non-contract'
                                            if not ext_code.hash(poolInfo[arg1].field_0):
                                                revert with 0, 'Address: call to non-contract'
                                            mem[(32 * _17387) + ceil32(return_data.size) + 1092 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                                            mem[(32 * _17387) + ceil32(return_data.size) + 1156 len 0] = 0
                                    else:
                                        call frogAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if arg2 > userInfo[arg1][msg.sender].field_0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        userInfo[arg1][msg.sender].field_0 -= arg2
                                        if not userInfo[arg1][msg.sender].field_0 - arg2:
                                            userInfo[arg1][msg.sender].field_256 = 0
                                        else:
                                            if (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / userInfo[arg1][msg.sender].field_0 - arg2 != poolInfo[arg1].field_768:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * _17387) + ceil32(return_data.size) + 965 len 31]
                                            userInfo[arg1][msg.sender].field_256 = (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / 10^12
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                            revert with 0, 'Address: call to non-contract'
                                        if not ext_code.hash(poolInfo[arg1].field_0):
                                            revert with 0, 'Address: call to non-contract'
                                        mem[(32 * _17387) + ceil32(return_data.size) + 1092 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                                else:
                                    if userInfo[arg1][msg.sender].field_256 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require ext_code.size(frogAddress)
                                    staticcall frogAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(frogAddress)
                                    if -userInfo[arg1][msg.sender].field_256 > ext_call.return_data[0]:
                                        call frogAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if arg2 > userInfo[arg1][msg.sender].field_0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        userInfo[arg1][msg.sender].field_0 -= arg2
                                        if not userInfo[arg1][msg.sender].field_0 - arg2:
                                            userInfo[arg1][msg.sender].field_256 = 0
                                        else:
                                            if (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / userInfo[arg1][msg.sender].field_0 - arg2 != poolInfo[arg1].field_768:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * _17387) + ceil32(return_data.size) + 965 len 31]
                                            userInfo[arg1][msg.sender].field_256 = (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / 10^12
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                            revert with 0, 'Address: call to non-contract'
                                        if not ext_code.hash(poolInfo[arg1].field_0):
                                            revert with 0, 'Address: call to non-contract'
                                        mem[(32 * _17387) + ceil32(return_data.size) + 1092 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                                    else:
                                        call frogAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, -userInfo[arg1][msg.sender].field_256
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if arg2 > userInfo[arg1][msg.sender].field_0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        userInfo[arg1][msg.sender].field_0 -= arg2
                                        if not userInfo[arg1][msg.sender].field_0 - arg2:
                                            userInfo[arg1][msg.sender].field_256 = 0
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                                revert with 0, 'Address: call to non-contract'
                                            if not ext_code.hash(poolInfo[arg1].field_0):
                                                revert with 0, 'Address: call to non-contract'
                                            mem[(32 * _17387) + ceil32(return_data.size) + 1092 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                                        else:
                                            if (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / userInfo[arg1][msg.sender].field_0 - arg2 != poolInfo[arg1].field_768:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * _17387) + ceil32(return_data.size) + 965 len 31]
                                            userInfo[arg1][msg.sender].field_256 = (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / 10^12
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                                revert with 0, 'Address: call to non-contract'
                                            if not ext_code.hash(poolInfo[arg1].field_0):
                                                revert with 0, 'Address: call to non-contract'
                                            mem[(32 * _17387) + ceil32(return_data.size) + 1092 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                                            mem[(32 * _17387) + ceil32(return_data.size) + 1156 len 0] = 0
                            call poolInfo[arg1].field_0 with:
                               funct uint32(msg.sender)
                                 gas gas_remaining wei
                                args Mask(224, 32, arg2) << 224, mem[(32 * _17387) + ceil32(return_data.size) + 1156 len 4]
                            if not return_data.size:
                                require not ext_call.success
                                revert with 'SafeMath: subtraction overflow'
                            mem[(32 * _17387) + ceil32(return_data.size) + 1124 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                if return_data.size:
                                    revert with ext_call.return_data[0 len return_data.size]
                                revert with 0, 'SafeERC20: low-level call failed'
                            if return_data.size:
                                require return_data.size >= 32
                                if not mem[(32 * _17387) + ceil32(return_data.size) + 1124]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[(32 * _17387) + ceil32(return_data.size) + ceil32(return_data.size) + 1203 len 22]
                        else:
                            if (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / (block.number * frogPerBlock) - (poolInfo[arg1].field_512 * frogPerBlock) != poolInfo[arg1].field_256:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                            mem[288] = 26
                            mem[320] = 'SafeMath: division by zero'
                            if not totalAllocPoint:
                                revert with 0, 'SafeMath: division by zero'
                            mem[352] = 26
                            mem[384] = 'SafeMath: division by zero'
                            if not 2^(block.number - startBlock / halvingPeriod):
                                revert with 0, 'SafeMath: division by zero'
                            mem[416] = 26
                            mem[448] = 'SafeMath: division by zero'
                            require ext_code.size(frogAddress)
                            call frogAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args this.address, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod)
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(frogAddress)
                            call frogAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args this.address, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[480] = 2
                            mem[512] = frogAddress
                            mem[544] = wbnbAddress
                            if block.timestamp + 1800 < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[576] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                            mem[580] = (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                            mem[612] = 0
                            mem[676] = fundsAddress
                            mem[708] = block.timestamp + 1800
                            mem[644] = 160
                            mem[740] = 2
                            mem[772 len 0] = None
                            require ext_code.size(routerAddress)
                            call routerAddress.swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20, 0, 160, fundsAddress, block.timestamp + 1800, 2, mem[772 len 64]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[576 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = ceil32(return_data.size) + 576
                            require return_data.size >= 32
                            _17161 = mem[576 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32
                            require mem[576 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 <= 4294967296
                            require mem[576 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 32 <= return_data.size
                            require mem[mem[576 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 576] <= 4294967296 and mem[576 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + (32 * mem[mem[576 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 576]) + 32 <= return_data.size
                            mem[ceil32(return_data.size) + 576] = mem[mem[576 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 576]
                            _17386 = mem[_17161 + 576]
                            mem[ceil32(return_data.size) + 608 len floor32(mem[_17161 + 576])] = mem[_17161 + 608 len floor32(mem[_17161 + 576])]
                            if not (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod):
                                if not ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: division by zero'
                                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[arg1].field_512 = block.number
                                if not userInfo[arg1][msg.sender].field_0:
                                    if userInfo[arg1][msg.sender].field_256 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require ext_code.size(frogAddress)
                                    staticcall frogAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(frogAddress)
                                    if -userInfo[arg1][msg.sender].field_256 <= ext_call.return_data[0]:
                                        call frogAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, -userInfo[arg1][msg.sender].field_256
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if arg2 > userInfo[arg1][msg.sender].field_0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        userInfo[arg1][msg.sender].field_0 -= arg2
                                        if not userInfo[arg1][msg.sender].field_0 - arg2:
                                            userInfo[arg1][msg.sender].field_256 = 0
                                        else:
                                            if (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / userInfo[arg1][msg.sender].field_0 - arg2 != poolInfo[arg1].field_768:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * _17386) + ceil32(return_data.size) + 965 len 31]
                                            userInfo[arg1][msg.sender].field_256 = (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / 10^12
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                            revert with 0, 'Address: call to non-contract'
                                        if not ext_code.hash(poolInfo[arg1].field_0):
                                            revert with 0, 'Address: call to non-contract'
                                        mem[(32 * _17386) + ceil32(return_data.size) + 1092 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                                    else:
                                        call frogAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if arg2 > userInfo[arg1][msg.sender].field_0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        userInfo[arg1][msg.sender].field_0 -= arg2
                                        if userInfo[arg1][msg.sender].field_0 - arg2:
                                            if (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / userInfo[arg1][msg.sender].field_0 - arg2 != poolInfo[arg1].field_768:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * _17386) + ceil32(return_data.size) + 965 len 31]
                                            userInfo[arg1][msg.sender].field_256 = (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / 10^12
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                                revert with 0, 'Address: call to non-contract'
                                            if not ext_code.hash(poolInfo[arg1].field_0):
                                                revert with 0, 'Address: call to non-contract'
                                            mem[(32 * _17386) + ceil32(return_data.size) + 1092 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                                        else:
                                            userInfo[arg1][msg.sender].field_256 = 0
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                                revert with 0, 'Address: call to non-contract'
                                            if not ext_code.hash(poolInfo[arg1].field_0):
                                                revert with 0, 'Address: call to non-contract'
                                            mem[(32 * _17386) + ceil32(return_data.size) + 1092 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                                            mem[(32 * _17386) + ceil32(return_data.size) + 1156 len 0] = 0
                                else:
                                    if poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / userInfo[arg1][msg.sender].field_0 != poolInfo[arg1].field_768:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * _17386) + ceil32(return_data.size) + 773 len 31]
                                    if userInfo[arg1][msg.sender].field_256 > poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require ext_code.size(frogAddress)
                                    staticcall frogAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(frogAddress)
                                    if (poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12) - userInfo[arg1][msg.sender].field_256 <= ext_call.return_data[0]:
                                        call frogAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, (poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12) - userInfo[arg1][msg.sender].field_256
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if arg2 > userInfo[arg1][msg.sender].field_0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        userInfo[arg1][msg.sender].field_0 -= arg2
                                        if not userInfo[arg1][msg.sender].field_0 - arg2:
                                            userInfo[arg1][msg.sender].field_256 = 0
                                        else:
                                            if (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / userInfo[arg1][msg.sender].field_0 - arg2 != poolInfo[arg1].field_768:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * _17386) + ceil32(return_data.size) + 965 len 31]
                                            userInfo[arg1][msg.sender].field_256 = (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / 10^12
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                            revert with 0, 'Address: call to non-contract'
                                        if not ext_code.hash(poolInfo[arg1].field_0):
                                            revert with 0, 'Address: call to non-contract'
                                        mem[(32 * _17386) + ceil32(return_data.size) + 1092 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                                    else:
                                        call frogAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if arg2 > userInfo[arg1][msg.sender].field_0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        userInfo[arg1][msg.sender].field_0 -= arg2
                                        if userInfo[arg1][msg.sender].field_0 - arg2:
                                            if (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / userInfo[arg1][msg.sender].field_0 - arg2 != poolInfo[arg1].field_768:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * _17386) + ceil32(return_data.size) + 965 len 31]
                                            userInfo[arg1][msg.sender].field_256 = (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / 10^12
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                                revert with 0, 'Address: call to non-contract'
                                            if not ext_code.hash(poolInfo[arg1].field_0):
                                                revert with 0, 'Address: call to non-contract'
                                            mem[(32 * _17386) + ceil32(return_data.size) + 1092 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                                        else:
                                            userInfo[arg1][msg.sender].field_256 = 0
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                                revert with 0, 'Address: call to non-contract'
                                            if not ext_code.hash(poolInfo[arg1].field_0):
                                                revert with 0, 'Address: call to non-contract'
                                            mem[(32 * _17386) + ceil32(return_data.size) + 1092 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                                            mem[(32 * _17386) + ceil32(return_data.size) + 1156 len 0] = 0
                            else:
                                if 10^12 * (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) != 10^12:
                                    revert with 0, 
                                                32,
                                                33,
                                                0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[(32 * _17386) + ceil32(return_data.size) + 709 len 31]
                                if not ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: division by zero'
                                if (10^12 * (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[arg1].field_768 += 10^12 * (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]
                                poolInfo[arg1].field_512 = block.number
                                if not userInfo[arg1][msg.sender].field_0:
                                    if userInfo[arg1][msg.sender].field_256 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require ext_code.size(frogAddress)
                                    staticcall frogAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(frogAddress)
                                    if -userInfo[arg1][msg.sender].field_256 <= ext_call.return_data[0]:
                                        call frogAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, -userInfo[arg1][msg.sender].field_256
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if arg2 > userInfo[arg1][msg.sender].field_0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        userInfo[arg1][msg.sender].field_0 -= arg2
                                        if userInfo[arg1][msg.sender].field_0 - arg2:
                                            if (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / userInfo[arg1][msg.sender].field_0 - arg2 != poolInfo[arg1].field_768:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * _17386) + ceil32(return_data.size) + 965 len 31]
                                            userInfo[arg1][msg.sender].field_256 = (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / 10^12
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                                revert with 0, 'Address: call to non-contract'
                                            if not ext_code.hash(poolInfo[arg1].field_0):
                                                revert with 0, 'Address: call to non-contract'
                                            mem[(32 * _17386) + ceil32(return_data.size) + 1092 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                                        else:
                                            userInfo[arg1][msg.sender].field_256 = 0
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                                revert with 0, 'Address: call to non-contract'
                                            if not ext_code.hash(poolInfo[arg1].field_0):
                                                revert with 0, 'Address: call to non-contract'
                                            mem[(32 * _17386) + ceil32(return_data.size) + 1092 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                                            mem[(32 * _17386) + ceil32(return_data.size) + 1156 len 0] = 0
                                    else:
                                        call frogAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if arg2 > userInfo[arg1][msg.sender].field_0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        userInfo[arg1][msg.sender].field_0 -= arg2
                                        if not userInfo[arg1][msg.sender].field_0 - arg2:
                                            userInfo[arg1][msg.sender].field_256 = 0
                                        else:
                                            if (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / userInfo[arg1][msg.sender].field_0 - arg2 != poolInfo[arg1].field_768:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * _17386) + ceil32(return_data.size) + 965 len 31]
                                            userInfo[arg1][msg.sender].field_256 = (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / 10^12
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                            revert with 0, 'Address: call to non-contract'
                                        if not ext_code.hash(poolInfo[arg1].field_0):
                                            revert with 0, 'Address: call to non-contract'
                                        mem[(32 * _17386) + ceil32(return_data.size) + 1092 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                                else:
                                    if poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / userInfo[arg1][msg.sender].field_0 != poolInfo[arg1].field_768:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * _17386) + ceil32(return_data.size) + 773 len 31]
                                    if userInfo[arg1][msg.sender].field_256 > poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require ext_code.size(frogAddress)
                                    staticcall frogAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(frogAddress)
                                    if (poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12) - userInfo[arg1][msg.sender].field_256 > ext_call.return_data[0]:
                                        call frogAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if arg2 > userInfo[arg1][msg.sender].field_0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        userInfo[arg1][msg.sender].field_0 -= arg2
                                        if not userInfo[arg1][msg.sender].field_0 - arg2:
                                            userInfo[arg1][msg.sender].field_256 = 0
                                        else:
                                            if (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / userInfo[arg1][msg.sender].field_0 - arg2 != poolInfo[arg1].field_768:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * _17386) + ceil32(return_data.size) + 965 len 31]
                                            userInfo[arg1][msg.sender].field_256 = (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / 10^12
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                            revert with 0, 'Address: call to non-contract'
                                        if not ext_code.hash(poolInfo[arg1].field_0):
                                            revert with 0, 'Address: call to non-contract'
                                        mem[(32 * _17386) + ceil32(return_data.size) + 1092 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                                    else:
                                        call frogAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, (poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12) - userInfo[arg1][msg.sender].field_256
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if arg2 > userInfo[arg1][msg.sender].field_0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        userInfo[arg1][msg.sender].field_0 -= arg2
                                        if not userInfo[arg1][msg.sender].field_0 - arg2:
                                            userInfo[arg1][msg.sender].field_256 = 0
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                                revert with 0, 'Address: call to non-contract'
                                            if not ext_code.hash(poolInfo[arg1].field_0):
                                                revert with 0, 'Address: call to non-contract'
                                            mem[(32 * _17386) + ceil32(return_data.size) + 1092 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                                        else:
                                            if (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / userInfo[arg1][msg.sender].field_0 - arg2 != poolInfo[arg1].field_768:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * _17386) + ceil32(return_data.size) + 965 len 31]
                                            userInfo[arg1][msg.sender].field_256 = (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / 10^12
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                                revert with 0, 'Address: call to non-contract'
                                            if not ext_code.hash(poolInfo[arg1].field_0):
                                                revert with 0, 'Address: call to non-contract'
                                            mem[(32 * _17386) + ceil32(return_data.size) + 1092 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                                            mem[(32 * _17386) + ceil32(return_data.size) + 1156 len 0] = 0
                            call poolInfo[arg1].field_0 with:
                               funct uint32(msg.sender)
                                 gas gas_remaining wei
                                args Mask(224, 32, arg2) << 224, mem[(32 * _17386) + ceil32(return_data.size) + 1156 len 4]
                            if not return_data.size:
                                require not ext_call.success
                                revert with 'SafeMath: subtraction overflow'
                            mem[(32 * _17386) + ceil32(return_data.size) + 1124 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                if return_data.size:
                                    revert with ext_call.return_data[0 len return_data.size]
                                revert with 0, 'SafeERC20: low-level call failed'
                            if return_data.size:
                                require return_data.size >= 32
                                if not mem[(32 * _17386) + ceil32(return_data.size) + 1124]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[(32 * _17386) + ceil32(return_data.size) + ceil32(return_data.size) + 1203 len 22]
                else:
                    if bonusEndBlock > block.number:
                        revert with 0, 'SafeMath: subtraction overflow'
                    mem[160] = 30
                    mem[192] = 'SafeMath: subtraction overflow'
                    if poolInfo[arg1].field_512 > bonusEndBlock:
                        revert with 0, 'SafeMath: subtraction overflow'
                    if not bonusEndBlock - poolInfo[arg1].field_512:
                        if block.number - bonusEndBlock < 0:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[224] = 30
                        mem[256] = 'SafeMath: subtraction overflow'
                        if startBlock > block.number:
                            revert with 0, 'SafeMath: subtraction overflow'
                        mem[288] = 26
                        mem[320] = 'SafeMath: division by zero'
                        if not halvingPeriod:
                            revert with 0, 'SafeMath: division by zero'
                        if not block.number - bonusEndBlock:
                            mem[352] = 26
                            mem[384] = 'SafeMath: division by zero'
                            if not totalAllocPoint:
                                revert with 0, 'SafeMath: division by zero'
                            mem[416] = 26
                            mem[448] = 'SafeMath: division by zero'
                            if not 2^(block.number - startBlock / halvingPeriod):
                                revert with 0, 'SafeMath: division by zero'
                            mem[480] = 26
                            mem[512] = 'SafeMath: division by zero'
                            require ext_code.size(frogAddress)
                            call frogAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args this.address, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod)
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(frogAddress)
                            call frogAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args this.address, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[544] = 2
                            mem[576] = frogAddress
                            mem[608] = wbnbAddress
                            if block.timestamp + 1800 < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[640] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                            mem[644] = 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                            mem[676] = 0
                            mem[740] = fundsAddress
                            mem[772] = block.timestamp + 1800
                            mem[708] = 160
                            mem[804] = 2
                            mem[836 len 0] = None
                            require ext_code.size(routerAddress)
                            call routerAddress.swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20, 0, 160, fundsAddress, block.timestamp + 1800, 2, mem[836 len 64]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[640 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = ceil32(return_data.size) + 640
                            require return_data.size >= 32
                            _17159 = mem[640 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32
                            require mem[640 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 <= 4294967296
                            require mem[640 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 32 <= return_data.size
                            require mem[mem[640 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 640] <= 4294967296 and mem[640 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + (32 * mem[mem[640 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 640]) + 32 <= return_data.size
                            mem[ceil32(return_data.size) + 640] = mem[mem[640 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 640]
                            _17385 = mem[_17159 + 640]
                            mem[ceil32(return_data.size) + 672 len floor32(mem[_17159 + 640])] = mem[_17159 + 672 len floor32(mem[_17159 + 640])]
                            if not 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod):
                                if not ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: division by zero'
                                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[arg1].field_512 = block.number
                                if not userInfo[arg1][msg.sender].field_0:
                                    if userInfo[arg1][msg.sender].field_256 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require ext_code.size(frogAddress)
                                    staticcall frogAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(frogAddress)
                                    if -userInfo[arg1][msg.sender].field_256 <= ext_call.return_data[0]:
                                        call frogAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, -userInfo[arg1][msg.sender].field_256
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if arg2 > userInfo[arg1][msg.sender].field_0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        userInfo[arg1][msg.sender].field_0 -= arg2
                                        if userInfo[arg1][msg.sender].field_0 - arg2:
                                            if (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / userInfo[arg1][msg.sender].field_0 - arg2 != poolInfo[arg1].field_768:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * _17385) + ceil32(return_data.size) + 1029 len 31]
                                            userInfo[arg1][msg.sender].field_256 = (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / 10^12
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                                revert with 0, 'Address: call to non-contract'
                                            if not ext_code.hash(poolInfo[arg1].field_0):
                                                revert with 0, 'Address: call to non-contract'
                                            mem[(32 * _17385) + ceil32(return_data.size) + 1156 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                                        else:
                                            userInfo[arg1][msg.sender].field_256 = 0
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                                revert with 0, 'Address: call to non-contract'
                                            if not ext_code.hash(poolInfo[arg1].field_0):
                                                revert with 0, 'Address: call to non-contract'
                                            mem[(32 * _17385) + ceil32(return_data.size) + 1156 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                                            mem[(32 * _17385) + ceil32(return_data.size) + 1220 len 0] = 0
                                    else:
                                        call frogAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if arg2 > userInfo[arg1][msg.sender].field_0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        userInfo[arg1][msg.sender].field_0 -= arg2
                                        if not userInfo[arg1][msg.sender].field_0 - arg2:
                                            userInfo[arg1][msg.sender].field_256 = 0
                                        else:
                                            if (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / userInfo[arg1][msg.sender].field_0 - arg2 != poolInfo[arg1].field_768:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * _17385) + ceil32(return_data.size) + 1029 len 31]
                                            userInfo[arg1][msg.sender].field_256 = (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / 10^12
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                            revert with 0, 'Address: call to non-contract'
                                        if not ext_code.hash(poolInfo[arg1].field_0):
                                            revert with 0, 'Address: call to non-contract'
                                        mem[(32 * _17385) + ceil32(return_data.size) + 1156 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                                else:
                                    if poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / userInfo[arg1][msg.sender].field_0 != poolInfo[arg1].field_768:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * _17385) + ceil32(return_data.size) + 837 len 31]
                                    if userInfo[arg1][msg.sender].field_256 > poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require ext_code.size(frogAddress)
                                    staticcall frogAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(frogAddress)
                                    if (poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12) - userInfo[arg1][msg.sender].field_256 <= ext_call.return_data[0]:
                                        call frogAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, (poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12) - userInfo[arg1][msg.sender].field_256
                                    else:
                                        call frogAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if arg2 > userInfo[arg1][msg.sender].field_0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    userInfo[arg1][msg.sender].field_0 -= arg2
                                    if not userInfo[arg1][msg.sender].field_0 - arg2:
                                        userInfo[arg1][msg.sender].field_256 = 0
                                    else:
                                        if (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / userInfo[arg1][msg.sender].field_0 - arg2 != poolInfo[arg1].field_768:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * _17385) + ceil32(return_data.size) + 1029 len 31]
                                        userInfo[arg1][msg.sender].field_256 = (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / 10^12
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                        revert with 0, 'Address: call to non-contract'
                                    if not ext_code.hash(poolInfo[arg1].field_0):
                                        revert with 0, 'Address: call to non-contract'
                                    mem[(32 * _17385) + ceil32(return_data.size) + 1156 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                            else:
                                if 10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) != 10^12:
                                    revert with 0, 
                                                32,
                                                33,
                                                0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[(32 * _17385) + ceil32(return_data.size) + 773 len 31]
                                if not ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: division by zero'
                                if (10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]
                                poolInfo[arg1].field_512 = block.number
                                if not userInfo[arg1][msg.sender].field_0:
                                    if userInfo[arg1][msg.sender].field_256 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require ext_code.size(frogAddress)
                                    staticcall frogAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(frogAddress)
                                    if -userInfo[arg1][msg.sender].field_256 <= ext_call.return_data[0]:
                                        call frogAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, -userInfo[arg1][msg.sender].field_256
                                    else:
                                        call frogAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if arg2 > userInfo[arg1][msg.sender].field_0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    userInfo[arg1][msg.sender].field_0 -= arg2
                                    if not userInfo[arg1][msg.sender].field_0 - arg2:
                                        userInfo[arg1][msg.sender].field_256 = 0
                                    else:
                                        if (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / userInfo[arg1][msg.sender].field_0 - arg2 != poolInfo[arg1].field_768:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * _17385) + ceil32(return_data.size) + 1029 len 31]
                                        userInfo[arg1][msg.sender].field_256 = (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / 10^12
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                        revert with 0, 'Address: call to non-contract'
                                    if not ext_code.hash(poolInfo[arg1].field_0):
                                        revert with 0, 'Address: call to non-contract'
                                    mem[(32 * _17385) + ceil32(return_data.size) + 1156 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                                else:
                                    if poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / userInfo[arg1][msg.sender].field_0 != poolInfo[arg1].field_768:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * _17385) + ceil32(return_data.size) + 837 len 31]
                                    if userInfo[arg1][msg.sender].field_256 > poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require ext_code.size(frogAddress)
                                    staticcall frogAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(frogAddress)
                                    if (poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12) - userInfo[arg1][msg.sender].field_256 > ext_call.return_data[0]:
                                        call frogAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if arg2 > userInfo[arg1][msg.sender].field_0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        userInfo[arg1][msg.sender].field_0 -= arg2
                                        if not userInfo[arg1][msg.sender].field_0 - arg2:
                                            userInfo[arg1][msg.sender].field_256 = 0
                                        else:
                                            if (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / userInfo[arg1][msg.sender].field_0 - arg2 != poolInfo[arg1].field_768:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * _17385) + ceil32(return_data.size) + 1029 len 31]
                                            userInfo[arg1][msg.sender].field_256 = (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / 10^12
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                            revert with 0, 'Address: call to non-contract'
                                        if not ext_code.hash(poolInfo[arg1].field_0):
                                            revert with 0, 'Address: call to non-contract'
                                        mem[(32 * _17385) + ceil32(return_data.size) + 1156 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                                    else:
                                        call frogAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, (poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12) - userInfo[arg1][msg.sender].field_256
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if arg2 > userInfo[arg1][msg.sender].field_0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        userInfo[arg1][msg.sender].field_0 -= arg2
                                        if not userInfo[arg1][msg.sender].field_0 - arg2:
                                            userInfo[arg1][msg.sender].field_256 = 0
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                                revert with 0, 'Address: call to non-contract'
                                            if not ext_code.hash(poolInfo[arg1].field_0):
                                                revert with 0, 'Address: call to non-contract'
                                            mem[(32 * _17385) + ceil32(return_data.size) + 1156 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                                        else:
                                            if (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / userInfo[arg1][msg.sender].field_0 - arg2 != poolInfo[arg1].field_768:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * _17385) + ceil32(return_data.size) + 1029 len 31]
                                            userInfo[arg1][msg.sender].field_256 = (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / 10^12
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                                revert with 0, 'Address: call to non-contract'
                                            if not ext_code.hash(poolInfo[arg1].field_0):
                                                revert with 0, 'Address: call to non-contract'
                                            mem[(32 * _17385) + ceil32(return_data.size) + 1156 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                                            mem[(32 * _17385) + ceil32(return_data.size) + 1220 len 0] = 0
                            call poolInfo[arg1].field_0 with:
                               funct uint32(msg.sender)
                                 gas gas_remaining wei
                                args Mask(224, 32, arg2) << 224, mem[(32 * _17385) + ceil32(return_data.size) + 1220 len 4]
                            if not return_data.size:
                                require not ext_call.success
                                revert with 'SafeMath: subtraction overflow'
                            mem[(32 * _17385) + ceil32(return_data.size) + 1188 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                if return_data.size:
                                    revert with ext_call.return_data[0 len return_data.size]
                                revert with 0, 'SafeERC20: low-level call failed'
                            if return_data.size:
                                require return_data.size >= 32
                                if not mem[(32 * _17385) + ceil32(return_data.size) + 1188]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[(32 * _17385) + ceil32(return_data.size) + ceil32(return_data.size) + 1267 len 22]
                        else:
                            if (block.number * frogPerBlock) - (bonusEndBlock * frogPerBlock) / block.number - bonusEndBlock != frogPerBlock:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                            if not (block.number * frogPerBlock) - (bonusEndBlock * frogPerBlock):
                                mem[352] = 26
                                mem[384] = 'SafeMath: division by zero'
                                if not totalAllocPoint:
                                    revert with 0, 'SafeMath: division by zero'
                                mem[416] = 26
                                mem[448] = 'SafeMath: division by zero'
                                if not 2^(block.number - startBlock / halvingPeriod):
                                    revert with 0, 'SafeMath: division by zero'
                                mem[480] = 26
                                mem[512] = 'SafeMath: division by zero'
                                require ext_code.size(frogAddress)
                                call frogAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args this.address, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod)
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(frogAddress)
                                call frogAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args this.address, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[544] = 2
                                mem[576] = frogAddress
                                mem[608] = wbnbAddress
                                if block.timestamp + 1800 < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[640] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                mem[644] = 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                                mem[676] = 0
                                mem[740] = fundsAddress
                                mem[772] = block.timestamp + 1800
                                mem[708] = 160
                                mem[804] = 2
                                mem[836 len 0] = None
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20, 0, 160, fundsAddress, block.timestamp + 1800, 2, mem[836 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[640 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(return_data.size) + 640
                                require return_data.size >= 32
                                _17157 = mem[640 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32
                                require mem[640 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 <= 4294967296
                                require mem[640 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 32 <= return_data.size
                                require mem[mem[640 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 640] <= 4294967296 and mem[640 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + (32 * mem[mem[640 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 640]) + 32 <= return_data.size
                                mem[ceil32(return_data.size) + 640] = mem[mem[640 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 640]
                                _17384 = mem[_17157 + 640]
                                mem[ceil32(return_data.size) + 672 len floor32(mem[_17157 + 640])] = mem[_17157 + 672 len floor32(mem[_17157 + 640])]
                                if 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod):
                                    if 10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) != 10^12:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * _17384) + ceil32(return_data.size) + 773 len 31]
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: division by zero'
                                    if (10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]
                                    poolInfo[arg1].field_512 = block.number
                                    if userInfo[arg1][msg.sender].field_0:
                                        if poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / userInfo[arg1][msg.sender].field_0 != poolInfo[arg1].field_768:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * _17384) + ceil32(return_data.size) + 837 len 31]
                                        if userInfo[arg1][msg.sender].field_256 > poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require ext_code.size(frogAddress)
                                        staticcall frogAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(frogAddress)
                                        if (poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12) - userInfo[arg1][msg.sender].field_256 <= ext_call.return_data[0]:
                                            call frogAddress.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, (poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12) - userInfo[arg1][msg.sender].field_256
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if arg2 > userInfo[arg1][msg.sender].field_0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            userInfo[arg1][msg.sender].field_0 -= arg2
                                            if not userInfo[arg1][msg.sender].field_0 - arg2:
                                                userInfo[arg1][msg.sender].field_256 = 0
                                            else:
                                                if (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / userInfo[arg1][msg.sender].field_0 - arg2 != poolInfo[arg1].field_768:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * _17384) + ceil32(return_data.size) + 1029 len 31]
                                                userInfo[arg1][msg.sender].field_256 = (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / 10^12
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                                revert with 0, 'Address: call to non-contract'
                                            if not ext_code.hash(poolInfo[arg1].field_0):
                                                revert with 0, 'Address: call to non-contract'
                                            mem[(32 * _17384) + ceil32(return_data.size) + 1156 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                                        else:
                                            call frogAddress.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if arg2 > userInfo[arg1][msg.sender].field_0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            userInfo[arg1][msg.sender].field_0 -= arg2
                                            if userInfo[arg1][msg.sender].field_0 - arg2:
                                                if (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / userInfo[arg1][msg.sender].field_0 - arg2 != poolInfo[arg1].field_768:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * _17384) + ceil32(return_data.size) + 1029 len 31]
                                                userInfo[arg1][msg.sender].field_256 = (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / 10^12
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                                    revert with 0, 'Address: call to non-contract'
                                                if not ext_code.hash(poolInfo[arg1].field_0):
                                                    revert with 0, 'Address: call to non-contract'
                                                mem[(32 * _17384) + ceil32(return_data.size) + 1156 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                                            else:
                                                userInfo[arg1][msg.sender].field_256 = 0
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                                    revert with 0, 'Address: call to non-contract'
                                                if not ext_code.hash(poolInfo[arg1].field_0):
                                                    revert with 0, 'Address: call to non-contract'
                                                mem[(32 * _17384) + ceil32(return_data.size) + 1156 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                                                mem[(32 * _17384) + ceil32(return_data.size) + 1220 len 0] = 0
                                    else:
                                        if userInfo[arg1][msg.sender].field_256 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require ext_code.size(frogAddress)
                                        staticcall frogAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(frogAddress)
                                        if -userInfo[arg1][msg.sender].field_256 > ext_call.return_data[0]:
                                            call frogAddress.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if arg2 > userInfo[arg1][msg.sender].field_0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            userInfo[arg1][msg.sender].field_0 -= arg2
                                            if not userInfo[arg1][msg.sender].field_0 - arg2:
                                                userInfo[arg1][msg.sender].field_256 = 0
                                            else:
                                                if (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / userInfo[arg1][msg.sender].field_0 - arg2 != poolInfo[arg1].field_768:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * _17384) + ceil32(return_data.size) + 1029 len 31]
                                                userInfo[arg1][msg.sender].field_256 = (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / 10^12
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                                revert with 0, 'Address: call to non-contract'
                                            if not ext_code.hash(poolInfo[arg1].field_0):
                                                revert with 0, 'Address: call to non-contract'
                                            mem[(32 * _17384) + ceil32(return_data.size) + 1156 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                                        else:
                                            call frogAddress.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, -userInfo[arg1][msg.sender].field_256
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if arg2 > userInfo[arg1][msg.sender].field_0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            userInfo[arg1][msg.sender].field_0 -= arg2
                                            if not userInfo[arg1][msg.sender].field_0 - arg2:
                                                userInfo[arg1][msg.sender].field_256 = 0
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                                    revert with 0, 'Address: call to non-contract'
                                                if not ext_code.hash(poolInfo[arg1].field_0):
                                                    revert with 0, 'Address: call to non-contract'
                                                mem[(32 * _17384) + ceil32(return_data.size) + 1156 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                                            else:
                                                if (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / userInfo[arg1][msg.sender].field_0 - arg2 != poolInfo[arg1].field_768:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * _17384) + ceil32(return_data.size) + 1029 len 31]
                                                userInfo[arg1][msg.sender].field_256 = (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / 10^12
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                                    revert with 0, 'Address: call to non-contract'
                                                if not ext_code.hash(poolInfo[arg1].field_0):
                                                    revert with 0, 'Address: call to non-contract'
                                                mem[(32 * _17384) + ceil32(return_data.size) + 1156 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                                                mem[(32 * _17384) + ceil32(return_data.size) + 1220 len 0] = 0
                                else:
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: division by zero'
                                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                    poolInfo[arg1].field_512 = block.number
                                    if not userInfo[arg1][msg.sender].field_0:
                                        if userInfo[arg1][msg.sender].field_256 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require ext_code.size(frogAddress)
                                        staticcall frogAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(frogAddress)
                                        if -userInfo[arg1][msg.sender].field_256 <= ext_call.return_data[0]:
                                            call frogAddress.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, -userInfo[arg1][msg.sender].field_256
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if arg2 > userInfo[arg1][msg.sender].field_0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            userInfo[arg1][msg.sender].field_0 -= arg2
                                            if not userInfo[arg1][msg.sender].field_0 - arg2:
                                                userInfo[arg1][msg.sender].field_256 = 0
                                            else:
                                                if (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / userInfo[arg1][msg.sender].field_0 - arg2 != poolInfo[arg1].field_768:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * _17384) + ceil32(return_data.size) + 1029 len 31]
                                                userInfo[arg1][msg.sender].field_256 = (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / 10^12
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                                revert with 0, 'Address: call to non-contract'
                                            if not ext_code.hash(poolInfo[arg1].field_0):
                                                revert with 0, 'Address: call to non-contract'
                                            mem[(32 * _17384) + ceil32(return_data.size) + 1156 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                                        else:
                                            call frogAddress.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if arg2 > userInfo[arg1][msg.sender].field_0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            userInfo[arg1][msg.sender].field_0 -= arg2
                                            if userInfo[arg1][msg.sender].field_0 - arg2:
                                                if (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / userInfo[arg1][msg.sender].field_0 - arg2 != poolInfo[arg1].field_768:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * _17384) + ceil32(return_data.size) + 1029 len 31]
                                                userInfo[arg1][msg.sender].field_256 = (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / 10^12
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                                    revert with 0, 'Address: call to non-contract'
                                                if not ext_code.hash(poolInfo[arg1].field_0):
                                                    revert with 0, 'Address: call to non-contract'
                                                mem[(32 * _17384) + ceil32(return_data.size) + 1156 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                                            else:
                                                userInfo[arg1][msg.sender].field_256 = 0
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                                    revert with 0, 'Address: call to non-contract'
                                                if not ext_code.hash(poolInfo[arg1].field_0):
                                                    revert with 0, 'Address: call to non-contract'
                                                mem[(32 * _17384) + ceil32(return_data.size) + 1156 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                                                mem[(32 * _17384) + ceil32(return_data.size) + 1220 len 0] = 0
                                    else:
                                        if poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / userInfo[arg1][msg.sender].field_0 != poolInfo[arg1].field_768:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * _17384) + ceil32(return_data.size) + 837 len 31]
                                        if userInfo[arg1][msg.sender].field_256 > poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require ext_code.size(frogAddress)
                                        staticcall frogAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(frogAddress)
                                        if (poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12) - userInfo[arg1][msg.sender].field_256 <= ext_call.return_data[0]:
                                            call frogAddress.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, (poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12) - userInfo[arg1][msg.sender].field_256
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if arg2 > userInfo[arg1][msg.sender].field_0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            userInfo[arg1][msg.sender].field_0 -= arg2
                                            if not userInfo[arg1][msg.sender].field_0 - arg2:
                                                userInfo[arg1][msg.sender].field_256 = 0
                                            else:
                                                if (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / userInfo[arg1][msg.sender].field_0 - arg2 != poolInfo[arg1].field_768:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * _17384) + ceil32(return_data.size) + 1029 len 31]
                                                userInfo[arg1][msg.sender].field_256 = (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / 10^12
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                                revert with 0, 'Address: call to non-contract'
                                            if not ext_code.hash(poolInfo[arg1].field_0):
                                                revert with 0, 'Address: call to non-contract'
                                            mem[(32 * _17384) + ceil32(return_data.size) + 1156 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                                        else:
                                            call frogAddress.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if arg2 > userInfo[arg1][msg.sender].field_0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            userInfo[arg1][msg.sender].field_0 -= arg2
                                            if not userInfo[arg1][msg.sender].field_0 - arg2:
                                                userInfo[arg1][msg.sender].field_256 = 0
                                            else:
                                                if (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / userInfo[arg1][msg.sender].field_0 - arg2 != poolInfo[arg1].field_768:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * _17384) + ceil32(return_data.size) + 1029 len 31]
                                                userInfo[arg1][msg.sender].field_256 = (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / 10^12
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                                revert with 0, 'Address: call to non-contract'
                                            if not ext_code.hash(poolInfo[arg1].field_0):
                                                revert with 0, 'Address: call to non-contract'
                                            mem[(32 * _17384) + ceil32(return_data.size) + 1156 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                                            mem[(32 * _17384) + ceil32(return_data.size) + 1220 len 0] = 0
                                call poolInfo[arg1].field_0 with:
                                   funct uint32(msg.sender)
                                     gas gas_remaining wei
                                    args Mask(224, 32, arg2) << 224, mem[(32 * _17384) + ceil32(return_data.size) + 1220 len 4]
                                if not return_data.size:
                                    require not ext_call.success
                                    revert with 'SafeMath: subtraction overflow'
                                mem[(32 * _17384) + ceil32(return_data.size) + 1188 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if return_data.size:
                                    require return_data.size >= 32
                                    if not mem[(32 * _17384) + ceil32(return_data.size) + 1188]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[(32 * _17384) + ceil32(return_data.size) + ceil32(return_data.size) + 1267 len 22]
                            else:
                                if (block.number * frogPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * frogPerBlock * poolInfo[arg1].field_256) / (block.number * frogPerBlock) - (bonusEndBlock * frogPerBlock) != poolInfo[arg1].field_256:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                mem[352] = 26
                                mem[384] = 'SafeMath: division by zero'
                                if not totalAllocPoint:
                                    revert with 0, 'SafeMath: division by zero'
                                mem[416] = 26
                                mem[448] = 'SafeMath: division by zero'
                                if not 2^(block.number - startBlock / halvingPeriod):
                                    revert with 0, 'SafeMath: division by zero'
                                mem[480] = 26
                                mem[512] = 'SafeMath: division by zero'
                                require ext_code.size(frogAddress)
                                call frogAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args this.address, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod)
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(frogAddress)
                                call frogAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args this.address, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[544] = 2
                                mem[576] = frogAddress
                                mem[608] = wbnbAddress
                                if block.timestamp + 1800 < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[640] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                mem[644] = (block.number * frogPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                                mem[676] = 0
                                mem[740] = fundsAddress
                                mem[772] = block.timestamp + 1800
                                mem[708] = 160
                                mem[804] = 2
                                mem[836 len 0] = None
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args (block.number * frogPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20, 0, 160, fundsAddress, block.timestamp + 1800, 2, mem[836 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[640 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(return_data.size) + 640
                                require return_data.size >= 32
                                _17155 = mem[640 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32
                                require mem[640 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 <= 4294967296
                                require mem[640 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 32 <= return_data.size
                                require mem[mem[640 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 640] <= 4294967296 and mem[640 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + (32 * mem[mem[640 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 640]) + 32 <= return_data.size
                                mem[ceil32(return_data.size) + 640] = mem[mem[640 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 640]
                                _17383 = mem[_17155 + 640]
                                mem[ceil32(return_data.size) + 672 len floor32(mem[_17155 + 640])] = mem[_17155 + 672 len floor32(mem[_17155 + 640])]
                                if not (block.number * frogPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod):
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: division by zero'
                                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                    poolInfo[arg1].field_512 = block.number
                                    if not userInfo[arg1][msg.sender].field_0:
                                        if userInfo[arg1][msg.sender].field_256 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require ext_code.size(frogAddress)
                                        staticcall frogAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(frogAddress)
                                        if -userInfo[arg1][msg.sender].field_256 <= ext_call.return_data[0]:
                                            call frogAddress.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, -userInfo[arg1][msg.sender].field_256
                                        else:
                                            call frogAddress.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, ext_call.return_data[0]
                                    else:
                                        if poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / userInfo[arg1][msg.sender].field_0 != poolInfo[arg1].field_768:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * _17383) + ceil32(return_data.size) + 837 len 31]
                                        if userInfo[arg1][msg.sender].field_256 > poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require ext_code.size(frogAddress)
                                        staticcall frogAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(frogAddress)
                                        if (poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12) - userInfo[arg1][msg.sender].field_256 <= ext_call.return_data[0]:
                                            call frogAddress.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, (poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12) - userInfo[arg1][msg.sender].field_256
                                        else:
                                            call frogAddress.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if arg2 > userInfo[arg1][msg.sender].field_0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    userInfo[arg1][msg.sender].field_0 -= arg2
                                    if not userInfo[arg1][msg.sender].field_0 - arg2:
                                        userInfo[arg1][msg.sender].field_256 = 0
                                    else:
                                        if (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / userInfo[arg1][msg.sender].field_0 - arg2 != poolInfo[arg1].field_768:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * _17383) + ceil32(return_data.size) + 1029 len 31]
                                        userInfo[arg1][msg.sender].field_256 = (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / 10^12
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                        revert with 0, 'Address: call to non-contract'
                                    if not ext_code.hash(poolInfo[arg1].field_0):
                                        revert with 0, 'Address: call to non-contract'
                                    mem[(32 * _17383) + ceil32(return_data.size) + 1156 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                                else:
                                    if 10^12 * (block.number * frogPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / (block.number * frogPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) != 10^12:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * _17383) + ceil32(return_data.size) + 773 len 31]
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: division by zero'
                                    if (10^12 * (block.number * frogPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_768 += 10^12 * (block.number * frogPerBlock * poolInfo[arg1].field_256) - (bonusEndBlock * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]
                                    poolInfo[arg1].field_512 = block.number
                                    if userInfo[arg1][msg.sender].field_0:
                                        if poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / userInfo[arg1][msg.sender].field_0 != poolInfo[arg1].field_768:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * _17383) + ceil32(return_data.size) + 837 len 31]
                                        if userInfo[arg1][msg.sender].field_256 > poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require ext_code.size(frogAddress)
                                        staticcall frogAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(frogAddress)
                                        if (poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12) - userInfo[arg1][msg.sender].field_256 <= ext_call.return_data[0]:
                                            call frogAddress.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, (poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12) - userInfo[arg1][msg.sender].field_256
                                        else:
                                            call frogAddress.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if arg2 > userInfo[arg1][msg.sender].field_0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        userInfo[arg1][msg.sender].field_0 -= arg2
                                        if not userInfo[arg1][msg.sender].field_0 - arg2:
                                            userInfo[arg1][msg.sender].field_256 = 0
                                        else:
                                            if (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / userInfo[arg1][msg.sender].field_0 - arg2 != poolInfo[arg1].field_768:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * _17383) + ceil32(return_data.size) + 1029 len 31]
                                            userInfo[arg1][msg.sender].field_256 = (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / 10^12
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                            revert with 0, 'Address: call to non-contract'
                                        if not ext_code.hash(poolInfo[arg1].field_0):
                                            revert with 0, 'Address: call to non-contract'
                                        mem[(32 * _17383) + ceil32(return_data.size) + 1156 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                                    else:
                                        if userInfo[arg1][msg.sender].field_256 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require ext_code.size(frogAddress)
                                        staticcall frogAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(frogAddress)
                                        if -userInfo[arg1][msg.sender].field_256 > ext_call.return_data[0]:
                                            call frogAddress.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if arg2 > userInfo[arg1][msg.sender].field_0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            userInfo[arg1][msg.sender].field_0 -= arg2
                                            if not userInfo[arg1][msg.sender].field_0 - arg2:
                                                userInfo[arg1][msg.sender].field_256 = 0
                                            else:
                                                if (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / userInfo[arg1][msg.sender].field_0 - arg2 != poolInfo[arg1].field_768:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * _17383) + ceil32(return_data.size) + 1029 len 31]
                                                userInfo[arg1][msg.sender].field_256 = (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / 10^12
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                                revert with 0, 'Address: call to non-contract'
                                            if not ext_code.hash(poolInfo[arg1].field_0):
                                                revert with 0, 'Address: call to non-contract'
                                            mem[(32 * _17383) + ceil32(return_data.size) + 1156 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                                        else:
                                            call frogAddress.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, -userInfo[arg1][msg.sender].field_256
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if arg2 > userInfo[arg1][msg.sender].field_0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            userInfo[arg1][msg.sender].field_0 -= arg2
                                            if not userInfo[arg1][msg.sender].field_0 - arg2:
                                                userInfo[arg1][msg.sender].field_256 = 0
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                                    revert with 0, 'Address: call to non-contract'
                                                if not ext_code.hash(poolInfo[arg1].field_0):
                                                    revert with 0, 'Address: call to non-contract'
                                                mem[(32 * _17383) + ceil32(return_data.size) + 1156 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                                            else:
                                                if (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / userInfo[arg1][msg.sender].field_0 - arg2 != poolInfo[arg1].field_768:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * _17383) + ceil32(return_data.size) + 1029 len 31]
                                                userInfo[arg1][msg.sender].field_256 = (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / 10^12
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                                    revert with 0, 'Address: call to non-contract'
                                                if not ext_code.hash(poolInfo[arg1].field_0):
                                                    revert with 0, 'Address: call to non-contract'
                                                mem[(32 * _17383) + ceil32(return_data.size) + 1156 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                                                mem[(32 * _17383) + ceil32(return_data.size) + 1220 len 0] = 0
                                call poolInfo[arg1].field_0 with:
                                   funct uint32(msg.sender)
                                     gas gas_remaining wei
                                    args Mask(224, 32, arg2) << 224, mem[(32 * _17383) + ceil32(return_data.size) + 1220 len 4]
                                if not return_data.size:
                                    require not ext_call.success
                                    revert with 'SafeMath: subtraction overflow'
                                mem[(32 * _17383) + ceil32(return_data.size) + 1188 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if return_data.size:
                                    require return_data.size >= 32
                                    if not mem[(32 * _17383) + ceil32(return_data.size) + 1188]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[(32 * _17383) + ceil32(return_data.size) + ceil32(return_data.size) + 1267 len 22]
                    else:
                        if bonusEndBlock - poolInfo[arg1].field_512 / bonusEndBlock - poolInfo[arg1].field_512 != 1:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                        if block.number < bonusEndBlock:
                            revert with 0, 'SafeMath: addition overflow'
                        mem[224] = 30
                        mem[256] = 'SafeMath: subtraction overflow'
                        if startBlock > block.number:
                            revert with 0, 'SafeMath: subtraction overflow'
                        mem[288] = 26
                        mem[320] = 'SafeMath: division by zero'
                        if not halvingPeriod:
                            revert with 0, 'SafeMath: division by zero'
                        if not block.number - poolInfo[arg1].field_512:
                            mem[352] = 26
                            mem[384] = 'SafeMath: division by zero'
                            if not totalAllocPoint:
                                revert with 0, 'SafeMath: division by zero'
                            mem[416] = 26
                            mem[448] = 'SafeMath: division by zero'
                            if not 2^(block.number - startBlock / halvingPeriod):
                                revert with 0, 'SafeMath: division by zero'
                            mem[480] = 26
                            mem[512] = 'SafeMath: division by zero'
                            require ext_code.size(frogAddress)
                            call frogAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args this.address, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod)
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(frogAddress)
                            call frogAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args this.address, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[544] = 2
                            mem[576] = frogAddress
                            mem[608] = wbnbAddress
                            if block.timestamp + 1800 < block.timestamp:
                                revert with 0, 'SafeMath: addition overflow'
                            mem[640] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                            mem[644] = 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                            mem[676] = 0
                            mem[740] = fundsAddress
                            mem[772] = block.timestamp + 1800
                            mem[708] = 160
                            mem[804] = 2
                            mem[836 len 0] = None
                            require ext_code.size(routerAddress)
                            call routerAddress.swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20, 0, 160, fundsAddress, block.timestamp + 1800, 2, mem[836 len 64]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[640 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = ceil32(return_data.size) + 640
                            require return_data.size >= 32
                            _17153 = mem[640 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32
                            require mem[640 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 <= 4294967296
                            require mem[640 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 32 <= return_data.size
                            require mem[mem[640 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 640] <= 4294967296 and mem[640 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + (32 * mem[mem[640 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 640]) + 32 <= return_data.size
                            mem[ceil32(return_data.size) + 640] = mem[mem[640 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 640]
                            _17382 = mem[_17153 + 640]
                            mem[ceil32(return_data.size) + 672 len floor32(mem[_17153 + 640])] = mem[_17153 + 672 len floor32(mem[_17153 + 640])]
                            if not 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod):
                                if not ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: division by zero'
                                if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[arg1].field_512 = block.number
                                if not userInfo[arg1][msg.sender].field_0:
                                    if userInfo[arg1][msg.sender].field_256 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require ext_code.size(frogAddress)
                                    staticcall frogAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(frogAddress)
                                    if -userInfo[arg1][msg.sender].field_256 > ext_call.return_data[0]:
                                        call frogAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if arg2 > userInfo[arg1][msg.sender].field_0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        userInfo[arg1][msg.sender].field_0 -= arg2
                                        if userInfo[arg1][msg.sender].field_0 - arg2:
                                            if (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / userInfo[arg1][msg.sender].field_0 - arg2 != poolInfo[arg1].field_768:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * _17382) + ceil32(return_data.size) + 1029 len 31]
                                            userInfo[arg1][msg.sender].field_256 = (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / 10^12
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                                revert with 0, 'Address: call to non-contract'
                                            if not ext_code.hash(poolInfo[arg1].field_0):
                                                revert with 0, 'Address: call to non-contract'
                                            mem[(32 * _17382) + ceil32(return_data.size) + 1156 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                                        else:
                                            userInfo[arg1][msg.sender].field_256 = 0
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                                revert with 0, 'Address: call to non-contract'
                                            if not ext_code.hash(poolInfo[arg1].field_0):
                                                revert with 0, 'Address: call to non-contract'
                                            mem[(32 * _17382) + ceil32(return_data.size) + 1156 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                                            mem[(32 * _17382) + ceil32(return_data.size) + 1220 len 0] = 0
                                    else:
                                        call frogAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, -userInfo[arg1][msg.sender].field_256
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if arg2 > userInfo[arg1][msg.sender].field_0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        userInfo[arg1][msg.sender].field_0 -= arg2
                                        if not userInfo[arg1][msg.sender].field_0 - arg2:
                                            userInfo[arg1][msg.sender].field_256 = 0
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                                revert with 0, 'Address: call to non-contract'
                                            if not ext_code.hash(poolInfo[arg1].field_0):
                                                revert with 0, 'Address: call to non-contract'
                                            mem[(32 * _17382) + ceil32(return_data.size) + 1156 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                                        else:
                                            if (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / userInfo[arg1][msg.sender].field_0 - arg2 != poolInfo[arg1].field_768:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * _17382) + ceil32(return_data.size) + 1029 len 31]
                                            userInfo[arg1][msg.sender].field_256 = (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / 10^12
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                                revert with 0, 'Address: call to non-contract'
                                            if not ext_code.hash(poolInfo[arg1].field_0):
                                                revert with 0, 'Address: call to non-contract'
                                            mem[(32 * _17382) + ceil32(return_data.size) + 1156 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                                            mem[(32 * _17382) + ceil32(return_data.size) + 1220 len 0] = 0
                                else:
                                    if poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / userInfo[arg1][msg.sender].field_0 != poolInfo[arg1].field_768:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * _17382) + ceil32(return_data.size) + 837 len 31]
                                    if userInfo[arg1][msg.sender].field_256 > poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require ext_code.size(frogAddress)
                                    staticcall frogAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(frogAddress)
                                    if (poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12) - userInfo[arg1][msg.sender].field_256 <= ext_call.return_data[0]:
                                        call frogAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, (poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12) - userInfo[arg1][msg.sender].field_256
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if arg2 > userInfo[arg1][msg.sender].field_0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        userInfo[arg1][msg.sender].field_0 -= arg2
                                        if not userInfo[arg1][msg.sender].field_0 - arg2:
                                            userInfo[arg1][msg.sender].field_256 = 0
                                        else:
                                            if (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / userInfo[arg1][msg.sender].field_0 - arg2 != poolInfo[arg1].field_768:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * _17382) + ceil32(return_data.size) + 1029 len 31]
                                            userInfo[arg1][msg.sender].field_256 = (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / 10^12
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                            revert with 0, 'Address: call to non-contract'
                                        if not ext_code.hash(poolInfo[arg1].field_0):
                                            revert with 0, 'Address: call to non-contract'
                                        mem[(32 * _17382) + ceil32(return_data.size) + 1156 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                                    else:
                                        call frogAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if arg2 > userInfo[arg1][msg.sender].field_0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        userInfo[arg1][msg.sender].field_0 -= arg2
                                        if not userInfo[arg1][msg.sender].field_0 - arg2:
                                            userInfo[arg1][msg.sender].field_256 = 0
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                                revert with 0, 'Address: call to non-contract'
                                            if not ext_code.hash(poolInfo[arg1].field_0):
                                                revert with 0, 'Address: call to non-contract'
                                            mem[(32 * _17382) + ceil32(return_data.size) + 1156 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                                        else:
                                            if (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / userInfo[arg1][msg.sender].field_0 - arg2 != poolInfo[arg1].field_768:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * _17382) + ceil32(return_data.size) + 1029 len 31]
                                            userInfo[arg1][msg.sender].field_256 = (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / 10^12
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                                revert with 0, 'Address: call to non-contract'
                                            if not ext_code.hash(poolInfo[arg1].field_0):
                                                revert with 0, 'Address: call to non-contract'
                                            mem[(32 * _17382) + ceil32(return_data.size) + 1156 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                                            mem[(32 * _17382) + ceil32(return_data.size) + 1220 len 0] = 0
                            else:
                                if 10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) != 10^12:
                                    revert with 0, 
                                                32,
                                                33,
                                                0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                mem[(32 * _17382) + ceil32(return_data.size) + 773 len 31]
                                if not ext_call.return_data[0]:
                                    revert with 0, 'SafeMath: division by zero'
                                if (10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]
                                poolInfo[arg1].field_512 = block.number
                                if not userInfo[arg1][msg.sender].field_0:
                                    if userInfo[arg1][msg.sender].field_256 > 0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require ext_code.size(frogAddress)
                                    staticcall frogAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(frogAddress)
                                    if -userInfo[arg1][msg.sender].field_256 <= ext_call.return_data[0]:
                                        call frogAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, -userInfo[arg1][msg.sender].field_256
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if arg2 > userInfo[arg1][msg.sender].field_0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        userInfo[arg1][msg.sender].field_0 -= arg2
                                        if not userInfo[arg1][msg.sender].field_0 - arg2:
                                            userInfo[arg1][msg.sender].field_256 = 0
                                        else:
                                            if (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / userInfo[arg1][msg.sender].field_0 - arg2 != poolInfo[arg1].field_768:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * _17382) + ceil32(return_data.size) + 1029 len 31]
                                            userInfo[arg1][msg.sender].field_256 = (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / 10^12
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                            revert with 0, 'Address: call to non-contract'
                                        if not ext_code.hash(poolInfo[arg1].field_0):
                                            revert with 0, 'Address: call to non-contract'
                                        mem[(32 * _17382) + ceil32(return_data.size) + 1156 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                                    else:
                                        call frogAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if arg2 > userInfo[arg1][msg.sender].field_0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        userInfo[arg1][msg.sender].field_0 -= arg2
                                        if not userInfo[arg1][msg.sender].field_0 - arg2:
                                            userInfo[arg1][msg.sender].field_256 = 0
                                        else:
                                            if (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / userInfo[arg1][msg.sender].field_0 - arg2 != poolInfo[arg1].field_768:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * _17382) + ceil32(return_data.size) + 1029 len 31]
                                            userInfo[arg1][msg.sender].field_256 = (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / 10^12
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                            revert with 0, 'Address: call to non-contract'
                                        if not ext_code.hash(poolInfo[arg1].field_0):
                                            revert with 0, 'Address: call to non-contract'
                                        mem[(32 * _17382) + ceil32(return_data.size) + 1156 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                                        mem[(32 * _17382) + ceil32(return_data.size) + 1220 len 0] = 0
                                else:
                                    if poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / userInfo[arg1][msg.sender].field_0 != poolInfo[arg1].field_768:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * _17382) + ceil32(return_data.size) + 837 len 31]
                                    if userInfo[arg1][msg.sender].field_256 > poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    require ext_code.size(frogAddress)
                                    staticcall frogAddress.0x70a08231 with:
                                            gas gas_remaining wei
                                           args this.address
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    require ext_code.size(frogAddress)
                                    if (poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12) - userInfo[arg1][msg.sender].field_256 <= ext_call.return_data[0]:
                                        call frogAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, (poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12) - userInfo[arg1][msg.sender].field_256
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if arg2 > userInfo[arg1][msg.sender].field_0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        userInfo[arg1][msg.sender].field_0 -= arg2
                                        if userInfo[arg1][msg.sender].field_0 - arg2:
                                            if (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / userInfo[arg1][msg.sender].field_0 - arg2 != poolInfo[arg1].field_768:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * _17382) + ceil32(return_data.size) + 1029 len 31]
                                            userInfo[arg1][msg.sender].field_256 = (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / 10^12
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                                revert with 0, 'Address: call to non-contract'
                                            if not ext_code.hash(poolInfo[arg1].field_0):
                                                revert with 0, 'Address: call to non-contract'
                                            mem[(32 * _17382) + ceil32(return_data.size) + 1156 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                                        else:
                                            userInfo[arg1][msg.sender].field_256 = 0
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                                revert with 0, 'Address: call to non-contract'
                                            if not ext_code.hash(poolInfo[arg1].field_0):
                                                revert with 0, 'Address: call to non-contract'
                                            mem[(32 * _17382) + ceil32(return_data.size) + 1156 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                                            mem[(32 * _17382) + ceil32(return_data.size) + 1220 len 0] = 0
                                    else:
                                        call frogAddress.0xa9059cbb with:
                                             gas gas_remaining wei
                                            args msg.sender, ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if arg2 > userInfo[arg1][msg.sender].field_0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        userInfo[arg1][msg.sender].field_0 -= arg2
                                        if not userInfo[arg1][msg.sender].field_0 - arg2:
                                            userInfo[arg1][msg.sender].field_256 = 0
                                        else:
                                            if (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / userInfo[arg1][msg.sender].field_0 - arg2 != poolInfo[arg1].field_768:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * _17382) + ceil32(return_data.size) + 1029 len 31]
                                            userInfo[arg1][msg.sender].field_256 = (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / 10^12
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                            revert with 0, 'Address: call to non-contract'
                                        if not ext_code.hash(poolInfo[arg1].field_0):
                                            revert with 0, 'Address: call to non-contract'
                                        mem[(32 * _17382) + ceil32(return_data.size) + 1156 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                                        mem[(32 * _17382) + ceil32(return_data.size) + 1220 len 0] = 0
                            call poolInfo[arg1].field_0 with:
                               funct uint32(msg.sender)
                                 gas gas_remaining wei
                                args Mask(224, 32, arg2) << 224, mem[(32 * _17382) + ceil32(return_data.size) + 1220 len 4]
                            if not return_data.size:
                                require not ext_call.success
                                revert with 'SafeMath: subtraction overflow'
                            mem[(32 * _17382) + ceil32(return_data.size) + 1188 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                if return_data.size:
                                    revert with ext_call.return_data[0 len return_data.size]
                                revert with 0, 'SafeERC20: low-level call failed'
                            if return_data.size:
                                require return_data.size >= 32
                                if not mem[(32 * _17382) + ceil32(return_data.size) + 1188]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[(32 * _17382) + ceil32(return_data.size) + ceil32(return_data.size) + 1267 len 22]
                        else:
                            if (block.number * frogPerBlock) - (poolInfo[arg1].field_512 * frogPerBlock) / block.number - poolInfo[arg1].field_512 != frogPerBlock:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                            if not (block.number * frogPerBlock) - (poolInfo[arg1].field_512 * frogPerBlock):
                                mem[352] = 26
                                mem[384] = 'SafeMath: division by zero'
                                if not totalAllocPoint:
                                    revert with 0, 'SafeMath: division by zero'
                                mem[416] = 26
                                mem[448] = 'SafeMath: division by zero'
                                if not 2^(block.number - startBlock / halvingPeriod):
                                    revert with 0, 'SafeMath: division by zero'
                                mem[480] = 26
                                mem[512] = 'SafeMath: division by zero'
                                require ext_code.size(frogAddress)
                                call frogAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args this.address, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod)
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(frogAddress)
                                call frogAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args this.address, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[544] = 2
                                mem[576] = frogAddress
                                mem[608] = wbnbAddress
                                if block.timestamp + 1800 < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[640] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                mem[644] = 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                                mem[676] = 0
                                mem[740] = fundsAddress
                                mem[772] = block.timestamp + 1800
                                mem[708] = 160
                                mem[804] = 2
                                mem[836 len 0] = None
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20, 0, 160, fundsAddress, block.timestamp + 1800, 2, mem[836 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[640 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(return_data.size) + 640
                                require return_data.size >= 32
                                _17151 = mem[640 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32
                                require mem[640 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 <= 4294967296
                                require mem[640 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 32 <= return_data.size
                                require mem[mem[640 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 640] <= 4294967296 and mem[640 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + (32 * mem[mem[640 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 640]) + 32 <= return_data.size
                                mem[ceil32(return_data.size) + 640] = mem[mem[640 len 4], Mask(224, 32, 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 640]
                                _17381 = mem[_17151 + 640]
                                mem[ceil32(return_data.size) + 672 len floor32(mem[_17151 + 640])] = mem[_17151 + 672 len floor32(mem[_17151 + 640])]
                                if not 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod):
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: division by zero'
                                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                    poolInfo[arg1].field_512 = block.number
                                    if not userInfo[arg1][msg.sender].field_0:
                                        if userInfo[arg1][msg.sender].field_256 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require ext_code.size(frogAddress)
                                        staticcall frogAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(frogAddress)
                                        if -userInfo[arg1][msg.sender].field_256 <= ext_call.return_data[0]:
                                            call frogAddress.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, -userInfo[arg1][msg.sender].field_256
                                        else:
                                            call frogAddress.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if arg2 > userInfo[arg1][msg.sender].field_0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        userInfo[arg1][msg.sender].field_0 -= arg2
                                        if not userInfo[arg1][msg.sender].field_0 - arg2:
                                            userInfo[arg1][msg.sender].field_256 = 0
                                        else:
                                            if (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / userInfo[arg1][msg.sender].field_0 - arg2 != poolInfo[arg1].field_768:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * _17381) + ceil32(return_data.size) + 1029 len 31]
                                            userInfo[arg1][msg.sender].field_256 = (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / 10^12
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                            revert with 0, 'Address: call to non-contract'
                                        if not ext_code.hash(poolInfo[arg1].field_0):
                                            revert with 0, 'Address: call to non-contract'
                                        mem[(32 * _17381) + ceil32(return_data.size) + 1156 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                                    else:
                                        if poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / userInfo[arg1][msg.sender].field_0 != poolInfo[arg1].field_768:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * _17381) + ceil32(return_data.size) + 837 len 31]
                                        if userInfo[arg1][msg.sender].field_256 > poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require ext_code.size(frogAddress)
                                        staticcall frogAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(frogAddress)
                                        if (poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12) - userInfo[arg1][msg.sender].field_256 <= ext_call.return_data[0]:
                                            call frogAddress.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, (poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12) - userInfo[arg1][msg.sender].field_256
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if arg2 > userInfo[arg1][msg.sender].field_0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            userInfo[arg1][msg.sender].field_0 -= arg2
                                            if not userInfo[arg1][msg.sender].field_0 - arg2:
                                                userInfo[arg1][msg.sender].field_256 = 0
                                            else:
                                                if (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / userInfo[arg1][msg.sender].field_0 - arg2 != poolInfo[arg1].field_768:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * _17381) + ceil32(return_data.size) + 1029 len 31]
                                                userInfo[arg1][msg.sender].field_256 = (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / 10^12
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                                revert with 0, 'Address: call to non-contract'
                                            if not ext_code.hash(poolInfo[arg1].field_0):
                                                revert with 0, 'Address: call to non-contract'
                                            mem[(32 * _17381) + ceil32(return_data.size) + 1156 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                                        else:
                                            call frogAddress.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if arg2 > userInfo[arg1][msg.sender].field_0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            userInfo[arg1][msg.sender].field_0 -= arg2
                                            if userInfo[arg1][msg.sender].field_0 - arg2:
                                                if (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / userInfo[arg1][msg.sender].field_0 - arg2 != poolInfo[arg1].field_768:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * _17381) + ceil32(return_data.size) + 1029 len 31]
                                                userInfo[arg1][msg.sender].field_256 = (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / 10^12
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                                    revert with 0, 'Address: call to non-contract'
                                                if not ext_code.hash(poolInfo[arg1].field_0):
                                                    revert with 0, 'Address: call to non-contract'
                                                mem[(32 * _17381) + ceil32(return_data.size) + 1156 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                                            else:
                                                userInfo[arg1][msg.sender].field_256 = 0
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                                    revert with 0, 'Address: call to non-contract'
                                                if not ext_code.hash(poolInfo[arg1].field_0):
                                                    revert with 0, 'Address: call to non-contract'
                                                mem[(32 * _17381) + ceil32(return_data.size) + 1156 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                                                mem[(32 * _17381) + ceil32(return_data.size) + 1220 len 0] = 0
                                else:
                                    if 10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) != 10^12:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * _17381) + ceil32(return_data.size) + 773 len 31]
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: division by zero'
                                    if (10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]
                                    poolInfo[arg1].field_512 = block.number
                                    if not userInfo[arg1][msg.sender].field_0:
                                        if userInfo[arg1][msg.sender].field_256 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require ext_code.size(frogAddress)
                                        staticcall frogAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(frogAddress)
                                        if -userInfo[arg1][msg.sender].field_256 <= ext_call.return_data[0]:
                                            call frogAddress.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, -userInfo[arg1][msg.sender].field_256
                                        else:
                                            call frogAddress.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, ext_call.return_data[0]
                                    else:
                                        if poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / userInfo[arg1][msg.sender].field_0 != poolInfo[arg1].field_768:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * _17381) + ceil32(return_data.size) + 837 len 31]
                                        if userInfo[arg1][msg.sender].field_256 > poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require ext_code.size(frogAddress)
                                        staticcall frogAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(frogAddress)
                                        if (poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12) - userInfo[arg1][msg.sender].field_256 <= ext_call.return_data[0]:
                                            call frogAddress.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, (poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12) - userInfo[arg1][msg.sender].field_256
                                        else:
                                            call frogAddress.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, ext_call.return_data[0]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require return_data.size >= 32
                                    if arg2 > userInfo[arg1][msg.sender].field_0:
                                        revert with 0, 'SafeMath: subtraction overflow'
                                    userInfo[arg1][msg.sender].field_0 -= arg2
                                    if not userInfo[arg1][msg.sender].field_0 - arg2:
                                        userInfo[arg1][msg.sender].field_256 = 0
                                    else:
                                        if (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / userInfo[arg1][msg.sender].field_0 - arg2 != poolInfo[arg1].field_768:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * _17381) + ceil32(return_data.size) + 1029 len 31]
                                        userInfo[arg1][msg.sender].field_256 = (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / 10^12
                                    if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                        revert with 0, 'Address: call to non-contract'
                                    if not ext_code.hash(poolInfo[arg1].field_0):
                                        revert with 0, 'Address: call to non-contract'
                                    mem[(32 * _17381) + ceil32(return_data.size) + 1156 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                                call poolInfo[arg1].field_0 with:
                                   funct uint32(msg.sender)
                                     gas gas_remaining wei
                                    args Mask(224, 32, arg2) << 224, mem[(32 * _17381) + ceil32(return_data.size) + 1220 len 4]
                                if not return_data.size:
                                    require not ext_call.success
                                    revert with 'SafeMath: subtraction overflow'
                                mem[(32 * _17381) + ceil32(return_data.size) + 1188 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if return_data.size:
                                    require return_data.size >= 32
                                    if not mem[(32 * _17381) + ceil32(return_data.size) + 1188]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[(32 * _17381) + ceil32(return_data.size) + ceil32(return_data.size) + 1267 len 22]
                            else:
                                if (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / (block.number * frogPerBlock) - (poolInfo[arg1].field_512 * frogPerBlock) != poolInfo[arg1].field_256:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                mem[352] = 26
                                mem[384] = 'SafeMath: division by zero'
                                if not totalAllocPoint:
                                    revert with 0, 'SafeMath: division by zero'
                                mem[416] = 26
                                mem[448] = 'SafeMath: division by zero'
                                if not 2^(block.number - startBlock / halvingPeriod):
                                    revert with 0, 'SafeMath: division by zero'
                                mem[480] = 26
                                mem[512] = 'SafeMath: division by zero'
                                require ext_code.size(frogAddress)
                                call frogAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args this.address, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod)
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(frogAddress)
                                call frogAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args this.address, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[544] = 2
                                mem[576] = frogAddress
                                mem[608] = wbnbAddress
                                if block.timestamp + 1800 < block.timestamp:
                                    revert with 0, 'SafeMath: addition overflow'
                                mem[640] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                mem[644] = (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20
                                mem[676] = 0
                                mem[740] = fundsAddress
                                mem[772] = block.timestamp + 1800
                                mem[708] = 160
                                mem[804] = 2
                                mem[836 len 0] = None
                                require ext_code.size(routerAddress)
                                call routerAddress.swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20, 0, 160, fundsAddress, block.timestamp + 1800, 2, mem[836 len 64]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[640 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(return_data.size) + 640
                                require return_data.size >= 32
                                _17149 = mem[640 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32
                                require mem[640 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 <= 4294967296
                                require mem[640 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 32 <= return_data.size
                                require mem[mem[640 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 640] <= 4294967296 and mem[640 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + (32 * mem[mem[640 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 640]) + 32 <= return_data.size
                                mem[ceil32(return_data.size) + 640] = mem[mem[640 len 4], Mask(224, 32, (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / 20) >> 32 + 640]
                                _17380 = mem[_17149 + 640]
                                mem[ceil32(return_data.size) + 672 len floor32(mem[_17149 + 640])] = mem[_17149 + 672 len floor32(mem[_17149 + 640])]
                                if (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod):
                                    if 10^12 * (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) != 10^12:
                                        revert with 0, 
                                                    32,
                                                    33,
                                                    0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                    mem[(32 * _17380) + ceil32(return_data.size) + 773 len 31]
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: division by zero'
                                    if (10^12 * (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_768 += 10^12 * (block.number * frogPerBlock * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * frogPerBlock * poolInfo[arg1].field_256) / totalAllocPoint / 2^(block.number - startBlock / halvingPeriod) / ext_call.return_data[0]
                                    poolInfo[arg1].field_512 = block.number
                                    if userInfo[arg1][msg.sender].field_0:
                                        if poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / userInfo[arg1][msg.sender].field_0 != poolInfo[arg1].field_768:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * _17380) + ceil32(return_data.size) + 837 len 31]
                                        if userInfo[arg1][msg.sender].field_256 > poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require ext_code.size(frogAddress)
                                        staticcall frogAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(frogAddress)
                                        if (poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12) - userInfo[arg1][msg.sender].field_256 <= ext_call.return_data[0]:
                                            call frogAddress.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, (poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12) - userInfo[arg1][msg.sender].field_256
                                        else:
                                            call frogAddress.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, ext_call.return_data[0]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        if arg2 > userInfo[arg1][msg.sender].field_0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        userInfo[arg1][msg.sender].field_0 -= arg2
                                        if not userInfo[arg1][msg.sender].field_0 - arg2:
                                            userInfo[arg1][msg.sender].field_256 = 0
                                        else:
                                            if (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / userInfo[arg1][msg.sender].field_0 - arg2 != poolInfo[arg1].field_768:
                                                revert with 0, 
                                                            32,
                                                            33,
                                                            0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                            mem[(32 * _17380) + ceil32(return_data.size) + 1029 len 31]
                                            userInfo[arg1][msg.sender].field_256 = (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / 10^12
                                        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                            revert with 0, 'Address: call to non-contract'
                                        if not ext_code.hash(poolInfo[arg1].field_0):
                                            revert with 0, 'Address: call to non-contract'
                                        mem[(32 * _17380) + ceil32(return_data.size) + 1156 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                                    else:
                                        if userInfo[arg1][msg.sender].field_256 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require ext_code.size(frogAddress)
                                        staticcall frogAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(frogAddress)
                                        if -userInfo[arg1][msg.sender].field_256 > ext_call.return_data[0]:
                                            call frogAddress.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if arg2 > userInfo[arg1][msg.sender].field_0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            userInfo[arg1][msg.sender].field_0 -= arg2
                                            if not userInfo[arg1][msg.sender].field_0 - arg2:
                                                userInfo[arg1][msg.sender].field_256 = 0
                                            else:
                                                if (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / userInfo[arg1][msg.sender].field_0 - arg2 != poolInfo[arg1].field_768:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * _17380) + ceil32(return_data.size) + 1029 len 31]
                                                userInfo[arg1][msg.sender].field_256 = (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / 10^12
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                                revert with 0, 'Address: call to non-contract'
                                            if not ext_code.hash(poolInfo[arg1].field_0):
                                                revert with 0, 'Address: call to non-contract'
                                            mem[(32 * _17380) + ceil32(return_data.size) + 1156 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                                        else:
                                            call frogAddress.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, -userInfo[arg1][msg.sender].field_256
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if arg2 > userInfo[arg1][msg.sender].field_0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            userInfo[arg1][msg.sender].field_0 -= arg2
                                            if not userInfo[arg1][msg.sender].field_0 - arg2:
                                                userInfo[arg1][msg.sender].field_256 = 0
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                                    revert with 0, 'Address: call to non-contract'
                                                if not ext_code.hash(poolInfo[arg1].field_0):
                                                    revert with 0, 'Address: call to non-contract'
                                                mem[(32 * _17380) + ceil32(return_data.size) + 1156 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                                            else:
                                                if (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / userInfo[arg1][msg.sender].field_0 - arg2 != poolInfo[arg1].field_768:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * _17380) + ceil32(return_data.size) + 1029 len 31]
                                                userInfo[arg1][msg.sender].field_256 = (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / 10^12
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                                    revert with 0, 'Address: call to non-contract'
                                                if not ext_code.hash(poolInfo[arg1].field_0):
                                                    revert with 0, 'Address: call to non-contract'
                                                mem[(32 * _17380) + ceil32(return_data.size) + 1156 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                                                mem[(32 * _17380) + ceil32(return_data.size) + 1220 len 0] = 0
                                else:
                                    if not ext_call.return_data[0]:
                                        revert with 0, 'SafeMath: division by zero'
                                    if (0 / ext_call.return_data[0]) + poolInfo[arg1].field_768 < poolInfo[arg1].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                    poolInfo[arg1].field_512 = block.number
                                    if not userInfo[arg1][msg.sender].field_0:
                                        if userInfo[arg1][msg.sender].field_256 > 0:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require ext_code.size(frogAddress)
                                        staticcall frogAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(frogAddress)
                                        if -userInfo[arg1][msg.sender].field_256 <= ext_call.return_data[0]:
                                            call frogAddress.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, -userInfo[arg1][msg.sender].field_256
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if arg2 > userInfo[arg1][msg.sender].field_0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            userInfo[arg1][msg.sender].field_0 -= arg2
                                            if not userInfo[arg1][msg.sender].field_0 - arg2:
                                                userInfo[arg1][msg.sender].field_256 = 0
                                            else:
                                                if (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / userInfo[arg1][msg.sender].field_0 - arg2 != poolInfo[arg1].field_768:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * _17380) + ceil32(return_data.size) + 1029 len 31]
                                                userInfo[arg1][msg.sender].field_256 = (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / 10^12
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                                revert with 0, 'Address: call to non-contract'
                                            if not ext_code.hash(poolInfo[arg1].field_0):
                                                revert with 0, 'Address: call to non-contract'
                                            mem[(32 * _17380) + ceil32(return_data.size) + 1156 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                                        else:
                                            call frogAddress.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if arg2 > userInfo[arg1][msg.sender].field_0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            userInfo[arg1][msg.sender].field_0 -= arg2
                                            if userInfo[arg1][msg.sender].field_0 - arg2:
                                                if (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / userInfo[arg1][msg.sender].field_0 - arg2 != poolInfo[arg1].field_768:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * _17380) + ceil32(return_data.size) + 1029 len 31]
                                                userInfo[arg1][msg.sender].field_256 = (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / 10^12
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                                    revert with 0, 'Address: call to non-contract'
                                                if not ext_code.hash(poolInfo[arg1].field_0):
                                                    revert with 0, 'Address: call to non-contract'
                                                mem[(32 * _17380) + ceil32(return_data.size) + 1156 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                                            else:
                                                userInfo[arg1][msg.sender].field_256 = 0
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                                    revert with 0, 'Address: call to non-contract'
                                                if not ext_code.hash(poolInfo[arg1].field_0):
                                                    revert with 0, 'Address: call to non-contract'
                                                mem[(32 * _17380) + ceil32(return_data.size) + 1156 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                                                mem[(32 * _17380) + ceil32(return_data.size) + 1220 len 0] = 0
                                    else:
                                        if poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / userInfo[arg1][msg.sender].field_0 != poolInfo[arg1].field_768:
                                            revert with 0, 
                                                        32,
                                                        33,
                                                        0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                        mem[(32 * _17380) + ceil32(return_data.size) + 837 len 31]
                                        if userInfo[arg1][msg.sender].field_256 > poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12:
                                            revert with 0, 'SafeMath: subtraction overflow'
                                        require ext_code.size(frogAddress)
                                        staticcall frogAddress.0x70a08231 with:
                                                gas gas_remaining wei
                                               args this.address
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 32
                                        require ext_code.size(frogAddress)
                                        if (poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12) - userInfo[arg1][msg.sender].field_256 > ext_call.return_data[0]:
                                            call frogAddress.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, ext_call.return_data[0]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if arg2 > userInfo[arg1][msg.sender].field_0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            userInfo[arg1][msg.sender].field_0 -= arg2
                                            if not userInfo[arg1][msg.sender].field_0 - arg2:
                                                userInfo[arg1][msg.sender].field_256 = 0
                                            else:
                                                if (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / userInfo[arg1][msg.sender].field_0 - arg2 != poolInfo[arg1].field_768:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * _17380) + ceil32(return_data.size) + 1029 len 31]
                                                userInfo[arg1][msg.sender].field_256 = (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / 10^12
                                            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                                revert with 0, 'Address: call to non-contract'
                                            if not ext_code.hash(poolInfo[arg1].field_0):
                                                revert with 0, 'Address: call to non-contract'
                                            mem[(32 * _17380) + ceil32(return_data.size) + 1156 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                                        else:
                                            call frogAddress.0xa9059cbb with:
                                                 gas gas_remaining wei
                                                args msg.sender, (poolInfo[arg1].field_768 * userInfo[arg1][msg.sender].field_0 / 10^12) - userInfo[arg1][msg.sender].field_256
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            require return_data.size >= 32
                                            if arg2 > userInfo[arg1][msg.sender].field_0:
                                                revert with 0, 'SafeMath: subtraction overflow'
                                            userInfo[arg1][msg.sender].field_0 -= arg2
                                            if not userInfo[arg1][msg.sender].field_0 - arg2:
                                                userInfo[arg1][msg.sender].field_256 = 0
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                                    revert with 0, 'Address: call to non-contract'
                                                if not ext_code.hash(poolInfo[arg1].field_0):
                                                    revert with 0, 'Address: call to non-contract'
                                                mem[(32 * _17380) + ceil32(return_data.size) + 1156 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                                            else:
                                                if (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / userInfo[arg1][msg.sender].field_0 - arg2 != poolInfo[arg1].field_768:
                                                    revert with 0, 
                                                                32,
                                                                33,
                                                                0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                                                mem[(32 * _17380) + ceil32(return_data.size) + 1029 len 31]
                                                userInfo[arg1][msg.sender].field_256 = (userInfo[arg1][msg.sender].field_0 * poolInfo[arg1].field_768) - (arg2 * poolInfo[arg1].field_768) / 10^12
                                                if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(poolInfo[arg1].field_0):
                                                    revert with 0, 'Address: call to non-contract'
                                                if not ext_code.hash(poolInfo[arg1].field_0):
                                                    revert with 0, 'Address: call to non-contract'
                                                mem[(32 * _17380) + ceil32(return_data.size) + 1156 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                                                mem[(32 * _17380) + ceil32(return_data.size) + 1220 len 0] = 0
                                call poolInfo[arg1].field_0 with:
                                   funct uint32(msg.sender)
                                     gas gas_remaining wei
                                    args Mask(224, 32, arg2) << 224, mem[(32 * _17380) + ceil32(return_data.size) + 1220 len 4]
                                if not return_data.size:
                                    require not ext_call.success
                                    revert with 'SafeMath: subtraction overflow'
                                mem[(32 * _17380) + ceil32(return_data.size) + 1188 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                if not ext_call.success:
                                    if return_data.size:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    revert with 0, 'SafeERC20: low-level call failed'
                                if return_data.size:
                                    require return_data.size >= 32
                                    if not mem[(32 * _17380) + ceil32(return_data.size) + 1188]:
                                        revert with 0, 
                                                    32,
                                                    42,
                                                    0x725361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                    mem[(32 * _17380) + ceil32(return_data.size) + ceil32(return_data.size) + 1267 len 22]
    emit Withdraw(arg2, msg.sender, arg1);
}



}

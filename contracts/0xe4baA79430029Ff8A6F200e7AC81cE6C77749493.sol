contract main {




// =====================  Runtime code  =====================


#
#  - sub_1bcc337f(?)
#
address owner;

function owner() {
    return owner
}

function _fallback() payable {
    revert
}

function renounceOwnership() {
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    emit OwnershipTransferred(owner, 0);
    owner = 0
}

function transferOwnership(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    38,
                    0xfe4f776e61626c653a206e6577206f776e657220697320746865207a65726f20616464726573,
                    mem[202 len 26]
    emit OwnershipTransferred(owner, arg1);
    owner = arg1
}

function sub_9c3f6bca(?) payable {
    require calldata.size - 4 >= 128
    require arg1 == address(arg1)
    require arg2 == address(arg2)
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    mem[96] = 2
    mem[128] = 0xbb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c
    mem[160] = address(arg2)
    mem[192] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
    mem[196] = arg3
    mem[228] = 64
    mem[260] = 2
    idx = 0
    s = 128
    t = 292
    while idx < 2:
        mem[t] = mem[s + 12 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require ext_code.size(address(arg1))
    staticcall address(arg1).getAmountsIn(uint256 rg1, address[] rg2) with:
            gas gas_remaining wei
           args arg3, Array(len=2, data=mem[292 len 64])
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    mem[192 len return_data.size] = ext_call.return_data[0 len return_data.size]
    mem[64] = ceil32(return_data.size) + 192
    require return_data.size >= 32
    _32 = mem[192 len 4], Mask(224, 32, arg3) >> 32
    require mem[192 len 4], Mask(224, 32, arg3) >> 32 <= test266151307()
    require return_data.size + 192 > mem[192 len 4], Mask(224, 32, arg3) >> 32 + 223
    _33 = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
    require mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192] <= test266151307()
    require (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 32 >= 0 and ceil32(return_data.size) + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 224 <= test266151307()
    mem[64] = ceil32(return_data.size) + (32 * mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]) + 224
    mem[ceil32(return_data.size) + 192] = mem[mem[192 len 4], Mask(224, 32, arg3) >> 32 + 192]
    require return_data.size >= _32 + (32 * _33) + 32
    mem[ceil32(return_data.size) + 224 len 32 * _33] = mem[_32 + 224 len 32 * _33]
    require 0 < _33
    _52 = mem[ceil32(return_data.size) + 224]
    mem[mem[64]] = 0xfb3bdb4100000000000000000000000000000000000000000000000000000000
    mem[mem[64] + 4] = arg3
    mem[mem[64] + 36] = 128
    mem[mem[64] + 132] = 2
    idx = 0
    s = 128
    t = mem[64] + 164
    while idx < 2:
        mem[t] = mem[s + 12 len 20]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    mem[mem[64] + 68] = this.address
    mem[mem[64] + 100] = block.timestamp + arg4
    require ext_code.size(address(arg1))
    call address(arg1).swapETHForExactTokens(uint256 rg1, address[] rg2, address rg3, uint256 rg4) with:
       value _52 wei
         gas gas_remaining wei
        args arg3, Array(len=2, data=mem[mem[64] + 164 len 64]), address(this.address), block.timestamp + arg4
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _67 = mem[64]
    mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    require mem[_67] <= test266151307()
    require _67 + return_data.size > _67 + mem[_67] + 31
    require mem[_67 + mem[_67]] <= test266151307()
    require (32 * mem[_67 + mem[_67]]) + 32 >= 0 and _67 + ceil32(return_data.size) + (32 * mem[_67 + mem[_67]]) + 32 <= test266151307()
    require return_data.size >= mem[_67] + (32 * mem[_67 + mem[_67]]) + 32
    call msg.sender with:
       value eth.balance(this.address) wei
         gas gas_remaining wei
}

function withdraw(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not arg1:
        call msg.sender with:
           value eth.balance(this.address) wei
             gas 2300 * is_zero(value) wei
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
    else:
        mem[100] = this.address
        require ext_code.size(arg1)
        staticcall arg1.balanceOf(address rg1) with:
                gas gas_remaining wei
               args this.address
        mem[96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        mem[ceil32(return_data.size) + 132] = msg.sender
        mem[ceil32(return_data.size) + 164] = ext_call.return_data[0]
        mem[ceil32(return_data.size) + 96] = 68
        mem[ceil32(return_data.size) + 132 len 28] = Mask(224, 32, msg.sender) >> 32
        mem[ceil32(return_data.size) + 128 len 4] = transfer(address rg1, uint256 rg2)
        mem[ceil32(return_data.size) + 196] = 32
        mem[ceil32(return_data.size) + 228] = 'SafeERC20: low-level call failed'
        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(arg1):
            revert with 0, 'Address: call to non-contract'
        if not ext_code.hash(arg1):
            revert with 0, 'Address: call to non-contract'
        mem[ceil32(return_data.size) + 260 len 64] = transfer(address rg1, uint256 rg2), msg.sender, ext_call.return_data[0 len 28]
        mem[ceil32(return_data.size) + 352 len 4] = 0
        mem[ceil32(return_data.size) + 324 len 0] = 0
        call arg1 with:
           funct uint32(msg.sender)
             gas gas_remaining wei
            args Mask(480, -256, ext_call.return_data[0 len 28]) << 256, mem[ceil32(return_data.size) + 324 len 4]
        if not return_data.size:
            if not ext_call.success:
                if ext_call.return_data[0]:
                    revert with memory
                      from 128
                       len ext_call.return_data[0]
                revert with 0, 'SafeERC20: low-level call failed'
            if ext_call.return_data[0]:
                require ext_call.return_data[0] >= 32
                if not 0, mem[132 len 28]:
                    revert with 0, 
                                32,
                                42,
                                0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                mem[ceil32(return_data.size) + 370 len 22]
        else:
            mem[ceil32(return_data.size) + 292 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not ext_call.success:
                if return_data.size:
                    revert with ext_call.return_data[0 len return_data.size]
                revert with 0, 'SafeERC20: low-level call failed'
            if return_data.size:
                require return_data.size >= 32
                if not mem[ceil32(return_data.size) + 292]:
                    revert with 0, 
                                32,
                                42,
                                0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                mem[ceil32(return_data.size) + ceil32(return_data.size) + 371 len 22]
}

function sub_ed05e63d(?) payable {
    mem[64] = 96
    require calldata.size - 4 >= 128
    require cd[4] <= test266151307()
    require cd[4] + 35 < calldata.size
    require ('cd', 4).length <= test266151307()
    require cd[4] + (32 * ('cd', 4).length) + 36 <= calldata.size
    require cd[36] <= test266151307()
    require cd[36] + 35 < calldata.size
    require ('cd', 36).length <= test266151307()
    require cd[36] + (32 * ('cd', 36).length) + 36 <= calldata.size
    require cd[68] <= test266151307()
    require cd[68] + 35 < calldata.size
    require ('cd', 68).length <= test266151307()
    require cd[68] + (32 * ('cd', 68).length) + 36 <= calldata.size
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    idx = 0
    while idx < ('cd', 36).length:
        require idx < ('cd', 4).length
        require cd[((32 * idx) + cd[4] + 36)] == address(cd[((32 * idx) + cd[4] + 36)])
        require idx < ('cd', 36).length
        require cd[((32 * idx) + cd[36] + 36)] == address(cd[((32 * idx) + cd[36] + 36)])
        require idx < ('cd', 68).length
        if owner != msg.sender:
            revert with 0, 'Ownable: caller is not the owner'
        _34 = mem[64]
        mem[mem[64]] = 2
        mem[64] = mem[64] + 96
        require 0 < mem[_34]
        mem[_34 + 32] = 0xbb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c
        require 1 < mem[_34]
        mem[_34 + 64] = address(cd[((32 * idx) + cd[36] + 36)])
        mem[_34 + 96] = 0x1f00ca7400000000000000000000000000000000000000000000000000000000
        mem[_34 + 100] = cd[((32 * idx) + cd[68] + 36)]
        mem[_34 + 132] = 64
        mem[_34 + 164] = mem[_34]
        s = 0
        t = _34 + 32
        u = _34 + 196
        while s < mem[_34]:
            mem[u] = mem[t + 12 len 20]
            s = s + 1
            t = t + 32
            u = u + 32
            continue 
        require ext_code.size(address(cd[((32 * idx) + cd[4] + 36)]))
        staticcall address(cd[((32 * idx) + cd[4] + 36)]).mem[mem[64] len 4] with:
                gas gas_remaining wei
               args mem[mem[64] + 4 len _34 + (32 * mem[_34]) + -mem[64] + 192]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _61 = mem[64]
        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _62 = mem[_61]
        require mem[_61] <= test266151307()
        require _61 + return_data.size > _61 + mem[_61] + 31
        _63 = mem[_61 + mem[_61]]
        require mem[_61 + mem[_61]] <= test266151307()
        require (32 * mem[_61 + mem[_61]]) + 32 >= 0 and _61 + ceil32(return_data.size) + (32 * mem[_61 + mem[_61]]) + 32 <= test266151307()
        mem[64] = _61 + ceil32(return_data.size) + (32 * mem[_61 + mem[_61]]) + 32
        mem[_61 + ceil32(return_data.size)] = _63
        require return_data.size >= _62 + (32 * _63) + 32
        t = _61 + _62 + 32
        u = _61 + ceil32(return_data.size) + 32
        s = 0
        while s < _63:
            mem[u] = mem[t]
            t = t + 32
            u = u + 32
            s = s + 1
            continue 
        require 0 < _63
        _79 = mem[_61 + ceil32(return_data.size) + 32]
        _80 = mem[64]
        mem[mem[64]] = 0xfb3bdb4100000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = cd[((32 * idx) + cd[68] + 36)]
        mem[mem[64] + 36] = 128
        _81 = mem[_34]
        mem[mem[64] + 132] = mem[_34]
        s = 0
        t = _34 + 32
        u = mem[64] + 164
        while s < _81:
            mem[u] = mem[t + 12 len 20]
            s = s + 1
            t = t + 32
            u = u + 32
            continue 
        mem[_80 + 68] = this.address
        mem[_80 + 100] = block.timestamp + cd[100]
        require ext_code.size(address(cd[((32 * idx) + cd[4] + 36)]))
        call address(cd[((32 * idx) + cd[4] + 36)]).mem[mem[64] len 4] with:
           value _79 wei
             gas gas_remaining wei
            args mem[mem[64] + 4 len _80 + (32 * _81) + -mem[64] + 160]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _91 = mem[64]
        mem[mem[64] len return_data.size] = ext_call.return_data[0 len return_data.size]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _92 = mem[_91]
        require mem[_91] <= test266151307()
        require _91 + return_data.size > _91 + mem[_91] + 31
        _93 = mem[_91 + mem[_91]]
        require mem[_91 + mem[_91]] <= test266151307()
        require (32 * mem[_91 + mem[_91]]) + 32 >= 0 and _91 + ceil32(return_data.size) + (32 * mem[_91 + mem[_91]]) + 32 <= test266151307()
        mem[64] = _91 + ceil32(return_data.size) + (32 * mem[_91 + mem[_91]]) + 32
        mem[_91 + ceil32(return_data.size)] = _93
        require return_data.size >= _92 + (32 * _93) + 32
        t = _91 + _92 + 32
        u = _91 + ceil32(return_data.size) + 32
        s = 0
        while s < _93:
            mem[u] = mem[t]
            t = t + 32
            u = u + 32
            s = s + 1
            continue 
        idx = idx + 1
        continue 
    call msg.sender with:
       value eth.balance(this.address) wei
         gas gas_remaining wei
}

function sub_bc08f724(?) payable {
    mem[64] = 96
    require not msg.value
    require calldata.size - 4 >= 32
    require cd[4] <= test266151307()
    require cd[4] + 35 < calldata.size
    require ('cd', 4).length <= test266151307()
    require cd[4] + (32 * ('cd', 4).length) + 36 <= calldata.size
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    idx = 0
    while idx < ('cd', 4).length:
        require cd[((32 * idx) + cd[4] + 36)] == address(cd[((32 * idx) + cd[4] + 36)])
        mem[mem[64] + 4] = this.address
        require ext_code.size(address(cd[((32 * idx) + cd[4] + 36)]))
        staticcall address(cd[((32 * idx) + cd[4] + 36)]).balanceOf(address rg1) with:
                gas gas_remaining wei
               args address(this.address)
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _52 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _53 = mem[_52]
        require idx < ('cd', 4).length
        require cd[((32 * idx) + cd[4] + 36)] == address(cd[((32 * idx) + cd[4] + 36)])
        _54 = mem[64]
        mem[mem[64] + 36] = msg.sender
        mem[mem[64] + 68] = _53
        _55 = mem[64]
        mem[mem[64]] = 68
        mem[64] = mem[64] + 100
        mem[_55 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_55 + 36 len 28]
        mem[64] = _54 + 164
        mem[_54 + 100] = 32
        mem[_54 + 132] = 'SafeERC20: low-level call failed'
        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(address(cd[((32 * idx) + cd[4] + 36)])):
            revert with 0, 'Address: call to non-contract'
        if not ext_code.hash(address(cd[((32 * idx) + cd[4] + 36)])):
            revert with 0, 'Address: call to non-contract'
        _61 = mem[_55]
        t = _55 + 32
        u = mem[64]
        s = mem[_55]
        while s >= 32:
            mem[u] = mem[t]
            t = t + 32
            u = u + 32
            s = s - 32
            continue 
        mem[mem[64] + floor32(mem[_55])] = mem[_55 + floor32(mem[_55]) + -(mem[_55] % 32) + 64 len mem[_55] % 32] or Mask(8 * -(mem[_55] % 32) + 32, -(8 * -(mem[_55] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_55])])
        call address(cd[((32 * idx) + cd[4] + 36)]).mem[mem[64] len 4] with:
             gas gas_remaining wei
            args mem[mem[64] + 4 len _61 + _54 + -mem[64] + 160]
        if not return_data.size:
            if ext_call.success:
                if mem[96]:
                    require mem[96] >= 32
                    if not mem[128]:
                        revert with 0, 
                                    32,
                                    42,
                                    0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                    mem[mem[64] + 110 len 22]
                idx = idx + 1
                continue 
            if mem[96]:
                revert with memory
                  from 128
                   len mem[96]
            _104 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = mem[_54 + 100]
            _106 = mem[_54 + 100]
            idx = 0
            while idx < _106:
                mem[idx + _104 + 68] = mem[idx + _54 + 132]
                idx = idx + 32
                continue 
            if not _106 % 32:
                revert with memory
                  from mem[64]
                   len _106 + _104 + -mem[64] + 68
            mem[floor32(_106) + _104 + 68] = mem[floor32(_106) + _104 + -(_106 % 32) + 100 len _106 % 32]
            revert with memory
              from mem[64]
               len floor32(_106) + _104 + -mem[64] + 100
        _101 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size) + 1
        mem[_101] = return_data.size
        mem[_101 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
        if ext_call.success:
            if return_data.size:
                require return_data.size >= 32
                if not mem[_101 + 32]:
                    revert with 0, 
                                32,
                                42,
                                0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                mem[mem[64] + 110 len 22]
            idx = idx + 1
            continue 
        if return_data.size:
            revert with ext_call.return_data[0 len return_data.size]
        _108 = mem[64]
        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 32
        mem[mem[64] + 36] = mem[_54 + 100]
        _110 = mem[_54 + 100]
        idx = 0
        while idx < _110:
            mem[idx + _108 + 68] = mem[idx + _54 + 132]
            idx = idx + 32
            continue 
        if not _110 % 32:
            revert with memory
              from mem[64]
               len _110 + _108 + -mem[64] + 68
        mem[floor32(_110) + _108 + 68] = mem[floor32(_110) + _108 + -(_110 % 32) + 100 len _110 % 32]
        revert with memory
          from mem[64]
           len floor32(_110) + _108 + -mem[64] + 100
}

function sub_a7006693(?) {
    require calldata.size - 4 >= 64
    require cd[4] <= test266151307()
    require cd[4] + 35 < calldata.size
    require ('cd', 4).length <= test266151307()
    require cd[4] + (64 * ('cd', 4).length) + 36 <= calldata.size
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    require 0 < ('cd', 4).length
    require ('cd', 4)[1] == address(('cd', 4)[1])
    require ext_code.size(address(('cd', 4)[1]))
    staticcall address(('cd', 4)[1]).getReserves() with:
            gas gas_remaining wei
    mem[96 len 96] = ext_call.return_data[0 len 96]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 96
    require ext_call.return_data[0] == ext_call.return_data[18 len 14]
    require ext_call.return_data[32] == ext_call.return_data[50 len 14]
    require ext_call.return_data[64] == ext_call.return_data[92 len 4]
    require 1 < ('cd', 4).length
    require ('cd', 4)[2] == address(('cd', 4)[2])
    require ext_code.size(address(('cd', 4)[1]))
    staticcall address(('cd', 4)[1]).token0() with:
            gas gas_remaining wei
    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    require ('cd', 4).length
    require ('cd', 4)[0] == address(('cd', 4)[0])
    mem[(2 * ceil32(return_data.size)) + 100] = cd[36]
    if ext_call.return_data[12 len 20] == address(('cd', 4)[2]):
        mem[(2 * ceil32(return_data.size)) + 132] = Mask(112, 0, ext_call.return_data[0])
        mem[(2 * ceil32(return_data.size)) + 164] = Mask(112, 0, ext_call.return_data[32])
        require ext_code.size(address(('cd', 4)[0]))
        staticcall address(('cd', 4)[0]).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                gas gas_remaining wei
               args cd[36], ext_call.return_data[0] << 144, Mask(112, 0, ext_call.return_data[32])
        mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_code.size(address(('cd', 4)[1]))
        staticcall address(('cd', 4)[1]).token0() with:
                gas gas_remaining wei
        mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        require 1 < ('cd', 4).length
        require ('cd', 4)[2] == address(('cd', 4)[2])
        require 3 < ('cd', 4).length
        require ('cd', 4)[6] == address(('cd', 4)[6])
        mem[(6 * ceil32(return_data.size)) + 100] = this.address
        require ext_code.size(address(('cd', 4)[6]))
        staticcall address(('cd', 4)[6]).balanceOf(address rg1) with:
                gas gas_remaining wei
               args this.address
        mem[(6 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[64] = (7 * ceil32(return_data.size)) + 96
        require return_data.size >= 32
        mem[(7 * ceil32(return_data.size)) + 128] = cd[36]
        mem[(7 * ceil32(return_data.size)) + 160] = ext_call.return_data[0]
        mem[(7 * ceil32(return_data.size)) + 192] = 96
        mem[(7 * ceil32(return_data.size)) + 224] = ('cd', 4).length
        idx = 0
        s = (7 * ceil32(return_data.size)) + 256
        t = cd[4] + 36
        while idx < ('cd', 4).length:
            u = 0
            v = t
            w = s
            while u < 2:
                require cd[v] == address(cd[v])
                mem[w] = address(cd[v])
                u = u + 1
                v = v + 32
                w = w + 32
                continue 
            idx = idx + 1
            s = s + 64
            t = t + 64
            continue 
        if address(('cd', 4)[2]) == ext_call.return_data[12 len 20]:
            _85 = mem[64]
            mem[64] = s
            mem[s] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
            mem[s + 4] = 0
            mem[s + 36] = ext_call.return_data[0]
            mem[s + 68] = this.address
            mem[s + 100] = 128
            _93 = mem[_85]
            mem[s + 132] = mem[_85]
            mem[s + 164 len ceil32(_93)] = mem[_85 + 32 len ceil32(_93)]
            if ceil32(_93) > _93:
                mem[s + _93 + 164] = 0
            require ext_code.size(address(('cd', 4)[1]))
            call address(('cd', 4)[1]).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, ext_call.return_data[0], address(this.address), 128, mem[s + 132 len ceil32(_93) + 32]
        else:
            _87 = mem[64]
            mem[64] = s
            mem[s] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
            mem[s + 4] = ext_call.return_data[0]
            mem[s + 36] = 0
            mem[s + 68] = this.address
            mem[s + 100] = 128
            _94 = mem[_87]
            mem[s + 132] = mem[_87]
            mem[s + 164 len ceil32(_94)] = mem[_87 + 32 len ceil32(_94)]
            if ceil32(_94) > _94:
                mem[s + _94 + 164] = 0
            require ext_code.size(address(('cd', 4)[1]))
            call address(('cd', 4)[1]).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args ext_call.return_data[0], 0, address(this.address), 128, mem[s + 132 len ceil32(_94) + 32]
    else:
        mem[(2 * ceil32(return_data.size)) + 132] = Mask(112, 0, ext_call.return_data[32])
        mem[(2 * ceil32(return_data.size)) + 164] = Mask(112, 0, ext_call.return_data[0])
        require ext_code.size(address(('cd', 4)[0]))
        staticcall address(('cd', 4)[0]).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                gas gas_remaining wei
               args cd[36], ext_call.return_data[32] << 144, Mask(112, 0, ext_call.return_data[0])
        mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_code.size(address(('cd', 4)[1]))
        staticcall address(('cd', 4)[1]).token0() with:
                gas gas_remaining wei
        mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        require 1 < ('cd', 4).length
        require ('cd', 4)[2] == address(('cd', 4)[2])
        require 3 < ('cd', 4).length
        require ('cd', 4)[6] == address(('cd', 4)[6])
        mem[(6 * ceil32(return_data.size)) + 100] = this.address
        require ext_code.size(address(('cd', 4)[6]))
        staticcall address(('cd', 4)[6]).balanceOf(address rg1) with:
                gas gas_remaining wei
               args this.address
        mem[(6 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[64] = (7 * ceil32(return_data.size)) + 96
        require return_data.size >= 32
        mem[(7 * ceil32(return_data.size)) + 128] = cd[36]
        mem[(7 * ceil32(return_data.size)) + 160] = ext_call.return_data[0]
        mem[(7 * ceil32(return_data.size)) + 192] = 96
        mem[(7 * ceil32(return_data.size)) + 224] = ('cd', 4).length
        idx = 0
        s = (7 * ceil32(return_data.size)) + 256
        t = cd[4] + 36
        while idx < ('cd', 4).length:
            u = 0
            v = t
            w = s
            while u < 2:
                require cd[v] == address(cd[v])
                mem[w] = address(cd[v])
                u = u + 1
                v = v + 32
                w = w + 32
                continue 
            idx = idx + 1
            s = s + 64
            t = t + 64
            continue 
        if address(('cd', 4)[2]) == ext_call.return_data[12 len 20]:
            _89 = mem[64]
            mem[64] = s
            mem[s] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
            mem[s + 4] = 0
            mem[s + 36] = ext_call.return_data[0]
            mem[s + 68] = this.address
            mem[s + 100] = 128
            _95 = mem[_89]
            mem[s + 132] = mem[_89]
            mem[s + 164 len ceil32(_95)] = mem[_89 + 32 len ceil32(_95)]
            if ceil32(_95) > _95:
                mem[s + _95 + 164] = 0
            require ext_code.size(address(('cd', 4)[1]))
            call address(('cd', 4)[1]).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, ext_call.return_data[0], address(this.address), 128, mem[s + 132 len ceil32(_95) + 32]
        else:
            _91 = mem[64]
            mem[64] = s
            mem[s] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
            mem[s + 4] = ext_call.return_data[0]
            mem[s + 36] = 0
            mem[s + 68] = this.address
            mem[s + 100] = 128
            _96 = mem[_91]
            mem[s + 132] = mem[_91]
            mem[s + 164 len ceil32(_96)] = mem[_91 + 32 len ceil32(_96)]
            if ceil32(_96) > _96:
                mem[s + _96 + 164] = 0
            require ext_code.size(address(('cd', 4)[1]))
            call address(('cd', 4)[1]).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args ext_call.return_data[0], 0, address(this.address), 128, mem[s + 132 len ceil32(_96) + 32]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
}

function sub_fe295968(?) {
    require calldata.size - 4 >= 64
    require cd[4] <= test266151307()
    require cd[4] + 35 < calldata.size
    require ('cd', 4).length <= test266151307()
    require cd[4] + (64 * ('cd', 4).length) + 36 <= calldata.size
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    require 1 < ('cd', 4).length
    require ('cd', 4)[2] == address(('cd', 4)[2])
    mem[100] = this.address
    require ext_code.size(address(('cd', 4)[2]))
    staticcall address(('cd', 4)[2]).balanceOf(address rg1) with:
            gas gas_remaining wei
           args this.address
    mem[96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require 0 < ('cd', 4).length
    require ('cd', 4)[1] == address(('cd', 4)[1])
    require ext_code.size(address(('cd', 4)[1]))
    staticcall address(('cd', 4)[1]).getReserves() with:
            gas gas_remaining wei
    mem[ceil32(return_data.size) + 96 len 96] = ext_call.return_data[0 len 96]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 96
    require ext_call.return_data[0] == ext_call.return_data[18 len 14]
    require ext_call.return_data[32] == ext_call.return_data[50 len 14]
    require ext_call.return_data[64] == ext_call.return_data[92 len 4]
    require 1 < ('cd', 4).length
    require ('cd', 4)[2] == address(('cd', 4)[2])
    require ext_code.size(address(('cd', 4)[1]))
    staticcall address(('cd', 4)[1]).token0() with:
            gas gas_remaining wei
    mem[(2 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    require ('cd', 4).length
    require ('cd', 4)[0] == address(('cd', 4)[0])
    mem[(4 * ceil32(return_data.size)) + 100] = cd[36]
    if ext_call.return_data[12 len 20] == address(('cd', 4)[2]):
        mem[(4 * ceil32(return_data.size)) + 132] = Mask(112, 0, ext_call.return_data[0])
        mem[(4 * ceil32(return_data.size)) + 164] = Mask(112, 0, ext_call.return_data[32])
        require ext_code.size(address(('cd', 4)[0]))
        staticcall address(('cd', 4)[0]).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                gas gas_remaining wei
               args cd[36], ext_call.return_data[0] << 144, Mask(112, 0, ext_call.return_data[32])
        mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_code.size(address(('cd', 4)[1]))
        staticcall address(('cd', 4)[1]).token0() with:
                gas gas_remaining wei
        mem[(6 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        require 1 < ('cd', 4).length
        require ('cd', 4)[2] == address(('cd', 4)[2])
        require 3 < ('cd', 4).length
        require ('cd', 4)[6] == address(('cd', 4)[6])
        mem[(7 * ceil32(return_data.size)) + 100] = this.address
        require ext_code.size(address(('cd', 4)[6]))
        staticcall address(('cd', 4)[6]).balanceOf(address rg1) with:
                gas gas_remaining wei
               args this.address
        mem[(7 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[64] = (8 * ceil32(return_data.size)) + 96
        require return_data.size >= 32
        mem[(8 * ceil32(return_data.size)) + 128] = cd[36]
        mem[(8 * ceil32(return_data.size)) + 160] = ext_call.return_data[0]
        mem[(8 * ceil32(return_data.size)) + 192] = 96
        mem[(8 * ceil32(return_data.size)) + 224] = ('cd', 4).length
        idx = 0
        s = (8 * ceil32(return_data.size)) + 256
        t = cd[4] + 36
        while idx < ('cd', 4).length:
            u = 0
            v = t
            w = s
            while u < 2:
                require cd[v] == address(cd[v])
                mem[w] = address(cd[v])
                u = u + 1
                v = v + 32
                w = w + 32
                continue 
            idx = idx + 1
            s = s + 64
            t = t + 64
            continue 
        if address(('cd', 4)[2]) == ext_call.return_data[12 len 20]:
            _185 = mem[64]
            mem[64] = s
            mem[s] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
            mem[s + 4] = 0
            mem[s + 36] = ext_call.return_data[0]
            mem[s + 68] = this.address
            mem[s + 100] = 128
            _193 = mem[_185]
            mem[s + 132] = mem[_185]
            mem[s + 164 len ceil32(_193)] = mem[_185 + 32 len ceil32(_193)]
            if ceil32(_193) > _193:
                mem[s + _193 + 164] = 0
            require ext_code.size(address(('cd', 4)[1]))
            call address(('cd', 4)[1]).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, ext_call.return_data[0], address(this.address), 128, mem[s + 132 len ceil32(_193) + 32]
        else:
            _187 = mem[64]
            mem[64] = s
            mem[s] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
            mem[s + 4] = ext_call.return_data[0]
            mem[s + 36] = 0
            mem[s + 68] = this.address
            mem[s + 100] = 128
            _194 = mem[_187]
            mem[s + 132] = mem[_187]
            mem[s + 164 len ceil32(_194)] = mem[_187 + 32 len ceil32(_194)]
            if ceil32(_194) > _194:
                mem[s + _194 + 164] = 0
            require ext_code.size(address(('cd', 4)[1]))
            call address(('cd', 4)[1]).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args ext_call.return_data[0], 0, address(this.address), 128, mem[s + 132 len ceil32(_194) + 32]
    else:
        mem[(4 * ceil32(return_data.size)) + 132] = Mask(112, 0, ext_call.return_data[32])
        mem[(4 * ceil32(return_data.size)) + 164] = Mask(112, 0, ext_call.return_data[0])
        require ext_code.size(address(('cd', 4)[0]))
        staticcall address(('cd', 4)[0]).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                gas gas_remaining wei
               args cd[36], ext_call.return_data[32] << 144, Mask(112, 0, ext_call.return_data[0])
        mem[(4 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_code.size(address(('cd', 4)[1]))
        staticcall address(('cd', 4)[1]).token0() with:
                gas gas_remaining wei
        mem[(6 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[12 len 20]
        require 1 < ('cd', 4).length
        require ('cd', 4)[2] == address(('cd', 4)[2])
        require 3 < ('cd', 4).length
        require ('cd', 4)[6] == address(('cd', 4)[6])
        mem[(7 * ceil32(return_data.size)) + 100] = this.address
        require ext_code.size(address(('cd', 4)[6]))
        staticcall address(('cd', 4)[6]).balanceOf(address rg1) with:
                gas gas_remaining wei
               args this.address
        mem[(7 * ceil32(return_data.size)) + 96] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[64] = (8 * ceil32(return_data.size)) + 96
        require return_data.size >= 32
        mem[(8 * ceil32(return_data.size)) + 128] = cd[36]
        mem[(8 * ceil32(return_data.size)) + 160] = ext_call.return_data[0]
        mem[(8 * ceil32(return_data.size)) + 192] = 96
        mem[(8 * ceil32(return_data.size)) + 224] = ('cd', 4).length
        idx = 0
        s = (8 * ceil32(return_data.size)) + 256
        t = cd[4] + 36
        while idx < ('cd', 4).length:
            u = 0
            v = t
            w = s
            while u < 2:
                require cd[v] == address(cd[v])
                mem[w] = address(cd[v])
                u = u + 1
                v = v + 32
                w = w + 32
                continue 
            idx = idx + 1
            s = s + 64
            t = t + 64
            continue 
        if address(('cd', 4)[2]) == ext_call.return_data[12 len 20]:
            _189 = mem[64]
            mem[64] = s
            mem[s] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
            mem[s + 4] = 0
            mem[s + 36] = ext_call.return_data[0]
            mem[s + 68] = this.address
            mem[s + 100] = 128
            _195 = mem[_189]
            mem[s + 132] = mem[_189]
            mem[s + 164 len ceil32(_195)] = mem[_189 + 32 len ceil32(_195)]
            if ceil32(_195) > _195:
                mem[s + _195 + 164] = 0
            require ext_code.size(address(('cd', 4)[1]))
            call address(('cd', 4)[1]).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args 0, ext_call.return_data[0], address(this.address), 128, mem[s + 132 len ceil32(_195) + 32]
        else:
            _191 = mem[64]
            mem[64] = s
            mem[s] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
            mem[s + 4] = ext_call.return_data[0]
            mem[s + 36] = 0
            mem[s + 68] = this.address
            mem[s + 100] = 128
            _196 = mem[_191]
            mem[s + 132] = mem[_191]
            mem[s + 164 len ceil32(_196)] = mem[_191 + 32 len ceil32(_196)]
            if ceil32(_196) > _196:
                mem[s + _196 + 164] = 0
            require ext_code.size(address(('cd', 4)[1]))
            call address(('cd', 4)[1]).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                 gas gas_remaining wei
                args ext_call.return_data[0], 0, address(this.address), 128, mem[s + 132 len ceil32(_196) + 32]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require 1 < ('cd', 4).length
    require ('cd', 4)[2] == address(('cd', 4)[2])
    require ext_code.size(address(('cd', 4)[2]))
    staticcall address(('cd', 4)[2]).balanceOf(address rg1) with:
            gas gas_remaining wei
           args this.address
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if ext_call.return_data[0] <= ext_call.return_data[0]:
        revert with 0, 'qL'
}

function sub_94be070c(?) payable {
    mem[64] = 96
    require not msg.value
    require calldata.size - 4 >= 64
    require cd[4] <= test266151307()
    require cd[4] + 35 < calldata.size
    require ('cd', 4).length <= test266151307()
    require cd[4] + (32 * ('cd', 4).length) + 36 <= calldata.size
    require cd[36] <= test266151307()
    require cd[36] + 35 < calldata.size
    require ('cd', 36).length <= test266151307()
    require cd[36] + (32 * ('cd', 36).length) + 36 <= calldata.size
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    idx = 0
    while idx < ('cd', 4).length:
        require cd[(cd[4] + (32 * idx) + 36)] < calldata.size + -cd[4] - 67
        require cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 36)] <= test266151307()
        require cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68 <= calldata.size - (64 * cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 36)])
        require idx < ('cd', 36).length
        if owner != msg.sender:
            revert with 0, 'Ownable: caller is not the owner'
        require 0 < cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 36)]
        require cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)] == address(cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)])
        require ext_code.size(address(cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
        staticcall address(cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).getReserves() with:
                gas gas_remaining wei
        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _79 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 96
        _80 = mem[_79]
        require mem[_79] == mem[_79 + 18 len 14]
        _81 = mem[_79 + 32]
        require mem[_79 + 32] == mem[_79 + 50 len 14]
        require mem[_79 + 64] == mem[_79 + 92 len 4]
        require 1 < cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 36)]
        require cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 132)] == address(cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 132)])
        require ext_code.size(address(cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
        staticcall address(cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).token0() with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _85 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        require mem[_85] == mem[_85 + 12 len 20]
        require cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 36)]
        require cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)] == address(cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)])
        mem[mem[64] + 4] = cd[((32 * idx) + cd[36] + 36)]
        if mem[_85 + 12 len 20] == address(cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 132)]):
            mem[mem[64] + 36] = Mask(112, 0, _80)
            mem[mem[64] + 68] = Mask(112, 0, _81)
            require ext_code.size(address(cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]))
            staticcall address(cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                    gas gas_remaining wei
                   args cd[((32 * idx) + cd[36] + 36)], _80 << 144, Mask(112, 0, _81)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _91 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _93 = mem[_91]
            require ext_code.size(address(cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
            staticcall address(cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).token0() with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _99 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_99] == mem[_99 + 12 len 20]
            require 1 < cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 36)]
            require cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 132)] == address(cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 132)])
            require 3 < cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 36)]
            require cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 260)] == address(cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 260)])
            mem[mem[64] + 4] = this.address
            require ext_code.size(address(cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 260)]))
            staticcall address(cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 260)]).balanceOf(address rg1) with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if address(cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 132)]) == mem[_99 + 12 len 20]:
                _111 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _115 = mem[_111]
                mem[mem[64] + 32] = cd[((32 * idx) + cd[36] + 36)]
                mem[mem[64] + 64] = _115
                mem[mem[64] + 96] = 96
                mem[mem[64] + 128] = cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 36)]
                s = 0
                t = mem[64] + 160
                u = cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68
                while s < cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 36)]:
                    idx = 0
                    v = u
                    w = t
                    while idx < 2:
                        require cd[v] == address(cd[v])
                        mem[w] = address(cd[v])
                        idx = idx + 1
                        v = v + 32
                        w = w + 32
                        continue 
                    s = s + 1
                    t = t + 64
                    u = u + 64
                    continue 
                _159 = mem[64]
                mem[64] = t
                mem[t] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[t + 4] = 0
                mem[t + 36] = _93
                mem[t + 68] = this.address
                mem[t + 100] = 128
                _167 = mem[_159]
                mem[t + 132] = mem[_159]
                s = 0
                while s < _167:
                    mem[s + t + 164] = mem[s + _159 + 32]
                    s = s + 32
                    continue 
                if ceil32(_167) > _167:
                    mem[t + _167 + 164] = 0
                require ext_code.size(address(cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                call address(cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                     gas gas_remaining wei
                    args 0, _93, address(this.address), 128, mem[t + 132 len ceil32(_167) + 32]
            else:
                _112 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _116 = mem[_112]
                mem[mem[64] + 32] = cd[((32 * idx) + cd[36] + 36)]
                mem[mem[64] + 64] = _116
                mem[mem[64] + 96] = 96
                mem[mem[64] + 128] = cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 36)]
                s = 0
                t = mem[64] + 160
                u = cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68
                while s < cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 36)]:
                    idx = 0
                    v = u
                    w = t
                    while idx < 2:
                        require cd[v] == address(cd[v])
                        mem[w] = address(cd[v])
                        idx = idx + 1
                        v = v + 32
                        w = w + 32
                        continue 
                    s = s + 1
                    t = t + 64
                    u = u + 64
                    continue 
                _161 = mem[64]
                mem[64] = t
                mem[t] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[t + 4] = _93
                mem[t + 36] = 0
                mem[t + 68] = this.address
                mem[t + 100] = 128
                _168 = mem[_161]
                mem[t + 132] = mem[_161]
                s = 0
                while s < _168:
                    mem[s + t + 164] = mem[s + _161 + 32]
                    s = s + 32
                    continue 
                if ceil32(_168) > _168:
                    mem[t + _168 + 164] = 0
                require ext_code.size(address(cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                call address(cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                     gas gas_remaining wei
                    args _93, 0, address(this.address), 128, mem[t + 132 len ceil32(_168) + 32]
        else:
            mem[mem[64] + 36] = Mask(112, 0, _81)
            mem[mem[64] + 68] = Mask(112, 0, _80)
            require ext_code.size(address(cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]))
            staticcall address(cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                    gas gas_remaining wei
                   args cd[((32 * idx) + cd[36] + 36)], _81 << 144, Mask(112, 0, _80)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _92 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _94 = mem[_92]
            require ext_code.size(address(cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
            staticcall address(cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).token0() with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _100 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_100] == mem[_100 + 12 len 20]
            require 1 < cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 36)]
            require cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 132)] == address(cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 132)])
            require 3 < cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 36)]
            require cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 260)] == address(cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 260)])
            mem[mem[64] + 4] = this.address
            require ext_code.size(address(cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 260)]))
            staticcall address(cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 260)]).balanceOf(address rg1) with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if address(cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 132)]) == mem[_100 + 12 len 20]:
                _113 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _117 = mem[_113]
                mem[mem[64] + 32] = cd[((32 * idx) + cd[36] + 36)]
                mem[mem[64] + 64] = _117
                mem[mem[64] + 96] = 96
                mem[mem[64] + 128] = cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 36)]
                s = 0
                t = mem[64] + 160
                u = cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68
                while s < cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 36)]:
                    idx = 0
                    v = u
                    w = t
                    while idx < 2:
                        require cd[v] == address(cd[v])
                        mem[w] = address(cd[v])
                        idx = idx + 1
                        v = v + 32
                        w = w + 32
                        continue 
                    s = s + 1
                    t = t + 64
                    u = u + 64
                    continue 
                _163 = mem[64]
                mem[64] = t
                mem[t] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[t + 4] = 0
                mem[t + 36] = _94
                mem[t + 68] = this.address
                mem[t + 100] = 128
                _169 = mem[_163]
                mem[t + 132] = mem[_163]
                s = 0
                while s < _169:
                    mem[s + t + 164] = mem[s + _163 + 32]
                    s = s + 32
                    continue 
                if ceil32(_169) > _169:
                    mem[t + _169 + 164] = 0
                require ext_code.size(address(cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                call address(cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                     gas gas_remaining wei
                    args 0, _94, address(this.address), 128, mem[t + 132 len ceil32(_169) + 32]
            else:
                _114 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _118 = mem[_114]
                mem[mem[64] + 32] = cd[((32 * idx) + cd[36] + 36)]
                mem[mem[64] + 64] = _118
                mem[mem[64] + 96] = 96
                mem[mem[64] + 128] = cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 36)]
                s = 0
                t = mem[64] + 160
                u = cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68
                while s < cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 36)]:
                    idx = 0
                    v = u
                    w = t
                    while idx < 2:
                        require cd[v] == address(cd[v])
                        mem[w] = address(cd[v])
                        idx = idx + 1
                        v = v + 32
                        w = w + 32
                        continue 
                    s = s + 1
                    t = t + 64
                    u = u + 64
                    continue 
                _165 = mem[64]
                mem[64] = t
                mem[t] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[t + 4] = _94
                mem[t + 36] = 0
                mem[t + 68] = this.address
                mem[t + 100] = 128
                _170 = mem[_165]
                mem[t + 132] = mem[_165]
                s = 0
                while s < _170:
                    mem[s + t + 164] = mem[s + _165 + 32]
                    s = s + 32
                    continue 
                if ceil32(_170) > _170:
                    mem[t + _170 + 164] = 0
                require ext_code.size(address(cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                call address(cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                     gas gas_remaining wei
                    args _94, 0, address(this.address), 128, mem[t + 132 len ceil32(_170) + 32]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        idx = idx + 1
        continue 
}

function sub_ed3ddc7a(?) payable {
    mem[64] = 96
    require not msg.value
    require calldata.size - 4 >= 64
    require cd[4] <= test266151307()
    require cd[4] + 35 < calldata.size
    require ('cd', 4).length <= test266151307()
    require cd[4] + (32 * ('cd', 4).length) + 36 <= calldata.size
    require cd[36] <= test266151307()
    require cd[36] + 35 < calldata.size
    require ('cd', 36).length <= test266151307()
    require cd[36] + (32 * ('cd', 36).length) + 36 <= calldata.size
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    idx = 0
    while idx < ('cd', 4).length:
        require cd[(cd[4] + (32 * idx) + 36)] < calldata.size + -cd[4] - 67
        require cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 36)] <= test266151307()
        require cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68 <= calldata.size - (64 * cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 36)])
        require idx < ('cd', 36).length
        if owner != msg.sender:
            revert with 0, 'Ownable: caller is not the owner'
        require 1 < cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 36)]
        require cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 132)] == address(cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 132)])
        mem[mem[64] + 4] = this.address
        require ext_code.size(address(cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 132)]))
        staticcall address(cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 132)]).balanceOf(address rg1) with:
                gas gas_remaining wei
               args address(this.address)
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _131 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _132 = mem[_131]
        require 0 < cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 36)]
        require cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)] == address(cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)])
        require ext_code.size(address(cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
        staticcall address(cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).getReserves() with:
                gas gas_remaining wei
        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _135 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 96
        _136 = mem[_135]
        require mem[_135] == mem[_135 + 18 len 14]
        _137 = mem[_135 + 32]
        require mem[_135 + 32] == mem[_135 + 50 len 14]
        require mem[_135 + 64] == mem[_135 + 92 len 4]
        require 1 < cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 36)]
        require cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 132)] == address(cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 132)])
        require ext_code.size(address(cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
        staticcall address(cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).token0() with:
                gas gas_remaining wei
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _141 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        require mem[_141] == mem[_141 + 12 len 20]
        require cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 36)]
        require cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)] == address(cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)])
        mem[mem[64] + 4] = cd[((32 * idx) + cd[36] + 36)]
        if mem[_141 + 12 len 20] == address(cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 132)]):
            mem[mem[64] + 36] = Mask(112, 0, _136)
            mem[mem[64] + 68] = Mask(112, 0, _137)
            require ext_code.size(address(cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]))
            staticcall address(cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                    gas gas_remaining wei
                   args cd[((32 * idx) + cd[36] + 36)], _136 << 144, Mask(112, 0, _137)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _147 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _149 = mem[_147]
            require ext_code.size(address(cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
            staticcall address(cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).token0() with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _155 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_155] == mem[_155 + 12 len 20]
            require 1 < cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 36)]
            require cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 132)] == address(cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 132)])
            require 3 < cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 36)]
            require cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 260)] == address(cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 260)])
            mem[mem[64] + 4] = this.address
            require ext_code.size(address(cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 260)]))
            staticcall address(cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 260)]).balanceOf(address rg1) with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if address(cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 132)]) == mem[_155 + 12 len 20]:
                _167 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _171 = mem[_167]
                mem[mem[64] + 32] = cd[((32 * idx) + cd[36] + 36)]
                mem[mem[64] + 64] = _171
                mem[mem[64] + 96] = 96
                mem[mem[64] + 128] = cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 36)]
                s = 0
                t = mem[64] + 160
                u = cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68
                while s < cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 36)]:
                    idx = 0
                    v = u
                    w = t
                    while idx < 2:
                        require cd[v] == address(cd[v])
                        mem[w] = address(cd[v])
                        idx = idx + 1
                        v = v + 32
                        w = w + 32
                        continue 
                    s = s + 1
                    t = t + 64
                    u = u + 64
                    continue 
                _311 = mem[64]
                mem[64] = t
                mem[t] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[t + 4] = 0
                mem[t + 36] = _149
                mem[t + 68] = this.address
                mem[t + 100] = 128
                _319 = mem[_311]
                mem[t + 132] = mem[_311]
                s = 0
                while s < _319:
                    mem[s + t + 164] = mem[s + _311 + 32]
                    s = s + 32
                    continue 
                if ceil32(_319) > _319:
                    mem[t + _319 + 164] = 0
                require ext_code.size(address(cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                call address(cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                     gas gas_remaining wei
                    args 0, _149, address(this.address), 128, mem[t + 132 len ceil32(_319) + 32]
            else:
                _168 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _172 = mem[_168]
                mem[mem[64] + 32] = cd[((32 * idx) + cd[36] + 36)]
                mem[mem[64] + 64] = _172
                mem[mem[64] + 96] = 96
                mem[mem[64] + 128] = cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 36)]
                s = 0
                t = mem[64] + 160
                u = cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68
                while s < cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 36)]:
                    idx = 0
                    v = u
                    w = t
                    while idx < 2:
                        require cd[v] == address(cd[v])
                        mem[w] = address(cd[v])
                        idx = idx + 1
                        v = v + 32
                        w = w + 32
                        continue 
                    s = s + 1
                    t = t + 64
                    u = u + 64
                    continue 
                _313 = mem[64]
                mem[64] = t
                mem[t] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[t + 4] = _149
                mem[t + 36] = 0
                mem[t + 68] = this.address
                mem[t + 100] = 128
                _320 = mem[_313]
                mem[t + 132] = mem[_313]
                s = 0
                while s < _320:
                    mem[s + t + 164] = mem[s + _313 + 32]
                    s = s + 32
                    continue 
                if ceil32(_320) > _320:
                    mem[t + _320 + 164] = 0
                require ext_code.size(address(cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                call address(cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                     gas gas_remaining wei
                    args _149, 0, address(this.address), 128, mem[t + 132 len ceil32(_320) + 32]
        else:
            mem[mem[64] + 36] = Mask(112, 0, _137)
            mem[mem[64] + 68] = Mask(112, 0, _136)
            require ext_code.size(address(cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]))
            staticcall address(cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                    gas gas_remaining wei
                   args cd[((32 * idx) + cd[36] + 36)], _137 << 144, Mask(112, 0, _136)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _148 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _150 = mem[_148]
            require ext_code.size(address(cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
            staticcall address(cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).token0() with:
                    gas gas_remaining wei
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _156 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            require mem[_156] == mem[_156 + 12 len 20]
            require 1 < cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 36)]
            require cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 132)] == address(cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 132)])
            require 3 < cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 36)]
            require cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 260)] == address(cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 260)])
            mem[mem[64] + 4] = this.address
            require ext_code.size(address(cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 260)]))
            staticcall address(cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 260)]).balanceOf(address rg1) with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if address(cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 132)]) == mem[_156 + 12 len 20]:
                _169 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _173 = mem[_169]
                mem[mem[64] + 32] = cd[((32 * idx) + cd[36] + 36)]
                mem[mem[64] + 64] = _173
                mem[mem[64] + 96] = 96
                mem[mem[64] + 128] = cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 36)]
                s = 0
                t = mem[64] + 160
                u = cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68
                while s < cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 36)]:
                    idx = 0
                    v = u
                    w = t
                    while idx < 2:
                        require cd[v] == address(cd[v])
                        mem[w] = address(cd[v])
                        idx = idx + 1
                        v = v + 32
                        w = w + 32
                        continue 
                    s = s + 1
                    t = t + 64
                    u = u + 64
                    continue 
                _315 = mem[64]
                mem[64] = t
                mem[t] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[t + 4] = 0
                mem[t + 36] = _150
                mem[t + 68] = this.address
                mem[t + 100] = 128
                _321 = mem[_315]
                mem[t + 132] = mem[_315]
                s = 0
                while s < _321:
                    mem[s + t + 164] = mem[s + _315 + 32]
                    s = s + 32
                    continue 
                if ceil32(_321) > _321:
                    mem[t + _321 + 164] = 0
                require ext_code.size(address(cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                call address(cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                     gas gas_remaining wei
                    args 0, _150, address(this.address), 128, mem[t + 132 len ceil32(_321) + 32]
            else:
                _170 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _174 = mem[_170]
                mem[mem[64] + 32] = cd[((32 * idx) + cd[36] + 36)]
                mem[mem[64] + 64] = _174
                mem[mem[64] + 96] = 96
                mem[mem[64] + 128] = cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 36)]
                s = 0
                t = mem[64] + 160
                u = cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68
                while s < cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 36)]:
                    idx = 0
                    v = u
                    w = t
                    while idx < 2:
                        require cd[v] == address(cd[v])
                        mem[w] = address(cd[v])
                        idx = idx + 1
                        v = v + 32
                        w = w + 32
                        continue 
                    s = s + 1
                    t = t + 64
                    u = u + 64
                    continue 
                _317 = mem[64]
                mem[64] = t
                mem[t] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[t + 4] = _150
                mem[t + 36] = 0
                mem[t + 68] = this.address
                mem[t + 100] = 128
                _322 = mem[_317]
                mem[t + 132] = mem[_317]
                s = 0
                while s < _322:
                    mem[s + t + 164] = mem[s + _317 + 32]
                    s = s + 32
                    continue 
                if ceil32(_322) > _322:
                    mem[t + _322 + 164] = 0
                require ext_code.size(address(cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                call address(cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                     gas gas_remaining wei
                    args _150, 0, address(this.address), 128, mem[t + 132 len ceil32(_322) + 32]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require 1 < cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 36)]
        require cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 132)] == address(cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 132)])
        mem[t + 4] = this.address
        require ext_code.size(address(cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 132)]))
        staticcall address(cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 132)]).balanceOf(address rg1) with:
                gas gas_remaining wei
               args this.address
        mem[t] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[64] = t + ceil32(return_data.size)
        require return_data.size >= 32
        if ext_call.return_data[0] <= _132:
            revert with 0, 'qL'
        idx = idx + 1
        continue 
}

function sub_f77a784f(?) {
    require calldata.size - 4 >= 64
    require cd[4] <= test266151307()
    require cd[4] + 35 < calldata.size
    require ('cd', 4).length <= test266151307()
    require cd[4] + (64 * ('cd', 4).length) + 36 <= calldata.size
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    require 1 < ('cd', 4).length
    require ('cd', 4)[2] == address(('cd', 4)[2])
    mem[100] = this.address
    require ext_code.size(address(('cd', 4)[2]))
    staticcall address(('cd', 4)[2]).balanceOf(address rg1) with:
            gas gas_remaining wei
           args this.address
    mem[96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    mem[64] = ceil32(return_data.size) + 96
    require return_data.size >= 32
    idx = 0
    s = cd[36]
    while idx < ('cd', 4).length:
        require cd[((64 * idx) + cd[4] + 36)] == address(cd[((64 * idx) + cd[4] + 36)])
        require idx < ('cd', 4).length
        require cd[((64 * idx) + cd[4] + 68)] == address(cd[((64 * idx) + cd[4] + 68)])
        require idx + 1 < ('cd', 4).length
        require cd[((64 * idx + 1) + cd[4] + 36)] == address(cd[((64 * idx + 1) + cd[4] + 36)])
        require idx + 1 < ('cd', 4).length
        require cd[((64 * idx + 1) + cd[4] + 68)] == address(cd[((64 * idx + 1) + cd[4] + 68)])
        mem[mem[64] + 4] = this.address
        require ext_code.size(address(cd[((64 * idx + 1) + cd[4] + 68)]))
        staticcall address(cd[((64 * idx + 1) + cd[4] + 68)]).balanceOf(address rg1) with:
                gas gas_remaining wei
               args address(this.address)
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _660 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _661 = mem[_660]
        _662 = mem[64]
        mem[mem[64] + 36] = address(cd[((64 * idx) + cd[4] + 68)])
        mem[mem[64] + 68] = s
        _663 = mem[64]
        mem[mem[64]] = 68
        mem[64] = mem[64] + 100
        mem[_663 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_663 + 36 len 28]
        mem[64] = _662 + 164
        mem[_662 + 100] = 32
        mem[_662 + 132] = 'SafeERC20: low-level call failed'
        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(address(cd[((64 * idx + 1) + cd[4] + 36)])):
            revert with 0, 'Address: call to non-contract'
        if not ext_code.hash(address(cd[((64 * idx + 1) + cd[4] + 36)])):
            revert with 0, 'Address: call to non-contract'
        _669 = mem[_663]
        t = _663 + 32
        u = mem[64]
        s = mem[_663]
        while s >= 32:
            mem[u] = mem[t]
            t = t + 32
            u = u + 32
            s = s - 32
            continue 
        mem[mem[64] + floor32(mem[_663])] = mem[_663 + floor32(mem[_663]) + -(mem[_663] % 32) + 64 len mem[_663] % 32] or Mask(8 * -(mem[_663] % 32) + 32, -(8 * -(mem[_663] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_663])])
        call address(cd[((64 * idx + 1) + cd[4] + 36)]).mem[mem[64] len 4] with:
             gas gas_remaining wei
            args mem[mem[64] + 4 len _669 + _662 + -mem[64] + 160]
        if not return_data.size:
            if not ext_call.success:
                if mem[96]:
                    revert with memory
                      from 128
                       len mem[96]
                _1304 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = mem[_662 + 100]
                _1306 = mem[_662 + 100]
                idx = 0
                while idx < _1306:
                    mem[idx + _1304 + 68] = mem[idx + _662 + 132]
                    idx = idx + 32
                    continue 
                if not _1306 % 32:
                    revert with memory
                      from mem[64]
                       len _1306 + _1304 + -mem[64] + 68
                mem[floor32(_1306) + _1304 + 68] = mem[floor32(_1306) + _1304 + -(_1306 % 32) + 100 len _1306 % 32]
                revert with memory
                  from mem[64]
                   len floor32(_1306) + _1304 + -mem[64] + 100
            if not mem[96]:
                require ext_code.size(address(cd[((64 * idx) + cd[4] + 68)]))
                staticcall address(cd[((64 * idx) + cd[4] + 68)]).getReserves() with:
                        gas gas_remaining wei
                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if address(cd[((64 * idx + 1) + cd[4] + 36)]) >= address(cd[((64 * idx + 1) + cd[4] + 68)]):
                    _1339 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 96
                    _1355 = mem[_1339]
                    require mem[_1339] == mem[_1339 + 18 len 14]
                    _1363 = mem[_1339 + 32]
                    require mem[_1339 + 32] == mem[_1339 + 50 len 14]
                    require mem[_1339 + 64] == mem[_1339 + 92 len 4]
                    mem[mem[64] + 4] = address(cd[((64 * idx) + cd[4] + 68)])
                    require ext_code.size(address(cd[((64 * idx + 1) + cd[4] + 36)]))
                    staticcall address(cd[((64 * idx + 1) + cd[4] + 36)]).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(cd[((64 * idx) + cd[4] + 68)])
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if address(cd[((64 * idx + 1) + cd[4] + 36)]) == address(cd[((64 * idx + 1) + cd[4] + 68)]):
                        _1404 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        mem[mem[64] + 4] = mem[_1404] - Mask(112, 0, _1355)
                        mem[mem[64] + 36] = Mask(112, 0, _1355)
                        mem[mem[64] + 68] = Mask(112, 0, _1363)
                        require ext_code.size(address(cd[((64 * idx) + cd[4] + 36)]))
                        staticcall address(cd[((64 * idx) + cd[4] + 36)]).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                                gas gas_remaining wei
                               args mem[mem[64] + 4], _1355 << 144, Mask(112, 0, _1363)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1468 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _1484 = mem[_1468]
                        if address(cd[((64 * idx + 1) + cd[4] + 36)]) == address(cd[((64 * idx + 1) + cd[4] + 68)]):
                            _1510 = mem[64]
                            mem[mem[64]] = 0
                            mem[64] = mem[64] + 32
                            mem[_1510 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                            mem[_1510 + 36] = 0
                            mem[_1510 + 68] = _1484
                            mem[_1510 + 100] = this.address
                            mem[_1510 + 132] = 128
                            mem[_1510 + 164] = mem[_1510]
                            s = 0
                            while s < mem[_1510]:
                                mem[s + _1510 + 196] = mem[s + _1510 + 32]
                                s = s + 32
                                continue 
                            if ceil32(mem[_1510]) > mem[_1510]:
                                mem[_1510 + mem[_1510] + 196] = 0
                            require ext_code.size(address(cd[((64 * idx) + cd[4] + 68)]))
                            call address(cd[((64 * idx) + cd[4] + 68)]).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                                 gas gas_remaining wei
                                args 0, _1484, address(this.address), 128, mem[_1510], mem[_1510 + 196 len ceil32(mem[_1510])]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_1510 + 36] = this.address
                            require ext_code.size(address(cd[((64 * idx + 1) + cd[4] + 68)]))
                            staticcall address(cd[((64 * idx + 1) + cd[4] + 68)]).balanceOf(address rg1) with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[_1510 + 32] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = _1510 + ceil32(return_data.size) + 32
                        else:
                            _1511 = mem[64]
                            mem[mem[64]] = 0
                            mem[64] = mem[64] + 32
                            mem[_1511 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                            mem[_1511 + 36] = _1484
                            mem[_1511 + 68] = 0
                            mem[_1511 + 100] = this.address
                            mem[_1511 + 132] = 128
                            mem[_1511 + 164] = mem[_1511]
                            s = 0
                            while s < mem[_1511]:
                                mem[s + _1511 + 196] = mem[s + _1511 + 32]
                                s = s + 32
                                continue 
                            if ceil32(mem[_1511]) > mem[_1511]:
                                mem[_1511 + mem[_1511] + 196] = 0
                            require ext_code.size(address(cd[((64 * idx) + cd[4] + 68)]))
                            call address(cd[((64 * idx) + cd[4] + 68)]).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                                 gas gas_remaining wei
                                args _1484, 0, address(this.address), 128, mem[_1511], mem[_1511 + 196 len ceil32(mem[_1511])]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_1511 + 36] = this.address
                            require ext_code.size(address(cd[((64 * idx + 1) + cd[4] + 68)]))
                            staticcall address(cd[((64 * idx + 1) + cd[4] + 68)]).balanceOf(address rg1) with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[_1511 + 32] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = _1511 + ceil32(return_data.size) + 32
                    else:
                        _1405 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        mem[mem[64] + 4] = mem[_1405] - Mask(112, 0, _1363)
                        mem[mem[64] + 36] = Mask(112, 0, _1363)
                        mem[mem[64] + 68] = Mask(112, 0, _1355)
                        require ext_code.size(address(cd[((64 * idx) + cd[4] + 36)]))
                        staticcall address(cd[((64 * idx) + cd[4] + 36)]).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                                gas gas_remaining wei
                               args mem[mem[64] + 4], _1363 << 144, Mask(112, 0, _1355)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _1469 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _1485 = mem[_1469]
                        if address(cd[((64 * idx + 1) + cd[4] + 36)]) == address(cd[((64 * idx + 1) + cd[4] + 68)]):
                            _1512 = mem[64]
                            mem[mem[64]] = 0
                            mem[64] = mem[64] + 32
                            mem[_1512 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                            mem[_1512 + 36] = 0
                            mem[_1512 + 68] = _1485
                            mem[_1512 + 100] = this.address
                            mem[_1512 + 132] = 128
                            mem[_1512 + 164] = mem[_1512]
                            s = 0
                            while s < mem[_1512]:
                                mem[s + _1512 + 196] = mem[s + _1512 + 32]
                                s = s + 32
                                continue 
                            if ceil32(mem[_1512]) > mem[_1512]:
                                mem[_1512 + mem[_1512] + 196] = 0
                            require ext_code.size(address(cd[((64 * idx) + cd[4] + 68)]))
                            call address(cd[((64 * idx) + cd[4] + 68)]).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                                 gas gas_remaining wei
                                args 0, _1485, address(this.address), 128, mem[_1512], mem[_1512 + 196 len ceil32(mem[_1512])]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_1512 + 36] = this.address
                            require ext_code.size(address(cd[((64 * idx + 1) + cd[4] + 68)]))
                            staticcall address(cd[((64 * idx + 1) + cd[4] + 68)]).balanceOf(address rg1) with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[_1512 + 32] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = _1512 + ceil32(return_data.size) + 32
                        else:
                            _1513 = mem[64]
                            mem[mem[64]] = 0
                            mem[64] = mem[64] + 32
                            mem[_1513 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                            mem[_1513 + 36] = _1485
                            mem[_1513 + 68] = 0
                            mem[_1513 + 100] = this.address
                            mem[_1513 + 132] = 128
                            mem[_1513 + 164] = mem[_1513]
                            s = 0
                            while s < mem[_1513]:
                                mem[s + _1513 + 196] = mem[s + _1513 + 32]
                                s = s + 32
                                continue 
                            if ceil32(mem[_1513]) > mem[_1513]:
                                mem[_1513 + mem[_1513] + 196] = 0
                            require ext_code.size(address(cd[((64 * idx) + cd[4] + 68)]))
                            call address(cd[((64 * idx) + cd[4] + 68)]).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                                 gas gas_remaining wei
                                args _1485, 0, address(this.address), 128, mem[_1513], mem[_1513 + 196 len ceil32(mem[_1513])]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_1513 + 36] = this.address
                            require ext_code.size(address(cd[((64 * idx + 1) + cd[4] + 68)]))
                            staticcall address(cd[((64 * idx + 1) + cd[4] + 68)]).balanceOf(address rg1) with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[_1513 + 32] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = _1513 + ceil32(return_data.size) + 32
                    require return_data.size >= 32
                    idx = idx + 2
                    s = ext_call.return_data[0] - _661
                    continue 
                _1338 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 96
                _1354 = mem[_1338]
                require mem[_1338] == mem[_1338 + 18 len 14]
                _1362 = mem[_1338 + 32]
                require mem[_1338 + 32] == mem[_1338 + 50 len 14]
                require mem[_1338 + 64] == mem[_1338 + 92 len 4]
                mem[mem[64] + 4] = address(cd[((64 * idx) + cd[4] + 68)])
                require ext_code.size(address(cd[((64 * idx + 1) + cd[4] + 36)]))
                staticcall address(cd[((64 * idx + 1) + cd[4] + 36)]).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(cd[((64 * idx) + cd[4] + 68)])
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if address(cd[((64 * idx + 1) + cd[4] + 36)]) == address(cd[((64 * idx + 1) + cd[4] + 36)]):
                    _1402 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    mem[mem[64] + 4] = mem[_1402] - Mask(112, 0, _1354)
                    mem[mem[64] + 36] = Mask(112, 0, _1354)
                    mem[mem[64] + 68] = Mask(112, 0, _1362)
                    require ext_code.size(address(cd[((64 * idx) + cd[4] + 36)]))
                    staticcall address(cd[((64 * idx) + cd[4] + 36)]).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                            gas gas_remaining wei
                           args mem[mem[64] + 4], _1354 << 144, Mask(112, 0, _1362)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1466 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1482 = mem[_1466]
                    if address(cd[((64 * idx + 1) + cd[4] + 36)]) == address(cd[((64 * idx + 1) + cd[4] + 36)]):
                        _1506 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_1506 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_1506 + 36] = 0
                        mem[_1506 + 68] = _1482
                        mem[_1506 + 100] = this.address
                        mem[_1506 + 132] = 128
                        mem[_1506 + 164] = mem[_1506]
                        s = 0
                        while s < mem[_1506]:
                            mem[s + _1506 + 196] = mem[s + _1506 + 32]
                            s = s + 32
                            continue 
                        if ceil32(mem[_1506]) > mem[_1506]:
                            mem[_1506 + mem[_1506] + 196] = 0
                        require ext_code.size(address(cd[((64 * idx) + cd[4] + 68)]))
                        call address(cd[((64 * idx) + cd[4] + 68)]).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                             gas gas_remaining wei
                            args 0, _1482, address(this.address), 128, mem[_1506], mem[_1506 + 196 len ceil32(mem[_1506])]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_1506 + 36] = this.address
                        require ext_code.size(address(cd[((64 * idx + 1) + cd[4] + 68)]))
                        staticcall address(cd[((64 * idx + 1) + cd[4] + 68)]).balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args this.address
                        mem[_1506 + 32] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[64] = _1506 + ceil32(return_data.size) + 32
                        require return_data.size >= 32
                        idx = idx + 2
                        s = ext_call.return_data[0] - _661
                        continue 
                    _1507 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_1507 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_1507 + 36] = _1482
                    mem[_1507 + 68] = 0
                    mem[_1507 + 100] = this.address
                    mem[_1507 + 132] = 128
                    mem[_1507 + 164] = mem[_1507]
                    s = 0
                    while s < mem[_1507]:
                        mem[s + _1507 + 196] = mem[s + _1507 + 32]
                        s = s + 32
                        continue 
                    if ceil32(mem[_1507]) <= mem[_1507]:
                        require ext_code.size(address(cd[((64 * idx) + cd[4] + 68)]))
                        call address(cd[((64 * idx) + cd[4] + 68)]).mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len ceil32(mem[_1507]) + _1507 + -mem[64] + 192]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(cd[((64 * idx + 1) + cd[4] + 68)]))
                        staticcall address(cd[((64 * idx + 1) + cd[4] + 68)]).balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2155 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        idx = idx + 2
                        s = mem[_2155] - _661
                        continue 
                    mem[_1507 + mem[_1507] + 196] = 0
                    require ext_code.size(address(cd[((64 * idx) + cd[4] + 68)]))
                    call address(cd[((64 * idx) + cd[4] + 68)]).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_1507]) + _1507 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(cd[((64 * idx + 1) + cd[4] + 68)]))
                    staticcall address(cd[((64 * idx + 1) + cd[4] + 68)]).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2187 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    idx = idx + 2
                    s = mem[_2187] - _661
                    continue 
                _1403 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[mem[64] + 4] = mem[_1403] - Mask(112, 0, _1362)
                mem[mem[64] + 36] = Mask(112, 0, _1362)
                mem[mem[64] + 68] = Mask(112, 0, _1354)
                require ext_code.size(address(cd[((64 * idx) + cd[4] + 36)]))
                staticcall address(cd[((64 * idx) + cd[4] + 36)]).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                        gas gas_remaining wei
                       args mem[mem[64] + 4], _1362 << 144, Mask(112, 0, _1354)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1467 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _1483 = mem[_1467]
                if address(cd[((64 * idx + 1) + cd[4] + 36)]) != address(cd[((64 * idx + 1) + cd[4] + 36)]):
                    _1509 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_1509 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_1509 + 36] = _1483
                    mem[_1509 + 68] = 0
                    mem[_1509 + 100] = this.address
                    mem[_1509 + 132] = 128
                    mem[_1509 + 164] = mem[_1509]
                    s = 0
                    while s < mem[_1509]:
                        mem[s + _1509 + 196] = mem[s + _1509 + 32]
                        s = s + 32
                        continue 
                    if ceil32(mem[_1509]) > mem[_1509]:
                        mem[_1509 + mem[_1509] + 196] = 0
                    require ext_code.size(address(cd[((64 * idx) + cd[4] + 68)]))
                    call address(cd[((64 * idx) + cd[4] + 68)]).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                         gas gas_remaining wei
                        args _1483, 0, address(this.address), 128, mem[_1509], mem[_1509 + 196 len ceil32(mem[_1509])]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[_1509 + 36] = this.address
                    require ext_code.size(address(cd[((64 * idx + 1) + cd[4] + 68)]))
                    staticcall address(cd[((64 * idx + 1) + cd[4] + 68)]).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args this.address
                    mem[_1509 + 32] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = _1509 + ceil32(return_data.size) + 32
                    require return_data.size >= 32
                    idx = idx + 2
                    s = ext_call.return_data[0] - _661
                    continue 
                _1508 = mem[64]
                mem[mem[64]] = 0
                mem[64] = mem[64] + 32
                mem[_1508 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[_1508 + 36] = 0
                mem[_1508 + 68] = _1483
                mem[_1508 + 100] = this.address
                mem[_1508 + 132] = 128
                mem[_1508 + 164] = mem[_1508]
                s = 0
                while s < mem[_1508]:
                    mem[s + _1508 + 196] = mem[s + _1508 + 32]
                    s = s + 32
                    continue 
                if ceil32(mem[_1508]) <= mem[_1508]:
                    require ext_code.size(address(cd[((64 * idx) + cd[4] + 68)]))
                    call address(cd[((64 * idx) + cd[4] + 68)]).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_1508]) + _1508 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(cd[((64 * idx + 1) + cd[4] + 68)]))
                    staticcall address(cd[((64 * idx + 1) + cd[4] + 68)]).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2156 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    idx = idx + 2
                    s = mem[_2156] - _661
                    continue 
                mem[_1508 + mem[_1508] + 196] = 0
                require ext_code.size(address(cd[((64 * idx) + cd[4] + 68)]))
                call address(cd[((64 * idx) + cd[4] + 68)]).mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len ceil32(mem[_1508]) + _1508 + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(cd[((64 * idx + 1) + cd[4] + 68)]))
                staticcall address(cd[((64 * idx + 1) + cd[4] + 68)]).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2188 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                idx = idx + 2
                s = mem[_2188] - _661
                continue 
            require mem[96] >= 32
            if not mem[128]:
                revert with 0, 
                            32,
                            42,
                            0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                            mem[mem[64] + 110 len 22]
            require ext_code.size(address(cd[((64 * idx) + cd[4] + 68)]))
            staticcall address(cd[((64 * idx) + cd[4] + 68)]).getReserves() with:
                    gas gas_remaining wei
            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if address(cd[((64 * idx + 1) + cd[4] + 36)]) < address(cd[((64 * idx + 1) + cd[4] + 68)]):
                _1350 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 96
                _1358 = mem[_1350]
                require mem[_1350] == mem[_1350 + 18 len 14]
                _1368 = mem[_1350 + 32]
                require mem[_1350 + 32] == mem[_1350 + 50 len 14]
                require mem[_1350 + 64] == mem[_1350 + 92 len 4]
                mem[mem[64] + 4] = address(cd[((64 * idx) + cd[4] + 68)])
                require ext_code.size(address(cd[((64 * idx + 1) + cd[4] + 36)]))
                staticcall address(cd[((64 * idx + 1) + cd[4] + 36)]).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(cd[((64 * idx) + cd[4] + 68)])
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if address(cd[((64 * idx + 1) + cd[4] + 36)]) == address(cd[((64 * idx + 1) + cd[4] + 36)]):
                    _1422 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    mem[mem[64] + 4] = mem[_1422] - Mask(112, 0, _1358)
                    mem[mem[64] + 36] = Mask(112, 0, _1358)
                    mem[mem[64] + 68] = Mask(112, 0, _1368)
                    require ext_code.size(address(cd[((64 * idx) + cd[4] + 36)]))
                    staticcall address(cd[((64 * idx) + cd[4] + 36)]).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                            gas gas_remaining wei
                           args mem[mem[64] + 4], _1358 << 144, Mask(112, 0, _1368)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1486 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1498 = mem[_1486]
                    if address(cd[((64 * idx + 1) + cd[4] + 36)]) != address(cd[((64 * idx + 1) + cd[4] + 36)]):
                        _1539 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_1539 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_1539 + 36] = _1498
                        mem[_1539 + 68] = 0
                        mem[_1539 + 100] = this.address
                        mem[_1539 + 132] = 128
                        mem[_1539 + 164] = mem[_1539]
                        s = 0
                        while s < mem[_1539]:
                            mem[s + _1539 + 196] = mem[s + _1539 + 32]
                            s = s + 32
                            continue 
                        if ceil32(mem[_1539]) > mem[_1539]:
                            mem[_1539 + mem[_1539] + 196] = 0
                        require ext_code.size(address(cd[((64 * idx) + cd[4] + 68)]))
                        call address(cd[((64 * idx) + cd[4] + 68)]).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                             gas gas_remaining wei
                            args _1498, 0, address(this.address), 128, mem[_1539], mem[_1539 + 196 len ceil32(mem[_1539])]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_1539 + 36] = this.address
                        require ext_code.size(address(cd[((64 * idx + 1) + cd[4] + 68)]))
                        staticcall address(cd[((64 * idx + 1) + cd[4] + 68)]).balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args this.address
                        mem[_1539 + 32] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[64] = _1539 + ceil32(return_data.size) + 32
                        require return_data.size >= 32
                        idx = idx + 2
                        s = ext_call.return_data[0] - _661
                        continue 
                    _1538 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_1538 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_1538 + 36] = 0
                    mem[_1538 + 68] = _1498
                    mem[_1538 + 100] = this.address
                    mem[_1538 + 132] = 128
                    mem[_1538 + 164] = mem[_1538]
                    s = 0
                    while s < mem[_1538]:
                        mem[s + _1538 + 196] = mem[s + _1538 + 32]
                        s = s + 32
                        continue 
                    if ceil32(mem[_1538]) <= mem[_1538]:
                        require ext_code.size(address(cd[((64 * idx) + cd[4] + 68)]))
                        call address(cd[((64 * idx) + cd[4] + 68)]).mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len ceil32(mem[_1538]) + _1538 + -mem[64] + 192]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(cd[((64 * idx + 1) + cd[4] + 68)]))
                        staticcall address(cd[((64 * idx + 1) + cd[4] + 68)]).balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2162 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        idx = idx + 2
                        s = mem[_2162] - _661
                        continue 
                    mem[_1538 + mem[_1538] + 196] = 0
                    require ext_code.size(address(cd[((64 * idx) + cd[4] + 68)]))
                    call address(cd[((64 * idx) + cd[4] + 68)]).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_1538]) + _1538 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(cd[((64 * idx + 1) + cd[4] + 68)]))
                    staticcall address(cd[((64 * idx + 1) + cd[4] + 68)]).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2194 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    idx = idx + 2
                    s = mem[_2194] - _661
                    continue 
                _1423 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[mem[64] + 4] = mem[_1423] - Mask(112, 0, _1368)
                mem[mem[64] + 36] = Mask(112, 0, _1368)
                mem[mem[64] + 68] = Mask(112, 0, _1358)
                require ext_code.size(address(cd[((64 * idx) + cd[4] + 36)]))
                staticcall address(cd[((64 * idx) + cd[4] + 36)]).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                        gas gas_remaining wei
                       args mem[mem[64] + 4], _1368 << 144, Mask(112, 0, _1358)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1487 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _1499 = mem[_1487]
                if address(cd[((64 * idx + 1) + cd[4] + 36)]) != address(cd[((64 * idx + 1) + cd[4] + 36)]):
                    _1541 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_1541 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_1541 + 36] = _1499
                    mem[_1541 + 68] = 0
                    mem[_1541 + 100] = this.address
                    mem[_1541 + 132] = 128
                    mem[_1541 + 164] = mem[_1541]
                    s = 0
                    while s < mem[_1541]:
                        mem[s + _1541 + 196] = mem[s + _1541 + 32]
                        s = s + 32
                        continue 
                    if ceil32(mem[_1541]) > mem[_1541]:
                        mem[_1541 + mem[_1541] + 196] = 0
                    require ext_code.size(address(cd[((64 * idx) + cd[4] + 68)]))
                    call address(cd[((64 * idx) + cd[4] + 68)]).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                         gas gas_remaining wei
                        args _1499, 0, address(this.address), 128, mem[_1541], mem[_1541 + 196 len ceil32(mem[_1541])]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[_1541 + 36] = this.address
                    require ext_code.size(address(cd[((64 * idx + 1) + cd[4] + 68)]))
                    staticcall address(cd[((64 * idx + 1) + cd[4] + 68)]).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args this.address
                    mem[_1541 + 32] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = _1541 + ceil32(return_data.size) + 32
                    require return_data.size >= 32
                    idx = idx + 2
                    s = ext_call.return_data[0] - _661
                    continue 
                _1540 = mem[64]
                mem[mem[64]] = 0
                mem[64] = mem[64] + 32
                mem[_1540 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[_1540 + 36] = 0
                mem[_1540 + 68] = _1499
                mem[_1540 + 100] = this.address
                mem[_1540 + 132] = 128
                mem[_1540 + 164] = mem[_1540]
                s = 0
                while s < mem[_1540]:
                    mem[s + _1540 + 196] = mem[s + _1540 + 32]
                    s = s + 32
                    continue 
                if ceil32(mem[_1540]) <= mem[_1540]:
                    require ext_code.size(address(cd[((64 * idx) + cd[4] + 68)]))
                    call address(cd[((64 * idx) + cd[4] + 68)]).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_1540]) + _1540 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(cd[((64 * idx + 1) + cd[4] + 68)]))
                    staticcall address(cd[((64 * idx + 1) + cd[4] + 68)]).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2164 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    idx = idx + 2
                    s = mem[_2164] - _661
                    continue 
                mem[_1540 + mem[_1540] + 196] = 0
                require ext_code.size(address(cd[((64 * idx) + cd[4] + 68)]))
                call address(cd[((64 * idx) + cd[4] + 68)]).mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len ceil32(mem[_1540]) + _1540 + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(cd[((64 * idx + 1) + cd[4] + 68)]))
                staticcall address(cd[((64 * idx + 1) + cd[4] + 68)]).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2196 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                idx = idx + 2
                s = mem[_2196] - _661
                continue 
            _1351 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 96
            _1359 = mem[_1351]
            require mem[_1351] == mem[_1351 + 18 len 14]
            _1369 = mem[_1351 + 32]
            require mem[_1351 + 32] == mem[_1351 + 50 len 14]
            require mem[_1351 + 64] == mem[_1351 + 92 len 4]
            mem[mem[64] + 4] = address(cd[((64 * idx) + cd[4] + 68)])
            require ext_code.size(address(cd[((64 * idx + 1) + cd[4] + 36)]))
            staticcall address(cd[((64 * idx + 1) + cd[4] + 36)]).balanceOf(address rg1) with:
                    gas gas_remaining wei
                   args address(cd[((64 * idx) + cd[4] + 68)])
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if address(cd[((64 * idx + 1) + cd[4] + 36)]) != address(cd[((64 * idx + 1) + cd[4] + 68)]):
                _1425 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[mem[64] + 4] = mem[_1425] - Mask(112, 0, _1369)
                mem[mem[64] + 36] = Mask(112, 0, _1369)
                mem[mem[64] + 68] = Mask(112, 0, _1359)
                require ext_code.size(address(cd[((64 * idx) + cd[4] + 36)]))
                staticcall address(cd[((64 * idx) + cd[4] + 36)]).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                        gas gas_remaining wei
                       args mem[mem[64] + 4], _1369 << 144, Mask(112, 0, _1359)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1489 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _1501 = mem[_1489]
                if address(cd[((64 * idx + 1) + cd[4] + 36)]) == address(cd[((64 * idx + 1) + cd[4] + 68)]):
                    _1544 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_1544 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_1544 + 36] = 0
                    mem[_1544 + 68] = _1501
                    mem[_1544 + 100] = this.address
                    mem[_1544 + 132] = 128
                    mem[_1544 + 164] = mem[_1544]
                    s = 0
                    while s < mem[_1544]:
                        mem[s + _1544 + 196] = mem[s + _1544 + 32]
                        s = s + 32
                        continue 
                    if ceil32(mem[_1544]) > mem[_1544]:
                        mem[_1544 + mem[_1544] + 196] = 0
                    require ext_code.size(address(cd[((64 * idx) + cd[4] + 68)]))
                    call address(cd[((64 * idx) + cd[4] + 68)]).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                         gas gas_remaining wei
                        args 0, _1501, address(this.address), 128, mem[_1544], mem[_1544 + 196 len ceil32(mem[_1544])]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[_1544 + 36] = this.address
                    require ext_code.size(address(cd[((64 * idx + 1) + cd[4] + 68)]))
                    staticcall address(cd[((64 * idx + 1) + cd[4] + 68)]).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args this.address
                    mem[_1544 + 32] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = _1544 + ceil32(return_data.size) + 32
                else:
                    _1545 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_1545 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_1545 + 36] = _1501
                    mem[_1545 + 68] = 0
                    mem[_1545 + 100] = this.address
                    mem[_1545 + 132] = 128
                    mem[_1545 + 164] = mem[_1545]
                    s = 0
                    while s < mem[_1545]:
                        mem[s + _1545 + 196] = mem[s + _1545 + 32]
                        s = s + 32
                        continue 
                    if ceil32(mem[_1545]) > mem[_1545]:
                        mem[_1545 + mem[_1545] + 196] = 0
                    require ext_code.size(address(cd[((64 * idx) + cd[4] + 68)]))
                    call address(cd[((64 * idx) + cd[4] + 68)]).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                         gas gas_remaining wei
                        args _1501, 0, address(this.address), 128, mem[_1545], mem[_1545 + 196 len ceil32(mem[_1545])]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[_1545 + 36] = this.address
                    require ext_code.size(address(cd[((64 * idx + 1) + cd[4] + 68)]))
                    staticcall address(cd[((64 * idx + 1) + cd[4] + 68)]).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args this.address
                    mem[_1545 + 32] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = _1545 + ceil32(return_data.size) + 32
                require return_data.size >= 32
                idx = idx + 2
                s = ext_call.return_data[0] - _661
                continue 
            _1424 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            mem[mem[64] + 4] = mem[_1424] - Mask(112, 0, _1359)
            mem[mem[64] + 36] = Mask(112, 0, _1359)
            mem[mem[64] + 68] = Mask(112, 0, _1369)
            require ext_code.size(address(cd[((64 * idx) + cd[4] + 36)]))
            staticcall address(cd[((64 * idx) + cd[4] + 36)]).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                    gas gas_remaining wei
                   args mem[mem[64] + 4], _1359 << 144, Mask(112, 0, _1369)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1488 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _1500 = mem[_1488]
            if address(cd[((64 * idx + 1) + cd[4] + 36)]) == address(cd[((64 * idx + 1) + cd[4] + 68)]):
                _1542 = mem[64]
                mem[mem[64]] = 0
                mem[64] = mem[64] + 32
                mem[_1542 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[_1542 + 36] = 0
                mem[_1542 + 68] = _1500
                mem[_1542 + 100] = this.address
                mem[_1542 + 132] = 128
                mem[_1542 + 164] = mem[_1542]
                s = 0
                while s < mem[_1542]:
                    mem[s + _1542 + 196] = mem[s + _1542 + 32]
                    s = s + 32
                    continue 
                if ceil32(mem[_1542]) <= mem[_1542]:
                    require ext_code.size(address(cd[((64 * idx) + cd[4] + 68)]))
                    call address(cd[((64 * idx) + cd[4] + 68)]).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_1542]) + _1542 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(cd[((64 * idx + 1) + cd[4] + 68)]))
                    staticcall address(cd[((64 * idx + 1) + cd[4] + 68)]).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2166 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    idx = idx + 2
                    s = mem[_2166] - _661
                    continue 
                mem[_1542 + mem[_1542] + 196] = 0
                require ext_code.size(address(cd[((64 * idx) + cd[4] + 68)]))
                call address(cd[((64 * idx) + cd[4] + 68)]).mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len ceil32(mem[_1542]) + _1542 + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(cd[((64 * idx + 1) + cd[4] + 68)]))
                staticcall address(cd[((64 * idx + 1) + cd[4] + 68)]).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2198 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                idx = idx + 2
                s = mem[_2198] - _661
                continue 
            _1543 = mem[64]
            mem[mem[64]] = 0
            mem[64] = mem[64] + 32
            mem[_1543 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
            mem[_1543 + 36] = _1500
            mem[_1543 + 68] = 0
            mem[_1543 + 100] = this.address
            mem[_1543 + 132] = 128
            mem[_1543 + 164] = mem[_1543]
            s = 0
            while s < mem[_1543]:
                mem[s + _1543 + 196] = mem[s + _1543 + 32]
                s = s + 32
                continue 
            if ceil32(mem[_1543]) <= mem[_1543]:
                require ext_code.size(address(cd[((64 * idx) + cd[4] + 68)]))
                call address(cd[((64 * idx) + cd[4] + 68)]).mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len ceil32(mem[_1543]) + _1543 + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(cd[((64 * idx + 1) + cd[4] + 68)]))
                staticcall address(cd[((64 * idx + 1) + cd[4] + 68)]).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2167 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                idx = idx + 2
                s = mem[_2167] - _661
                continue 
            mem[_1543 + mem[_1543] + 196] = 0
            require ext_code.size(address(cd[((64 * idx) + cd[4] + 68)]))
            call address(cd[((64 * idx) + cd[4] + 68)]).mem[mem[64] len 4] with:
                 gas gas_remaining wei
                args mem[mem[64] + 4 len ceil32(mem[_1543]) + _1543 + -mem[64] + 192]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[mem[64] + 4] = this.address
            require ext_code.size(address(cd[((64 * idx + 1) + cd[4] + 68)]))
            staticcall address(cd[((64 * idx + 1) + cd[4] + 68)]).balanceOf(address rg1) with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _2199 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            idx = idx + 2
            s = mem[_2199] - _661
            continue 
        _1301 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size) + 1
        mem[_1301] = return_data.size
        mem[_1301 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
        if not ext_call.success:
            if return_data.size:
                revert with ext_call.return_data[0 len return_data.size]
            _1308 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = mem[_662 + 100]
            _1310 = mem[_662 + 100]
            idx = 0
            while idx < _1310:
                mem[idx + _1308 + 68] = mem[idx + _662 + 132]
                idx = idx + 32
                continue 
            if not _1310 % 32:
                revert with memory
                  from mem[64]
                   len _1310 + _1308 + -mem[64] + 68
            mem[floor32(_1310) + _1308 + 68] = mem[floor32(_1310) + _1308 + -(_1310 % 32) + 100 len _1310 % 32]
            revert with memory
              from mem[64]
               len floor32(_1310) + _1308 + -mem[64] + 100
        if not return_data.size:
            require ext_code.size(address(cd[((64 * idx) + cd[4] + 68)]))
            staticcall address(cd[((64 * idx) + cd[4] + 68)]).getReserves() with:
                    gas gas_remaining wei
            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if address(cd[((64 * idx + 1) + cd[4] + 36)]) < address(cd[((64 * idx + 1) + cd[4] + 68)]):
                _1344 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 96
                _1356 = mem[_1344]
                require mem[_1344] == mem[_1344 + 18 len 14]
                _1364 = mem[_1344 + 32]
                require mem[_1344 + 32] == mem[_1344 + 50 len 14]
                require mem[_1344 + 64] == mem[_1344 + 92 len 4]
                mem[mem[64] + 4] = address(cd[((64 * idx) + cd[4] + 68)])
                require ext_code.size(address(cd[((64 * idx + 1) + cd[4] + 36)]))
                staticcall address(cd[((64 * idx + 1) + cd[4] + 36)]).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(cd[((64 * idx) + cd[4] + 68)])
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if address(cd[((64 * idx + 1) + cd[4] + 36)]) == address(cd[((64 * idx + 1) + cd[4] + 36)]):
                    _1410 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    mem[mem[64] + 4] = mem[_1410] - Mask(112, 0, _1356)
                    mem[mem[64] + 36] = Mask(112, 0, _1356)
                    mem[mem[64] + 68] = Mask(112, 0, _1364)
                    require ext_code.size(address(cd[((64 * idx) + cd[4] + 36)]))
                    staticcall address(cd[((64 * idx) + cd[4] + 36)]).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                            gas gas_remaining wei
                           args mem[mem[64] + 4], _1356 << 144, Mask(112, 0, _1364)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _1474 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _1490 = mem[_1474]
                    if address(cd[((64 * idx + 1) + cd[4] + 36)]) != address(cd[((64 * idx + 1) + cd[4] + 36)]):
                        _1515 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_1515 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_1515 + 36] = _1490
                        mem[_1515 + 68] = 0
                        mem[_1515 + 100] = this.address
                        mem[_1515 + 132] = 128
                        mem[_1515 + 164] = mem[_1515]
                        s = 0
                        while s < mem[_1515]:
                            mem[s + _1515 + 196] = mem[s + _1515 + 32]
                            s = s + 32
                            continue 
                        if ceil32(mem[_1515]) > mem[_1515]:
                            mem[_1515 + mem[_1515] + 196] = 0
                        require ext_code.size(address(cd[((64 * idx) + cd[4] + 68)]))
                        call address(cd[((64 * idx) + cd[4] + 68)]).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                             gas gas_remaining wei
                            args _1490, 0, address(this.address), 128, mem[_1515], mem[_1515 + 196 len ceil32(mem[_1515])]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_1515 + 36] = this.address
                        require ext_code.size(address(cd[((64 * idx + 1) + cd[4] + 68)]))
                        staticcall address(cd[((64 * idx + 1) + cd[4] + 68)]).balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args this.address
                        mem[_1515 + 32] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[64] = _1515 + ceil32(return_data.size) + 32
                        require return_data.size >= 32
                        idx = idx + 2
                        s = ext_call.return_data[0] - _661
                        continue 
                    _1514 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_1514 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_1514 + 36] = 0
                    mem[_1514 + 68] = _1490
                    mem[_1514 + 100] = this.address
                    mem[_1514 + 132] = 128
                    mem[_1514 + 164] = mem[_1514]
                    s = 0
                    while s < mem[_1514]:
                        mem[s + _1514 + 196] = mem[s + _1514 + 32]
                        s = s + 32
                        continue 
                    if ceil32(mem[_1514]) <= mem[_1514]:
                        require ext_code.size(address(cd[((64 * idx) + cd[4] + 68)]))
                        call address(cd[((64 * idx) + cd[4] + 68)]).mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len ceil32(mem[_1514]) + _1514 + -mem[64] + 192]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(cd[((64 * idx + 1) + cd[4] + 68)]))
                        staticcall address(cd[((64 * idx + 1) + cd[4] + 68)]).balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2170 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        idx = idx + 2
                        s = mem[_2170] - _661
                        continue 
                    mem[_1514 + mem[_1514] + 196] = 0
                    require ext_code.size(address(cd[((64 * idx) + cd[4] + 68)]))
                    call address(cd[((64 * idx) + cd[4] + 68)]).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_1514]) + _1514 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(cd[((64 * idx + 1) + cd[4] + 68)]))
                    staticcall address(cd[((64 * idx + 1) + cd[4] + 68)]).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2202 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    idx = idx + 2
                    s = mem[_2202] - _661
                    continue 
                _1411 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[mem[64] + 4] = mem[_1411] - Mask(112, 0, _1364)
                mem[mem[64] + 36] = Mask(112, 0, _1364)
                mem[mem[64] + 68] = Mask(112, 0, _1356)
                require ext_code.size(address(cd[((64 * idx) + cd[4] + 36)]))
                staticcall address(cd[((64 * idx) + cd[4] + 36)]).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                        gas gas_remaining wei
                       args mem[mem[64] + 4], _1364 << 144, Mask(112, 0, _1356)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1475 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _1491 = mem[_1475]
                if address(cd[((64 * idx + 1) + cd[4] + 36)]) != address(cd[((64 * idx + 1) + cd[4] + 36)]):
                    _1517 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_1517 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_1517 + 36] = _1491
                    mem[_1517 + 68] = 0
                    mem[_1517 + 100] = this.address
                    mem[_1517 + 132] = 128
                    mem[_1517 + 164] = mem[_1517]
                    s = 0
                    while s < mem[_1517]:
                        mem[s + _1517 + 196] = mem[s + _1517 + 32]
                        s = s + 32
                        continue 
                    if ceil32(mem[_1517]) > mem[_1517]:
                        mem[_1517 + mem[_1517] + 196] = 0
                    require ext_code.size(address(cd[((64 * idx) + cd[4] + 68)]))
                    call address(cd[((64 * idx) + cd[4] + 68)]).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                         gas gas_remaining wei
                        args _1491, 0, address(this.address), 128, mem[_1517], mem[_1517 + 196 len ceil32(mem[_1517])]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[_1517 + 36] = this.address
                    require ext_code.size(address(cd[((64 * idx + 1) + cd[4] + 68)]))
                    staticcall address(cd[((64 * idx + 1) + cd[4] + 68)]).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args this.address
                    mem[_1517 + 32] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = _1517 + ceil32(return_data.size) + 32
                    require return_data.size >= 32
                    idx = idx + 2
                    s = ext_call.return_data[0] - _661
                    continue 
                _1516 = mem[64]
                mem[mem[64]] = 0
                mem[64] = mem[64] + 32
                mem[_1516 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[_1516 + 36] = 0
                mem[_1516 + 68] = _1491
                mem[_1516 + 100] = this.address
                mem[_1516 + 132] = 128
                mem[_1516 + 164] = mem[_1516]
                s = 0
                while s < mem[_1516]:
                    mem[s + _1516 + 196] = mem[s + _1516 + 32]
                    s = s + 32
                    continue 
                if ceil32(mem[_1516]) <= mem[_1516]:
                    require ext_code.size(address(cd[((64 * idx) + cd[4] + 68)]))
                    call address(cd[((64 * idx) + cd[4] + 68)]).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_1516]) + _1516 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(cd[((64 * idx + 1) + cd[4] + 68)]))
                    staticcall address(cd[((64 * idx + 1) + cd[4] + 68)]).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2172 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    idx = idx + 2
                    s = mem[_2172] - _661
                    continue 
                mem[_1516 + mem[_1516] + 196] = 0
                require ext_code.size(address(cd[((64 * idx) + cd[4] + 68)]))
                call address(cd[((64 * idx) + cd[4] + 68)]).mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len ceil32(mem[_1516]) + _1516 + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(cd[((64 * idx + 1) + cd[4] + 68)]))
                staticcall address(cd[((64 * idx + 1) + cd[4] + 68)]).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2204 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                idx = idx + 2
                s = mem[_2204] - _661
                continue 
            _1345 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 96
            _1357 = mem[_1345]
            require mem[_1345] == mem[_1345 + 18 len 14]
            _1365 = mem[_1345 + 32]
            require mem[_1345 + 32] == mem[_1345 + 50 len 14]
            require mem[_1345 + 64] == mem[_1345 + 92 len 4]
            mem[mem[64] + 4] = address(cd[((64 * idx) + cd[4] + 68)])
            require ext_code.size(address(cd[((64 * idx + 1) + cd[4] + 36)]))
            staticcall address(cd[((64 * idx + 1) + cd[4] + 36)]).balanceOf(address rg1) with:
                    gas gas_remaining wei
                   args address(cd[((64 * idx) + cd[4] + 68)])
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if address(cd[((64 * idx + 1) + cd[4] + 36)]) == address(cd[((64 * idx + 1) + cd[4] + 68)]):
                _1412 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[mem[64] + 4] = mem[_1412] - Mask(112, 0, _1357)
                mem[mem[64] + 36] = Mask(112, 0, _1357)
                mem[mem[64] + 68] = Mask(112, 0, _1365)
                require ext_code.size(address(cd[((64 * idx) + cd[4] + 36)]))
                staticcall address(cd[((64 * idx) + cd[4] + 36)]).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                        gas gas_remaining wei
                       args mem[mem[64] + 4], _1357 << 144, Mask(112, 0, _1365)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1476 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _1492 = mem[_1476]
                if address(cd[((64 * idx + 1) + cd[4] + 36)]) != address(cd[((64 * idx + 1) + cd[4] + 68)]):
                    _1519 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_1519 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_1519 + 36] = _1492
                    mem[_1519 + 68] = 0
                    mem[_1519 + 100] = this.address
                    mem[_1519 + 132] = 128
                    mem[_1519 + 164] = mem[_1519]
                    s = 0
                    while s < mem[_1519]:
                        mem[s + _1519 + 196] = mem[s + _1519 + 32]
                        s = s + 32
                        continue 
                    if ceil32(mem[_1519]) > mem[_1519]:
                        mem[_1519 + mem[_1519] + 196] = 0
                    require ext_code.size(address(cd[((64 * idx) + cd[4] + 68)]))
                    call address(cd[((64 * idx) + cd[4] + 68)]).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                         gas gas_remaining wei
                        args _1492, 0, address(this.address), 128, mem[_1519], mem[_1519 + 196 len ceil32(mem[_1519])]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[_1519 + 36] = this.address
                    require ext_code.size(address(cd[((64 * idx + 1) + cd[4] + 68)]))
                    staticcall address(cd[((64 * idx + 1) + cd[4] + 68)]).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args this.address
                    mem[_1519 + 32] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = _1519 + ceil32(return_data.size) + 32
                    require return_data.size >= 32
                    idx = idx + 2
                    s = ext_call.return_data[0] - _661
                    continue 
                _1518 = mem[64]
                mem[mem[64]] = 0
                mem[64] = mem[64] + 32
                mem[_1518 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[_1518 + 36] = 0
                mem[_1518 + 68] = _1492
                mem[_1518 + 100] = this.address
                mem[_1518 + 132] = 128
                mem[_1518 + 164] = mem[_1518]
                s = 0
                while s < mem[_1518]:
                    mem[s + _1518 + 196] = mem[s + _1518 + 32]
                    s = s + 32
                    continue 
                if ceil32(mem[_1518]) <= mem[_1518]:
                    require ext_code.size(address(cd[((64 * idx) + cd[4] + 68)]))
                    call address(cd[((64 * idx) + cd[4] + 68)]).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_1518]) + _1518 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(cd[((64 * idx + 1) + cd[4] + 68)]))
                    staticcall address(cd[((64 * idx + 1) + cd[4] + 68)]).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2174 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    idx = idx + 2
                    s = mem[_2174] - _661
                    continue 
                mem[_1518 + mem[_1518] + 196] = 0
                require ext_code.size(address(cd[((64 * idx) + cd[4] + 68)]))
                call address(cd[((64 * idx) + cd[4] + 68)]).mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len ceil32(mem[_1518]) + _1518 + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(cd[((64 * idx + 1) + cd[4] + 68)]))
                staticcall address(cd[((64 * idx + 1) + cd[4] + 68)]).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2206 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                idx = idx + 2
                s = mem[_2206] - _661
                continue 
            _1413 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            mem[mem[64] + 4] = mem[_1413] - Mask(112, 0, _1365)
            mem[mem[64] + 36] = Mask(112, 0, _1365)
            mem[mem[64] + 68] = Mask(112, 0, _1357)
            require ext_code.size(address(cd[((64 * idx) + cd[4] + 36)]))
            staticcall address(cd[((64 * idx) + cd[4] + 36)]).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                    gas gas_remaining wei
                   args mem[mem[64] + 4], _1365 << 144, Mask(112, 0, _1357)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1477 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _1493 = mem[_1477]
            if address(cd[((64 * idx + 1) + cd[4] + 36)]) == address(cd[((64 * idx + 1) + cd[4] + 68)]):
                _1520 = mem[64]
                mem[mem[64]] = 0
                mem[64] = mem[64] + 32
                mem[_1520 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[_1520 + 36] = 0
                mem[_1520 + 68] = _1493
                mem[_1520 + 100] = this.address
                mem[_1520 + 132] = 128
                mem[_1520 + 164] = mem[_1520]
                s = 0
                while s < mem[_1520]:
                    mem[s + _1520 + 196] = mem[s + _1520 + 32]
                    s = s + 32
                    continue 
                if ceil32(mem[_1520]) <= mem[_1520]:
                    require ext_code.size(address(cd[((64 * idx) + cd[4] + 68)]))
                    call address(cd[((64 * idx) + cd[4] + 68)]).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_1520]) + _1520 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(cd[((64 * idx + 1) + cd[4] + 68)]))
                    staticcall address(cd[((64 * idx + 1) + cd[4] + 68)]).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2176 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    idx = idx + 2
                    s = mem[_2176] - _661
                    continue 
                mem[_1520 + mem[_1520] + 196] = 0
                require ext_code.size(address(cd[((64 * idx) + cd[4] + 68)]))
                call address(cd[((64 * idx) + cd[4] + 68)]).mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len ceil32(mem[_1520]) + _1520 + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(cd[((64 * idx + 1) + cd[4] + 68)]))
                staticcall address(cd[((64 * idx + 1) + cd[4] + 68)]).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2208 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                idx = idx + 2
                s = mem[_2208] - _661
                continue 
            _1521 = mem[64]
            mem[mem[64]] = 0
            mem[64] = mem[64] + 32
            mem[_1521 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
            mem[_1521 + 36] = _1493
            mem[_1521 + 68] = 0
            mem[_1521 + 100] = this.address
            mem[_1521 + 132] = 128
            mem[_1521 + 164] = mem[_1521]
            s = 0
            while s < mem[_1521]:
                mem[s + _1521 + 196] = mem[s + _1521 + 32]
                s = s + 32
                continue 
            if ceil32(mem[_1521]) <= mem[_1521]:
                require ext_code.size(address(cd[((64 * idx) + cd[4] + 68)]))
                call address(cd[((64 * idx) + cd[4] + 68)]).mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len ceil32(mem[_1521]) + _1521 + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(cd[((64 * idx + 1) + cd[4] + 68)]))
                staticcall address(cd[((64 * idx + 1) + cd[4] + 68)]).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2177 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                idx = idx + 2
                s = mem[_2177] - _661
                continue 
            mem[_1521 + mem[_1521] + 196] = 0
            require ext_code.size(address(cd[((64 * idx) + cd[4] + 68)]))
            call address(cd[((64 * idx) + cd[4] + 68)]).mem[mem[64] len 4] with:
                 gas gas_remaining wei
                args mem[mem[64] + 4 len ceil32(mem[_1521]) + _1521 + -mem[64] + 192]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[mem[64] + 4] = this.address
            require ext_code.size(address(cd[((64 * idx + 1) + cd[4] + 68)]))
            staticcall address(cd[((64 * idx + 1) + cd[4] + 68)]).balanceOf(address rg1) with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _2209 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            idx = idx + 2
            s = mem[_2209] - _661
            continue 
        require return_data.size >= 32
        if not mem[_1301 + 32]:
            revert with 0, 
                        32,
                        42,
                        0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                        mem[mem[64] + 110 len 22]
        require ext_code.size(address(cd[((64 * idx) + cd[4] + 68)]))
        staticcall address(cd[((64 * idx) + cd[4] + 68)]).getReserves() with:
                gas gas_remaining wei
        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        if address(cd[((64 * idx + 1) + cd[4] + 36)]) < address(cd[((64 * idx + 1) + cd[4] + 68)]):
            _1352 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 96
            _1360 = mem[_1352]
            require mem[_1352] == mem[_1352 + 18 len 14]
            _1372 = mem[_1352 + 32]
            require mem[_1352 + 32] == mem[_1352 + 50 len 14]
            require mem[_1352 + 64] == mem[_1352 + 92 len 4]
            mem[mem[64] + 4] = address(cd[((64 * idx) + cd[4] + 68)])
            require ext_code.size(address(cd[((64 * idx + 1) + cd[4] + 36)]))
            staticcall address(cd[((64 * idx + 1) + cd[4] + 36)]).balanceOf(address rg1) with:
                    gas gas_remaining wei
                   args address(cd[((64 * idx) + cd[4] + 68)])
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if address(cd[((64 * idx + 1) + cd[4] + 36)]) == address(cd[((64 * idx + 1) + cd[4] + 36)]):
                _1430 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[mem[64] + 4] = mem[_1430] - Mask(112, 0, _1360)
                mem[mem[64] + 36] = Mask(112, 0, _1360)
                mem[mem[64] + 68] = Mask(112, 0, _1372)
                require ext_code.size(address(cd[((64 * idx) + cd[4] + 36)]))
                staticcall address(cd[((64 * idx) + cd[4] + 36)]).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                        gas gas_remaining wei
                       args mem[mem[64] + 4], _1360 << 144, Mask(112, 0, _1372)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1494 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _1502 = mem[_1494]
                if address(cd[((64 * idx + 1) + cd[4] + 36)]) == address(cd[((64 * idx + 1) + cd[4] + 36)]):
                    _1546 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_1546 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_1546 + 36] = 0
                    mem[_1546 + 68] = _1502
                    mem[_1546 + 100] = this.address
                    mem[_1546 + 132] = 128
                    mem[_1546 + 164] = mem[_1546]
                    s = 0
                    while s < mem[_1546]:
                        mem[s + _1546 + 196] = mem[s + _1546 + 32]
                        s = s + 32
                        continue 
                    if ceil32(mem[_1546]) > mem[_1546]:
                        mem[_1546 + mem[_1546] + 196] = 0
                    require ext_code.size(address(cd[((64 * idx) + cd[4] + 68)]))
                    call address(cd[((64 * idx) + cd[4] + 68)]).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                         gas gas_remaining wei
                        args 0, _1502, address(this.address), 128, mem[_1546], mem[_1546 + 196 len ceil32(mem[_1546])]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[_1546 + 36] = this.address
                    require ext_code.size(address(cd[((64 * idx + 1) + cd[4] + 68)]))
                    staticcall address(cd[((64 * idx + 1) + cd[4] + 68)]).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args this.address
                    mem[_1546 + 32] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = _1546 + ceil32(return_data.size) + 32
                else:
                    _1547 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_1547 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_1547 + 36] = _1502
                    mem[_1547 + 68] = 0
                    mem[_1547 + 100] = this.address
                    mem[_1547 + 132] = 128
                    mem[_1547 + 164] = mem[_1547]
                    s = 0
                    while s < mem[_1547]:
                        mem[s + _1547 + 196] = mem[s + _1547 + 32]
                        s = s + 32
                        continue 
                    if ceil32(mem[_1547]) > mem[_1547]:
                        mem[_1547 + mem[_1547] + 196] = 0
                    require ext_code.size(address(cd[((64 * idx) + cd[4] + 68)]))
                    call address(cd[((64 * idx) + cd[4] + 68)]).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                         gas gas_remaining wei
                        args _1502, 0, address(this.address), 128, mem[_1547], mem[_1547 + 196 len ceil32(mem[_1547])]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[_1547 + 36] = this.address
                    require ext_code.size(address(cd[((64 * idx + 1) + cd[4] + 68)]))
                    staticcall address(cd[((64 * idx + 1) + cd[4] + 68)]).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args this.address
                    mem[_1547 + 32] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = _1547 + ceil32(return_data.size) + 32
            else:
                _1431 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[mem[64] + 4] = mem[_1431] - Mask(112, 0, _1372)
                mem[mem[64] + 36] = Mask(112, 0, _1372)
                mem[mem[64] + 68] = Mask(112, 0, _1360)
                require ext_code.size(address(cd[((64 * idx) + cd[4] + 36)]))
                staticcall address(cd[((64 * idx) + cd[4] + 36)]).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                        gas gas_remaining wei
                       args mem[mem[64] + 4], _1372 << 144, Mask(112, 0, _1360)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1495 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _1503 = mem[_1495]
                if address(cd[((64 * idx + 1) + cd[4] + 36)]) == address(cd[((64 * idx + 1) + cd[4] + 36)]):
                    _1548 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_1548 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_1548 + 36] = 0
                    mem[_1548 + 68] = _1503
                    mem[_1548 + 100] = this.address
                    mem[_1548 + 132] = 128
                    mem[_1548 + 164] = mem[_1548]
                    s = 0
                    while s < mem[_1548]:
                        mem[s + _1548 + 196] = mem[s + _1548 + 32]
                        s = s + 32
                        continue 
                    if ceil32(mem[_1548]) > mem[_1548]:
                        mem[_1548 + mem[_1548] + 196] = 0
                    require ext_code.size(address(cd[((64 * idx) + cd[4] + 68)]))
                    call address(cd[((64 * idx) + cd[4] + 68)]).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                         gas gas_remaining wei
                        args 0, _1503, address(this.address), 128, mem[_1548], mem[_1548 + 196 len ceil32(mem[_1548])]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[_1548 + 36] = this.address
                    require ext_code.size(address(cd[((64 * idx + 1) + cd[4] + 68)]))
                    staticcall address(cd[((64 * idx + 1) + cd[4] + 68)]).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args this.address
                    mem[_1548 + 32] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = _1548 + ceil32(return_data.size) + 32
                else:
                    _1549 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_1549 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_1549 + 36] = _1503
                    mem[_1549 + 68] = 0
                    mem[_1549 + 100] = this.address
                    mem[_1549 + 132] = 128
                    mem[_1549 + 164] = mem[_1549]
                    s = 0
                    while s < mem[_1549]:
                        mem[s + _1549 + 196] = mem[s + _1549 + 32]
                        s = s + 32
                        continue 
                    if ceil32(mem[_1549]) > mem[_1549]:
                        mem[_1549 + mem[_1549] + 196] = 0
                    require ext_code.size(address(cd[((64 * idx) + cd[4] + 68)]))
                    call address(cd[((64 * idx) + cd[4] + 68)]).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                         gas gas_remaining wei
                        args _1503, 0, address(this.address), 128, mem[_1549], mem[_1549 + 196 len ceil32(mem[_1549])]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[_1549 + 36] = this.address
                    require ext_code.size(address(cd[((64 * idx + 1) + cd[4] + 68)]))
                    staticcall address(cd[((64 * idx + 1) + cd[4] + 68)]).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args this.address
                    mem[_1549 + 32] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = _1549 + ceil32(return_data.size) + 32
            require return_data.size >= 32
            idx = idx + 2
            s = ext_call.return_data[0] - _661
            continue 
        _1353 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 96
        _1361 = mem[_1353]
        require mem[_1353] == mem[_1353 + 18 len 14]
        _1373 = mem[_1353 + 32]
        require mem[_1353 + 32] == mem[_1353 + 50 len 14]
        require mem[_1353 + 64] == mem[_1353 + 92 len 4]
        mem[mem[64] + 4] = address(cd[((64 * idx) + cd[4] + 68)])
        require ext_code.size(address(cd[((64 * idx + 1) + cd[4] + 36)]))
        staticcall address(cd[((64 * idx + 1) + cd[4] + 36)]).balanceOf(address rg1) with:
                gas gas_remaining wei
               args address(cd[((64 * idx) + cd[4] + 68)])
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        if address(cd[((64 * idx + 1) + cd[4] + 36)]) == address(cd[((64 * idx + 1) + cd[4] + 68)]):
            _1432 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            mem[mem[64] + 4] = mem[_1432] - Mask(112, 0, _1361)
            mem[mem[64] + 36] = Mask(112, 0, _1361)
            mem[mem[64] + 68] = Mask(112, 0, _1373)
            require ext_code.size(address(cd[((64 * idx) + cd[4] + 36)]))
            staticcall address(cd[((64 * idx) + cd[4] + 36)]).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                    gas gas_remaining wei
                   args mem[mem[64] + 4], _1361 << 144, Mask(112, 0, _1373)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1496 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _1504 = mem[_1496]
            if address(cd[((64 * idx + 1) + cd[4] + 36)]) == address(cd[((64 * idx + 1) + cd[4] + 68)]):
                _1550 = mem[64]
                mem[mem[64]] = 0
                mem[64] = mem[64] + 32
                mem[_1550 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[_1550 + 36] = 0
                mem[_1550 + 68] = _1504
                mem[_1550 + 100] = this.address
                mem[_1550 + 132] = 128
                mem[_1550 + 164] = mem[_1550]
                s = 0
                while s < mem[_1550]:
                    mem[s + _1550 + 196] = mem[s + _1550 + 32]
                    s = s + 32
                    continue 
                if ceil32(mem[_1550]) > mem[_1550]:
                    mem[_1550 + mem[_1550] + 196] = 0
                require ext_code.size(address(cd[((64 * idx) + cd[4] + 68)]))
                call address(cd[((64 * idx) + cd[4] + 68)]).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                     gas gas_remaining wei
                    args 0, _1504, address(this.address), 128, mem[_1550], mem[_1550 + 196 len ceil32(mem[_1550])]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[_1550 + 36] = this.address
                require ext_code.size(address(cd[((64 * idx + 1) + cd[4] + 68)]))
                staticcall address(cd[((64 * idx + 1) + cd[4] + 68)]).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args this.address
                mem[_1550 + 32] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[64] = _1550 + ceil32(return_data.size) + 32
            else:
                _1551 = mem[64]
                mem[mem[64]] = 0
                mem[64] = mem[64] + 32
                mem[_1551 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[_1551 + 36] = _1504
                mem[_1551 + 68] = 0
                mem[_1551 + 100] = this.address
                mem[_1551 + 132] = 128
                mem[_1551 + 164] = mem[_1551]
                s = 0
                while s < mem[_1551]:
                    mem[s + _1551 + 196] = mem[s + _1551 + 32]
                    s = s + 32
                    continue 
                if ceil32(mem[_1551]) > mem[_1551]:
                    mem[_1551 + mem[_1551] + 196] = 0
                require ext_code.size(address(cd[((64 * idx) + cd[4] + 68)]))
                call address(cd[((64 * idx) + cd[4] + 68)]).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                     gas gas_remaining wei
                    args _1504, 0, address(this.address), 128, mem[_1551], mem[_1551 + 196 len ceil32(mem[_1551])]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[_1551 + 36] = this.address
                require ext_code.size(address(cd[((64 * idx + 1) + cd[4] + 68)]))
                staticcall address(cd[((64 * idx + 1) + cd[4] + 68)]).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args this.address
                mem[_1551 + 32] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[64] = _1551 + ceil32(return_data.size) + 32
            require return_data.size >= 32
            idx = idx + 2
            s = ext_call.return_data[0] - _661
            continue 
        _1433 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        mem[mem[64] + 4] = mem[_1433] - Mask(112, 0, _1373)
        mem[mem[64] + 36] = Mask(112, 0, _1373)
        mem[mem[64] + 68] = Mask(112, 0, _1361)
        require ext_code.size(address(cd[((64 * idx) + cd[4] + 36)]))
        staticcall address(cd[((64 * idx) + cd[4] + 36)]).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                gas gas_remaining wei
               args mem[mem[64] + 4], _1373 << 144, Mask(112, 0, _1361)
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _1497 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _1505 = mem[_1497]
        if address(cd[((64 * idx + 1) + cd[4] + 36)]) == address(cd[((64 * idx + 1) + cd[4] + 68)]):
            _1552 = mem[64]
            mem[mem[64]] = 0
            mem[64] = mem[64] + 32
            mem[_1552 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
            mem[_1552 + 36] = 0
            mem[_1552 + 68] = _1505
            mem[_1552 + 100] = this.address
            mem[_1552 + 132] = 128
            mem[_1552 + 164] = mem[_1552]
            s = 0
            while s < mem[_1552]:
                mem[s + _1552 + 196] = mem[s + _1552 + 32]
                s = s + 32
                continue 
            if ceil32(mem[_1552]) <= mem[_1552]:
                require ext_code.size(address(cd[((64 * idx) + cd[4] + 68)]))
                call address(cd[((64 * idx) + cd[4] + 68)]).mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len ceil32(mem[_1552]) + _1552 + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(cd[((64 * idx + 1) + cd[4] + 68)]))
                staticcall address(cd[((64 * idx + 1) + cd[4] + 68)]).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2184 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                idx = idx + 2
                s = mem[_2184] - _661
                continue 
            mem[_1552 + mem[_1552] + 196] = 0
            require ext_code.size(address(cd[((64 * idx) + cd[4] + 68)]))
            call address(cd[((64 * idx) + cd[4] + 68)]).mem[mem[64] len 4] with:
                 gas gas_remaining wei
                args mem[mem[64] + 4 len ceil32(mem[_1552]) + _1552 + -mem[64] + 192]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[mem[64] + 4] = this.address
            require ext_code.size(address(cd[((64 * idx + 1) + cd[4] + 68)]))
            staticcall address(cd[((64 * idx + 1) + cd[4] + 68)]).balanceOf(address rg1) with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _2216 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            idx = idx + 2
            s = mem[_2216] - _661
            continue 
        _1553 = mem[64]
        mem[mem[64]] = 0
        mem[64] = mem[64] + 32
        mem[_1553 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[_1553 + 36] = _1505
        mem[_1553 + 68] = 0
        mem[_1553 + 100] = this.address
        mem[_1553 + 132] = 128
        mem[_1553 + 164] = mem[_1553]
        s = 0
        while s < mem[_1553]:
            mem[s + _1553 + 196] = mem[s + _1553 + 32]
            s = s + 32
            continue 
        if ceil32(mem[_1553]) <= mem[_1553]:
            require ext_code.size(address(cd[((64 * idx) + cd[4] + 68)]))
            call address(cd[((64 * idx) + cd[4] + 68)]).mem[mem[64] len 4] with:
                 gas gas_remaining wei
                args mem[mem[64] + 4 len ceil32(mem[_1553]) + _1553 + -mem[64] + 192]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[mem[64] + 4] = this.address
            require ext_code.size(address(cd[((64 * idx + 1) + cd[4] + 68)]))
            staticcall address(cd[((64 * idx + 1) + cd[4] + 68)]).balanceOf(address rg1) with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _2185 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            idx = idx + 2
            s = mem[_2185] - _661
            continue 
        mem[_1553 + mem[_1553] + 196] = 0
        require ext_code.size(address(cd[((64 * idx) + cd[4] + 68)]))
        call address(cd[((64 * idx) + cd[4] + 68)]).mem[mem[64] len 4] with:
             gas gas_remaining wei
            args mem[mem[64] + 4 len ceil32(mem[_1553]) + _1553 + -mem[64] + 192]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[mem[64] + 4] = this.address
        require ext_code.size(address(cd[((64 * idx + 1) + cd[4] + 68)]))
        staticcall address(cd[((64 * idx + 1) + cd[4] + 68)]).balanceOf(address rg1) with:
                gas gas_remaining wei
               args address(this.address)
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _2217 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        idx = idx + 2
        s = mem[_2217] - _661
        continue 
    require 1 < ('cd', 4).length
    require ('cd', 4)[2] == address(('cd', 4)[2])
    mem[mem[64] + 4] = this.address
    require ext_code.size(address(('cd', 4)[2]))
    staticcall address(('cd', 4)[2]).balanceOf(address rg1) with:
            gas gas_remaining wei
           args address(this.address)
    mem[mem[64]] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _654 = mem[64]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    if mem[_654] <= ext_call.return_data[0]:
        revert with 0, 'sL'
}

function demaxCall(address arg1, uint256 arg2, uint256 arg3, bytes arg4) {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg4 <= test266151307()
    require arg4 + 35 < calldata.size
    require arg4.length <= test266151307()
    require arg4 + arg4.length + 36 <= calldata.size
    require ext_code.size(msg.sender)
    staticcall msg.sender.token0() with:
            gas gas_remaining wei
    mem[96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    require ext_code.size(msg.sender)
    staticcall msg.sender.token1() with:
            gas gas_remaining wei
    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    require arg4.length >= 96
    require cd[(arg4 + 100)] <= test266151307()
    require arg4 + arg4.length + 36 > arg4 + cd[(arg4 + 100)] + 67
    require cd[(arg4 + cd[(arg4 + 100)] + 36)] <= test266151307()
    require (32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 128 >= 96 and (2 * ceil32(return_data.size)) + (32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 128 <= test266151307()
    mem[64] = (2 * ceil32(return_data.size)) + (32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 128
    mem[(2 * ceil32(return_data.size)) + 96] = cd[(arg4 + cd[(arg4 + 100)] + 36)]
    require arg4.length + 36 >= cd[(arg4 + 100)] + (64 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 68
    s = arg4 + cd[(arg4 + 100)] + 68
    t = (2 * ceil32(return_data.size)) + 128
    idx = 0
    while idx < cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        require s + 31 < arg4 + arg4.length + 36
        _1499 = mem[64]
        require mem[64] + 64 >= mem[64] and mem[64] + 64 <= test266151307()
        mem[64] = mem[64] + 64
        require s + 64 <= arg4 + arg4.length + 36
        u = 0
        v = s
        w = _1499
        while u < 2:
            require cd[v] == address(cd[v])
            mem[w] = cd[v]
            u = u + 1
            v = v + 32
            w = w + 32
            continue 
        mem[t] = _1499
        s = s + 64
        t = t + 32
        idx = idx + 1
        continue 
    require 0 < mem[(2 * ceil32(return_data.size)) + 96]
    require msg.sender == mem[mem[(2 * ceil32(return_data.size)) + 128] + 44 len 20]
    require 3 < mem[(2 * ceil32(return_data.size)) + 96]
    _1503 = mem[mem[(2 * ceil32(return_data.size)) + 224]]
    mem[mem[64] + 4] = this.address
    require ext_code.size(address(_1503))
    staticcall address(_1503).balanceOf(address rg1) with:
            gas gas_remaining wei
           args address(this.address)
    mem[mem[64]] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _1506 = mem[64]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    _2246 = mem[(2 * ceil32(return_data.size)) + 96]
    idx = 2
    s = mem[_1506] - cd[(arg4 + 68)]
    while idx < _2246:
        require idx < mem[(2 * ceil32(return_data.size)) + 96]
        _2252 = mem[mem[(32 * idx) + (2 * ceil32(return_data.size)) + 128]]
        require idx < mem[(2 * ceil32(return_data.size)) + 96]
        _2260 = mem[mem[(32 * idx) + (2 * ceil32(return_data.size)) + 128] + 32]
        require idx + 1 < mem[(2 * ceil32(return_data.size)) + 96]
        _2263 = mem[mem[(32 * idx + 1) + (2 * ceil32(return_data.size)) + 128]]
        require idx + 1 < mem[(2 * ceil32(return_data.size)) + 96]
        _2266 = mem[mem[(32 * idx + 1) + (2 * ceil32(return_data.size)) + 128] + 32]
        mem[mem[64] + 4] = this.address
        require ext_code.size(address(_2266))
        staticcall address(_2266).balanceOf(address rg1) with:
                gas gas_remaining wei
               args address(this.address)
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _2285 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _2292 = mem[_2285]
        _2305 = mem[64]
        mem[mem[64] + 36] = address(_2260)
        mem[mem[64] + 68] = s
        _2306 = mem[64]
        mem[mem[64]] = 68
        mem[64] = mem[64] + 100
        mem[_2306 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_2306 + 36 len 28]
        mem[64] = _2305 + 164
        mem[_2305 + 100] = 32
        mem[_2305 + 132] = 'SafeERC20: low-level call failed'
        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(address(_2263)):
            revert with 0, 'Address: call to non-contract'
        if not ext_code.hash(address(_2263)):
            revert with 0, 'Address: call to non-contract'
        _2356 = mem[_2306]
        t = _2306 + 32
        u = mem[64]
        s = mem[_2306]
        while s >= 32:
            mem[u] = mem[t]
            t = t + 32
            u = u + 32
            s = s - 32
            continue 
        mem[mem[64] + floor32(mem[_2306])] = mem[_2306 + floor32(mem[_2306]) + -(mem[_2306] % 32) + 64 len mem[_2306] % 32] or Mask(8 * -(mem[_2306] % 32) + 32, -(8 * -(mem[_2306] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_2306])])
        call address(_2263).mem[mem[64] len 4] with:
             gas gas_remaining wei
            args mem[mem[64] + 4 len _2356 + _2305 + -mem[64] + 160]
        if not return_data.size:
            if not ext_call.success:
                if mem[96]:
                    revert with memory
                      from 128
                       len mem[96]
                _3021 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = mem[_2305 + 100]
                _3023 = mem[_2305 + 100]
                idx = 0
                while idx < _3023:
                    mem[idx + _3021 + 68] = mem[idx + _2305 + 132]
                    idx = idx + 32
                    continue 
                if not _3023 % 32:
                    revert with memory
                      from mem[64]
                       len _3023 + _3021 + -mem[64] + 68
                mem[floor32(_3023) + _3021 + 68] = mem[floor32(_3023) + _3021 + -(_3023 % 32) + 100 len _3023 % 32]
                revert with memory
                  from mem[64]
                   len floor32(_3023) + _3021 + -mem[64] + 100
            if not mem[96]:
                require ext_code.size(address(_2260))
                staticcall address(_2260).getReserves() with:
                        gas gas_remaining wei
                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if address(_2263) < address(_2266):
                    _3091 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 96
                    _3107 = mem[_3091]
                    require mem[_3091] == mem[_3091 + 18 len 14]
                    _3115 = mem[_3091 + 32]
                    require mem[_3091 + 32] == mem[_3091 + 50 len 14]
                    require mem[_3091 + 64] == mem[_3091 + 92 len 4]
                    mem[mem[64] + 4] = address(_2260)
                    require ext_code.size(address(_2263))
                    staticcall address(_2263).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(_2260)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if address(_2263) != address(_2263):
                        _3156 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        mem[mem[64] + 4] = mem[_3156] - Mask(112, 0, _3115)
                        mem[mem[64] + 36] = Mask(112, 0, _3115)
                        mem[mem[64] + 68] = Mask(112, 0, _3107)
                        require ext_code.size(address(_2252))
                        staticcall address(_2252).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                                gas gas_remaining wei
                               args mem[mem[64] + 4], _3115 << 144, Mask(112, 0, _3107)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3220 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _3236 = mem[_3220]
                        if address(_2263) == address(_2263):
                            _3261 = mem[64]
                            mem[mem[64]] = 0
                            mem[64] = mem[64] + 32
                            mem[_3261 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                            mem[_3261 + 36] = 0
                            mem[_3261 + 68] = _3236
                            mem[_3261 + 100] = this.address
                            mem[_3261 + 132] = 128
                            mem[_3261 + 164] = mem[_3261]
                            s = 0
                            while s < mem[_3261]:
                                mem[s + _3261 + 196] = mem[s + _3261 + 32]
                                s = s + 32
                                continue 
                            if ceil32(mem[_3261]) > mem[_3261]:
                                mem[_3261 + mem[_3261] + 196] = 0
                            require ext_code.size(address(_2260))
                            call address(_2260).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                                 gas gas_remaining wei
                                args 0, _3236, address(this.address), 128, mem[_3261], mem[_3261 + 196 len ceil32(mem[_3261])]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_3261 + 36] = this.address
                            require ext_code.size(address(_2266))
                            staticcall address(_2266).balanceOf(address rg1) with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[_3261 + 32] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = _3261 + ceil32(return_data.size) + 32
                        else:
                            _3262 = mem[64]
                            mem[mem[64]] = 0
                            mem[64] = mem[64] + 32
                            mem[_3262 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                            mem[_3262 + 36] = _3236
                            mem[_3262 + 68] = 0
                            mem[_3262 + 100] = this.address
                            mem[_3262 + 132] = 128
                            mem[_3262 + 164] = mem[_3262]
                            s = 0
                            while s < mem[_3262]:
                                mem[s + _3262 + 196] = mem[s + _3262 + 32]
                                s = s + 32
                                continue 
                            if ceil32(mem[_3262]) > mem[_3262]:
                                mem[_3262 + mem[_3262] + 196] = 0
                            require ext_code.size(address(_2260))
                            call address(_2260).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                                 gas gas_remaining wei
                                args _3236, 0, address(this.address), 128, mem[_3262], mem[_3262 + 196 len ceil32(mem[_3262])]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_3262 + 36] = this.address
                            require ext_code.size(address(_2266))
                            staticcall address(_2266).balanceOf(address rg1) with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[_3262 + 32] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = _3262 + ceil32(return_data.size) + 32
                        require return_data.size >= 32
                        idx = idx + 2
                        s = ext_call.return_data[0] - _2292
                        continue 
                    _3155 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    mem[mem[64] + 4] = mem[_3155] - Mask(112, 0, _3107)
                    mem[mem[64] + 36] = Mask(112, 0, _3107)
                    mem[mem[64] + 68] = Mask(112, 0, _3115)
                    require ext_code.size(address(_2252))
                    staticcall address(_2252).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                            gas gas_remaining wei
                           args mem[mem[64] + 4], _3107 << 144, Mask(112, 0, _3115)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3219 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _3235 = mem[_3219]
                    if address(_2263) != address(_2263):
                        _3260 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_3260 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_3260 + 36] = _3235
                        mem[_3260 + 68] = 0
                        mem[_3260 + 100] = this.address
                        mem[_3260 + 132] = 128
                        mem[_3260 + 164] = mem[_3260]
                        s = 0
                        while s < mem[_3260]:
                            mem[s + _3260 + 196] = mem[s + _3260 + 32]
                            s = s + 32
                            continue 
                        if ceil32(mem[_3260]) > mem[_3260]:
                            mem[_3260 + mem[_3260] + 196] = 0
                        require ext_code.size(address(_2260))
                        call address(_2260).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                             gas gas_remaining wei
                            args _3235, 0, address(this.address), 128, mem[_3260], mem[_3260 + 196 len ceil32(mem[_3260])]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_3260 + 36] = this.address
                        require ext_code.size(address(_2266))
                        staticcall address(_2266).balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args this.address
                        mem[_3260 + 32] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[64] = _3260 + ceil32(return_data.size) + 32
                        require return_data.size >= 32
                        idx = idx + 2
                        s = ext_call.return_data[0] - _2292
                        continue 
                    _3259 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_3259 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_3259 + 36] = 0
                    mem[_3259 + 68] = _3235
                    mem[_3259 + 100] = this.address
                    mem[_3259 + 132] = 128
                    mem[_3259 + 164] = mem[_3259]
                    s = 0
                    while s < mem[_3259]:
                        mem[s + _3259 + 196] = mem[s + _3259 + 32]
                        s = s + 32
                        continue 
                    if ceil32(mem[_3259]) <= mem[_3259]:
                        require ext_code.size(address(_2260))
                        call address(_2260).mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len ceil32(mem[_3259]) + _3259 + -mem[64] + 192]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(_2266))
                        staticcall address(_2266).balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3923 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        idx = idx + 2
                        s = mem[_3923] - _2292
                        continue 
                    mem[_3259 + mem[_3259] + 196] = 0
                    require ext_code.size(address(_2260))
                    call address(_2260).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_3259]) + _3259 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(_2266))
                    staticcall address(_2266).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3955 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    idx = idx + 2
                    s = mem[_3955] - _2292
                    continue 
                _3092 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 96
                _3108 = mem[_3092]
                require mem[_3092] == mem[_3092 + 18 len 14]
                _3116 = mem[_3092 + 32]
                require mem[_3092 + 32] == mem[_3092 + 50 len 14]
                require mem[_3092 + 64] == mem[_3092 + 92 len 4]
                mem[mem[64] + 4] = address(_2260)
                require ext_code.size(address(_2263))
                staticcall address(_2263).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(_2260)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if address(_2263) == address(_2266):
                    _3157 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    mem[mem[64] + 4] = mem[_3157] - Mask(112, 0, _3108)
                    mem[mem[64] + 36] = Mask(112, 0, _3108)
                    mem[mem[64] + 68] = Mask(112, 0, _3116)
                    require ext_code.size(address(_2252))
                    staticcall address(_2252).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                            gas gas_remaining wei
                           args mem[mem[64] + 4], _3108 << 144, Mask(112, 0, _3116)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3221 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _3237 = mem[_3221]
                    if address(_2263) == address(_2266):
                        _3263 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_3263 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_3263 + 36] = 0
                        mem[_3263 + 68] = _3237
                        mem[_3263 + 100] = this.address
                        mem[_3263 + 132] = 128
                        mem[_3263 + 164] = mem[_3263]
                        s = 0
                        while s < mem[_3263]:
                            mem[s + _3263 + 196] = mem[s + _3263 + 32]
                            s = s + 32
                            continue 
                        if ceil32(mem[_3263]) <= mem[_3263]:
                            require ext_code.size(address(_2260))
                            call address(_2260).mem[mem[64] len 4] with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len ceil32(mem[_3263]) + _3263 + -mem[64] + 192]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(address(_2266))
                            staticcall address(_2266).balanceOf(address rg1) with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3927 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            idx = idx + 2
                            s = mem[_3927] - _2292
                            continue 
                        mem[_3263 + mem[_3263] + 196] = 0
                        require ext_code.size(address(_2260))
                        call address(_2260).mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len ceil32(mem[_3263]) + _3263 + -mem[64] + 192]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(_2266))
                        staticcall address(_2266).balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3959 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        idx = idx + 2
                        s = mem[_3959] - _2292
                        continue 
                    _3264 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_3264 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_3264 + 36] = _3237
                    mem[_3264 + 68] = 0
                    mem[_3264 + 100] = this.address
                    mem[_3264 + 132] = 128
                    mem[_3264 + 164] = mem[_3264]
                    s = 0
                    while s < mem[_3264]:
                        mem[s + _3264 + 196] = mem[s + _3264 + 32]
                        s = s + 32
                        continue 
                    if ceil32(mem[_3264]) <= mem[_3264]:
                        require ext_code.size(address(_2260))
                        call address(_2260).mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len ceil32(mem[_3264]) + _3264 + -mem[64] + 192]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(_2266))
                        staticcall address(_2266).balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3928 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        idx = idx + 2
                        s = mem[_3928] - _2292
                        continue 
                    mem[_3264 + mem[_3264] + 196] = 0
                    require ext_code.size(address(_2260))
                    call address(_2260).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_3264]) + _3264 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(_2266))
                    staticcall address(_2266).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3960 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    idx = idx + 2
                    s = mem[_3960] - _2292
                    continue 
                _3158 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[mem[64] + 4] = mem[_3158] - Mask(112, 0, _3116)
                mem[mem[64] + 36] = Mask(112, 0, _3116)
                mem[mem[64] + 68] = Mask(112, 0, _3108)
                require ext_code.size(address(_2252))
                staticcall address(_2252).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                        gas gas_remaining wei
                       args mem[mem[64] + 4], _3116 << 144, Mask(112, 0, _3108)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3222 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _3238 = mem[_3222]
                if address(_2263) == address(_2266):
                    _3265 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_3265 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_3265 + 36] = 0
                    mem[_3265 + 68] = _3238
                    mem[_3265 + 100] = this.address
                    mem[_3265 + 132] = 128
                    mem[_3265 + 164] = mem[_3265]
                    s = 0
                    while s < mem[_3265]:
                        mem[s + _3265 + 196] = mem[s + _3265 + 32]
                        s = s + 32
                        continue 
                    if ceil32(mem[_3265]) <= mem[_3265]:
                        require ext_code.size(address(_2260))
                        call address(_2260).mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len ceil32(mem[_3265]) + _3265 + -mem[64] + 192]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(_2266))
                        staticcall address(_2266).balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3929 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        idx = idx + 2
                        s = mem[_3929] - _2292
                        continue 
                    mem[_3265 + mem[_3265] + 196] = 0
                    require ext_code.size(address(_2260))
                    call address(_2260).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_3265]) + _3265 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(_2266))
                    staticcall address(_2266).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3961 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    idx = idx + 2
                    s = mem[_3961] - _2292
                    continue 
                _3266 = mem[64]
                mem[mem[64]] = 0
                mem[64] = mem[64] + 32
                mem[_3266 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[_3266 + 36] = _3238
                mem[_3266 + 68] = 0
                mem[_3266 + 100] = this.address
                mem[_3266 + 132] = 128
                mem[_3266 + 164] = mem[_3266]
                s = 0
                while s < mem[_3266]:
                    mem[s + _3266 + 196] = mem[s + _3266 + 32]
                    s = s + 32
                    continue 
                if ceil32(mem[_3266]) <= mem[_3266]:
                    require ext_code.size(address(_2260))
                    call address(_2260).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_3266]) + _3266 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(_2266))
                    staticcall address(_2266).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3930 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    idx = idx + 2
                    s = mem[_3930] - _2292
                    continue 
                mem[_3266 + mem[_3266] + 196] = 0
                require ext_code.size(address(_2260))
                call address(_2260).mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len ceil32(mem[_3266]) + _3266 + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(_2266))
                staticcall address(_2266).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3962 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                idx = idx + 2
                s = mem[_3962] - _2292
                continue 
            require mem[96] >= 32
            if not mem[128]:
                revert with 0, 
                            32,
                            42,
                            0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                            mem[mem[64] + 110 len 22]
            require ext_code.size(address(_2260))
            staticcall address(_2260).getReserves() with:
                    gas gas_remaining wei
            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if address(_2263) < address(_2266):
                _3103 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 96
                _3111 = mem[_3103]
                require mem[_3103] == mem[_3103 + 18 len 14]
                _3121 = mem[_3103 + 32]
                require mem[_3103 + 32] == mem[_3103 + 50 len 14]
                require mem[_3103 + 64] == mem[_3103 + 92 len 4]
                mem[mem[64] + 4] = address(_2260)
                require ext_code.size(address(_2263))
                staticcall address(_2263).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(_2260)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if address(_2263) == address(_2263):
                    _3175 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    mem[mem[64] + 4] = mem[_3175] - Mask(112, 0, _3111)
                    mem[mem[64] + 36] = Mask(112, 0, _3111)
                    mem[mem[64] + 68] = Mask(112, 0, _3121)
                    require ext_code.size(address(_2252))
                    staticcall address(_2252).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                            gas gas_remaining wei
                           args mem[mem[64] + 4], _3111 << 144, Mask(112, 0, _3121)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3239 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _3251 = mem[_3239]
                    if address(_2263) == address(_2263):
                        _3291 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_3291 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_3291 + 36] = 0
                        mem[_3291 + 68] = _3251
                        mem[_3291 + 100] = this.address
                        mem[_3291 + 132] = 128
                        mem[_3291 + 164] = mem[_3291]
                        s = 0
                        while s < mem[_3291]:
                            mem[s + _3291 + 196] = mem[s + _3291 + 32]
                            s = s + 32
                            continue 
                        if ceil32(mem[_3291]) > mem[_3291]:
                            mem[_3291 + mem[_3291] + 196] = 0
                        require ext_code.size(address(_2260))
                        call address(_2260).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                             gas gas_remaining wei
                            args 0, _3251, address(this.address), 128, mem[_3291], mem[_3291 + 196 len ceil32(mem[_3291])]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_3291 + 36] = this.address
                        require ext_code.size(address(_2266))
                        staticcall address(_2266).balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args this.address
                        mem[_3291 + 32] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[64] = _3291 + ceil32(return_data.size) + 32
                    else:
                        _3292 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_3292 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_3292 + 36] = _3251
                        mem[_3292 + 68] = 0
                        mem[_3292 + 100] = this.address
                        mem[_3292 + 132] = 128
                        mem[_3292 + 164] = mem[_3292]
                        s = 0
                        while s < mem[_3292]:
                            mem[s + _3292 + 196] = mem[s + _3292 + 32]
                            s = s + 32
                            continue 
                        if ceil32(mem[_3292]) > mem[_3292]:
                            mem[_3292 + mem[_3292] + 196] = 0
                        require ext_code.size(address(_2260))
                        call address(_2260).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                             gas gas_remaining wei
                            args _3251, 0, address(this.address), 128, mem[_3292], mem[_3292 + 196 len ceil32(mem[_3292])]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_3292 + 36] = this.address
                        require ext_code.size(address(_2266))
                        staticcall address(_2266).balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args this.address
                        mem[_3292 + 32] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[64] = _3292 + ceil32(return_data.size) + 32
                    require return_data.size >= 32
                    idx = idx + 2
                    s = ext_call.return_data[0] - _2292
                    continue 
                _3176 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[mem[64] + 4] = mem[_3176] - Mask(112, 0, _3121)
                mem[mem[64] + 36] = Mask(112, 0, _3121)
                mem[mem[64] + 68] = Mask(112, 0, _3111)
                require ext_code.size(address(_2252))
                staticcall address(_2252).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                        gas gas_remaining wei
                       args mem[mem[64] + 4], _3121 << 144, Mask(112, 0, _3111)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3240 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _3252 = mem[_3240]
                if address(_2263) != address(_2263):
                    _3294 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_3294 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_3294 + 36] = _3252
                    mem[_3294 + 68] = 0
                    mem[_3294 + 100] = this.address
                    mem[_3294 + 132] = 128
                    mem[_3294 + 164] = mem[_3294]
                    s = 0
                    while s < mem[_3294]:
                        mem[s + _3294 + 196] = mem[s + _3294 + 32]
                        s = s + 32
                        continue 
                    if ceil32(mem[_3294]) > mem[_3294]:
                        mem[_3294 + mem[_3294] + 196] = 0
                    require ext_code.size(address(_2260))
                    call address(_2260).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                         gas gas_remaining wei
                        args _3252, 0, address(this.address), 128, mem[_3294], mem[_3294 + 196 len ceil32(mem[_3294])]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[_3294 + 36] = this.address
                    require ext_code.size(address(_2266))
                    staticcall address(_2266).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args this.address
                    mem[_3294 + 32] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = _3294 + ceil32(return_data.size) + 32
                    require return_data.size >= 32
                    idx = idx + 2
                    s = ext_call.return_data[0] - _2292
                    continue 
                _3293 = mem[64]
                mem[mem[64]] = 0
                mem[64] = mem[64] + 32
                mem[_3293 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[_3293 + 36] = 0
                mem[_3293 + 68] = _3252
                mem[_3293 + 100] = this.address
                mem[_3293 + 132] = 128
                mem[_3293 + 164] = mem[_3293]
                s = 0
                while s < mem[_3293]:
                    mem[s + _3293 + 196] = mem[s + _3293 + 32]
                    s = s + 32
                    continue 
                if ceil32(mem[_3293]) <= mem[_3293]:
                    require ext_code.size(address(_2260))
                    call address(_2260).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_3293]) + _3293 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(_2266))
                    staticcall address(_2266).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3933 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    idx = idx + 2
                    s = mem[_3933] - _2292
                    continue 
                mem[_3293 + mem[_3293] + 196] = 0
                require ext_code.size(address(_2260))
                call address(_2260).mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len ceil32(mem[_3293]) + _3293 + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(_2266))
                staticcall address(_2266).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3965 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                idx = idx + 2
                s = mem[_3965] - _2292
                continue 
            _3104 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 96
            _3112 = mem[_3104]
            require mem[_3104] == mem[_3104 + 18 len 14]
            _3122 = mem[_3104 + 32]
            require mem[_3104 + 32] == mem[_3104 + 50 len 14]
            require mem[_3104 + 64] == mem[_3104 + 92 len 4]
            mem[mem[64] + 4] = address(_2260)
            require ext_code.size(address(_2263))
            staticcall address(_2263).balanceOf(address rg1) with:
                    gas gas_remaining wei
                   args address(_2260)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if address(_2263) == address(_2266):
                _3177 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[mem[64] + 4] = mem[_3177] - Mask(112, 0, _3112)
                mem[mem[64] + 36] = Mask(112, 0, _3112)
                mem[mem[64] + 68] = Mask(112, 0, _3122)
                require ext_code.size(address(_2252))
                staticcall address(_2252).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                        gas gas_remaining wei
                       args mem[mem[64] + 4], _3112 << 144, Mask(112, 0, _3122)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3241 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _3253 = mem[_3241]
                if address(_2263) == address(_2266):
                    _3295 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_3295 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_3295 + 36] = 0
                    mem[_3295 + 68] = _3253
                    mem[_3295 + 100] = this.address
                    mem[_3295 + 132] = 128
                    mem[_3295 + 164] = mem[_3295]
                    s = 0
                    while s < mem[_3295]:
                        mem[s + _3295 + 196] = mem[s + _3295 + 32]
                        s = s + 32
                        continue 
                    if ceil32(mem[_3295]) <= mem[_3295]:
                        require ext_code.size(address(_2260))
                        call address(_2260).mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len ceil32(mem[_3295]) + _3295 + -mem[64] + 192]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(_2266))
                        staticcall address(_2266).balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3935 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        idx = idx + 2
                        s = mem[_3935] - _2292
                        continue 
                    mem[_3295 + mem[_3295] + 196] = 0
                    require ext_code.size(address(_2260))
                    call address(_2260).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_3295]) + _3295 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(_2266))
                    staticcall address(_2266).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3967 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    idx = idx + 2
                    s = mem[_3967] - _2292
                    continue 
                _3296 = mem[64]
                mem[mem[64]] = 0
                mem[64] = mem[64] + 32
                mem[_3296 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[_3296 + 36] = _3253
                mem[_3296 + 68] = 0
                mem[_3296 + 100] = this.address
                mem[_3296 + 132] = 128
                mem[_3296 + 164] = mem[_3296]
                s = 0
                while s < mem[_3296]:
                    mem[s + _3296 + 196] = mem[s + _3296 + 32]
                    s = s + 32
                    continue 
                if ceil32(mem[_3296]) <= mem[_3296]:
                    require ext_code.size(address(_2260))
                    call address(_2260).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_3296]) + _3296 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(_2266))
                    staticcall address(_2266).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3936 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    idx = idx + 2
                    s = mem[_3936] - _2292
                    continue 
                mem[_3296 + mem[_3296] + 196] = 0
                require ext_code.size(address(_2260))
                call address(_2260).mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len ceil32(mem[_3296]) + _3296 + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(_2266))
                staticcall address(_2266).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3968 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                idx = idx + 2
                s = mem[_3968] - _2292
                continue 
            _3178 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            mem[mem[64] + 4] = mem[_3178] - Mask(112, 0, _3122)
            mem[mem[64] + 36] = Mask(112, 0, _3122)
            mem[mem[64] + 68] = Mask(112, 0, _3112)
            require ext_code.size(address(_2252))
            staticcall address(_2252).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                    gas gas_remaining wei
                   args mem[mem[64] + 4], _3122 << 144, Mask(112, 0, _3112)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3242 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _3254 = mem[_3242]
            if address(_2263) == address(_2266):
                _3297 = mem[64]
                mem[mem[64]] = 0
                mem[64] = mem[64] + 32
                mem[_3297 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[_3297 + 36] = 0
                mem[_3297 + 68] = _3254
                mem[_3297 + 100] = this.address
                mem[_3297 + 132] = 128
                mem[_3297 + 164] = mem[_3297]
                s = 0
                while s < mem[_3297]:
                    mem[s + _3297 + 196] = mem[s + _3297 + 32]
                    s = s + 32
                    continue 
                if ceil32(mem[_3297]) > mem[_3297]:
                    mem[_3297 + mem[_3297] + 196] = 0
                require ext_code.size(address(_2260))
                call address(_2260).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                     gas gas_remaining wei
                    args 0, _3254, address(this.address), 128, mem[_3297], mem[_3297 + 196 len ceil32(mem[_3297])]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[_3297 + 36] = this.address
                require ext_code.size(address(_2266))
                staticcall address(_2266).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args this.address
                mem[_3297 + 32] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[64] = _3297 + ceil32(return_data.size) + 32
                require return_data.size >= 32
                idx = idx + 2
                s = ext_call.return_data[0] - _2292
                continue 
            _3298 = mem[64]
            mem[mem[64]] = 0
            mem[64] = mem[64] + 32
            mem[_3298 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
            mem[_3298 + 36] = _3254
            mem[_3298 + 68] = 0
            mem[_3298 + 100] = this.address
            mem[_3298 + 132] = 128
            mem[_3298 + 164] = mem[_3298]
            s = 0
            while s < mem[_3298]:
                mem[s + _3298 + 196] = mem[s + _3298 + 32]
                s = s + 32
                continue 
            if ceil32(mem[_3298]) <= mem[_3298]:
                require ext_code.size(address(_2260))
                call address(_2260).mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len ceil32(mem[_3298]) + _3298 + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(_2266))
                staticcall address(_2266).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3938 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                idx = idx + 2
                s = mem[_3938] - _2292
                continue 
            mem[_3298 + mem[_3298] + 196] = 0
            require ext_code.size(address(_2260))
            call address(_2260).mem[mem[64] len 4] with:
                 gas gas_remaining wei
                args mem[mem[64] + 4 len ceil32(mem[_3298]) + _3298 + -mem[64] + 192]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[mem[64] + 4] = this.address
            require ext_code.size(address(_2266))
            staticcall address(_2266).balanceOf(address rg1) with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3970 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            idx = idx + 2
            s = mem[_3970] - _2292
            continue 
        _2998 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size) + 1
        mem[_2998] = return_data.size
        mem[_2998 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
        if not ext_call.success:
            if return_data.size:
                revert with ext_call.return_data[0 len return_data.size]
            _3025 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = mem[_2305 + 100]
            _3027 = mem[_2305 + 100]
            idx = 0
            while idx < _3027:
                mem[idx + _3025 + 68] = mem[idx + _2305 + 132]
                idx = idx + 32
                continue 
            if not _3027 % 32:
                revert with memory
                  from mem[64]
                   len _3027 + _3025 + -mem[64] + 68
            mem[floor32(_3027) + _3025 + 68] = mem[floor32(_3027) + _3025 + -(_3027 % 32) + 100 len _3027 % 32]
            revert with memory
              from mem[64]
               len floor32(_3027) + _3025 + -mem[64] + 100
        if not return_data.size:
            require ext_code.size(address(_2260))
            staticcall address(_2260).getReserves() with:
                    gas gas_remaining wei
            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if address(_2263) < address(_2266):
                _3097 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 96
                _3109 = mem[_3097]
                require mem[_3097] == mem[_3097 + 18 len 14]
                _3117 = mem[_3097 + 32]
                require mem[_3097 + 32] == mem[_3097 + 50 len 14]
                require mem[_3097 + 64] == mem[_3097 + 92 len 4]
                mem[mem[64] + 4] = address(_2260)
                require ext_code.size(address(_2263))
                staticcall address(_2263).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(_2260)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if address(_2263) == address(_2263):
                    _3163 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    mem[mem[64] + 4] = mem[_3163] - Mask(112, 0, _3109)
                    mem[mem[64] + 36] = Mask(112, 0, _3109)
                    mem[mem[64] + 68] = Mask(112, 0, _3117)
                    require ext_code.size(address(_2252))
                    staticcall address(_2252).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                            gas gas_remaining wei
                           args mem[mem[64] + 4], _3109 << 144, Mask(112, 0, _3117)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3227 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _3243 = mem[_3227]
                    if address(_2263) != address(_2263):
                        _3268 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_3268 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_3268 + 36] = _3243
                        mem[_3268 + 68] = 0
                        mem[_3268 + 100] = this.address
                        mem[_3268 + 132] = 128
                        mem[_3268 + 164] = mem[_3268]
                        s = 0
                        while s < mem[_3268]:
                            mem[s + _3268 + 196] = mem[s + _3268 + 32]
                            s = s + 32
                            continue 
                        if ceil32(mem[_3268]) > mem[_3268]:
                            mem[_3268 + mem[_3268] + 196] = 0
                        require ext_code.size(address(_2260))
                        call address(_2260).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                             gas gas_remaining wei
                            args _3243, 0, address(this.address), 128, mem[_3268], mem[_3268 + 196 len ceil32(mem[_3268])]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_3268 + 36] = this.address
                        require ext_code.size(address(_2266))
                        staticcall address(_2266).balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args this.address
                        mem[_3268 + 32] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[64] = _3268 + ceil32(return_data.size) + 32
                        require return_data.size >= 32
                        idx = idx + 2
                        s = ext_call.return_data[0] - _2292
                        continue 
                    _3267 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_3267 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_3267 + 36] = 0
                    mem[_3267 + 68] = _3243
                    mem[_3267 + 100] = this.address
                    mem[_3267 + 132] = 128
                    mem[_3267 + 164] = mem[_3267]
                    s = 0
                    while s < mem[_3267]:
                        mem[s + _3267 + 196] = mem[s + _3267 + 32]
                        s = s + 32
                        continue 
                    if ceil32(mem[_3267]) <= mem[_3267]:
                        require ext_code.size(address(_2260))
                        call address(_2260).mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len ceil32(mem[_3267]) + _3267 + -mem[64] + 192]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(_2266))
                        staticcall address(_2266).balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3939 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        idx = idx + 2
                        s = mem[_3939] - _2292
                        continue 
                    mem[_3267 + mem[_3267] + 196] = 0
                    require ext_code.size(address(_2260))
                    call address(_2260).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_3267]) + _3267 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(_2266))
                    staticcall address(_2266).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3971 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    idx = idx + 2
                    s = mem[_3971] - _2292
                    continue 
                _3164 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[mem[64] + 4] = mem[_3164] - Mask(112, 0, _3117)
                mem[mem[64] + 36] = Mask(112, 0, _3117)
                mem[mem[64] + 68] = Mask(112, 0, _3109)
                require ext_code.size(address(_2252))
                staticcall address(_2252).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                        gas gas_remaining wei
                       args mem[mem[64] + 4], _3117 << 144, Mask(112, 0, _3109)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3228 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _3244 = mem[_3228]
                if address(_2263) == address(_2263):
                    _3269 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_3269 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_3269 + 36] = 0
                    mem[_3269 + 68] = _3244
                    mem[_3269 + 100] = this.address
                    mem[_3269 + 132] = 128
                    mem[_3269 + 164] = mem[_3269]
                    s = 0
                    while s < mem[_3269]:
                        mem[s + _3269 + 196] = mem[s + _3269 + 32]
                        s = s + 32
                        continue 
                    if ceil32(mem[_3269]) <= mem[_3269]:
                        require ext_code.size(address(_2260))
                        call address(_2260).mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len ceil32(mem[_3269]) + _3269 + -mem[64] + 192]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(_2266))
                        staticcall address(_2266).balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3941 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        idx = idx + 2
                        s = mem[_3941] - _2292
                        continue 
                    mem[_3269 + mem[_3269] + 196] = 0
                    require ext_code.size(address(_2260))
                    call address(_2260).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_3269]) + _3269 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(_2266))
                    staticcall address(_2266).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3973 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    idx = idx + 2
                    s = mem[_3973] - _2292
                    continue 
                _3270 = mem[64]
                mem[mem[64]] = 0
                mem[64] = mem[64] + 32
                mem[_3270 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[_3270 + 36] = _3244
                mem[_3270 + 68] = 0
                mem[_3270 + 100] = this.address
                mem[_3270 + 132] = 128
                mem[_3270 + 164] = mem[_3270]
                s = 0
                while s < mem[_3270]:
                    mem[s + _3270 + 196] = mem[s + _3270 + 32]
                    s = s + 32
                    continue 
                if ceil32(mem[_3270]) <= mem[_3270]:
                    require ext_code.size(address(_2260))
                    call address(_2260).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_3270]) + _3270 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(_2266))
                    staticcall address(_2266).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3942 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    idx = idx + 2
                    s = mem[_3942] - _2292
                    continue 
                mem[_3270 + mem[_3270] + 196] = 0
                require ext_code.size(address(_2260))
                call address(_2260).mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len ceil32(mem[_3270]) + _3270 + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(_2266))
                staticcall address(_2266).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3974 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                idx = idx + 2
                s = mem[_3974] - _2292
                continue 
            _3098 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 96
            _3110 = mem[_3098]
            require mem[_3098] == mem[_3098 + 18 len 14]
            _3118 = mem[_3098 + 32]
            require mem[_3098 + 32] == mem[_3098 + 50 len 14]
            require mem[_3098 + 64] == mem[_3098 + 92 len 4]
            mem[mem[64] + 4] = address(_2260)
            require ext_code.size(address(_2263))
            staticcall address(_2263).balanceOf(address rg1) with:
                    gas gas_remaining wei
                   args address(_2260)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if address(_2263) == address(_2266):
                _3165 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[mem[64] + 4] = mem[_3165] - Mask(112, 0, _3110)
                mem[mem[64] + 36] = Mask(112, 0, _3110)
                mem[mem[64] + 68] = Mask(112, 0, _3118)
                require ext_code.size(address(_2252))
                staticcall address(_2252).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                        gas gas_remaining wei
                       args mem[mem[64] + 4], _3110 << 144, Mask(112, 0, _3118)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3229 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _3245 = mem[_3229]
                if address(_2263) == address(_2266):
                    _3271 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_3271 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_3271 + 36] = 0
                    mem[_3271 + 68] = _3245
                    mem[_3271 + 100] = this.address
                    mem[_3271 + 132] = 128
                    mem[_3271 + 164] = mem[_3271]
                    s = 0
                    while s < mem[_3271]:
                        mem[s + _3271 + 196] = mem[s + _3271 + 32]
                        s = s + 32
                        continue 
                    if ceil32(mem[_3271]) > mem[_3271]:
                        mem[_3271 + mem[_3271] + 196] = 0
                    require ext_code.size(address(_2260))
                    call address(_2260).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                         gas gas_remaining wei
                        args 0, _3245, address(this.address), 128, mem[_3271], mem[_3271 + 196 len ceil32(mem[_3271])]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[_3271 + 36] = this.address
                    require ext_code.size(address(_2266))
                    staticcall address(_2266).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args this.address
                    mem[_3271 + 32] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = _3271 + ceil32(return_data.size) + 32
                else:
                    _3272 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_3272 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_3272 + 36] = _3245
                    mem[_3272 + 68] = 0
                    mem[_3272 + 100] = this.address
                    mem[_3272 + 132] = 128
                    mem[_3272 + 164] = mem[_3272]
                    s = 0
                    while s < mem[_3272]:
                        mem[s + _3272 + 196] = mem[s + _3272 + 32]
                        s = s + 32
                        continue 
                    if ceil32(mem[_3272]) > mem[_3272]:
                        mem[_3272 + mem[_3272] + 196] = 0
                    require ext_code.size(address(_2260))
                    call address(_2260).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                         gas gas_remaining wei
                        args _3245, 0, address(this.address), 128, mem[_3272], mem[_3272 + 196 len ceil32(mem[_3272])]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[_3272 + 36] = this.address
                    require ext_code.size(address(_2266))
                    staticcall address(_2266).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args this.address
                    mem[_3272 + 32] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = _3272 + ceil32(return_data.size) + 32
                require return_data.size >= 32
                idx = idx + 2
                s = ext_call.return_data[0] - _2292
                continue 
            _3166 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            mem[mem[64] + 4] = mem[_3166] - Mask(112, 0, _3118)
            mem[mem[64] + 36] = Mask(112, 0, _3118)
            mem[mem[64] + 68] = Mask(112, 0, _3110)
            require ext_code.size(address(_2252))
            staticcall address(_2252).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                    gas gas_remaining wei
                   args mem[mem[64] + 4], _3118 << 144, Mask(112, 0, _3110)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3230 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _3246 = mem[_3230]
            if address(_2263) == address(_2266):
                _3273 = mem[64]
                mem[mem[64]] = 0
                mem[64] = mem[64] + 32
                mem[_3273 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[_3273 + 36] = 0
                mem[_3273 + 68] = _3246
                mem[_3273 + 100] = this.address
                mem[_3273 + 132] = 128
                mem[_3273 + 164] = mem[_3273]
                s = 0
                while s < mem[_3273]:
                    mem[s + _3273 + 196] = mem[s + _3273 + 32]
                    s = s + 32
                    continue 
                if ceil32(mem[_3273]) <= mem[_3273]:
                    require ext_code.size(address(_2260))
                    call address(_2260).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_3273]) + _3273 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(_2266))
                    staticcall address(_2266).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3945 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    idx = idx + 2
                    s = mem[_3945] - _2292
                    continue 
                mem[_3273 + mem[_3273] + 196] = 0
                require ext_code.size(address(_2260))
                call address(_2260).mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len ceil32(mem[_3273]) + _3273 + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(_2266))
                staticcall address(_2266).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3977 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                idx = idx + 2
                s = mem[_3977] - _2292
                continue 
            _3274 = mem[64]
            mem[mem[64]] = 0
            mem[64] = mem[64] + 32
            mem[_3274 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
            mem[_3274 + 36] = _3246
            mem[_3274 + 68] = 0
            mem[_3274 + 100] = this.address
            mem[_3274 + 132] = 128
            mem[_3274 + 164] = mem[_3274]
            s = 0
            while s < mem[_3274]:
                mem[s + _3274 + 196] = mem[s + _3274 + 32]
                s = s + 32
                continue 
            if ceil32(mem[_3274]) <= mem[_3274]:
                require ext_code.size(address(_2260))
                call address(_2260).mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len ceil32(mem[_3274]) + _3274 + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(_2266))
                staticcall address(_2266).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3946 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                idx = idx + 2
                s = mem[_3946] - _2292
                continue 
            mem[_3274 + mem[_3274] + 196] = 0
            require ext_code.size(address(_2260))
            call address(_2260).mem[mem[64] len 4] with:
                 gas gas_remaining wei
                args mem[mem[64] + 4 len ceil32(mem[_3274]) + _3274 + -mem[64] + 192]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[mem[64] + 4] = this.address
            require ext_code.size(address(_2266))
            staticcall address(_2266).balanceOf(address rg1) with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3978 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            idx = idx + 2
            s = mem[_3978] - _2292
            continue 
        require return_data.size >= 32
        if not mem[_2998 + 32]:
            revert with 0, 
                        32,
                        42,
                        0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                        mem[mem[64] + 110 len 22]
        require ext_code.size(address(_2260))
        staticcall address(_2260).getReserves() with:
                gas gas_remaining wei
        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        if address(_2263) < address(_2266):
            _3105 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 96
            _3113 = mem[_3105]
            require mem[_3105] == mem[_3105 + 18 len 14]
            _3125 = mem[_3105 + 32]
            require mem[_3105 + 32] == mem[_3105 + 50 len 14]
            require mem[_3105 + 64] == mem[_3105 + 92 len 4]
            mem[mem[64] + 4] = address(_2260)
            require ext_code.size(address(_2263))
            staticcall address(_2263).balanceOf(address rg1) with:
                    gas gas_remaining wei
                   args address(_2260)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if address(_2263) == address(_2263):
                _3183 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[mem[64] + 4] = mem[_3183] - Mask(112, 0, _3113)
                mem[mem[64] + 36] = Mask(112, 0, _3113)
                mem[mem[64] + 68] = Mask(112, 0, _3125)
                require ext_code.size(address(_2252))
                staticcall address(_2252).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                        gas gas_remaining wei
                       args mem[mem[64] + 4], _3113 << 144, Mask(112, 0, _3125)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3247 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _3255 = mem[_3247]
                if address(_2263) == address(_2263):
                    _3299 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_3299 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_3299 + 36] = 0
                    mem[_3299 + 68] = _3255
                    mem[_3299 + 100] = this.address
                    mem[_3299 + 132] = 128
                    mem[_3299 + 164] = mem[_3299]
                    s = 0
                    while s < mem[_3299]:
                        mem[s + _3299 + 196] = mem[s + _3299 + 32]
                        s = s + 32
                        continue 
                    if ceil32(mem[_3299]) > mem[_3299]:
                        mem[_3299 + mem[_3299] + 196] = 0
                    require ext_code.size(address(_2260))
                    call address(_2260).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                         gas gas_remaining wei
                        args 0, _3255, address(this.address), 128, mem[_3299], mem[_3299 + 196 len ceil32(mem[_3299])]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[_3299 + 36] = this.address
                    require ext_code.size(address(_2266))
                    staticcall address(_2266).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args this.address
                    mem[_3299 + 32] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = _3299 + ceil32(return_data.size) + 32
                    require return_data.size >= 32
                    idx = idx + 2
                    s = ext_call.return_data[0] - _2292
                    continue 
                _3300 = mem[64]
                mem[mem[64]] = 0
                mem[64] = mem[64] + 32
                mem[_3300 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[_3300 + 36] = _3255
                mem[_3300 + 68] = 0
                mem[_3300 + 100] = this.address
                mem[_3300 + 132] = 128
                mem[_3300 + 164] = mem[_3300]
                s = 0
                while s < mem[_3300]:
                    mem[s + _3300 + 196] = mem[s + _3300 + 32]
                    s = s + 32
                    continue 
                if ceil32(mem[_3300]) <= mem[_3300]:
                    require ext_code.size(address(_2260))
                    call address(_2260).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_3300]) + _3300 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(_2266))
                    staticcall address(_2266).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3948 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    idx = idx + 2
                    s = mem[_3948] - _2292
                    continue 
                mem[_3300 + mem[_3300] + 196] = 0
                require ext_code.size(address(_2260))
                call address(_2260).mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len ceil32(mem[_3300]) + _3300 + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(_2266))
                staticcall address(_2266).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3980 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                idx = idx + 2
                s = mem[_3980] - _2292
                continue 
            _3184 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            mem[mem[64] + 4] = mem[_3184] - Mask(112, 0, _3125)
            mem[mem[64] + 36] = Mask(112, 0, _3125)
            mem[mem[64] + 68] = Mask(112, 0, _3113)
            require ext_code.size(address(_2252))
            staticcall address(_2252).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                    gas gas_remaining wei
                   args mem[mem[64] + 4], _3125 << 144, Mask(112, 0, _3113)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3248 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _3256 = mem[_3248]
            if address(_2263) == address(_2263):
                _3301 = mem[64]
                mem[mem[64]] = 0
                mem[64] = mem[64] + 32
                mem[_3301 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[_3301 + 36] = 0
                mem[_3301 + 68] = _3256
                mem[_3301 + 100] = this.address
                mem[_3301 + 132] = 128
                mem[_3301 + 164] = mem[_3301]
                s = 0
                while s < mem[_3301]:
                    mem[s + _3301 + 196] = mem[s + _3301 + 32]
                    s = s + 32
                    continue 
                if ceil32(mem[_3301]) <= mem[_3301]:
                    require ext_code.size(address(_2260))
                    call address(_2260).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_3301]) + _3301 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(_2266))
                    staticcall address(_2266).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3949 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    idx = idx + 2
                    s = mem[_3949] - _2292
                    continue 
                mem[_3301 + mem[_3301] + 196] = 0
                require ext_code.size(address(_2260))
                call address(_2260).mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len ceil32(mem[_3301]) + _3301 + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(_2266))
                staticcall address(_2266).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3981 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                idx = idx + 2
                s = mem[_3981] - _2292
                continue 
            _3302 = mem[64]
            mem[mem[64]] = 0
            mem[64] = mem[64] + 32
            mem[_3302 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
            mem[_3302 + 36] = _3256
            mem[_3302 + 68] = 0
            mem[_3302 + 100] = this.address
            mem[_3302 + 132] = 128
            mem[_3302 + 164] = mem[_3302]
            s = 0
            while s < mem[_3302]:
                mem[s + _3302 + 196] = mem[s + _3302 + 32]
                s = s + 32
                continue 
            if ceil32(mem[_3302]) <= mem[_3302]:
                require ext_code.size(address(_2260))
                call address(_2260).mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len ceil32(mem[_3302]) + _3302 + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(_2266))
                staticcall address(_2266).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3950 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                idx = idx + 2
                s = mem[_3950] - _2292
                continue 
            mem[_3302 + mem[_3302] + 196] = 0
            require ext_code.size(address(_2260))
            call address(_2260).mem[mem[64] len 4] with:
                 gas gas_remaining wei
                args mem[mem[64] + 4 len ceil32(mem[_3302]) + _3302 + -mem[64] + 192]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[mem[64] + 4] = this.address
            require ext_code.size(address(_2266))
            staticcall address(_2266).balanceOf(address rg1) with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3982 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            idx = idx + 2
            s = mem[_3982] - _2292
            continue 
        _3106 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 96
        _3114 = mem[_3106]
        require mem[_3106] == mem[_3106 + 18 len 14]
        _3126 = mem[_3106 + 32]
        require mem[_3106 + 32] == mem[_3106 + 50 len 14]
        require mem[_3106 + 64] == mem[_3106 + 92 len 4]
        mem[mem[64] + 4] = address(_2260)
        require ext_code.size(address(_2263))
        staticcall address(_2263).balanceOf(address rg1) with:
                gas gas_remaining wei
               args address(_2260)
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        if address(_2263) != address(_2266):
            _3186 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            mem[mem[64] + 4] = mem[_3186] - Mask(112, 0, _3126)
            mem[mem[64] + 36] = Mask(112, 0, _3126)
            mem[mem[64] + 68] = Mask(112, 0, _3114)
            require ext_code.size(address(_2252))
            staticcall address(_2252).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                    gas gas_remaining wei
                   args mem[mem[64] + 4], _3126 << 144, Mask(112, 0, _3114)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3250 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _3258 = mem[_3250]
            if address(_2263) == address(_2266):
                _3305 = mem[64]
                mem[mem[64]] = 0
                mem[64] = mem[64] + 32
                mem[_3305 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[_3305 + 36] = 0
                mem[_3305 + 68] = _3258
                mem[_3305 + 100] = this.address
                mem[_3305 + 132] = 128
                mem[_3305 + 164] = mem[_3305]
                s = 0
                while s < mem[_3305]:
                    mem[s + _3305 + 196] = mem[s + _3305 + 32]
                    s = s + 32
                    continue 
                if ceil32(mem[_3305]) > mem[_3305]:
                    mem[_3305 + mem[_3305] + 196] = 0
                require ext_code.size(address(_2260))
                call address(_2260).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                     gas gas_remaining wei
                    args 0, _3258, address(this.address), 128, mem[_3305], mem[_3305 + 196 len ceil32(mem[_3305])]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[_3305 + 36] = this.address
                require ext_code.size(address(_2266))
                staticcall address(_2266).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args this.address
                mem[_3305 + 32] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[64] = _3305 + ceil32(return_data.size) + 32
            else:
                _3306 = mem[64]
                mem[mem[64]] = 0
                mem[64] = mem[64] + 32
                mem[_3306 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[_3306 + 36] = _3258
                mem[_3306 + 68] = 0
                mem[_3306 + 100] = this.address
                mem[_3306 + 132] = 128
                mem[_3306 + 164] = mem[_3306]
                s = 0
                while s < mem[_3306]:
                    mem[s + _3306 + 196] = mem[s + _3306 + 32]
                    s = s + 32
                    continue 
                if ceil32(mem[_3306]) > mem[_3306]:
                    mem[_3306 + mem[_3306] + 196] = 0
                require ext_code.size(address(_2260))
                call address(_2260).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                     gas gas_remaining wei
                    args _3258, 0, address(this.address), 128, mem[_3306], mem[_3306 + 196 len ceil32(mem[_3306])]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[_3306 + 36] = this.address
                require ext_code.size(address(_2266))
                staticcall address(_2266).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args this.address
                mem[_3306 + 32] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[64] = _3306 + ceil32(return_data.size) + 32
            require return_data.size >= 32
            idx = idx + 2
            s = ext_call.return_data[0] - _2292
            continue 
        _3185 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        mem[mem[64] + 4] = mem[_3185] - Mask(112, 0, _3114)
        mem[mem[64] + 36] = Mask(112, 0, _3114)
        mem[mem[64] + 68] = Mask(112, 0, _3126)
        require ext_code.size(address(_2252))
        staticcall address(_2252).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                gas gas_remaining wei
               args mem[mem[64] + 4], _3114 << 144, Mask(112, 0, _3126)
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _3249 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _3257 = mem[_3249]
        if address(_2263) == address(_2266):
            _3303 = mem[64]
            mem[mem[64]] = 0
            mem[64] = mem[64] + 32
            mem[_3303 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
            mem[_3303 + 36] = 0
            mem[_3303 + 68] = _3257
            mem[_3303 + 100] = this.address
            mem[_3303 + 132] = 128
            mem[_3303 + 164] = mem[_3303]
            s = 0
            while s < mem[_3303]:
                mem[s + _3303 + 196] = mem[s + _3303 + 32]
                s = s + 32
                continue 
            if ceil32(mem[_3303]) <= mem[_3303]:
                require ext_code.size(address(_2260))
                call address(_2260).mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len ceil32(mem[_3303]) + _3303 + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(_2266))
                staticcall address(_2266).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3951 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                idx = idx + 2
                s = mem[_3951] - _2292
                continue 
            mem[_3303 + mem[_3303] + 196] = 0
            require ext_code.size(address(_2260))
            call address(_2260).mem[mem[64] len 4] with:
                 gas gas_remaining wei
                args mem[mem[64] + 4 len ceil32(mem[_3303]) + _3303 + -mem[64] + 192]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[mem[64] + 4] = this.address
            require ext_code.size(address(_2266))
            staticcall address(_2266).balanceOf(address rg1) with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3983 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            idx = idx + 2
            s = mem[_3983] - _2292
            continue 
        _3304 = mem[64]
        mem[mem[64]] = 0
        mem[64] = mem[64] + 32
        mem[_3304 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[_3304 + 36] = _3257
        mem[_3304 + 68] = 0
        mem[_3304 + 100] = this.address
        mem[_3304 + 132] = 128
        mem[_3304 + 164] = mem[_3304]
        s = 0
        while s < mem[_3304]:
            mem[s + _3304 + 196] = mem[s + _3304 + 32]
            s = s + 32
            continue 
        if ceil32(mem[_3304]) <= mem[_3304]:
            require ext_code.size(address(_2260))
            call address(_2260).mem[mem[64] len 4] with:
                 gas gas_remaining wei
                args mem[mem[64] + 4 len ceil32(mem[_3304]) + _3304 + -mem[64] + 192]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[mem[64] + 4] = this.address
            require ext_code.size(address(_2266))
            staticcall address(_2266).balanceOf(address rg1) with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3952 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            idx = idx + 2
            s = mem[_3952] - _2292
            continue 
        mem[_3304 + mem[_3304] + 196] = 0
        require ext_code.size(address(_2260))
        call address(_2260).mem[mem[64] len 4] with:
             gas gas_remaining wei
            args mem[mem[64] + 4 len ceil32(mem[_3304]) + _3304 + -mem[64] + 192]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[mem[64] + 4] = this.address
        require ext_code.size(address(_2266))
        staticcall address(_2266).balanceOf(address rg1) with:
                gas gas_remaining wei
               args address(this.address)
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _3984 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        idx = idx + 2
        s = mem[_3984] - _2292
        continue 
    if not arg2:
        _2249 = mem[64]
        mem[mem[64] + 36] = msg.sender
        mem[mem[64] + 68] = cd[(arg4 + 36)]
        _2250 = mem[64]
        mem[mem[64]] = 68
        mem[mem[64] + 32 len 4] = transfer(address rg1, uint256 rg2)
        mem[64] = mem[64] + 164
        mem[_2249 + 100] = 32
        mem[_2249 + 132] = 'SafeERC20: low-level call failed'
        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(address(ext_call.return_data[0])):
            revert with 0, 'Address: call to non-contract'
        if not ext_code.hash(address(ext_call.return_data[0])):
            revert with 0, 'Address: call to non-contract'
        _2271 = mem[_2250]
        mem[_2249 + 164 len floor32(mem[_2250])] = mem[_2250 + 32 len floor32(mem[_2250])]
        mem[_2249 + floor32(mem[_2250]) + -(mem[_2250] % 32) + 196 len mem[_2250] % 32] = mem[_2250 + floor32(mem[_2250]) + -(mem[_2250] % 32) + 64 len mem[_2250] % 32]
        call address(ext_call.return_data[0]) with:
             gas gas_remaining wei
            args mem[_2249 + 168 len _2271 - 4]
        if not return_data.size:
            if not ext_call.success:
                if mem[96]:
                    revert with memory
                      from 128
                       len mem[96]
                revert with 0, 'SafeERC20: low-level call failed'
            if mem[96]:
                require mem[96] >= 32
                if not mem[128]:
                    revert with 0, 
                                32,
                                42,
                                0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                mem[_2249 + 274 len 22]
        else:
            mem[_2249 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not ext_call.success:
                if return_data.size:
                    revert with ext_call.return_data[0 len return_data.size]
                revert with 0, 'SafeERC20: low-level call failed'
            if return_data.size:
                require return_data.size >= 32
                if not mem[_2249 + 196]:
                    revert with 0, 
                                32,
                                42,
                                0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                mem[_2249 + ceil32(return_data.size) + 275 len 22]
    else:
        _2255 = mem[64]
        mem[mem[64] + 36] = msg.sender
        mem[mem[64] + 68] = cd[(arg4 + 36)]
        _2256 = mem[64]
        mem[mem[64]] = 68
        mem[mem[64] + 32 len 4] = transfer(address rg1, uint256 rg2)
        mem[64] = mem[64] + 164
        mem[_2255 + 100] = 32
        mem[_2255 + 132] = 'SafeERC20: low-level call failed'
        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(address(ext_call.return_data[0])):
            revert with 0, 'Address: call to non-contract'
        if not ext_code.hash(address(ext_call.return_data[0])):
            revert with 0, 'Address: call to non-contract'
        _2278 = mem[_2256]
        mem[_2255 + 164 len floor32(mem[_2256])] = mem[_2256 + 32 len floor32(mem[_2256])]
        mem[_2255 + floor32(mem[_2256]) + -(mem[_2256] % 32) + 196 len mem[_2256] % 32] = mem[_2256 + floor32(mem[_2256]) + -(mem[_2256] % 32) + 64 len mem[_2256] % 32]
        call address(ext_call.return_data[0]) with:
             gas gas_remaining wei
            args mem[_2255 + 168 len _2278 - 4]
        if not return_data.size:
            if not ext_call.success:
                if mem[96]:
                    revert with memory
                      from 128
                       len mem[96]
                revert with 0, 'SafeERC20: low-level call failed'
            if mem[96]:
                require mem[96] >= 32
                if not mem[128]:
                    revert with 0, 
                                32,
                                42,
                                0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                mem[_2255 + 274 len 22]
        else:
            mem[_2255 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not ext_call.success:
                if return_data.size:
                    revert with ext_call.return_data[0 len return_data.size]
                revert with 0, 'SafeERC20: low-level call failed'
            if return_data.size:
                require return_data.size >= 32
                if not mem[_2255 + 196]:
                    revert with 0, 
                                32,
                                42,
                                0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                mem[_2255 + ceil32(return_data.size) + 275 len 22]
}

function BSCswapCall(address arg1, uint256 arg2, uint256 arg3, bytes arg4) {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg4 <= test266151307()
    require arg4 + 35 < calldata.size
    require arg4.length <= test266151307()
    require arg4 + arg4.length + 36 <= calldata.size
    require ext_code.size(msg.sender)
    staticcall msg.sender.token0() with:
            gas gas_remaining wei
    mem[96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    require ext_code.size(msg.sender)
    staticcall msg.sender.token1() with:
            gas gas_remaining wei
    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    require arg4.length >= 96
    require cd[(arg4 + 100)] <= test266151307()
    require arg4 + arg4.length + 36 > arg4 + cd[(arg4 + 100)] + 67
    require cd[(arg4 + cd[(arg4 + 100)] + 36)] <= test266151307()
    require (32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 128 >= 96 and (2 * ceil32(return_data.size)) + (32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 128 <= test266151307()
    mem[64] = (2 * ceil32(return_data.size)) + (32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 128
    mem[(2 * ceil32(return_data.size)) + 96] = cd[(arg4 + cd[(arg4 + 100)] + 36)]
    require arg4.length + 36 >= cd[(arg4 + 100)] + (64 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 68
    s = arg4 + cd[(arg4 + 100)] + 68
    t = (2 * ceil32(return_data.size)) + 128
    idx = 0
    while idx < cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        require s + 31 < arg4 + arg4.length + 36
        _1499 = mem[64]
        require mem[64] + 64 >= mem[64] and mem[64] + 64 <= test266151307()
        mem[64] = mem[64] + 64
        require s + 64 <= arg4 + arg4.length + 36
        u = 0
        v = s
        w = _1499
        while u < 2:
            require cd[v] == address(cd[v])
            mem[w] = cd[v]
            u = u + 1
            v = v + 32
            w = w + 32
            continue 
        mem[t] = _1499
        s = s + 64
        t = t + 32
        idx = idx + 1
        continue 
    require 0 < mem[(2 * ceil32(return_data.size)) + 96]
    require msg.sender == mem[mem[(2 * ceil32(return_data.size)) + 128] + 44 len 20]
    require 3 < mem[(2 * ceil32(return_data.size)) + 96]
    _1503 = mem[mem[(2 * ceil32(return_data.size)) + 224]]
    mem[mem[64] + 4] = this.address
    require ext_code.size(address(_1503))
    staticcall address(_1503).balanceOf(address rg1) with:
            gas gas_remaining wei
           args address(this.address)
    mem[mem[64]] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _1506 = mem[64]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    _2246 = mem[(2 * ceil32(return_data.size)) + 96]
    idx = 2
    s = mem[_1506] - cd[(arg4 + 68)]
    while idx < _2246:
        require idx < mem[(2 * ceil32(return_data.size)) + 96]
        _2252 = mem[mem[(32 * idx) + (2 * ceil32(return_data.size)) + 128]]
        require idx < mem[(2 * ceil32(return_data.size)) + 96]
        _2260 = mem[mem[(32 * idx) + (2 * ceil32(return_data.size)) + 128] + 32]
        require idx + 1 < mem[(2 * ceil32(return_data.size)) + 96]
        _2263 = mem[mem[(32 * idx + 1) + (2 * ceil32(return_data.size)) + 128]]
        require idx + 1 < mem[(2 * ceil32(return_data.size)) + 96]
        _2266 = mem[mem[(32 * idx + 1) + (2 * ceil32(return_data.size)) + 128] + 32]
        mem[mem[64] + 4] = this.address
        require ext_code.size(address(_2266))
        staticcall address(_2266).balanceOf(address rg1) with:
                gas gas_remaining wei
               args address(this.address)
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _2285 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _2292 = mem[_2285]
        _2305 = mem[64]
        mem[mem[64] + 36] = address(_2260)
        mem[mem[64] + 68] = s
        _2306 = mem[64]
        mem[mem[64]] = 68
        mem[64] = mem[64] + 100
        mem[_2306 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_2306 + 36 len 28]
        mem[64] = _2305 + 164
        mem[_2305 + 100] = 32
        mem[_2305 + 132] = 'SafeERC20: low-level call failed'
        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(address(_2263)):
            revert with 0, 'Address: call to non-contract'
        if not ext_code.hash(address(_2263)):
            revert with 0, 'Address: call to non-contract'
        _2356 = mem[_2306]
        t = _2306 + 32
        u = mem[64]
        s = mem[_2306]
        while s >= 32:
            mem[u] = mem[t]
            t = t + 32
            u = u + 32
            s = s - 32
            continue 
        mem[mem[64] + floor32(mem[_2306])] = mem[_2306 + floor32(mem[_2306]) + -(mem[_2306] % 32) + 64 len mem[_2306] % 32] or Mask(8 * -(mem[_2306] % 32) + 32, -(8 * -(mem[_2306] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_2306])])
        call address(_2263).mem[mem[64] len 4] with:
             gas gas_remaining wei
            args mem[mem[64] + 4 len _2356 + _2305 + -mem[64] + 160]
        if not return_data.size:
            if not ext_call.success:
                if mem[96]:
                    revert with memory
                      from 128
                       len mem[96]
                _3021 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = mem[_2305 + 100]
                _3023 = mem[_2305 + 100]
                idx = 0
                while idx < _3023:
                    mem[idx + _3021 + 68] = mem[idx + _2305 + 132]
                    idx = idx + 32
                    continue 
                if not _3023 % 32:
                    revert with memory
                      from mem[64]
                       len _3023 + _3021 + -mem[64] + 68
                mem[floor32(_3023) + _3021 + 68] = mem[floor32(_3023) + _3021 + -(_3023 % 32) + 100 len _3023 % 32]
                revert with memory
                  from mem[64]
                   len floor32(_3023) + _3021 + -mem[64] + 100
            if not mem[96]:
                require ext_code.size(address(_2260))
                staticcall address(_2260).getReserves() with:
                        gas gas_remaining wei
                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if address(_2263) < address(_2266):
                    _3091 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 96
                    _3107 = mem[_3091]
                    require mem[_3091] == mem[_3091 + 18 len 14]
                    _3115 = mem[_3091 + 32]
                    require mem[_3091 + 32] == mem[_3091 + 50 len 14]
                    require mem[_3091 + 64] == mem[_3091 + 92 len 4]
                    mem[mem[64] + 4] = address(_2260)
                    require ext_code.size(address(_2263))
                    staticcall address(_2263).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(_2260)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if address(_2263) != address(_2263):
                        _3156 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        mem[mem[64] + 4] = mem[_3156] - Mask(112, 0, _3115)
                        mem[mem[64] + 36] = Mask(112, 0, _3115)
                        mem[mem[64] + 68] = Mask(112, 0, _3107)
                        require ext_code.size(address(_2252))
                        staticcall address(_2252).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                                gas gas_remaining wei
                               args mem[mem[64] + 4], _3115 << 144, Mask(112, 0, _3107)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3220 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _3236 = mem[_3220]
                        if address(_2263) == address(_2263):
                            _3261 = mem[64]
                            mem[mem[64]] = 0
                            mem[64] = mem[64] + 32
                            mem[_3261 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                            mem[_3261 + 36] = 0
                            mem[_3261 + 68] = _3236
                            mem[_3261 + 100] = this.address
                            mem[_3261 + 132] = 128
                            mem[_3261 + 164] = mem[_3261]
                            s = 0
                            while s < mem[_3261]:
                                mem[s + _3261 + 196] = mem[s + _3261 + 32]
                                s = s + 32
                                continue 
                            if ceil32(mem[_3261]) > mem[_3261]:
                                mem[_3261 + mem[_3261] + 196] = 0
                            require ext_code.size(address(_2260))
                            call address(_2260).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                                 gas gas_remaining wei
                                args 0, _3236, address(this.address), 128, mem[_3261], mem[_3261 + 196 len ceil32(mem[_3261])]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_3261 + 36] = this.address
                            require ext_code.size(address(_2266))
                            staticcall address(_2266).balanceOf(address rg1) with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[_3261 + 32] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = _3261 + ceil32(return_data.size) + 32
                        else:
                            _3262 = mem[64]
                            mem[mem[64]] = 0
                            mem[64] = mem[64] + 32
                            mem[_3262 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                            mem[_3262 + 36] = _3236
                            mem[_3262 + 68] = 0
                            mem[_3262 + 100] = this.address
                            mem[_3262 + 132] = 128
                            mem[_3262 + 164] = mem[_3262]
                            s = 0
                            while s < mem[_3262]:
                                mem[s + _3262 + 196] = mem[s + _3262 + 32]
                                s = s + 32
                                continue 
                            if ceil32(mem[_3262]) > mem[_3262]:
                                mem[_3262 + mem[_3262] + 196] = 0
                            require ext_code.size(address(_2260))
                            call address(_2260).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                                 gas gas_remaining wei
                                args _3236, 0, address(this.address), 128, mem[_3262], mem[_3262 + 196 len ceil32(mem[_3262])]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_3262 + 36] = this.address
                            require ext_code.size(address(_2266))
                            staticcall address(_2266).balanceOf(address rg1) with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[_3262 + 32] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = _3262 + ceil32(return_data.size) + 32
                        require return_data.size >= 32
                        idx = idx + 2
                        s = ext_call.return_data[0] - _2292
                        continue 
                    _3155 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    mem[mem[64] + 4] = mem[_3155] - Mask(112, 0, _3107)
                    mem[mem[64] + 36] = Mask(112, 0, _3107)
                    mem[mem[64] + 68] = Mask(112, 0, _3115)
                    require ext_code.size(address(_2252))
                    staticcall address(_2252).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                            gas gas_remaining wei
                           args mem[mem[64] + 4], _3107 << 144, Mask(112, 0, _3115)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3219 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _3235 = mem[_3219]
                    if address(_2263) != address(_2263):
                        _3260 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_3260 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_3260 + 36] = _3235
                        mem[_3260 + 68] = 0
                        mem[_3260 + 100] = this.address
                        mem[_3260 + 132] = 128
                        mem[_3260 + 164] = mem[_3260]
                        s = 0
                        while s < mem[_3260]:
                            mem[s + _3260 + 196] = mem[s + _3260 + 32]
                            s = s + 32
                            continue 
                        if ceil32(mem[_3260]) > mem[_3260]:
                            mem[_3260 + mem[_3260] + 196] = 0
                        require ext_code.size(address(_2260))
                        call address(_2260).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                             gas gas_remaining wei
                            args _3235, 0, address(this.address), 128, mem[_3260], mem[_3260 + 196 len ceil32(mem[_3260])]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_3260 + 36] = this.address
                        require ext_code.size(address(_2266))
                        staticcall address(_2266).balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args this.address
                        mem[_3260 + 32] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[64] = _3260 + ceil32(return_data.size) + 32
                        require return_data.size >= 32
                        idx = idx + 2
                        s = ext_call.return_data[0] - _2292
                        continue 
                    _3259 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_3259 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_3259 + 36] = 0
                    mem[_3259 + 68] = _3235
                    mem[_3259 + 100] = this.address
                    mem[_3259 + 132] = 128
                    mem[_3259 + 164] = mem[_3259]
                    s = 0
                    while s < mem[_3259]:
                        mem[s + _3259 + 196] = mem[s + _3259 + 32]
                        s = s + 32
                        continue 
                    if ceil32(mem[_3259]) <= mem[_3259]:
                        require ext_code.size(address(_2260))
                        call address(_2260).mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len ceil32(mem[_3259]) + _3259 + -mem[64] + 192]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(_2266))
                        staticcall address(_2266).balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3923 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        idx = idx + 2
                        s = mem[_3923] - _2292
                        continue 
                    mem[_3259 + mem[_3259] + 196] = 0
                    require ext_code.size(address(_2260))
                    call address(_2260).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_3259]) + _3259 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(_2266))
                    staticcall address(_2266).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3955 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    idx = idx + 2
                    s = mem[_3955] - _2292
                    continue 
                _3092 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 96
                _3108 = mem[_3092]
                require mem[_3092] == mem[_3092 + 18 len 14]
                _3116 = mem[_3092 + 32]
                require mem[_3092 + 32] == mem[_3092 + 50 len 14]
                require mem[_3092 + 64] == mem[_3092 + 92 len 4]
                mem[mem[64] + 4] = address(_2260)
                require ext_code.size(address(_2263))
                staticcall address(_2263).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(_2260)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if address(_2263) == address(_2266):
                    _3157 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    mem[mem[64] + 4] = mem[_3157] - Mask(112, 0, _3108)
                    mem[mem[64] + 36] = Mask(112, 0, _3108)
                    mem[mem[64] + 68] = Mask(112, 0, _3116)
                    require ext_code.size(address(_2252))
                    staticcall address(_2252).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                            gas gas_remaining wei
                           args mem[mem[64] + 4], _3108 << 144, Mask(112, 0, _3116)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3221 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _3237 = mem[_3221]
                    if address(_2263) == address(_2266):
                        _3263 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_3263 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_3263 + 36] = 0
                        mem[_3263 + 68] = _3237
                        mem[_3263 + 100] = this.address
                        mem[_3263 + 132] = 128
                        mem[_3263 + 164] = mem[_3263]
                        s = 0
                        while s < mem[_3263]:
                            mem[s + _3263 + 196] = mem[s + _3263 + 32]
                            s = s + 32
                            continue 
                        if ceil32(mem[_3263]) <= mem[_3263]:
                            require ext_code.size(address(_2260))
                            call address(_2260).mem[mem[64] len 4] with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len ceil32(mem[_3263]) + _3263 + -mem[64] + 192]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(address(_2266))
                            staticcall address(_2266).balanceOf(address rg1) with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3927 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            idx = idx + 2
                            s = mem[_3927] - _2292
                            continue 
                        mem[_3263 + mem[_3263] + 196] = 0
                        require ext_code.size(address(_2260))
                        call address(_2260).mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len ceil32(mem[_3263]) + _3263 + -mem[64] + 192]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(_2266))
                        staticcall address(_2266).balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3959 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        idx = idx + 2
                        s = mem[_3959] - _2292
                        continue 
                    _3264 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_3264 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_3264 + 36] = _3237
                    mem[_3264 + 68] = 0
                    mem[_3264 + 100] = this.address
                    mem[_3264 + 132] = 128
                    mem[_3264 + 164] = mem[_3264]
                    s = 0
                    while s < mem[_3264]:
                        mem[s + _3264 + 196] = mem[s + _3264 + 32]
                        s = s + 32
                        continue 
                    if ceil32(mem[_3264]) <= mem[_3264]:
                        require ext_code.size(address(_2260))
                        call address(_2260).mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len ceil32(mem[_3264]) + _3264 + -mem[64] + 192]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(_2266))
                        staticcall address(_2266).balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3928 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        idx = idx + 2
                        s = mem[_3928] - _2292
                        continue 
                    mem[_3264 + mem[_3264] + 196] = 0
                    require ext_code.size(address(_2260))
                    call address(_2260).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_3264]) + _3264 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(_2266))
                    staticcall address(_2266).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3960 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    idx = idx + 2
                    s = mem[_3960] - _2292
                    continue 
                _3158 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[mem[64] + 4] = mem[_3158] - Mask(112, 0, _3116)
                mem[mem[64] + 36] = Mask(112, 0, _3116)
                mem[mem[64] + 68] = Mask(112, 0, _3108)
                require ext_code.size(address(_2252))
                staticcall address(_2252).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                        gas gas_remaining wei
                       args mem[mem[64] + 4], _3116 << 144, Mask(112, 0, _3108)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3222 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _3238 = mem[_3222]
                if address(_2263) == address(_2266):
                    _3265 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_3265 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_3265 + 36] = 0
                    mem[_3265 + 68] = _3238
                    mem[_3265 + 100] = this.address
                    mem[_3265 + 132] = 128
                    mem[_3265 + 164] = mem[_3265]
                    s = 0
                    while s < mem[_3265]:
                        mem[s + _3265 + 196] = mem[s + _3265 + 32]
                        s = s + 32
                        continue 
                    if ceil32(mem[_3265]) <= mem[_3265]:
                        require ext_code.size(address(_2260))
                        call address(_2260).mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len ceil32(mem[_3265]) + _3265 + -mem[64] + 192]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(_2266))
                        staticcall address(_2266).balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3929 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        idx = idx + 2
                        s = mem[_3929] - _2292
                        continue 
                    mem[_3265 + mem[_3265] + 196] = 0
                    require ext_code.size(address(_2260))
                    call address(_2260).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_3265]) + _3265 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(_2266))
                    staticcall address(_2266).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3961 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    idx = idx + 2
                    s = mem[_3961] - _2292
                    continue 
                _3266 = mem[64]
                mem[mem[64]] = 0
                mem[64] = mem[64] + 32
                mem[_3266 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[_3266 + 36] = _3238
                mem[_3266 + 68] = 0
                mem[_3266 + 100] = this.address
                mem[_3266 + 132] = 128
                mem[_3266 + 164] = mem[_3266]
                s = 0
                while s < mem[_3266]:
                    mem[s + _3266 + 196] = mem[s + _3266 + 32]
                    s = s + 32
                    continue 
                if ceil32(mem[_3266]) <= mem[_3266]:
                    require ext_code.size(address(_2260))
                    call address(_2260).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_3266]) + _3266 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(_2266))
                    staticcall address(_2266).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3930 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    idx = idx + 2
                    s = mem[_3930] - _2292
                    continue 
                mem[_3266 + mem[_3266] + 196] = 0
                require ext_code.size(address(_2260))
                call address(_2260).mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len ceil32(mem[_3266]) + _3266 + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(_2266))
                staticcall address(_2266).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3962 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                idx = idx + 2
                s = mem[_3962] - _2292
                continue 
            require mem[96] >= 32
            if not mem[128]:
                revert with 0, 
                            32,
                            42,
                            0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                            mem[mem[64] + 110 len 22]
            require ext_code.size(address(_2260))
            staticcall address(_2260).getReserves() with:
                    gas gas_remaining wei
            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if address(_2263) < address(_2266):
                _3103 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 96
                _3111 = mem[_3103]
                require mem[_3103] == mem[_3103 + 18 len 14]
                _3121 = mem[_3103 + 32]
                require mem[_3103 + 32] == mem[_3103 + 50 len 14]
                require mem[_3103 + 64] == mem[_3103 + 92 len 4]
                mem[mem[64] + 4] = address(_2260)
                require ext_code.size(address(_2263))
                staticcall address(_2263).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(_2260)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if address(_2263) == address(_2263):
                    _3175 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    mem[mem[64] + 4] = mem[_3175] - Mask(112, 0, _3111)
                    mem[mem[64] + 36] = Mask(112, 0, _3111)
                    mem[mem[64] + 68] = Mask(112, 0, _3121)
                    require ext_code.size(address(_2252))
                    staticcall address(_2252).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                            gas gas_remaining wei
                           args mem[mem[64] + 4], _3111 << 144, Mask(112, 0, _3121)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3239 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _3251 = mem[_3239]
                    if address(_2263) == address(_2263):
                        _3291 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_3291 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_3291 + 36] = 0
                        mem[_3291 + 68] = _3251
                        mem[_3291 + 100] = this.address
                        mem[_3291 + 132] = 128
                        mem[_3291 + 164] = mem[_3291]
                        s = 0
                        while s < mem[_3291]:
                            mem[s + _3291 + 196] = mem[s + _3291 + 32]
                            s = s + 32
                            continue 
                        if ceil32(mem[_3291]) > mem[_3291]:
                            mem[_3291 + mem[_3291] + 196] = 0
                        require ext_code.size(address(_2260))
                        call address(_2260).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                             gas gas_remaining wei
                            args 0, _3251, address(this.address), 128, mem[_3291], mem[_3291 + 196 len ceil32(mem[_3291])]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_3291 + 36] = this.address
                        require ext_code.size(address(_2266))
                        staticcall address(_2266).balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args this.address
                        mem[_3291 + 32] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[64] = _3291 + ceil32(return_data.size) + 32
                    else:
                        _3292 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_3292 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_3292 + 36] = _3251
                        mem[_3292 + 68] = 0
                        mem[_3292 + 100] = this.address
                        mem[_3292 + 132] = 128
                        mem[_3292 + 164] = mem[_3292]
                        s = 0
                        while s < mem[_3292]:
                            mem[s + _3292 + 196] = mem[s + _3292 + 32]
                            s = s + 32
                            continue 
                        if ceil32(mem[_3292]) > mem[_3292]:
                            mem[_3292 + mem[_3292] + 196] = 0
                        require ext_code.size(address(_2260))
                        call address(_2260).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                             gas gas_remaining wei
                            args _3251, 0, address(this.address), 128, mem[_3292], mem[_3292 + 196 len ceil32(mem[_3292])]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_3292 + 36] = this.address
                        require ext_code.size(address(_2266))
                        staticcall address(_2266).balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args this.address
                        mem[_3292 + 32] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[64] = _3292 + ceil32(return_data.size) + 32
                    require return_data.size >= 32
                    idx = idx + 2
                    s = ext_call.return_data[0] - _2292
                    continue 
                _3176 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[mem[64] + 4] = mem[_3176] - Mask(112, 0, _3121)
                mem[mem[64] + 36] = Mask(112, 0, _3121)
                mem[mem[64] + 68] = Mask(112, 0, _3111)
                require ext_code.size(address(_2252))
                staticcall address(_2252).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                        gas gas_remaining wei
                       args mem[mem[64] + 4], _3121 << 144, Mask(112, 0, _3111)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3240 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _3252 = mem[_3240]
                if address(_2263) != address(_2263):
                    _3294 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_3294 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_3294 + 36] = _3252
                    mem[_3294 + 68] = 0
                    mem[_3294 + 100] = this.address
                    mem[_3294 + 132] = 128
                    mem[_3294 + 164] = mem[_3294]
                    s = 0
                    while s < mem[_3294]:
                        mem[s + _3294 + 196] = mem[s + _3294 + 32]
                        s = s + 32
                        continue 
                    if ceil32(mem[_3294]) > mem[_3294]:
                        mem[_3294 + mem[_3294] + 196] = 0
                    require ext_code.size(address(_2260))
                    call address(_2260).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                         gas gas_remaining wei
                        args _3252, 0, address(this.address), 128, mem[_3294], mem[_3294 + 196 len ceil32(mem[_3294])]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[_3294 + 36] = this.address
                    require ext_code.size(address(_2266))
                    staticcall address(_2266).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args this.address
                    mem[_3294 + 32] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = _3294 + ceil32(return_data.size) + 32
                    require return_data.size >= 32
                    idx = idx + 2
                    s = ext_call.return_data[0] - _2292
                    continue 
                _3293 = mem[64]
                mem[mem[64]] = 0
                mem[64] = mem[64] + 32
                mem[_3293 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[_3293 + 36] = 0
                mem[_3293 + 68] = _3252
                mem[_3293 + 100] = this.address
                mem[_3293 + 132] = 128
                mem[_3293 + 164] = mem[_3293]
                s = 0
                while s < mem[_3293]:
                    mem[s + _3293 + 196] = mem[s + _3293 + 32]
                    s = s + 32
                    continue 
                if ceil32(mem[_3293]) <= mem[_3293]:
                    require ext_code.size(address(_2260))
                    call address(_2260).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_3293]) + _3293 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(_2266))
                    staticcall address(_2266).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3933 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    idx = idx + 2
                    s = mem[_3933] - _2292
                    continue 
                mem[_3293 + mem[_3293] + 196] = 0
                require ext_code.size(address(_2260))
                call address(_2260).mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len ceil32(mem[_3293]) + _3293 + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(_2266))
                staticcall address(_2266).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3965 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                idx = idx + 2
                s = mem[_3965] - _2292
                continue 
            _3104 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 96
            _3112 = mem[_3104]
            require mem[_3104] == mem[_3104 + 18 len 14]
            _3122 = mem[_3104 + 32]
            require mem[_3104 + 32] == mem[_3104 + 50 len 14]
            require mem[_3104 + 64] == mem[_3104 + 92 len 4]
            mem[mem[64] + 4] = address(_2260)
            require ext_code.size(address(_2263))
            staticcall address(_2263).balanceOf(address rg1) with:
                    gas gas_remaining wei
                   args address(_2260)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if address(_2263) == address(_2266):
                _3177 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[mem[64] + 4] = mem[_3177] - Mask(112, 0, _3112)
                mem[mem[64] + 36] = Mask(112, 0, _3112)
                mem[mem[64] + 68] = Mask(112, 0, _3122)
                require ext_code.size(address(_2252))
                staticcall address(_2252).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                        gas gas_remaining wei
                       args mem[mem[64] + 4], _3112 << 144, Mask(112, 0, _3122)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3241 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _3253 = mem[_3241]
                if address(_2263) == address(_2266):
                    _3295 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_3295 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_3295 + 36] = 0
                    mem[_3295 + 68] = _3253
                    mem[_3295 + 100] = this.address
                    mem[_3295 + 132] = 128
                    mem[_3295 + 164] = mem[_3295]
                    s = 0
                    while s < mem[_3295]:
                        mem[s + _3295 + 196] = mem[s + _3295 + 32]
                        s = s + 32
                        continue 
                    if ceil32(mem[_3295]) <= mem[_3295]:
                        require ext_code.size(address(_2260))
                        call address(_2260).mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len ceil32(mem[_3295]) + _3295 + -mem[64] + 192]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(_2266))
                        staticcall address(_2266).balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3935 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        idx = idx + 2
                        s = mem[_3935] - _2292
                        continue 
                    mem[_3295 + mem[_3295] + 196] = 0
                    require ext_code.size(address(_2260))
                    call address(_2260).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_3295]) + _3295 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(_2266))
                    staticcall address(_2266).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3967 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    idx = idx + 2
                    s = mem[_3967] - _2292
                    continue 
                _3296 = mem[64]
                mem[mem[64]] = 0
                mem[64] = mem[64] + 32
                mem[_3296 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[_3296 + 36] = _3253
                mem[_3296 + 68] = 0
                mem[_3296 + 100] = this.address
                mem[_3296 + 132] = 128
                mem[_3296 + 164] = mem[_3296]
                s = 0
                while s < mem[_3296]:
                    mem[s + _3296 + 196] = mem[s + _3296 + 32]
                    s = s + 32
                    continue 
                if ceil32(mem[_3296]) <= mem[_3296]:
                    require ext_code.size(address(_2260))
                    call address(_2260).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_3296]) + _3296 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(_2266))
                    staticcall address(_2266).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3936 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    idx = idx + 2
                    s = mem[_3936] - _2292
                    continue 
                mem[_3296 + mem[_3296] + 196] = 0
                require ext_code.size(address(_2260))
                call address(_2260).mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len ceil32(mem[_3296]) + _3296 + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(_2266))
                staticcall address(_2266).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3968 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                idx = idx + 2
                s = mem[_3968] - _2292
                continue 
            _3178 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            mem[mem[64] + 4] = mem[_3178] - Mask(112, 0, _3122)
            mem[mem[64] + 36] = Mask(112, 0, _3122)
            mem[mem[64] + 68] = Mask(112, 0, _3112)
            require ext_code.size(address(_2252))
            staticcall address(_2252).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                    gas gas_remaining wei
                   args mem[mem[64] + 4], _3122 << 144, Mask(112, 0, _3112)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3242 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _3254 = mem[_3242]
            if address(_2263) == address(_2266):
                _3297 = mem[64]
                mem[mem[64]] = 0
                mem[64] = mem[64] + 32
                mem[_3297 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[_3297 + 36] = 0
                mem[_3297 + 68] = _3254
                mem[_3297 + 100] = this.address
                mem[_3297 + 132] = 128
                mem[_3297 + 164] = mem[_3297]
                s = 0
                while s < mem[_3297]:
                    mem[s + _3297 + 196] = mem[s + _3297 + 32]
                    s = s + 32
                    continue 
                if ceil32(mem[_3297]) > mem[_3297]:
                    mem[_3297 + mem[_3297] + 196] = 0
                require ext_code.size(address(_2260))
                call address(_2260).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                     gas gas_remaining wei
                    args 0, _3254, address(this.address), 128, mem[_3297], mem[_3297 + 196 len ceil32(mem[_3297])]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[_3297 + 36] = this.address
                require ext_code.size(address(_2266))
                staticcall address(_2266).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args this.address
                mem[_3297 + 32] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[64] = _3297 + ceil32(return_data.size) + 32
                require return_data.size >= 32
                idx = idx + 2
                s = ext_call.return_data[0] - _2292
                continue 
            _3298 = mem[64]
            mem[mem[64]] = 0
            mem[64] = mem[64] + 32
            mem[_3298 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
            mem[_3298 + 36] = _3254
            mem[_3298 + 68] = 0
            mem[_3298 + 100] = this.address
            mem[_3298 + 132] = 128
            mem[_3298 + 164] = mem[_3298]
            s = 0
            while s < mem[_3298]:
                mem[s + _3298 + 196] = mem[s + _3298 + 32]
                s = s + 32
                continue 
            if ceil32(mem[_3298]) <= mem[_3298]:
                require ext_code.size(address(_2260))
                call address(_2260).mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len ceil32(mem[_3298]) + _3298 + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(_2266))
                staticcall address(_2266).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3938 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                idx = idx + 2
                s = mem[_3938] - _2292
                continue 
            mem[_3298 + mem[_3298] + 196] = 0
            require ext_code.size(address(_2260))
            call address(_2260).mem[mem[64] len 4] with:
                 gas gas_remaining wei
                args mem[mem[64] + 4 len ceil32(mem[_3298]) + _3298 + -mem[64] + 192]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[mem[64] + 4] = this.address
            require ext_code.size(address(_2266))
            staticcall address(_2266).balanceOf(address rg1) with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3970 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            idx = idx + 2
            s = mem[_3970] - _2292
            continue 
        _2998 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size) + 1
        mem[_2998] = return_data.size
        mem[_2998 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
        if not ext_call.success:
            if return_data.size:
                revert with ext_call.return_data[0 len return_data.size]
            _3025 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = mem[_2305 + 100]
            _3027 = mem[_2305 + 100]
            idx = 0
            while idx < _3027:
                mem[idx + _3025 + 68] = mem[idx + _2305 + 132]
                idx = idx + 32
                continue 
            if not _3027 % 32:
                revert with memory
                  from mem[64]
                   len _3027 + _3025 + -mem[64] + 68
            mem[floor32(_3027) + _3025 + 68] = mem[floor32(_3027) + _3025 + -(_3027 % 32) + 100 len _3027 % 32]
            revert with memory
              from mem[64]
               len floor32(_3027) + _3025 + -mem[64] + 100
        if not return_data.size:
            require ext_code.size(address(_2260))
            staticcall address(_2260).getReserves() with:
                    gas gas_remaining wei
            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if address(_2263) < address(_2266):
                _3097 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 96
                _3109 = mem[_3097]
                require mem[_3097] == mem[_3097 + 18 len 14]
                _3117 = mem[_3097 + 32]
                require mem[_3097 + 32] == mem[_3097 + 50 len 14]
                require mem[_3097 + 64] == mem[_3097 + 92 len 4]
                mem[mem[64] + 4] = address(_2260)
                require ext_code.size(address(_2263))
                staticcall address(_2263).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(_2260)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if address(_2263) == address(_2263):
                    _3163 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    mem[mem[64] + 4] = mem[_3163] - Mask(112, 0, _3109)
                    mem[mem[64] + 36] = Mask(112, 0, _3109)
                    mem[mem[64] + 68] = Mask(112, 0, _3117)
                    require ext_code.size(address(_2252))
                    staticcall address(_2252).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                            gas gas_remaining wei
                           args mem[mem[64] + 4], _3109 << 144, Mask(112, 0, _3117)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3227 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _3243 = mem[_3227]
                    if address(_2263) != address(_2263):
                        _3268 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_3268 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_3268 + 36] = _3243
                        mem[_3268 + 68] = 0
                        mem[_3268 + 100] = this.address
                        mem[_3268 + 132] = 128
                        mem[_3268 + 164] = mem[_3268]
                        s = 0
                        while s < mem[_3268]:
                            mem[s + _3268 + 196] = mem[s + _3268 + 32]
                            s = s + 32
                            continue 
                        if ceil32(mem[_3268]) > mem[_3268]:
                            mem[_3268 + mem[_3268] + 196] = 0
                        require ext_code.size(address(_2260))
                        call address(_2260).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                             gas gas_remaining wei
                            args _3243, 0, address(this.address), 128, mem[_3268], mem[_3268 + 196 len ceil32(mem[_3268])]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_3268 + 36] = this.address
                        require ext_code.size(address(_2266))
                        staticcall address(_2266).balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args this.address
                        mem[_3268 + 32] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[64] = _3268 + ceil32(return_data.size) + 32
                        require return_data.size >= 32
                        idx = idx + 2
                        s = ext_call.return_data[0] - _2292
                        continue 
                    _3267 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_3267 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_3267 + 36] = 0
                    mem[_3267 + 68] = _3243
                    mem[_3267 + 100] = this.address
                    mem[_3267 + 132] = 128
                    mem[_3267 + 164] = mem[_3267]
                    s = 0
                    while s < mem[_3267]:
                        mem[s + _3267 + 196] = mem[s + _3267 + 32]
                        s = s + 32
                        continue 
                    if ceil32(mem[_3267]) <= mem[_3267]:
                        require ext_code.size(address(_2260))
                        call address(_2260).mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len ceil32(mem[_3267]) + _3267 + -mem[64] + 192]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(_2266))
                        staticcall address(_2266).balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3939 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        idx = idx + 2
                        s = mem[_3939] - _2292
                        continue 
                    mem[_3267 + mem[_3267] + 196] = 0
                    require ext_code.size(address(_2260))
                    call address(_2260).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_3267]) + _3267 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(_2266))
                    staticcall address(_2266).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3971 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    idx = idx + 2
                    s = mem[_3971] - _2292
                    continue 
                _3164 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[mem[64] + 4] = mem[_3164] - Mask(112, 0, _3117)
                mem[mem[64] + 36] = Mask(112, 0, _3117)
                mem[mem[64] + 68] = Mask(112, 0, _3109)
                require ext_code.size(address(_2252))
                staticcall address(_2252).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                        gas gas_remaining wei
                       args mem[mem[64] + 4], _3117 << 144, Mask(112, 0, _3109)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3228 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _3244 = mem[_3228]
                if address(_2263) == address(_2263):
                    _3269 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_3269 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_3269 + 36] = 0
                    mem[_3269 + 68] = _3244
                    mem[_3269 + 100] = this.address
                    mem[_3269 + 132] = 128
                    mem[_3269 + 164] = mem[_3269]
                    s = 0
                    while s < mem[_3269]:
                        mem[s + _3269 + 196] = mem[s + _3269 + 32]
                        s = s + 32
                        continue 
                    if ceil32(mem[_3269]) <= mem[_3269]:
                        require ext_code.size(address(_2260))
                        call address(_2260).mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len ceil32(mem[_3269]) + _3269 + -mem[64] + 192]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(_2266))
                        staticcall address(_2266).balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3941 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        idx = idx + 2
                        s = mem[_3941] - _2292
                        continue 
                    mem[_3269 + mem[_3269] + 196] = 0
                    require ext_code.size(address(_2260))
                    call address(_2260).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_3269]) + _3269 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(_2266))
                    staticcall address(_2266).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3973 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    idx = idx + 2
                    s = mem[_3973] - _2292
                    continue 
                _3270 = mem[64]
                mem[mem[64]] = 0
                mem[64] = mem[64] + 32
                mem[_3270 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[_3270 + 36] = _3244
                mem[_3270 + 68] = 0
                mem[_3270 + 100] = this.address
                mem[_3270 + 132] = 128
                mem[_3270 + 164] = mem[_3270]
                s = 0
                while s < mem[_3270]:
                    mem[s + _3270 + 196] = mem[s + _3270 + 32]
                    s = s + 32
                    continue 
                if ceil32(mem[_3270]) <= mem[_3270]:
                    require ext_code.size(address(_2260))
                    call address(_2260).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_3270]) + _3270 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(_2266))
                    staticcall address(_2266).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3942 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    idx = idx + 2
                    s = mem[_3942] - _2292
                    continue 
                mem[_3270 + mem[_3270] + 196] = 0
                require ext_code.size(address(_2260))
                call address(_2260).mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len ceil32(mem[_3270]) + _3270 + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(_2266))
                staticcall address(_2266).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3974 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                idx = idx + 2
                s = mem[_3974] - _2292
                continue 
            _3098 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 96
            _3110 = mem[_3098]
            require mem[_3098] == mem[_3098 + 18 len 14]
            _3118 = mem[_3098 + 32]
            require mem[_3098 + 32] == mem[_3098 + 50 len 14]
            require mem[_3098 + 64] == mem[_3098 + 92 len 4]
            mem[mem[64] + 4] = address(_2260)
            require ext_code.size(address(_2263))
            staticcall address(_2263).balanceOf(address rg1) with:
                    gas gas_remaining wei
                   args address(_2260)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if address(_2263) == address(_2266):
                _3165 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[mem[64] + 4] = mem[_3165] - Mask(112, 0, _3110)
                mem[mem[64] + 36] = Mask(112, 0, _3110)
                mem[mem[64] + 68] = Mask(112, 0, _3118)
                require ext_code.size(address(_2252))
                staticcall address(_2252).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                        gas gas_remaining wei
                       args mem[mem[64] + 4], _3110 << 144, Mask(112, 0, _3118)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3229 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _3245 = mem[_3229]
                if address(_2263) == address(_2266):
                    _3271 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_3271 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_3271 + 36] = 0
                    mem[_3271 + 68] = _3245
                    mem[_3271 + 100] = this.address
                    mem[_3271 + 132] = 128
                    mem[_3271 + 164] = mem[_3271]
                    s = 0
                    while s < mem[_3271]:
                        mem[s + _3271 + 196] = mem[s + _3271 + 32]
                        s = s + 32
                        continue 
                    if ceil32(mem[_3271]) > mem[_3271]:
                        mem[_3271 + mem[_3271] + 196] = 0
                    require ext_code.size(address(_2260))
                    call address(_2260).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                         gas gas_remaining wei
                        args 0, _3245, address(this.address), 128, mem[_3271], mem[_3271 + 196 len ceil32(mem[_3271])]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[_3271 + 36] = this.address
                    require ext_code.size(address(_2266))
                    staticcall address(_2266).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args this.address
                    mem[_3271 + 32] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = _3271 + ceil32(return_data.size) + 32
                else:
                    _3272 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_3272 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_3272 + 36] = _3245
                    mem[_3272 + 68] = 0
                    mem[_3272 + 100] = this.address
                    mem[_3272 + 132] = 128
                    mem[_3272 + 164] = mem[_3272]
                    s = 0
                    while s < mem[_3272]:
                        mem[s + _3272 + 196] = mem[s + _3272 + 32]
                        s = s + 32
                        continue 
                    if ceil32(mem[_3272]) > mem[_3272]:
                        mem[_3272 + mem[_3272] + 196] = 0
                    require ext_code.size(address(_2260))
                    call address(_2260).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                         gas gas_remaining wei
                        args _3245, 0, address(this.address), 128, mem[_3272], mem[_3272 + 196 len ceil32(mem[_3272])]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[_3272 + 36] = this.address
                    require ext_code.size(address(_2266))
                    staticcall address(_2266).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args this.address
                    mem[_3272 + 32] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = _3272 + ceil32(return_data.size) + 32
                require return_data.size >= 32
                idx = idx + 2
                s = ext_call.return_data[0] - _2292
                continue 
            _3166 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            mem[mem[64] + 4] = mem[_3166] - Mask(112, 0, _3118)
            mem[mem[64] + 36] = Mask(112, 0, _3118)
            mem[mem[64] + 68] = Mask(112, 0, _3110)
            require ext_code.size(address(_2252))
            staticcall address(_2252).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                    gas gas_remaining wei
                   args mem[mem[64] + 4], _3118 << 144, Mask(112, 0, _3110)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3230 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _3246 = mem[_3230]
            if address(_2263) == address(_2266):
                _3273 = mem[64]
                mem[mem[64]] = 0
                mem[64] = mem[64] + 32
                mem[_3273 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[_3273 + 36] = 0
                mem[_3273 + 68] = _3246
                mem[_3273 + 100] = this.address
                mem[_3273 + 132] = 128
                mem[_3273 + 164] = mem[_3273]
                s = 0
                while s < mem[_3273]:
                    mem[s + _3273 + 196] = mem[s + _3273 + 32]
                    s = s + 32
                    continue 
                if ceil32(mem[_3273]) <= mem[_3273]:
                    require ext_code.size(address(_2260))
                    call address(_2260).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_3273]) + _3273 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(_2266))
                    staticcall address(_2266).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3945 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    idx = idx + 2
                    s = mem[_3945] - _2292
                    continue 
                mem[_3273 + mem[_3273] + 196] = 0
                require ext_code.size(address(_2260))
                call address(_2260).mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len ceil32(mem[_3273]) + _3273 + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(_2266))
                staticcall address(_2266).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3977 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                idx = idx + 2
                s = mem[_3977] - _2292
                continue 
            _3274 = mem[64]
            mem[mem[64]] = 0
            mem[64] = mem[64] + 32
            mem[_3274 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
            mem[_3274 + 36] = _3246
            mem[_3274 + 68] = 0
            mem[_3274 + 100] = this.address
            mem[_3274 + 132] = 128
            mem[_3274 + 164] = mem[_3274]
            s = 0
            while s < mem[_3274]:
                mem[s + _3274 + 196] = mem[s + _3274 + 32]
                s = s + 32
                continue 
            if ceil32(mem[_3274]) <= mem[_3274]:
                require ext_code.size(address(_2260))
                call address(_2260).mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len ceil32(mem[_3274]) + _3274 + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(_2266))
                staticcall address(_2266).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3946 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                idx = idx + 2
                s = mem[_3946] - _2292
                continue 
            mem[_3274 + mem[_3274] + 196] = 0
            require ext_code.size(address(_2260))
            call address(_2260).mem[mem[64] len 4] with:
                 gas gas_remaining wei
                args mem[mem[64] + 4 len ceil32(mem[_3274]) + _3274 + -mem[64] + 192]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[mem[64] + 4] = this.address
            require ext_code.size(address(_2266))
            staticcall address(_2266).balanceOf(address rg1) with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3978 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            idx = idx + 2
            s = mem[_3978] - _2292
            continue 
        require return_data.size >= 32
        if not mem[_2998 + 32]:
            revert with 0, 
                        32,
                        42,
                        0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                        mem[mem[64] + 110 len 22]
        require ext_code.size(address(_2260))
        staticcall address(_2260).getReserves() with:
                gas gas_remaining wei
        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        if address(_2263) < address(_2266):
            _3105 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 96
            _3113 = mem[_3105]
            require mem[_3105] == mem[_3105 + 18 len 14]
            _3125 = mem[_3105 + 32]
            require mem[_3105 + 32] == mem[_3105 + 50 len 14]
            require mem[_3105 + 64] == mem[_3105 + 92 len 4]
            mem[mem[64] + 4] = address(_2260)
            require ext_code.size(address(_2263))
            staticcall address(_2263).balanceOf(address rg1) with:
                    gas gas_remaining wei
                   args address(_2260)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if address(_2263) == address(_2263):
                _3183 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[mem[64] + 4] = mem[_3183] - Mask(112, 0, _3113)
                mem[mem[64] + 36] = Mask(112, 0, _3113)
                mem[mem[64] + 68] = Mask(112, 0, _3125)
                require ext_code.size(address(_2252))
                staticcall address(_2252).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                        gas gas_remaining wei
                       args mem[mem[64] + 4], _3113 << 144, Mask(112, 0, _3125)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3247 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _3255 = mem[_3247]
                if address(_2263) == address(_2263):
                    _3299 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_3299 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_3299 + 36] = 0
                    mem[_3299 + 68] = _3255
                    mem[_3299 + 100] = this.address
                    mem[_3299 + 132] = 128
                    mem[_3299 + 164] = mem[_3299]
                    s = 0
                    while s < mem[_3299]:
                        mem[s + _3299 + 196] = mem[s + _3299 + 32]
                        s = s + 32
                        continue 
                    if ceil32(mem[_3299]) > mem[_3299]:
                        mem[_3299 + mem[_3299] + 196] = 0
                    require ext_code.size(address(_2260))
                    call address(_2260).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                         gas gas_remaining wei
                        args 0, _3255, address(this.address), 128, mem[_3299], mem[_3299 + 196 len ceil32(mem[_3299])]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[_3299 + 36] = this.address
                    require ext_code.size(address(_2266))
                    staticcall address(_2266).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args this.address
                    mem[_3299 + 32] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = _3299 + ceil32(return_data.size) + 32
                    require return_data.size >= 32
                    idx = idx + 2
                    s = ext_call.return_data[0] - _2292
                    continue 
                _3300 = mem[64]
                mem[mem[64]] = 0
                mem[64] = mem[64] + 32
                mem[_3300 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[_3300 + 36] = _3255
                mem[_3300 + 68] = 0
                mem[_3300 + 100] = this.address
                mem[_3300 + 132] = 128
                mem[_3300 + 164] = mem[_3300]
                s = 0
                while s < mem[_3300]:
                    mem[s + _3300 + 196] = mem[s + _3300 + 32]
                    s = s + 32
                    continue 
                if ceil32(mem[_3300]) <= mem[_3300]:
                    require ext_code.size(address(_2260))
                    call address(_2260).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_3300]) + _3300 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(_2266))
                    staticcall address(_2266).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3948 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    idx = idx + 2
                    s = mem[_3948] - _2292
                    continue 
                mem[_3300 + mem[_3300] + 196] = 0
                require ext_code.size(address(_2260))
                call address(_2260).mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len ceil32(mem[_3300]) + _3300 + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(_2266))
                staticcall address(_2266).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3980 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                idx = idx + 2
                s = mem[_3980] - _2292
                continue 
            _3184 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            mem[mem[64] + 4] = mem[_3184] - Mask(112, 0, _3125)
            mem[mem[64] + 36] = Mask(112, 0, _3125)
            mem[mem[64] + 68] = Mask(112, 0, _3113)
            require ext_code.size(address(_2252))
            staticcall address(_2252).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                    gas gas_remaining wei
                   args mem[mem[64] + 4], _3125 << 144, Mask(112, 0, _3113)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3248 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _3256 = mem[_3248]
            if address(_2263) == address(_2263):
                _3301 = mem[64]
                mem[mem[64]] = 0
                mem[64] = mem[64] + 32
                mem[_3301 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[_3301 + 36] = 0
                mem[_3301 + 68] = _3256
                mem[_3301 + 100] = this.address
                mem[_3301 + 132] = 128
                mem[_3301 + 164] = mem[_3301]
                s = 0
                while s < mem[_3301]:
                    mem[s + _3301 + 196] = mem[s + _3301 + 32]
                    s = s + 32
                    continue 
                if ceil32(mem[_3301]) <= mem[_3301]:
                    require ext_code.size(address(_2260))
                    call address(_2260).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_3301]) + _3301 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(_2266))
                    staticcall address(_2266).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3949 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    idx = idx + 2
                    s = mem[_3949] - _2292
                    continue 
                mem[_3301 + mem[_3301] + 196] = 0
                require ext_code.size(address(_2260))
                call address(_2260).mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len ceil32(mem[_3301]) + _3301 + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(_2266))
                staticcall address(_2266).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3981 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                idx = idx + 2
                s = mem[_3981] - _2292
                continue 
            _3302 = mem[64]
            mem[mem[64]] = 0
            mem[64] = mem[64] + 32
            mem[_3302 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
            mem[_3302 + 36] = _3256
            mem[_3302 + 68] = 0
            mem[_3302 + 100] = this.address
            mem[_3302 + 132] = 128
            mem[_3302 + 164] = mem[_3302]
            s = 0
            while s < mem[_3302]:
                mem[s + _3302 + 196] = mem[s + _3302 + 32]
                s = s + 32
                continue 
            if ceil32(mem[_3302]) <= mem[_3302]:
                require ext_code.size(address(_2260))
                call address(_2260).mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len ceil32(mem[_3302]) + _3302 + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(_2266))
                staticcall address(_2266).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3950 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                idx = idx + 2
                s = mem[_3950] - _2292
                continue 
            mem[_3302 + mem[_3302] + 196] = 0
            require ext_code.size(address(_2260))
            call address(_2260).mem[mem[64] len 4] with:
                 gas gas_remaining wei
                args mem[mem[64] + 4 len ceil32(mem[_3302]) + _3302 + -mem[64] + 192]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[mem[64] + 4] = this.address
            require ext_code.size(address(_2266))
            staticcall address(_2266).balanceOf(address rg1) with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3982 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            idx = idx + 2
            s = mem[_3982] - _2292
            continue 
        _3106 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 96
        _3114 = mem[_3106]
        require mem[_3106] == mem[_3106 + 18 len 14]
        _3126 = mem[_3106 + 32]
        require mem[_3106 + 32] == mem[_3106 + 50 len 14]
        require mem[_3106 + 64] == mem[_3106 + 92 len 4]
        mem[mem[64] + 4] = address(_2260)
        require ext_code.size(address(_2263))
        staticcall address(_2263).balanceOf(address rg1) with:
                gas gas_remaining wei
               args address(_2260)
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        if address(_2263) != address(_2266):
            _3186 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            mem[mem[64] + 4] = mem[_3186] - Mask(112, 0, _3126)
            mem[mem[64] + 36] = Mask(112, 0, _3126)
            mem[mem[64] + 68] = Mask(112, 0, _3114)
            require ext_code.size(address(_2252))
            staticcall address(_2252).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                    gas gas_remaining wei
                   args mem[mem[64] + 4], _3126 << 144, Mask(112, 0, _3114)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3250 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _3258 = mem[_3250]
            if address(_2263) == address(_2266):
                _3305 = mem[64]
                mem[mem[64]] = 0
                mem[64] = mem[64] + 32
                mem[_3305 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[_3305 + 36] = 0
                mem[_3305 + 68] = _3258
                mem[_3305 + 100] = this.address
                mem[_3305 + 132] = 128
                mem[_3305 + 164] = mem[_3305]
                s = 0
                while s < mem[_3305]:
                    mem[s + _3305 + 196] = mem[s + _3305 + 32]
                    s = s + 32
                    continue 
                if ceil32(mem[_3305]) > mem[_3305]:
                    mem[_3305 + mem[_3305] + 196] = 0
                require ext_code.size(address(_2260))
                call address(_2260).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                     gas gas_remaining wei
                    args 0, _3258, address(this.address), 128, mem[_3305], mem[_3305 + 196 len ceil32(mem[_3305])]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[_3305 + 36] = this.address
                require ext_code.size(address(_2266))
                staticcall address(_2266).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args this.address
                mem[_3305 + 32] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[64] = _3305 + ceil32(return_data.size) + 32
            else:
                _3306 = mem[64]
                mem[mem[64]] = 0
                mem[64] = mem[64] + 32
                mem[_3306 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[_3306 + 36] = _3258
                mem[_3306 + 68] = 0
                mem[_3306 + 100] = this.address
                mem[_3306 + 132] = 128
                mem[_3306 + 164] = mem[_3306]
                s = 0
                while s < mem[_3306]:
                    mem[s + _3306 + 196] = mem[s + _3306 + 32]
                    s = s + 32
                    continue 
                if ceil32(mem[_3306]) > mem[_3306]:
                    mem[_3306 + mem[_3306] + 196] = 0
                require ext_code.size(address(_2260))
                call address(_2260).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                     gas gas_remaining wei
                    args _3258, 0, address(this.address), 128, mem[_3306], mem[_3306 + 196 len ceil32(mem[_3306])]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[_3306 + 36] = this.address
                require ext_code.size(address(_2266))
                staticcall address(_2266).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args this.address
                mem[_3306 + 32] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[64] = _3306 + ceil32(return_data.size) + 32
            require return_data.size >= 32
            idx = idx + 2
            s = ext_call.return_data[0] - _2292
            continue 
        _3185 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        mem[mem[64] + 4] = mem[_3185] - Mask(112, 0, _3114)
        mem[mem[64] + 36] = Mask(112, 0, _3114)
        mem[mem[64] + 68] = Mask(112, 0, _3126)
        require ext_code.size(address(_2252))
        staticcall address(_2252).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                gas gas_remaining wei
               args mem[mem[64] + 4], _3114 << 144, Mask(112, 0, _3126)
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _3249 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _3257 = mem[_3249]
        if address(_2263) == address(_2266):
            _3303 = mem[64]
            mem[mem[64]] = 0
            mem[64] = mem[64] + 32
            mem[_3303 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
            mem[_3303 + 36] = 0
            mem[_3303 + 68] = _3257
            mem[_3303 + 100] = this.address
            mem[_3303 + 132] = 128
            mem[_3303 + 164] = mem[_3303]
            s = 0
            while s < mem[_3303]:
                mem[s + _3303 + 196] = mem[s + _3303 + 32]
                s = s + 32
                continue 
            if ceil32(mem[_3303]) <= mem[_3303]:
                require ext_code.size(address(_2260))
                call address(_2260).mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len ceil32(mem[_3303]) + _3303 + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(_2266))
                staticcall address(_2266).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3951 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                idx = idx + 2
                s = mem[_3951] - _2292
                continue 
            mem[_3303 + mem[_3303] + 196] = 0
            require ext_code.size(address(_2260))
            call address(_2260).mem[mem[64] len 4] with:
                 gas gas_remaining wei
                args mem[mem[64] + 4 len ceil32(mem[_3303]) + _3303 + -mem[64] + 192]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[mem[64] + 4] = this.address
            require ext_code.size(address(_2266))
            staticcall address(_2266).balanceOf(address rg1) with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3983 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            idx = idx + 2
            s = mem[_3983] - _2292
            continue 
        _3304 = mem[64]
        mem[mem[64]] = 0
        mem[64] = mem[64] + 32
        mem[_3304 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[_3304 + 36] = _3257
        mem[_3304 + 68] = 0
        mem[_3304 + 100] = this.address
        mem[_3304 + 132] = 128
        mem[_3304 + 164] = mem[_3304]
        s = 0
        while s < mem[_3304]:
            mem[s + _3304 + 196] = mem[s + _3304 + 32]
            s = s + 32
            continue 
        if ceil32(mem[_3304]) <= mem[_3304]:
            require ext_code.size(address(_2260))
            call address(_2260).mem[mem[64] len 4] with:
                 gas gas_remaining wei
                args mem[mem[64] + 4 len ceil32(mem[_3304]) + _3304 + -mem[64] + 192]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[mem[64] + 4] = this.address
            require ext_code.size(address(_2266))
            staticcall address(_2266).balanceOf(address rg1) with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3952 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            idx = idx + 2
            s = mem[_3952] - _2292
            continue 
        mem[_3304 + mem[_3304] + 196] = 0
        require ext_code.size(address(_2260))
        call address(_2260).mem[mem[64] len 4] with:
             gas gas_remaining wei
            args mem[mem[64] + 4 len ceil32(mem[_3304]) + _3304 + -mem[64] + 192]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[mem[64] + 4] = this.address
        require ext_code.size(address(_2266))
        staticcall address(_2266).balanceOf(address rg1) with:
                gas gas_remaining wei
               args address(this.address)
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _3984 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        idx = idx + 2
        s = mem[_3984] - _2292
        continue 
    if not arg2:
        _2249 = mem[64]
        mem[mem[64] + 36] = msg.sender
        mem[mem[64] + 68] = cd[(arg4 + 36)]
        _2250 = mem[64]
        mem[mem[64]] = 68
        mem[mem[64] + 32 len 4] = transfer(address rg1, uint256 rg2)
        mem[64] = mem[64] + 164
        mem[_2249 + 100] = 32
        mem[_2249 + 132] = 'SafeERC20: low-level call failed'
        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(address(ext_call.return_data[0])):
            revert with 0, 'Address: call to non-contract'
        if not ext_code.hash(address(ext_call.return_data[0])):
            revert with 0, 'Address: call to non-contract'
        _2271 = mem[_2250]
        mem[_2249 + 164 len floor32(mem[_2250])] = mem[_2250 + 32 len floor32(mem[_2250])]
        mem[_2249 + floor32(mem[_2250]) + -(mem[_2250] % 32) + 196 len mem[_2250] % 32] = mem[_2250 + floor32(mem[_2250]) + -(mem[_2250] % 32) + 64 len mem[_2250] % 32]
        call address(ext_call.return_data[0]) with:
             gas gas_remaining wei
            args mem[_2249 + 168 len _2271 - 4]
        if not return_data.size:
            if not ext_call.success:
                if mem[96]:
                    revert with memory
                      from 128
                       len mem[96]
                revert with 0, 'SafeERC20: low-level call failed'
            if mem[96]:
                require mem[96] >= 32
                if not mem[128]:
                    revert with 0, 
                                32,
                                42,
                                0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                mem[_2249 + 274 len 22]
        else:
            mem[_2249 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not ext_call.success:
                if return_data.size:
                    revert with ext_call.return_data[0 len return_data.size]
                revert with 0, 'SafeERC20: low-level call failed'
            if return_data.size:
                require return_data.size >= 32
                if not mem[_2249 + 196]:
                    revert with 0, 
                                32,
                                42,
                                0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                mem[_2249 + ceil32(return_data.size) + 275 len 22]
    else:
        _2255 = mem[64]
        mem[mem[64] + 36] = msg.sender
        mem[mem[64] + 68] = cd[(arg4 + 36)]
        _2256 = mem[64]
        mem[mem[64]] = 68
        mem[mem[64] + 32 len 4] = transfer(address rg1, uint256 rg2)
        mem[64] = mem[64] + 164
        mem[_2255 + 100] = 32
        mem[_2255 + 132] = 'SafeERC20: low-level call failed'
        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(address(ext_call.return_data[0])):
            revert with 0, 'Address: call to non-contract'
        if not ext_code.hash(address(ext_call.return_data[0])):
            revert with 0, 'Address: call to non-contract'
        _2278 = mem[_2256]
        mem[_2255 + 164 len floor32(mem[_2256])] = mem[_2256 + 32 len floor32(mem[_2256])]
        mem[_2255 + floor32(mem[_2256]) + -(mem[_2256] % 32) + 196 len mem[_2256] % 32] = mem[_2256 + floor32(mem[_2256]) + -(mem[_2256] % 32) + 64 len mem[_2256] % 32]
        call address(ext_call.return_data[0]) with:
             gas gas_remaining wei
            args mem[_2255 + 168 len _2278 - 4]
        if not return_data.size:
            if not ext_call.success:
                if mem[96]:
                    revert with memory
                      from 128
                       len mem[96]
                revert with 0, 'SafeERC20: low-level call failed'
            if mem[96]:
                require mem[96] >= 32
                if not mem[128]:
                    revert with 0, 
                                32,
                                42,
                                0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                mem[_2255 + 274 len 22]
        else:
            mem[_2255 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not ext_call.success:
                if return_data.size:
                    revert with ext_call.return_data[0 len return_data.size]
                revert with 0, 'SafeERC20: low-level call failed'
            if return_data.size:
                require return_data.size >= 32
                if not mem[_2255 + 196]:
                    revert with 0, 
                                32,
                                42,
                                0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                mem[_2255 + ceil32(return_data.size) + 275 len 22]
}

function pancakeCall(address arg1, uint256 arg2, uint256 arg3, bytes arg4) {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg4 <= test266151307()
    require arg4 + 35 < calldata.size
    require arg4.length <= test266151307()
    require arg4 + arg4.length + 36 <= calldata.size
    require ext_code.size(msg.sender)
    staticcall msg.sender.token0() with:
            gas gas_remaining wei
    mem[96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    require ext_code.size(msg.sender)
    staticcall msg.sender.token1() with:
            gas gas_remaining wei
    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    require arg4.length >= 96
    require cd[(arg4 + 100)] <= test266151307()
    require arg4 + arg4.length + 36 > arg4 + cd[(arg4 + 100)] + 67
    require cd[(arg4 + cd[(arg4 + 100)] + 36)] <= test266151307()
    require (32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 128 >= 96 and (2 * ceil32(return_data.size)) + (32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 128 <= test266151307()
    mem[64] = (2 * ceil32(return_data.size)) + (32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 128
    mem[(2 * ceil32(return_data.size)) + 96] = cd[(arg4 + cd[(arg4 + 100)] + 36)]
    require arg4.length + 36 >= cd[(arg4 + 100)] + (64 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 68
    s = arg4 + cd[(arg4 + 100)] + 68
    t = (2 * ceil32(return_data.size)) + 128
    idx = 0
    while idx < cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        require s + 31 < arg4 + arg4.length + 36
        _1499 = mem[64]
        require mem[64] + 64 >= mem[64] and mem[64] + 64 <= test266151307()
        mem[64] = mem[64] + 64
        require s + 64 <= arg4 + arg4.length + 36
        u = 0
        v = s
        w = _1499
        while u < 2:
            require cd[v] == address(cd[v])
            mem[w] = cd[v]
            u = u + 1
            v = v + 32
            w = w + 32
            continue 
        mem[t] = _1499
        s = s + 64
        t = t + 32
        idx = idx + 1
        continue 
    require 0 < mem[(2 * ceil32(return_data.size)) + 96]
    require msg.sender == mem[mem[(2 * ceil32(return_data.size)) + 128] + 44 len 20]
    require 3 < mem[(2 * ceil32(return_data.size)) + 96]
    _1503 = mem[mem[(2 * ceil32(return_data.size)) + 224]]
    mem[mem[64] + 4] = this.address
    require ext_code.size(address(_1503))
    staticcall address(_1503).balanceOf(address rg1) with:
            gas gas_remaining wei
           args address(this.address)
    mem[mem[64]] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _1506 = mem[64]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    _2246 = mem[(2 * ceil32(return_data.size)) + 96]
    idx = 2
    s = mem[_1506] - cd[(arg4 + 68)]
    while idx < _2246:
        require idx < mem[(2 * ceil32(return_data.size)) + 96]
        _2252 = mem[mem[(32 * idx) + (2 * ceil32(return_data.size)) + 128]]
        require idx < mem[(2 * ceil32(return_data.size)) + 96]
        _2260 = mem[mem[(32 * idx) + (2 * ceil32(return_data.size)) + 128] + 32]
        require idx + 1 < mem[(2 * ceil32(return_data.size)) + 96]
        _2263 = mem[mem[(32 * idx + 1) + (2 * ceil32(return_data.size)) + 128]]
        require idx + 1 < mem[(2 * ceil32(return_data.size)) + 96]
        _2266 = mem[mem[(32 * idx + 1) + (2 * ceil32(return_data.size)) + 128] + 32]
        mem[mem[64] + 4] = this.address
        require ext_code.size(address(_2266))
        staticcall address(_2266).balanceOf(address rg1) with:
                gas gas_remaining wei
               args address(this.address)
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _2285 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _2292 = mem[_2285]
        _2305 = mem[64]
        mem[mem[64] + 36] = address(_2260)
        mem[mem[64] + 68] = s
        _2306 = mem[64]
        mem[mem[64]] = 68
        mem[64] = mem[64] + 100
        mem[_2306 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_2306 + 36 len 28]
        mem[64] = _2305 + 164
        mem[_2305 + 100] = 32
        mem[_2305 + 132] = 'SafeERC20: low-level call failed'
        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(address(_2263)):
            revert with 0, 'Address: call to non-contract'
        if not ext_code.hash(address(_2263)):
            revert with 0, 'Address: call to non-contract'
        _2356 = mem[_2306]
        t = _2306 + 32
        u = mem[64]
        s = mem[_2306]
        while s >= 32:
            mem[u] = mem[t]
            t = t + 32
            u = u + 32
            s = s - 32
            continue 
        mem[mem[64] + floor32(mem[_2306])] = mem[_2306 + floor32(mem[_2306]) + -(mem[_2306] % 32) + 64 len mem[_2306] % 32] or Mask(8 * -(mem[_2306] % 32) + 32, -(8 * -(mem[_2306] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_2306])])
        call address(_2263).mem[mem[64] len 4] with:
             gas gas_remaining wei
            args mem[mem[64] + 4 len _2356 + _2305 + -mem[64] + 160]
        if not return_data.size:
            if not ext_call.success:
                if mem[96]:
                    revert with memory
                      from 128
                       len mem[96]
                _3021 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = mem[_2305 + 100]
                _3023 = mem[_2305 + 100]
                idx = 0
                while idx < _3023:
                    mem[idx + _3021 + 68] = mem[idx + _2305 + 132]
                    idx = idx + 32
                    continue 
                if not _3023 % 32:
                    revert with memory
                      from mem[64]
                       len _3023 + _3021 + -mem[64] + 68
                mem[floor32(_3023) + _3021 + 68] = mem[floor32(_3023) + _3021 + -(_3023 % 32) + 100 len _3023 % 32]
                revert with memory
                  from mem[64]
                   len floor32(_3023) + _3021 + -mem[64] + 100
            if not mem[96]:
                require ext_code.size(address(_2260))
                staticcall address(_2260).getReserves() with:
                        gas gas_remaining wei
                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if address(_2263) < address(_2266):
                    _3091 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 96
                    _3107 = mem[_3091]
                    require mem[_3091] == mem[_3091 + 18 len 14]
                    _3115 = mem[_3091 + 32]
                    require mem[_3091 + 32] == mem[_3091 + 50 len 14]
                    require mem[_3091 + 64] == mem[_3091 + 92 len 4]
                    mem[mem[64] + 4] = address(_2260)
                    require ext_code.size(address(_2263))
                    staticcall address(_2263).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(_2260)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if address(_2263) != address(_2263):
                        _3156 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        mem[mem[64] + 4] = mem[_3156] - Mask(112, 0, _3115)
                        mem[mem[64] + 36] = Mask(112, 0, _3115)
                        mem[mem[64] + 68] = Mask(112, 0, _3107)
                        require ext_code.size(address(_2252))
                        staticcall address(_2252).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                                gas gas_remaining wei
                               args mem[mem[64] + 4], _3115 << 144, Mask(112, 0, _3107)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3220 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _3236 = mem[_3220]
                        if address(_2263) == address(_2263):
                            _3261 = mem[64]
                            mem[mem[64]] = 0
                            mem[64] = mem[64] + 32
                            mem[_3261 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                            mem[_3261 + 36] = 0
                            mem[_3261 + 68] = _3236
                            mem[_3261 + 100] = this.address
                            mem[_3261 + 132] = 128
                            mem[_3261 + 164] = mem[_3261]
                            s = 0
                            while s < mem[_3261]:
                                mem[s + _3261 + 196] = mem[s + _3261 + 32]
                                s = s + 32
                                continue 
                            if ceil32(mem[_3261]) > mem[_3261]:
                                mem[_3261 + mem[_3261] + 196] = 0
                            require ext_code.size(address(_2260))
                            call address(_2260).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                                 gas gas_remaining wei
                                args 0, _3236, address(this.address), 128, mem[_3261], mem[_3261 + 196 len ceil32(mem[_3261])]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_3261 + 36] = this.address
                            require ext_code.size(address(_2266))
                            staticcall address(_2266).balanceOf(address rg1) with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[_3261 + 32] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = _3261 + ceil32(return_data.size) + 32
                        else:
                            _3262 = mem[64]
                            mem[mem[64]] = 0
                            mem[64] = mem[64] + 32
                            mem[_3262 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                            mem[_3262 + 36] = _3236
                            mem[_3262 + 68] = 0
                            mem[_3262 + 100] = this.address
                            mem[_3262 + 132] = 128
                            mem[_3262 + 164] = mem[_3262]
                            s = 0
                            while s < mem[_3262]:
                                mem[s + _3262 + 196] = mem[s + _3262 + 32]
                                s = s + 32
                                continue 
                            if ceil32(mem[_3262]) > mem[_3262]:
                                mem[_3262 + mem[_3262] + 196] = 0
                            require ext_code.size(address(_2260))
                            call address(_2260).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                                 gas gas_remaining wei
                                args _3236, 0, address(this.address), 128, mem[_3262], mem[_3262 + 196 len ceil32(mem[_3262])]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_3262 + 36] = this.address
                            require ext_code.size(address(_2266))
                            staticcall address(_2266).balanceOf(address rg1) with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[_3262 + 32] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = _3262 + ceil32(return_data.size) + 32
                        require return_data.size >= 32
                        idx = idx + 2
                        s = ext_call.return_data[0] - _2292
                        continue 
                    _3155 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    mem[mem[64] + 4] = mem[_3155] - Mask(112, 0, _3107)
                    mem[mem[64] + 36] = Mask(112, 0, _3107)
                    mem[mem[64] + 68] = Mask(112, 0, _3115)
                    require ext_code.size(address(_2252))
                    staticcall address(_2252).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                            gas gas_remaining wei
                           args mem[mem[64] + 4], _3107 << 144, Mask(112, 0, _3115)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3219 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _3235 = mem[_3219]
                    if address(_2263) != address(_2263):
                        _3260 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_3260 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_3260 + 36] = _3235
                        mem[_3260 + 68] = 0
                        mem[_3260 + 100] = this.address
                        mem[_3260 + 132] = 128
                        mem[_3260 + 164] = mem[_3260]
                        s = 0
                        while s < mem[_3260]:
                            mem[s + _3260 + 196] = mem[s + _3260 + 32]
                            s = s + 32
                            continue 
                        if ceil32(mem[_3260]) > mem[_3260]:
                            mem[_3260 + mem[_3260] + 196] = 0
                        require ext_code.size(address(_2260))
                        call address(_2260).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                             gas gas_remaining wei
                            args _3235, 0, address(this.address), 128, mem[_3260], mem[_3260 + 196 len ceil32(mem[_3260])]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_3260 + 36] = this.address
                        require ext_code.size(address(_2266))
                        staticcall address(_2266).balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args this.address
                        mem[_3260 + 32] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[64] = _3260 + ceil32(return_data.size) + 32
                        require return_data.size >= 32
                        idx = idx + 2
                        s = ext_call.return_data[0] - _2292
                        continue 
                    _3259 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_3259 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_3259 + 36] = 0
                    mem[_3259 + 68] = _3235
                    mem[_3259 + 100] = this.address
                    mem[_3259 + 132] = 128
                    mem[_3259 + 164] = mem[_3259]
                    s = 0
                    while s < mem[_3259]:
                        mem[s + _3259 + 196] = mem[s + _3259 + 32]
                        s = s + 32
                        continue 
                    if ceil32(mem[_3259]) <= mem[_3259]:
                        require ext_code.size(address(_2260))
                        call address(_2260).mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len ceil32(mem[_3259]) + _3259 + -mem[64] + 192]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(_2266))
                        staticcall address(_2266).balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3923 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        idx = idx + 2
                        s = mem[_3923] - _2292
                        continue 
                    mem[_3259 + mem[_3259] + 196] = 0
                    require ext_code.size(address(_2260))
                    call address(_2260).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_3259]) + _3259 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(_2266))
                    staticcall address(_2266).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3955 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    idx = idx + 2
                    s = mem[_3955] - _2292
                    continue 
                _3092 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 96
                _3108 = mem[_3092]
                require mem[_3092] == mem[_3092 + 18 len 14]
                _3116 = mem[_3092 + 32]
                require mem[_3092 + 32] == mem[_3092 + 50 len 14]
                require mem[_3092 + 64] == mem[_3092 + 92 len 4]
                mem[mem[64] + 4] = address(_2260)
                require ext_code.size(address(_2263))
                staticcall address(_2263).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(_2260)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if address(_2263) == address(_2266):
                    _3157 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    mem[mem[64] + 4] = mem[_3157] - Mask(112, 0, _3108)
                    mem[mem[64] + 36] = Mask(112, 0, _3108)
                    mem[mem[64] + 68] = Mask(112, 0, _3116)
                    require ext_code.size(address(_2252))
                    staticcall address(_2252).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                            gas gas_remaining wei
                           args mem[mem[64] + 4], _3108 << 144, Mask(112, 0, _3116)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3221 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _3237 = mem[_3221]
                    if address(_2263) == address(_2266):
                        _3263 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_3263 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_3263 + 36] = 0
                        mem[_3263 + 68] = _3237
                        mem[_3263 + 100] = this.address
                        mem[_3263 + 132] = 128
                        mem[_3263 + 164] = mem[_3263]
                        s = 0
                        while s < mem[_3263]:
                            mem[s + _3263 + 196] = mem[s + _3263 + 32]
                            s = s + 32
                            continue 
                        if ceil32(mem[_3263]) <= mem[_3263]:
                            require ext_code.size(address(_2260))
                            call address(_2260).mem[mem[64] len 4] with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len ceil32(mem[_3263]) + _3263 + -mem[64] + 192]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(address(_2266))
                            staticcall address(_2266).balanceOf(address rg1) with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3927 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            idx = idx + 2
                            s = mem[_3927] - _2292
                            continue 
                        mem[_3263 + mem[_3263] + 196] = 0
                        require ext_code.size(address(_2260))
                        call address(_2260).mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len ceil32(mem[_3263]) + _3263 + -mem[64] + 192]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(_2266))
                        staticcall address(_2266).balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3959 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        idx = idx + 2
                        s = mem[_3959] - _2292
                        continue 
                    _3264 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_3264 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_3264 + 36] = _3237
                    mem[_3264 + 68] = 0
                    mem[_3264 + 100] = this.address
                    mem[_3264 + 132] = 128
                    mem[_3264 + 164] = mem[_3264]
                    s = 0
                    while s < mem[_3264]:
                        mem[s + _3264 + 196] = mem[s + _3264 + 32]
                        s = s + 32
                        continue 
                    if ceil32(mem[_3264]) <= mem[_3264]:
                        require ext_code.size(address(_2260))
                        call address(_2260).mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len ceil32(mem[_3264]) + _3264 + -mem[64] + 192]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(_2266))
                        staticcall address(_2266).balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3928 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        idx = idx + 2
                        s = mem[_3928] - _2292
                        continue 
                    mem[_3264 + mem[_3264] + 196] = 0
                    require ext_code.size(address(_2260))
                    call address(_2260).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_3264]) + _3264 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(_2266))
                    staticcall address(_2266).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3960 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    idx = idx + 2
                    s = mem[_3960] - _2292
                    continue 
                _3158 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[mem[64] + 4] = mem[_3158] - Mask(112, 0, _3116)
                mem[mem[64] + 36] = Mask(112, 0, _3116)
                mem[mem[64] + 68] = Mask(112, 0, _3108)
                require ext_code.size(address(_2252))
                staticcall address(_2252).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                        gas gas_remaining wei
                       args mem[mem[64] + 4], _3116 << 144, Mask(112, 0, _3108)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3222 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _3238 = mem[_3222]
                if address(_2263) == address(_2266):
                    _3265 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_3265 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_3265 + 36] = 0
                    mem[_3265 + 68] = _3238
                    mem[_3265 + 100] = this.address
                    mem[_3265 + 132] = 128
                    mem[_3265 + 164] = mem[_3265]
                    s = 0
                    while s < mem[_3265]:
                        mem[s + _3265 + 196] = mem[s + _3265 + 32]
                        s = s + 32
                        continue 
                    if ceil32(mem[_3265]) <= mem[_3265]:
                        require ext_code.size(address(_2260))
                        call address(_2260).mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len ceil32(mem[_3265]) + _3265 + -mem[64] + 192]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(_2266))
                        staticcall address(_2266).balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3929 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        idx = idx + 2
                        s = mem[_3929] - _2292
                        continue 
                    mem[_3265 + mem[_3265] + 196] = 0
                    require ext_code.size(address(_2260))
                    call address(_2260).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_3265]) + _3265 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(_2266))
                    staticcall address(_2266).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3961 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    idx = idx + 2
                    s = mem[_3961] - _2292
                    continue 
                _3266 = mem[64]
                mem[mem[64]] = 0
                mem[64] = mem[64] + 32
                mem[_3266 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[_3266 + 36] = _3238
                mem[_3266 + 68] = 0
                mem[_3266 + 100] = this.address
                mem[_3266 + 132] = 128
                mem[_3266 + 164] = mem[_3266]
                s = 0
                while s < mem[_3266]:
                    mem[s + _3266 + 196] = mem[s + _3266 + 32]
                    s = s + 32
                    continue 
                if ceil32(mem[_3266]) <= mem[_3266]:
                    require ext_code.size(address(_2260))
                    call address(_2260).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_3266]) + _3266 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(_2266))
                    staticcall address(_2266).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3930 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    idx = idx + 2
                    s = mem[_3930] - _2292
                    continue 
                mem[_3266 + mem[_3266] + 196] = 0
                require ext_code.size(address(_2260))
                call address(_2260).mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len ceil32(mem[_3266]) + _3266 + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(_2266))
                staticcall address(_2266).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3962 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                idx = idx + 2
                s = mem[_3962] - _2292
                continue 
            require mem[96] >= 32
            if not mem[128]:
                revert with 0, 
                            32,
                            42,
                            0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                            mem[mem[64] + 110 len 22]
            require ext_code.size(address(_2260))
            staticcall address(_2260).getReserves() with:
                    gas gas_remaining wei
            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if address(_2263) < address(_2266):
                _3103 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 96
                _3111 = mem[_3103]
                require mem[_3103] == mem[_3103 + 18 len 14]
                _3121 = mem[_3103 + 32]
                require mem[_3103 + 32] == mem[_3103 + 50 len 14]
                require mem[_3103 + 64] == mem[_3103 + 92 len 4]
                mem[mem[64] + 4] = address(_2260)
                require ext_code.size(address(_2263))
                staticcall address(_2263).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(_2260)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if address(_2263) == address(_2263):
                    _3175 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    mem[mem[64] + 4] = mem[_3175] - Mask(112, 0, _3111)
                    mem[mem[64] + 36] = Mask(112, 0, _3111)
                    mem[mem[64] + 68] = Mask(112, 0, _3121)
                    require ext_code.size(address(_2252))
                    staticcall address(_2252).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                            gas gas_remaining wei
                           args mem[mem[64] + 4], _3111 << 144, Mask(112, 0, _3121)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3239 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _3251 = mem[_3239]
                    if address(_2263) == address(_2263):
                        _3291 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_3291 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_3291 + 36] = 0
                        mem[_3291 + 68] = _3251
                        mem[_3291 + 100] = this.address
                        mem[_3291 + 132] = 128
                        mem[_3291 + 164] = mem[_3291]
                        s = 0
                        while s < mem[_3291]:
                            mem[s + _3291 + 196] = mem[s + _3291 + 32]
                            s = s + 32
                            continue 
                        if ceil32(mem[_3291]) > mem[_3291]:
                            mem[_3291 + mem[_3291] + 196] = 0
                        require ext_code.size(address(_2260))
                        call address(_2260).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                             gas gas_remaining wei
                            args 0, _3251, address(this.address), 128, mem[_3291], mem[_3291 + 196 len ceil32(mem[_3291])]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_3291 + 36] = this.address
                        require ext_code.size(address(_2266))
                        staticcall address(_2266).balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args this.address
                        mem[_3291 + 32] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[64] = _3291 + ceil32(return_data.size) + 32
                    else:
                        _3292 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_3292 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_3292 + 36] = _3251
                        mem[_3292 + 68] = 0
                        mem[_3292 + 100] = this.address
                        mem[_3292 + 132] = 128
                        mem[_3292 + 164] = mem[_3292]
                        s = 0
                        while s < mem[_3292]:
                            mem[s + _3292 + 196] = mem[s + _3292 + 32]
                            s = s + 32
                            continue 
                        if ceil32(mem[_3292]) > mem[_3292]:
                            mem[_3292 + mem[_3292] + 196] = 0
                        require ext_code.size(address(_2260))
                        call address(_2260).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                             gas gas_remaining wei
                            args _3251, 0, address(this.address), 128, mem[_3292], mem[_3292 + 196 len ceil32(mem[_3292])]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_3292 + 36] = this.address
                        require ext_code.size(address(_2266))
                        staticcall address(_2266).balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args this.address
                        mem[_3292 + 32] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[64] = _3292 + ceil32(return_data.size) + 32
                    require return_data.size >= 32
                    idx = idx + 2
                    s = ext_call.return_data[0] - _2292
                    continue 
                _3176 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[mem[64] + 4] = mem[_3176] - Mask(112, 0, _3121)
                mem[mem[64] + 36] = Mask(112, 0, _3121)
                mem[mem[64] + 68] = Mask(112, 0, _3111)
                require ext_code.size(address(_2252))
                staticcall address(_2252).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                        gas gas_remaining wei
                       args mem[mem[64] + 4], _3121 << 144, Mask(112, 0, _3111)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3240 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _3252 = mem[_3240]
                if address(_2263) != address(_2263):
                    _3294 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_3294 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_3294 + 36] = _3252
                    mem[_3294 + 68] = 0
                    mem[_3294 + 100] = this.address
                    mem[_3294 + 132] = 128
                    mem[_3294 + 164] = mem[_3294]
                    s = 0
                    while s < mem[_3294]:
                        mem[s + _3294 + 196] = mem[s + _3294 + 32]
                        s = s + 32
                        continue 
                    if ceil32(mem[_3294]) > mem[_3294]:
                        mem[_3294 + mem[_3294] + 196] = 0
                    require ext_code.size(address(_2260))
                    call address(_2260).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                         gas gas_remaining wei
                        args _3252, 0, address(this.address), 128, mem[_3294], mem[_3294 + 196 len ceil32(mem[_3294])]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[_3294 + 36] = this.address
                    require ext_code.size(address(_2266))
                    staticcall address(_2266).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args this.address
                    mem[_3294 + 32] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = _3294 + ceil32(return_data.size) + 32
                    require return_data.size >= 32
                    idx = idx + 2
                    s = ext_call.return_data[0] - _2292
                    continue 
                _3293 = mem[64]
                mem[mem[64]] = 0
                mem[64] = mem[64] + 32
                mem[_3293 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[_3293 + 36] = 0
                mem[_3293 + 68] = _3252
                mem[_3293 + 100] = this.address
                mem[_3293 + 132] = 128
                mem[_3293 + 164] = mem[_3293]
                s = 0
                while s < mem[_3293]:
                    mem[s + _3293 + 196] = mem[s + _3293 + 32]
                    s = s + 32
                    continue 
                if ceil32(mem[_3293]) <= mem[_3293]:
                    require ext_code.size(address(_2260))
                    call address(_2260).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_3293]) + _3293 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(_2266))
                    staticcall address(_2266).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3933 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    idx = idx + 2
                    s = mem[_3933] - _2292
                    continue 
                mem[_3293 + mem[_3293] + 196] = 0
                require ext_code.size(address(_2260))
                call address(_2260).mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len ceil32(mem[_3293]) + _3293 + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(_2266))
                staticcall address(_2266).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3965 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                idx = idx + 2
                s = mem[_3965] - _2292
                continue 
            _3104 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 96
            _3112 = mem[_3104]
            require mem[_3104] == mem[_3104 + 18 len 14]
            _3122 = mem[_3104 + 32]
            require mem[_3104 + 32] == mem[_3104 + 50 len 14]
            require mem[_3104 + 64] == mem[_3104 + 92 len 4]
            mem[mem[64] + 4] = address(_2260)
            require ext_code.size(address(_2263))
            staticcall address(_2263).balanceOf(address rg1) with:
                    gas gas_remaining wei
                   args address(_2260)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if address(_2263) == address(_2266):
                _3177 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[mem[64] + 4] = mem[_3177] - Mask(112, 0, _3112)
                mem[mem[64] + 36] = Mask(112, 0, _3112)
                mem[mem[64] + 68] = Mask(112, 0, _3122)
                require ext_code.size(address(_2252))
                staticcall address(_2252).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                        gas gas_remaining wei
                       args mem[mem[64] + 4], _3112 << 144, Mask(112, 0, _3122)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3241 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _3253 = mem[_3241]
                if address(_2263) == address(_2266):
                    _3295 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_3295 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_3295 + 36] = 0
                    mem[_3295 + 68] = _3253
                    mem[_3295 + 100] = this.address
                    mem[_3295 + 132] = 128
                    mem[_3295 + 164] = mem[_3295]
                    s = 0
                    while s < mem[_3295]:
                        mem[s + _3295 + 196] = mem[s + _3295 + 32]
                        s = s + 32
                        continue 
                    if ceil32(mem[_3295]) <= mem[_3295]:
                        require ext_code.size(address(_2260))
                        call address(_2260).mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len ceil32(mem[_3295]) + _3295 + -mem[64] + 192]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(_2266))
                        staticcall address(_2266).balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3935 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        idx = idx + 2
                        s = mem[_3935] - _2292
                        continue 
                    mem[_3295 + mem[_3295] + 196] = 0
                    require ext_code.size(address(_2260))
                    call address(_2260).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_3295]) + _3295 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(_2266))
                    staticcall address(_2266).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3967 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    idx = idx + 2
                    s = mem[_3967] - _2292
                    continue 
                _3296 = mem[64]
                mem[mem[64]] = 0
                mem[64] = mem[64] + 32
                mem[_3296 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[_3296 + 36] = _3253
                mem[_3296 + 68] = 0
                mem[_3296 + 100] = this.address
                mem[_3296 + 132] = 128
                mem[_3296 + 164] = mem[_3296]
                s = 0
                while s < mem[_3296]:
                    mem[s + _3296 + 196] = mem[s + _3296 + 32]
                    s = s + 32
                    continue 
                if ceil32(mem[_3296]) <= mem[_3296]:
                    require ext_code.size(address(_2260))
                    call address(_2260).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_3296]) + _3296 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(_2266))
                    staticcall address(_2266).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3936 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    idx = idx + 2
                    s = mem[_3936] - _2292
                    continue 
                mem[_3296 + mem[_3296] + 196] = 0
                require ext_code.size(address(_2260))
                call address(_2260).mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len ceil32(mem[_3296]) + _3296 + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(_2266))
                staticcall address(_2266).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3968 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                idx = idx + 2
                s = mem[_3968] - _2292
                continue 
            _3178 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            mem[mem[64] + 4] = mem[_3178] - Mask(112, 0, _3122)
            mem[mem[64] + 36] = Mask(112, 0, _3122)
            mem[mem[64] + 68] = Mask(112, 0, _3112)
            require ext_code.size(address(_2252))
            staticcall address(_2252).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                    gas gas_remaining wei
                   args mem[mem[64] + 4], _3122 << 144, Mask(112, 0, _3112)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3242 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _3254 = mem[_3242]
            if address(_2263) == address(_2266):
                _3297 = mem[64]
                mem[mem[64]] = 0
                mem[64] = mem[64] + 32
                mem[_3297 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[_3297 + 36] = 0
                mem[_3297 + 68] = _3254
                mem[_3297 + 100] = this.address
                mem[_3297 + 132] = 128
                mem[_3297 + 164] = mem[_3297]
                s = 0
                while s < mem[_3297]:
                    mem[s + _3297 + 196] = mem[s + _3297 + 32]
                    s = s + 32
                    continue 
                if ceil32(mem[_3297]) > mem[_3297]:
                    mem[_3297 + mem[_3297] + 196] = 0
                require ext_code.size(address(_2260))
                call address(_2260).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                     gas gas_remaining wei
                    args 0, _3254, address(this.address), 128, mem[_3297], mem[_3297 + 196 len ceil32(mem[_3297])]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[_3297 + 36] = this.address
                require ext_code.size(address(_2266))
                staticcall address(_2266).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args this.address
                mem[_3297 + 32] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[64] = _3297 + ceil32(return_data.size) + 32
                require return_data.size >= 32
                idx = idx + 2
                s = ext_call.return_data[0] - _2292
                continue 
            _3298 = mem[64]
            mem[mem[64]] = 0
            mem[64] = mem[64] + 32
            mem[_3298 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
            mem[_3298 + 36] = _3254
            mem[_3298 + 68] = 0
            mem[_3298 + 100] = this.address
            mem[_3298 + 132] = 128
            mem[_3298 + 164] = mem[_3298]
            s = 0
            while s < mem[_3298]:
                mem[s + _3298 + 196] = mem[s + _3298 + 32]
                s = s + 32
                continue 
            if ceil32(mem[_3298]) <= mem[_3298]:
                require ext_code.size(address(_2260))
                call address(_2260).mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len ceil32(mem[_3298]) + _3298 + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(_2266))
                staticcall address(_2266).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3938 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                idx = idx + 2
                s = mem[_3938] - _2292
                continue 
            mem[_3298 + mem[_3298] + 196] = 0
            require ext_code.size(address(_2260))
            call address(_2260).mem[mem[64] len 4] with:
                 gas gas_remaining wei
                args mem[mem[64] + 4 len ceil32(mem[_3298]) + _3298 + -mem[64] + 192]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[mem[64] + 4] = this.address
            require ext_code.size(address(_2266))
            staticcall address(_2266).balanceOf(address rg1) with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3970 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            idx = idx + 2
            s = mem[_3970] - _2292
            continue 
        _2998 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size) + 1
        mem[_2998] = return_data.size
        mem[_2998 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
        if not ext_call.success:
            if return_data.size:
                revert with ext_call.return_data[0 len return_data.size]
            _3025 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = mem[_2305 + 100]
            _3027 = mem[_2305 + 100]
            idx = 0
            while idx < _3027:
                mem[idx + _3025 + 68] = mem[idx + _2305 + 132]
                idx = idx + 32
                continue 
            if not _3027 % 32:
                revert with memory
                  from mem[64]
                   len _3027 + _3025 + -mem[64] + 68
            mem[floor32(_3027) + _3025 + 68] = mem[floor32(_3027) + _3025 + -(_3027 % 32) + 100 len _3027 % 32]
            revert with memory
              from mem[64]
               len floor32(_3027) + _3025 + -mem[64] + 100
        if not return_data.size:
            require ext_code.size(address(_2260))
            staticcall address(_2260).getReserves() with:
                    gas gas_remaining wei
            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if address(_2263) < address(_2266):
                _3097 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 96
                _3109 = mem[_3097]
                require mem[_3097] == mem[_3097 + 18 len 14]
                _3117 = mem[_3097 + 32]
                require mem[_3097 + 32] == mem[_3097 + 50 len 14]
                require mem[_3097 + 64] == mem[_3097 + 92 len 4]
                mem[mem[64] + 4] = address(_2260)
                require ext_code.size(address(_2263))
                staticcall address(_2263).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(_2260)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if address(_2263) == address(_2263):
                    _3163 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    mem[mem[64] + 4] = mem[_3163] - Mask(112, 0, _3109)
                    mem[mem[64] + 36] = Mask(112, 0, _3109)
                    mem[mem[64] + 68] = Mask(112, 0, _3117)
                    require ext_code.size(address(_2252))
                    staticcall address(_2252).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                            gas gas_remaining wei
                           args mem[mem[64] + 4], _3109 << 144, Mask(112, 0, _3117)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3227 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _3243 = mem[_3227]
                    if address(_2263) != address(_2263):
                        _3268 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_3268 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_3268 + 36] = _3243
                        mem[_3268 + 68] = 0
                        mem[_3268 + 100] = this.address
                        mem[_3268 + 132] = 128
                        mem[_3268 + 164] = mem[_3268]
                        s = 0
                        while s < mem[_3268]:
                            mem[s + _3268 + 196] = mem[s + _3268 + 32]
                            s = s + 32
                            continue 
                        if ceil32(mem[_3268]) > mem[_3268]:
                            mem[_3268 + mem[_3268] + 196] = 0
                        require ext_code.size(address(_2260))
                        call address(_2260).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                             gas gas_remaining wei
                            args _3243, 0, address(this.address), 128, mem[_3268], mem[_3268 + 196 len ceil32(mem[_3268])]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_3268 + 36] = this.address
                        require ext_code.size(address(_2266))
                        staticcall address(_2266).balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args this.address
                        mem[_3268 + 32] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[64] = _3268 + ceil32(return_data.size) + 32
                        require return_data.size >= 32
                        idx = idx + 2
                        s = ext_call.return_data[0] - _2292
                        continue 
                    _3267 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_3267 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_3267 + 36] = 0
                    mem[_3267 + 68] = _3243
                    mem[_3267 + 100] = this.address
                    mem[_3267 + 132] = 128
                    mem[_3267 + 164] = mem[_3267]
                    s = 0
                    while s < mem[_3267]:
                        mem[s + _3267 + 196] = mem[s + _3267 + 32]
                        s = s + 32
                        continue 
                    if ceil32(mem[_3267]) <= mem[_3267]:
                        require ext_code.size(address(_2260))
                        call address(_2260).mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len ceil32(mem[_3267]) + _3267 + -mem[64] + 192]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(_2266))
                        staticcall address(_2266).balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3939 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        idx = idx + 2
                        s = mem[_3939] - _2292
                        continue 
                    mem[_3267 + mem[_3267] + 196] = 0
                    require ext_code.size(address(_2260))
                    call address(_2260).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_3267]) + _3267 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(_2266))
                    staticcall address(_2266).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3971 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    idx = idx + 2
                    s = mem[_3971] - _2292
                    continue 
                _3164 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[mem[64] + 4] = mem[_3164] - Mask(112, 0, _3117)
                mem[mem[64] + 36] = Mask(112, 0, _3117)
                mem[mem[64] + 68] = Mask(112, 0, _3109)
                require ext_code.size(address(_2252))
                staticcall address(_2252).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                        gas gas_remaining wei
                       args mem[mem[64] + 4], _3117 << 144, Mask(112, 0, _3109)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3228 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _3244 = mem[_3228]
                if address(_2263) == address(_2263):
                    _3269 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_3269 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_3269 + 36] = 0
                    mem[_3269 + 68] = _3244
                    mem[_3269 + 100] = this.address
                    mem[_3269 + 132] = 128
                    mem[_3269 + 164] = mem[_3269]
                    s = 0
                    while s < mem[_3269]:
                        mem[s + _3269 + 196] = mem[s + _3269 + 32]
                        s = s + 32
                        continue 
                    if ceil32(mem[_3269]) <= mem[_3269]:
                        require ext_code.size(address(_2260))
                        call address(_2260).mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len ceil32(mem[_3269]) + _3269 + -mem[64] + 192]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(_2266))
                        staticcall address(_2266).balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3941 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        idx = idx + 2
                        s = mem[_3941] - _2292
                        continue 
                    mem[_3269 + mem[_3269] + 196] = 0
                    require ext_code.size(address(_2260))
                    call address(_2260).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_3269]) + _3269 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(_2266))
                    staticcall address(_2266).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3973 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    idx = idx + 2
                    s = mem[_3973] - _2292
                    continue 
                _3270 = mem[64]
                mem[mem[64]] = 0
                mem[64] = mem[64] + 32
                mem[_3270 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[_3270 + 36] = _3244
                mem[_3270 + 68] = 0
                mem[_3270 + 100] = this.address
                mem[_3270 + 132] = 128
                mem[_3270 + 164] = mem[_3270]
                s = 0
                while s < mem[_3270]:
                    mem[s + _3270 + 196] = mem[s + _3270 + 32]
                    s = s + 32
                    continue 
                if ceil32(mem[_3270]) <= mem[_3270]:
                    require ext_code.size(address(_2260))
                    call address(_2260).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_3270]) + _3270 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(_2266))
                    staticcall address(_2266).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3942 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    idx = idx + 2
                    s = mem[_3942] - _2292
                    continue 
                mem[_3270 + mem[_3270] + 196] = 0
                require ext_code.size(address(_2260))
                call address(_2260).mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len ceil32(mem[_3270]) + _3270 + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(_2266))
                staticcall address(_2266).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3974 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                idx = idx + 2
                s = mem[_3974] - _2292
                continue 
            _3098 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 96
            _3110 = mem[_3098]
            require mem[_3098] == mem[_3098 + 18 len 14]
            _3118 = mem[_3098 + 32]
            require mem[_3098 + 32] == mem[_3098 + 50 len 14]
            require mem[_3098 + 64] == mem[_3098 + 92 len 4]
            mem[mem[64] + 4] = address(_2260)
            require ext_code.size(address(_2263))
            staticcall address(_2263).balanceOf(address rg1) with:
                    gas gas_remaining wei
                   args address(_2260)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if address(_2263) == address(_2266):
                _3165 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[mem[64] + 4] = mem[_3165] - Mask(112, 0, _3110)
                mem[mem[64] + 36] = Mask(112, 0, _3110)
                mem[mem[64] + 68] = Mask(112, 0, _3118)
                require ext_code.size(address(_2252))
                staticcall address(_2252).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                        gas gas_remaining wei
                       args mem[mem[64] + 4], _3110 << 144, Mask(112, 0, _3118)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3229 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _3245 = mem[_3229]
                if address(_2263) == address(_2266):
                    _3271 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_3271 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_3271 + 36] = 0
                    mem[_3271 + 68] = _3245
                    mem[_3271 + 100] = this.address
                    mem[_3271 + 132] = 128
                    mem[_3271 + 164] = mem[_3271]
                    s = 0
                    while s < mem[_3271]:
                        mem[s + _3271 + 196] = mem[s + _3271 + 32]
                        s = s + 32
                        continue 
                    if ceil32(mem[_3271]) > mem[_3271]:
                        mem[_3271 + mem[_3271] + 196] = 0
                    require ext_code.size(address(_2260))
                    call address(_2260).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                         gas gas_remaining wei
                        args 0, _3245, address(this.address), 128, mem[_3271], mem[_3271 + 196 len ceil32(mem[_3271])]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[_3271 + 36] = this.address
                    require ext_code.size(address(_2266))
                    staticcall address(_2266).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args this.address
                    mem[_3271 + 32] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = _3271 + ceil32(return_data.size) + 32
                else:
                    _3272 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_3272 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_3272 + 36] = _3245
                    mem[_3272 + 68] = 0
                    mem[_3272 + 100] = this.address
                    mem[_3272 + 132] = 128
                    mem[_3272 + 164] = mem[_3272]
                    s = 0
                    while s < mem[_3272]:
                        mem[s + _3272 + 196] = mem[s + _3272 + 32]
                        s = s + 32
                        continue 
                    if ceil32(mem[_3272]) > mem[_3272]:
                        mem[_3272 + mem[_3272] + 196] = 0
                    require ext_code.size(address(_2260))
                    call address(_2260).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                         gas gas_remaining wei
                        args _3245, 0, address(this.address), 128, mem[_3272], mem[_3272 + 196 len ceil32(mem[_3272])]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[_3272 + 36] = this.address
                    require ext_code.size(address(_2266))
                    staticcall address(_2266).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args this.address
                    mem[_3272 + 32] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = _3272 + ceil32(return_data.size) + 32
                require return_data.size >= 32
                idx = idx + 2
                s = ext_call.return_data[0] - _2292
                continue 
            _3166 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            mem[mem[64] + 4] = mem[_3166] - Mask(112, 0, _3118)
            mem[mem[64] + 36] = Mask(112, 0, _3118)
            mem[mem[64] + 68] = Mask(112, 0, _3110)
            require ext_code.size(address(_2252))
            staticcall address(_2252).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                    gas gas_remaining wei
                   args mem[mem[64] + 4], _3118 << 144, Mask(112, 0, _3110)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3230 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _3246 = mem[_3230]
            if address(_2263) == address(_2266):
                _3273 = mem[64]
                mem[mem[64]] = 0
                mem[64] = mem[64] + 32
                mem[_3273 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[_3273 + 36] = 0
                mem[_3273 + 68] = _3246
                mem[_3273 + 100] = this.address
                mem[_3273 + 132] = 128
                mem[_3273 + 164] = mem[_3273]
                s = 0
                while s < mem[_3273]:
                    mem[s + _3273 + 196] = mem[s + _3273 + 32]
                    s = s + 32
                    continue 
                if ceil32(mem[_3273]) <= mem[_3273]:
                    require ext_code.size(address(_2260))
                    call address(_2260).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_3273]) + _3273 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(_2266))
                    staticcall address(_2266).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3945 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    idx = idx + 2
                    s = mem[_3945] - _2292
                    continue 
                mem[_3273 + mem[_3273] + 196] = 0
                require ext_code.size(address(_2260))
                call address(_2260).mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len ceil32(mem[_3273]) + _3273 + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(_2266))
                staticcall address(_2266).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3977 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                idx = idx + 2
                s = mem[_3977] - _2292
                continue 
            _3274 = mem[64]
            mem[mem[64]] = 0
            mem[64] = mem[64] + 32
            mem[_3274 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
            mem[_3274 + 36] = _3246
            mem[_3274 + 68] = 0
            mem[_3274 + 100] = this.address
            mem[_3274 + 132] = 128
            mem[_3274 + 164] = mem[_3274]
            s = 0
            while s < mem[_3274]:
                mem[s + _3274 + 196] = mem[s + _3274 + 32]
                s = s + 32
                continue 
            if ceil32(mem[_3274]) <= mem[_3274]:
                require ext_code.size(address(_2260))
                call address(_2260).mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len ceil32(mem[_3274]) + _3274 + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(_2266))
                staticcall address(_2266).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3946 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                idx = idx + 2
                s = mem[_3946] - _2292
                continue 
            mem[_3274 + mem[_3274] + 196] = 0
            require ext_code.size(address(_2260))
            call address(_2260).mem[mem[64] len 4] with:
                 gas gas_remaining wei
                args mem[mem[64] + 4 len ceil32(mem[_3274]) + _3274 + -mem[64] + 192]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[mem[64] + 4] = this.address
            require ext_code.size(address(_2266))
            staticcall address(_2266).balanceOf(address rg1) with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3978 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            idx = idx + 2
            s = mem[_3978] - _2292
            continue 
        require return_data.size >= 32
        if not mem[_2998 + 32]:
            revert with 0, 
                        32,
                        42,
                        0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                        mem[mem[64] + 110 len 22]
        require ext_code.size(address(_2260))
        staticcall address(_2260).getReserves() with:
                gas gas_remaining wei
        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        if address(_2263) < address(_2266):
            _3105 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 96
            _3113 = mem[_3105]
            require mem[_3105] == mem[_3105 + 18 len 14]
            _3125 = mem[_3105 + 32]
            require mem[_3105 + 32] == mem[_3105 + 50 len 14]
            require mem[_3105 + 64] == mem[_3105 + 92 len 4]
            mem[mem[64] + 4] = address(_2260)
            require ext_code.size(address(_2263))
            staticcall address(_2263).balanceOf(address rg1) with:
                    gas gas_remaining wei
                   args address(_2260)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if address(_2263) == address(_2263):
                _3183 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[mem[64] + 4] = mem[_3183] - Mask(112, 0, _3113)
                mem[mem[64] + 36] = Mask(112, 0, _3113)
                mem[mem[64] + 68] = Mask(112, 0, _3125)
                require ext_code.size(address(_2252))
                staticcall address(_2252).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                        gas gas_remaining wei
                       args mem[mem[64] + 4], _3113 << 144, Mask(112, 0, _3125)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3247 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _3255 = mem[_3247]
                if address(_2263) == address(_2263):
                    _3299 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_3299 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_3299 + 36] = 0
                    mem[_3299 + 68] = _3255
                    mem[_3299 + 100] = this.address
                    mem[_3299 + 132] = 128
                    mem[_3299 + 164] = mem[_3299]
                    s = 0
                    while s < mem[_3299]:
                        mem[s + _3299 + 196] = mem[s + _3299 + 32]
                        s = s + 32
                        continue 
                    if ceil32(mem[_3299]) > mem[_3299]:
                        mem[_3299 + mem[_3299] + 196] = 0
                    require ext_code.size(address(_2260))
                    call address(_2260).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                         gas gas_remaining wei
                        args 0, _3255, address(this.address), 128, mem[_3299], mem[_3299 + 196 len ceil32(mem[_3299])]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[_3299 + 36] = this.address
                    require ext_code.size(address(_2266))
                    staticcall address(_2266).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args this.address
                    mem[_3299 + 32] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = _3299 + ceil32(return_data.size) + 32
                    require return_data.size >= 32
                    idx = idx + 2
                    s = ext_call.return_data[0] - _2292
                    continue 
                _3300 = mem[64]
                mem[mem[64]] = 0
                mem[64] = mem[64] + 32
                mem[_3300 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[_3300 + 36] = _3255
                mem[_3300 + 68] = 0
                mem[_3300 + 100] = this.address
                mem[_3300 + 132] = 128
                mem[_3300 + 164] = mem[_3300]
                s = 0
                while s < mem[_3300]:
                    mem[s + _3300 + 196] = mem[s + _3300 + 32]
                    s = s + 32
                    continue 
                if ceil32(mem[_3300]) <= mem[_3300]:
                    require ext_code.size(address(_2260))
                    call address(_2260).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_3300]) + _3300 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(_2266))
                    staticcall address(_2266).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3948 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    idx = idx + 2
                    s = mem[_3948] - _2292
                    continue 
                mem[_3300 + mem[_3300] + 196] = 0
                require ext_code.size(address(_2260))
                call address(_2260).mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len ceil32(mem[_3300]) + _3300 + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(_2266))
                staticcall address(_2266).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3980 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                idx = idx + 2
                s = mem[_3980] - _2292
                continue 
            _3184 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            mem[mem[64] + 4] = mem[_3184] - Mask(112, 0, _3125)
            mem[mem[64] + 36] = Mask(112, 0, _3125)
            mem[mem[64] + 68] = Mask(112, 0, _3113)
            require ext_code.size(address(_2252))
            staticcall address(_2252).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                    gas gas_remaining wei
                   args mem[mem[64] + 4], _3125 << 144, Mask(112, 0, _3113)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3248 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _3256 = mem[_3248]
            if address(_2263) == address(_2263):
                _3301 = mem[64]
                mem[mem[64]] = 0
                mem[64] = mem[64] + 32
                mem[_3301 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[_3301 + 36] = 0
                mem[_3301 + 68] = _3256
                mem[_3301 + 100] = this.address
                mem[_3301 + 132] = 128
                mem[_3301 + 164] = mem[_3301]
                s = 0
                while s < mem[_3301]:
                    mem[s + _3301 + 196] = mem[s + _3301 + 32]
                    s = s + 32
                    continue 
                if ceil32(mem[_3301]) <= mem[_3301]:
                    require ext_code.size(address(_2260))
                    call address(_2260).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_3301]) + _3301 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(_2266))
                    staticcall address(_2266).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3949 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    idx = idx + 2
                    s = mem[_3949] - _2292
                    continue 
                mem[_3301 + mem[_3301] + 196] = 0
                require ext_code.size(address(_2260))
                call address(_2260).mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len ceil32(mem[_3301]) + _3301 + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(_2266))
                staticcall address(_2266).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3981 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                idx = idx + 2
                s = mem[_3981] - _2292
                continue 
            _3302 = mem[64]
            mem[mem[64]] = 0
            mem[64] = mem[64] + 32
            mem[_3302 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
            mem[_3302 + 36] = _3256
            mem[_3302 + 68] = 0
            mem[_3302 + 100] = this.address
            mem[_3302 + 132] = 128
            mem[_3302 + 164] = mem[_3302]
            s = 0
            while s < mem[_3302]:
                mem[s + _3302 + 196] = mem[s + _3302 + 32]
                s = s + 32
                continue 
            if ceil32(mem[_3302]) <= mem[_3302]:
                require ext_code.size(address(_2260))
                call address(_2260).mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len ceil32(mem[_3302]) + _3302 + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(_2266))
                staticcall address(_2266).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3950 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                idx = idx + 2
                s = mem[_3950] - _2292
                continue 
            mem[_3302 + mem[_3302] + 196] = 0
            require ext_code.size(address(_2260))
            call address(_2260).mem[mem[64] len 4] with:
                 gas gas_remaining wei
                args mem[mem[64] + 4 len ceil32(mem[_3302]) + _3302 + -mem[64] + 192]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[mem[64] + 4] = this.address
            require ext_code.size(address(_2266))
            staticcall address(_2266).balanceOf(address rg1) with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3982 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            idx = idx + 2
            s = mem[_3982] - _2292
            continue 
        _3106 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 96
        _3114 = mem[_3106]
        require mem[_3106] == mem[_3106 + 18 len 14]
        _3126 = mem[_3106 + 32]
        require mem[_3106 + 32] == mem[_3106 + 50 len 14]
        require mem[_3106 + 64] == mem[_3106 + 92 len 4]
        mem[mem[64] + 4] = address(_2260)
        require ext_code.size(address(_2263))
        staticcall address(_2263).balanceOf(address rg1) with:
                gas gas_remaining wei
               args address(_2260)
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        if address(_2263) != address(_2266):
            _3186 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            mem[mem[64] + 4] = mem[_3186] - Mask(112, 0, _3126)
            mem[mem[64] + 36] = Mask(112, 0, _3126)
            mem[mem[64] + 68] = Mask(112, 0, _3114)
            require ext_code.size(address(_2252))
            staticcall address(_2252).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                    gas gas_remaining wei
                   args mem[mem[64] + 4], _3126 << 144, Mask(112, 0, _3114)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3250 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _3258 = mem[_3250]
            if address(_2263) == address(_2266):
                _3305 = mem[64]
                mem[mem[64]] = 0
                mem[64] = mem[64] + 32
                mem[_3305 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[_3305 + 36] = 0
                mem[_3305 + 68] = _3258
                mem[_3305 + 100] = this.address
                mem[_3305 + 132] = 128
                mem[_3305 + 164] = mem[_3305]
                s = 0
                while s < mem[_3305]:
                    mem[s + _3305 + 196] = mem[s + _3305 + 32]
                    s = s + 32
                    continue 
                if ceil32(mem[_3305]) > mem[_3305]:
                    mem[_3305 + mem[_3305] + 196] = 0
                require ext_code.size(address(_2260))
                call address(_2260).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                     gas gas_remaining wei
                    args 0, _3258, address(this.address), 128, mem[_3305], mem[_3305 + 196 len ceil32(mem[_3305])]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[_3305 + 36] = this.address
                require ext_code.size(address(_2266))
                staticcall address(_2266).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args this.address
                mem[_3305 + 32] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[64] = _3305 + ceil32(return_data.size) + 32
            else:
                _3306 = mem[64]
                mem[mem[64]] = 0
                mem[64] = mem[64] + 32
                mem[_3306 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[_3306 + 36] = _3258
                mem[_3306 + 68] = 0
                mem[_3306 + 100] = this.address
                mem[_3306 + 132] = 128
                mem[_3306 + 164] = mem[_3306]
                s = 0
                while s < mem[_3306]:
                    mem[s + _3306 + 196] = mem[s + _3306 + 32]
                    s = s + 32
                    continue 
                if ceil32(mem[_3306]) > mem[_3306]:
                    mem[_3306 + mem[_3306] + 196] = 0
                require ext_code.size(address(_2260))
                call address(_2260).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                     gas gas_remaining wei
                    args _3258, 0, address(this.address), 128, mem[_3306], mem[_3306 + 196 len ceil32(mem[_3306])]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[_3306 + 36] = this.address
                require ext_code.size(address(_2266))
                staticcall address(_2266).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args this.address
                mem[_3306 + 32] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[64] = _3306 + ceil32(return_data.size) + 32
            require return_data.size >= 32
            idx = idx + 2
            s = ext_call.return_data[0] - _2292
            continue 
        _3185 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        mem[mem[64] + 4] = mem[_3185] - Mask(112, 0, _3114)
        mem[mem[64] + 36] = Mask(112, 0, _3114)
        mem[mem[64] + 68] = Mask(112, 0, _3126)
        require ext_code.size(address(_2252))
        staticcall address(_2252).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                gas gas_remaining wei
               args mem[mem[64] + 4], _3114 << 144, Mask(112, 0, _3126)
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _3249 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _3257 = mem[_3249]
        if address(_2263) == address(_2266):
            _3303 = mem[64]
            mem[mem[64]] = 0
            mem[64] = mem[64] + 32
            mem[_3303 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
            mem[_3303 + 36] = 0
            mem[_3303 + 68] = _3257
            mem[_3303 + 100] = this.address
            mem[_3303 + 132] = 128
            mem[_3303 + 164] = mem[_3303]
            s = 0
            while s < mem[_3303]:
                mem[s + _3303 + 196] = mem[s + _3303 + 32]
                s = s + 32
                continue 
            if ceil32(mem[_3303]) <= mem[_3303]:
                require ext_code.size(address(_2260))
                call address(_2260).mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len ceil32(mem[_3303]) + _3303 + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(_2266))
                staticcall address(_2266).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3951 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                idx = idx + 2
                s = mem[_3951] - _2292
                continue 
            mem[_3303 + mem[_3303] + 196] = 0
            require ext_code.size(address(_2260))
            call address(_2260).mem[mem[64] len 4] with:
                 gas gas_remaining wei
                args mem[mem[64] + 4 len ceil32(mem[_3303]) + _3303 + -mem[64] + 192]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[mem[64] + 4] = this.address
            require ext_code.size(address(_2266))
            staticcall address(_2266).balanceOf(address rg1) with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3983 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            idx = idx + 2
            s = mem[_3983] - _2292
            continue 
        _3304 = mem[64]
        mem[mem[64]] = 0
        mem[64] = mem[64] + 32
        mem[_3304 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[_3304 + 36] = _3257
        mem[_3304 + 68] = 0
        mem[_3304 + 100] = this.address
        mem[_3304 + 132] = 128
        mem[_3304 + 164] = mem[_3304]
        s = 0
        while s < mem[_3304]:
            mem[s + _3304 + 196] = mem[s + _3304 + 32]
            s = s + 32
            continue 
        if ceil32(mem[_3304]) <= mem[_3304]:
            require ext_code.size(address(_2260))
            call address(_2260).mem[mem[64] len 4] with:
                 gas gas_remaining wei
                args mem[mem[64] + 4 len ceil32(mem[_3304]) + _3304 + -mem[64] + 192]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[mem[64] + 4] = this.address
            require ext_code.size(address(_2266))
            staticcall address(_2266).balanceOf(address rg1) with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3952 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            idx = idx + 2
            s = mem[_3952] - _2292
            continue 
        mem[_3304 + mem[_3304] + 196] = 0
        require ext_code.size(address(_2260))
        call address(_2260).mem[mem[64] len 4] with:
             gas gas_remaining wei
            args mem[mem[64] + 4 len ceil32(mem[_3304]) + _3304 + -mem[64] + 192]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[mem[64] + 4] = this.address
        require ext_code.size(address(_2266))
        staticcall address(_2266).balanceOf(address rg1) with:
                gas gas_remaining wei
               args address(this.address)
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _3984 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        idx = idx + 2
        s = mem[_3984] - _2292
        continue 
    if not arg2:
        _2249 = mem[64]
        mem[mem[64] + 36] = msg.sender
        mem[mem[64] + 68] = cd[(arg4 + 36)]
        _2250 = mem[64]
        mem[mem[64]] = 68
        mem[mem[64] + 32 len 4] = transfer(address rg1, uint256 rg2)
        mem[64] = mem[64] + 164
        mem[_2249 + 100] = 32
        mem[_2249 + 132] = 'SafeERC20: low-level call failed'
        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(address(ext_call.return_data[0])):
            revert with 0, 'Address: call to non-contract'
        if not ext_code.hash(address(ext_call.return_data[0])):
            revert with 0, 'Address: call to non-contract'
        _2271 = mem[_2250]
        mem[_2249 + 164 len floor32(mem[_2250])] = mem[_2250 + 32 len floor32(mem[_2250])]
        mem[_2249 + floor32(mem[_2250]) + -(mem[_2250] % 32) + 196 len mem[_2250] % 32] = mem[_2250 + floor32(mem[_2250]) + -(mem[_2250] % 32) + 64 len mem[_2250] % 32]
        call address(ext_call.return_data[0]) with:
             gas gas_remaining wei
            args mem[_2249 + 168 len _2271 - 4]
        if not return_data.size:
            if not ext_call.success:
                if mem[96]:
                    revert with memory
                      from 128
                       len mem[96]
                revert with 0, 'SafeERC20: low-level call failed'
            if mem[96]:
                require mem[96] >= 32
                if not mem[128]:
                    revert with 0, 
                                32,
                                42,
                                0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                mem[_2249 + 274 len 22]
        else:
            mem[_2249 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not ext_call.success:
                if return_data.size:
                    revert with ext_call.return_data[0 len return_data.size]
                revert with 0, 'SafeERC20: low-level call failed'
            if return_data.size:
                require return_data.size >= 32
                if not mem[_2249 + 196]:
                    revert with 0, 
                                32,
                                42,
                                0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                mem[_2249 + ceil32(return_data.size) + 275 len 22]
    else:
        _2255 = mem[64]
        mem[mem[64] + 36] = msg.sender
        mem[mem[64] + 68] = cd[(arg4 + 36)]
        _2256 = mem[64]
        mem[mem[64]] = 68
        mem[mem[64] + 32 len 4] = transfer(address rg1, uint256 rg2)
        mem[64] = mem[64] + 164
        mem[_2255 + 100] = 32
        mem[_2255 + 132] = 'SafeERC20: low-level call failed'
        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(address(ext_call.return_data[0])):
            revert with 0, 'Address: call to non-contract'
        if not ext_code.hash(address(ext_call.return_data[0])):
            revert with 0, 'Address: call to non-contract'
        _2278 = mem[_2256]
        mem[_2255 + 164 len floor32(mem[_2256])] = mem[_2256 + 32 len floor32(mem[_2256])]
        mem[_2255 + floor32(mem[_2256]) + -(mem[_2256] % 32) + 196 len mem[_2256] % 32] = mem[_2256 + floor32(mem[_2256]) + -(mem[_2256] % 32) + 64 len mem[_2256] % 32]
        call address(ext_call.return_data[0]) with:
             gas gas_remaining wei
            args mem[_2255 + 168 len _2278 - 4]
        if not return_data.size:
            if not ext_call.success:
                if mem[96]:
                    revert with memory
                      from 128
                       len mem[96]
                revert with 0, 'SafeERC20: low-level call failed'
            if mem[96]:
                require mem[96] >= 32
                if not mem[128]:
                    revert with 0, 
                                32,
                                42,
                                0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                mem[_2255 + 274 len 22]
        else:
            mem[_2255 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not ext_call.success:
                if return_data.size:
                    revert with ext_call.return_data[0 len return_data.size]
                revert with 0, 'SafeERC20: low-level call failed'
            if return_data.size:
                require return_data.size >= 32
                if not mem[_2255 + 196]:
                    revert with 0, 
                                32,
                                42,
                                0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                mem[_2255 + ceil32(return_data.size) + 275 len 22]
}

function ThugswapCall(address arg1, uint256 arg2, uint256 arg3, bytes arg4) {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg4 <= test266151307()
    require arg4 + 35 < calldata.size
    require arg4.length <= test266151307()
    require arg4 + arg4.length + 36 <= calldata.size
    require ext_code.size(msg.sender)
    staticcall msg.sender.token0() with:
            gas gas_remaining wei
    mem[96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    require ext_code.size(msg.sender)
    staticcall msg.sender.token1() with:
            gas gas_remaining wei
    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    require arg4.length >= 96
    require cd[(arg4 + 100)] <= test266151307()
    require arg4 + arg4.length + 36 > arg4 + cd[(arg4 + 100)] + 67
    require cd[(arg4 + cd[(arg4 + 100)] + 36)] <= test266151307()
    require (32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 128 >= 96 and (2 * ceil32(return_data.size)) + (32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 128 <= test266151307()
    mem[64] = (2 * ceil32(return_data.size)) + (32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 128
    mem[(2 * ceil32(return_data.size)) + 96] = cd[(arg4 + cd[(arg4 + 100)] + 36)]
    require arg4.length + 36 >= cd[(arg4 + 100)] + (64 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 68
    s = arg4 + cd[(arg4 + 100)] + 68
    t = (2 * ceil32(return_data.size)) + 128
    idx = 0
    while idx < cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        require s + 31 < arg4 + arg4.length + 36
        _1499 = mem[64]
        require mem[64] + 64 >= mem[64] and mem[64] + 64 <= test266151307()
        mem[64] = mem[64] + 64
        require s + 64 <= arg4 + arg4.length + 36
        u = 0
        v = s
        w = _1499
        while u < 2:
            require cd[v] == address(cd[v])
            mem[w] = cd[v]
            u = u + 1
            v = v + 32
            w = w + 32
            continue 
        mem[t] = _1499
        s = s + 64
        t = t + 32
        idx = idx + 1
        continue 
    require 0 < mem[(2 * ceil32(return_data.size)) + 96]
    require msg.sender == mem[mem[(2 * ceil32(return_data.size)) + 128] + 44 len 20]
    require 3 < mem[(2 * ceil32(return_data.size)) + 96]
    _1503 = mem[mem[(2 * ceil32(return_data.size)) + 224]]
    mem[mem[64] + 4] = this.address
    require ext_code.size(address(_1503))
    staticcall address(_1503).balanceOf(address rg1) with:
            gas gas_remaining wei
           args address(this.address)
    mem[mem[64]] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _1506 = mem[64]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    _2246 = mem[(2 * ceil32(return_data.size)) + 96]
    idx = 2
    s = mem[_1506] - cd[(arg4 + 68)]
    while idx < _2246:
        require idx < mem[(2 * ceil32(return_data.size)) + 96]
        _2252 = mem[mem[(32 * idx) + (2 * ceil32(return_data.size)) + 128]]
        require idx < mem[(2 * ceil32(return_data.size)) + 96]
        _2260 = mem[mem[(32 * idx) + (2 * ceil32(return_data.size)) + 128] + 32]
        require idx + 1 < mem[(2 * ceil32(return_data.size)) + 96]
        _2263 = mem[mem[(32 * idx + 1) + (2 * ceil32(return_data.size)) + 128]]
        require idx + 1 < mem[(2 * ceil32(return_data.size)) + 96]
        _2266 = mem[mem[(32 * idx + 1) + (2 * ceil32(return_data.size)) + 128] + 32]
        mem[mem[64] + 4] = this.address
        require ext_code.size(address(_2266))
        staticcall address(_2266).balanceOf(address rg1) with:
                gas gas_remaining wei
               args address(this.address)
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _2285 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _2292 = mem[_2285]
        _2305 = mem[64]
        mem[mem[64] + 36] = address(_2260)
        mem[mem[64] + 68] = s
        _2306 = mem[64]
        mem[mem[64]] = 68
        mem[64] = mem[64] + 100
        mem[_2306 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_2306 + 36 len 28]
        mem[64] = _2305 + 164
        mem[_2305 + 100] = 32
        mem[_2305 + 132] = 'SafeERC20: low-level call failed'
        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(address(_2263)):
            revert with 0, 'Address: call to non-contract'
        if not ext_code.hash(address(_2263)):
            revert with 0, 'Address: call to non-contract'
        _2356 = mem[_2306]
        t = _2306 + 32
        u = mem[64]
        s = mem[_2306]
        while s >= 32:
            mem[u] = mem[t]
            t = t + 32
            u = u + 32
            s = s - 32
            continue 
        mem[mem[64] + floor32(mem[_2306])] = mem[_2306 + floor32(mem[_2306]) + -(mem[_2306] % 32) + 64 len mem[_2306] % 32] or Mask(8 * -(mem[_2306] % 32) + 32, -(8 * -(mem[_2306] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_2306])])
        call address(_2263).mem[mem[64] len 4] with:
             gas gas_remaining wei
            args mem[mem[64] + 4 len _2356 + _2305 + -mem[64] + 160]
        if not return_data.size:
            if not ext_call.success:
                if mem[96]:
                    revert with memory
                      from 128
                       len mem[96]
                _3021 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = mem[_2305 + 100]
                _3023 = mem[_2305 + 100]
                idx = 0
                while idx < _3023:
                    mem[idx + _3021 + 68] = mem[idx + _2305 + 132]
                    idx = idx + 32
                    continue 
                if not _3023 % 32:
                    revert with memory
                      from mem[64]
                       len _3023 + _3021 + -mem[64] + 68
                mem[floor32(_3023) + _3021 + 68] = mem[floor32(_3023) + _3021 + -(_3023 % 32) + 100 len _3023 % 32]
                revert with memory
                  from mem[64]
                   len floor32(_3023) + _3021 + -mem[64] + 100
            if not mem[96]:
                require ext_code.size(address(_2260))
                staticcall address(_2260).getReserves() with:
                        gas gas_remaining wei
                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if address(_2263) < address(_2266):
                    _3091 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 96
                    _3107 = mem[_3091]
                    require mem[_3091] == mem[_3091 + 18 len 14]
                    _3115 = mem[_3091 + 32]
                    require mem[_3091 + 32] == mem[_3091 + 50 len 14]
                    require mem[_3091 + 64] == mem[_3091 + 92 len 4]
                    mem[mem[64] + 4] = address(_2260)
                    require ext_code.size(address(_2263))
                    staticcall address(_2263).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(_2260)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if address(_2263) != address(_2263):
                        _3156 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        mem[mem[64] + 4] = mem[_3156] - Mask(112, 0, _3115)
                        mem[mem[64] + 36] = Mask(112, 0, _3115)
                        mem[mem[64] + 68] = Mask(112, 0, _3107)
                        require ext_code.size(address(_2252))
                        staticcall address(_2252).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                                gas gas_remaining wei
                               args mem[mem[64] + 4], _3115 << 144, Mask(112, 0, _3107)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3220 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _3236 = mem[_3220]
                        if address(_2263) == address(_2263):
                            _3261 = mem[64]
                            mem[mem[64]] = 0
                            mem[64] = mem[64] + 32
                            mem[_3261 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                            mem[_3261 + 36] = 0
                            mem[_3261 + 68] = _3236
                            mem[_3261 + 100] = this.address
                            mem[_3261 + 132] = 128
                            mem[_3261 + 164] = mem[_3261]
                            s = 0
                            while s < mem[_3261]:
                                mem[s + _3261 + 196] = mem[s + _3261 + 32]
                                s = s + 32
                                continue 
                            if ceil32(mem[_3261]) > mem[_3261]:
                                mem[_3261 + mem[_3261] + 196] = 0
                            require ext_code.size(address(_2260))
                            call address(_2260).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                                 gas gas_remaining wei
                                args 0, _3236, address(this.address), 128, mem[_3261], mem[_3261 + 196 len ceil32(mem[_3261])]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_3261 + 36] = this.address
                            require ext_code.size(address(_2266))
                            staticcall address(_2266).balanceOf(address rg1) with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[_3261 + 32] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = _3261 + ceil32(return_data.size) + 32
                        else:
                            _3262 = mem[64]
                            mem[mem[64]] = 0
                            mem[64] = mem[64] + 32
                            mem[_3262 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                            mem[_3262 + 36] = _3236
                            mem[_3262 + 68] = 0
                            mem[_3262 + 100] = this.address
                            mem[_3262 + 132] = 128
                            mem[_3262 + 164] = mem[_3262]
                            s = 0
                            while s < mem[_3262]:
                                mem[s + _3262 + 196] = mem[s + _3262 + 32]
                                s = s + 32
                                continue 
                            if ceil32(mem[_3262]) > mem[_3262]:
                                mem[_3262 + mem[_3262] + 196] = 0
                            require ext_code.size(address(_2260))
                            call address(_2260).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                                 gas gas_remaining wei
                                args _3236, 0, address(this.address), 128, mem[_3262], mem[_3262 + 196 len ceil32(mem[_3262])]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_3262 + 36] = this.address
                            require ext_code.size(address(_2266))
                            staticcall address(_2266).balanceOf(address rg1) with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[_3262 + 32] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = _3262 + ceil32(return_data.size) + 32
                        require return_data.size >= 32
                        idx = idx + 2
                        s = ext_call.return_data[0] - _2292
                        continue 
                    _3155 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    mem[mem[64] + 4] = mem[_3155] - Mask(112, 0, _3107)
                    mem[mem[64] + 36] = Mask(112, 0, _3107)
                    mem[mem[64] + 68] = Mask(112, 0, _3115)
                    require ext_code.size(address(_2252))
                    staticcall address(_2252).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                            gas gas_remaining wei
                           args mem[mem[64] + 4], _3107 << 144, Mask(112, 0, _3115)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3219 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _3235 = mem[_3219]
                    if address(_2263) != address(_2263):
                        _3260 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_3260 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_3260 + 36] = _3235
                        mem[_3260 + 68] = 0
                        mem[_3260 + 100] = this.address
                        mem[_3260 + 132] = 128
                        mem[_3260 + 164] = mem[_3260]
                        s = 0
                        while s < mem[_3260]:
                            mem[s + _3260 + 196] = mem[s + _3260 + 32]
                            s = s + 32
                            continue 
                        if ceil32(mem[_3260]) > mem[_3260]:
                            mem[_3260 + mem[_3260] + 196] = 0
                        require ext_code.size(address(_2260))
                        call address(_2260).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                             gas gas_remaining wei
                            args _3235, 0, address(this.address), 128, mem[_3260], mem[_3260 + 196 len ceil32(mem[_3260])]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_3260 + 36] = this.address
                        require ext_code.size(address(_2266))
                        staticcall address(_2266).balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args this.address
                        mem[_3260 + 32] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[64] = _3260 + ceil32(return_data.size) + 32
                        require return_data.size >= 32
                        idx = idx + 2
                        s = ext_call.return_data[0] - _2292
                        continue 
                    _3259 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_3259 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_3259 + 36] = 0
                    mem[_3259 + 68] = _3235
                    mem[_3259 + 100] = this.address
                    mem[_3259 + 132] = 128
                    mem[_3259 + 164] = mem[_3259]
                    s = 0
                    while s < mem[_3259]:
                        mem[s + _3259 + 196] = mem[s + _3259 + 32]
                        s = s + 32
                        continue 
                    if ceil32(mem[_3259]) <= mem[_3259]:
                        require ext_code.size(address(_2260))
                        call address(_2260).mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len ceil32(mem[_3259]) + _3259 + -mem[64] + 192]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(_2266))
                        staticcall address(_2266).balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3923 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        idx = idx + 2
                        s = mem[_3923] - _2292
                        continue 
                    mem[_3259 + mem[_3259] + 196] = 0
                    require ext_code.size(address(_2260))
                    call address(_2260).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_3259]) + _3259 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(_2266))
                    staticcall address(_2266).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3955 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    idx = idx + 2
                    s = mem[_3955] - _2292
                    continue 
                _3092 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 96
                _3108 = mem[_3092]
                require mem[_3092] == mem[_3092 + 18 len 14]
                _3116 = mem[_3092 + 32]
                require mem[_3092 + 32] == mem[_3092 + 50 len 14]
                require mem[_3092 + 64] == mem[_3092 + 92 len 4]
                mem[mem[64] + 4] = address(_2260)
                require ext_code.size(address(_2263))
                staticcall address(_2263).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(_2260)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if address(_2263) == address(_2266):
                    _3157 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    mem[mem[64] + 4] = mem[_3157] - Mask(112, 0, _3108)
                    mem[mem[64] + 36] = Mask(112, 0, _3108)
                    mem[mem[64] + 68] = Mask(112, 0, _3116)
                    require ext_code.size(address(_2252))
                    staticcall address(_2252).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                            gas gas_remaining wei
                           args mem[mem[64] + 4], _3108 << 144, Mask(112, 0, _3116)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3221 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _3237 = mem[_3221]
                    if address(_2263) == address(_2266):
                        _3263 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_3263 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_3263 + 36] = 0
                        mem[_3263 + 68] = _3237
                        mem[_3263 + 100] = this.address
                        mem[_3263 + 132] = 128
                        mem[_3263 + 164] = mem[_3263]
                        s = 0
                        while s < mem[_3263]:
                            mem[s + _3263 + 196] = mem[s + _3263 + 32]
                            s = s + 32
                            continue 
                        if ceil32(mem[_3263]) <= mem[_3263]:
                            require ext_code.size(address(_2260))
                            call address(_2260).mem[mem[64] len 4] with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len ceil32(mem[_3263]) + _3263 + -mem[64] + 192]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(address(_2266))
                            staticcall address(_2266).balanceOf(address rg1) with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3927 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            idx = idx + 2
                            s = mem[_3927] - _2292
                            continue 
                        mem[_3263 + mem[_3263] + 196] = 0
                        require ext_code.size(address(_2260))
                        call address(_2260).mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len ceil32(mem[_3263]) + _3263 + -mem[64] + 192]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(_2266))
                        staticcall address(_2266).balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3959 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        idx = idx + 2
                        s = mem[_3959] - _2292
                        continue 
                    _3264 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_3264 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_3264 + 36] = _3237
                    mem[_3264 + 68] = 0
                    mem[_3264 + 100] = this.address
                    mem[_3264 + 132] = 128
                    mem[_3264 + 164] = mem[_3264]
                    s = 0
                    while s < mem[_3264]:
                        mem[s + _3264 + 196] = mem[s + _3264 + 32]
                        s = s + 32
                        continue 
                    if ceil32(mem[_3264]) <= mem[_3264]:
                        require ext_code.size(address(_2260))
                        call address(_2260).mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len ceil32(mem[_3264]) + _3264 + -mem[64] + 192]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(_2266))
                        staticcall address(_2266).balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3928 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        idx = idx + 2
                        s = mem[_3928] - _2292
                        continue 
                    mem[_3264 + mem[_3264] + 196] = 0
                    require ext_code.size(address(_2260))
                    call address(_2260).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_3264]) + _3264 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(_2266))
                    staticcall address(_2266).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3960 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    idx = idx + 2
                    s = mem[_3960] - _2292
                    continue 
                _3158 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[mem[64] + 4] = mem[_3158] - Mask(112, 0, _3116)
                mem[mem[64] + 36] = Mask(112, 0, _3116)
                mem[mem[64] + 68] = Mask(112, 0, _3108)
                require ext_code.size(address(_2252))
                staticcall address(_2252).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                        gas gas_remaining wei
                       args mem[mem[64] + 4], _3116 << 144, Mask(112, 0, _3108)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3222 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _3238 = mem[_3222]
                if address(_2263) == address(_2266):
                    _3265 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_3265 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_3265 + 36] = 0
                    mem[_3265 + 68] = _3238
                    mem[_3265 + 100] = this.address
                    mem[_3265 + 132] = 128
                    mem[_3265 + 164] = mem[_3265]
                    s = 0
                    while s < mem[_3265]:
                        mem[s + _3265 + 196] = mem[s + _3265 + 32]
                        s = s + 32
                        continue 
                    if ceil32(mem[_3265]) <= mem[_3265]:
                        require ext_code.size(address(_2260))
                        call address(_2260).mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len ceil32(mem[_3265]) + _3265 + -mem[64] + 192]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(_2266))
                        staticcall address(_2266).balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3929 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        idx = idx + 2
                        s = mem[_3929] - _2292
                        continue 
                    mem[_3265 + mem[_3265] + 196] = 0
                    require ext_code.size(address(_2260))
                    call address(_2260).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_3265]) + _3265 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(_2266))
                    staticcall address(_2266).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3961 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    idx = idx + 2
                    s = mem[_3961] - _2292
                    continue 
                _3266 = mem[64]
                mem[mem[64]] = 0
                mem[64] = mem[64] + 32
                mem[_3266 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[_3266 + 36] = _3238
                mem[_3266 + 68] = 0
                mem[_3266 + 100] = this.address
                mem[_3266 + 132] = 128
                mem[_3266 + 164] = mem[_3266]
                s = 0
                while s < mem[_3266]:
                    mem[s + _3266 + 196] = mem[s + _3266 + 32]
                    s = s + 32
                    continue 
                if ceil32(mem[_3266]) <= mem[_3266]:
                    require ext_code.size(address(_2260))
                    call address(_2260).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_3266]) + _3266 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(_2266))
                    staticcall address(_2266).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3930 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    idx = idx + 2
                    s = mem[_3930] - _2292
                    continue 
                mem[_3266 + mem[_3266] + 196] = 0
                require ext_code.size(address(_2260))
                call address(_2260).mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len ceil32(mem[_3266]) + _3266 + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(_2266))
                staticcall address(_2266).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3962 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                idx = idx + 2
                s = mem[_3962] - _2292
                continue 
            require mem[96] >= 32
            if not mem[128]:
                revert with 0, 
                            32,
                            42,
                            0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                            mem[mem[64] + 110 len 22]
            require ext_code.size(address(_2260))
            staticcall address(_2260).getReserves() with:
                    gas gas_remaining wei
            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if address(_2263) < address(_2266):
                _3103 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 96
                _3111 = mem[_3103]
                require mem[_3103] == mem[_3103 + 18 len 14]
                _3121 = mem[_3103 + 32]
                require mem[_3103 + 32] == mem[_3103 + 50 len 14]
                require mem[_3103 + 64] == mem[_3103 + 92 len 4]
                mem[mem[64] + 4] = address(_2260)
                require ext_code.size(address(_2263))
                staticcall address(_2263).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(_2260)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if address(_2263) == address(_2263):
                    _3175 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    mem[mem[64] + 4] = mem[_3175] - Mask(112, 0, _3111)
                    mem[mem[64] + 36] = Mask(112, 0, _3111)
                    mem[mem[64] + 68] = Mask(112, 0, _3121)
                    require ext_code.size(address(_2252))
                    staticcall address(_2252).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                            gas gas_remaining wei
                           args mem[mem[64] + 4], _3111 << 144, Mask(112, 0, _3121)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3239 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _3251 = mem[_3239]
                    if address(_2263) == address(_2263):
                        _3291 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_3291 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_3291 + 36] = 0
                        mem[_3291 + 68] = _3251
                        mem[_3291 + 100] = this.address
                        mem[_3291 + 132] = 128
                        mem[_3291 + 164] = mem[_3291]
                        s = 0
                        while s < mem[_3291]:
                            mem[s + _3291 + 196] = mem[s + _3291 + 32]
                            s = s + 32
                            continue 
                        if ceil32(mem[_3291]) > mem[_3291]:
                            mem[_3291 + mem[_3291] + 196] = 0
                        require ext_code.size(address(_2260))
                        call address(_2260).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                             gas gas_remaining wei
                            args 0, _3251, address(this.address), 128, mem[_3291], mem[_3291 + 196 len ceil32(mem[_3291])]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_3291 + 36] = this.address
                        require ext_code.size(address(_2266))
                        staticcall address(_2266).balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args this.address
                        mem[_3291 + 32] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[64] = _3291 + ceil32(return_data.size) + 32
                    else:
                        _3292 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_3292 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_3292 + 36] = _3251
                        mem[_3292 + 68] = 0
                        mem[_3292 + 100] = this.address
                        mem[_3292 + 132] = 128
                        mem[_3292 + 164] = mem[_3292]
                        s = 0
                        while s < mem[_3292]:
                            mem[s + _3292 + 196] = mem[s + _3292 + 32]
                            s = s + 32
                            continue 
                        if ceil32(mem[_3292]) > mem[_3292]:
                            mem[_3292 + mem[_3292] + 196] = 0
                        require ext_code.size(address(_2260))
                        call address(_2260).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                             gas gas_remaining wei
                            args _3251, 0, address(this.address), 128, mem[_3292], mem[_3292 + 196 len ceil32(mem[_3292])]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_3292 + 36] = this.address
                        require ext_code.size(address(_2266))
                        staticcall address(_2266).balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args this.address
                        mem[_3292 + 32] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[64] = _3292 + ceil32(return_data.size) + 32
                    require return_data.size >= 32
                    idx = idx + 2
                    s = ext_call.return_data[0] - _2292
                    continue 
                _3176 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[mem[64] + 4] = mem[_3176] - Mask(112, 0, _3121)
                mem[mem[64] + 36] = Mask(112, 0, _3121)
                mem[mem[64] + 68] = Mask(112, 0, _3111)
                require ext_code.size(address(_2252))
                staticcall address(_2252).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                        gas gas_remaining wei
                       args mem[mem[64] + 4], _3121 << 144, Mask(112, 0, _3111)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3240 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _3252 = mem[_3240]
                if address(_2263) != address(_2263):
                    _3294 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_3294 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_3294 + 36] = _3252
                    mem[_3294 + 68] = 0
                    mem[_3294 + 100] = this.address
                    mem[_3294 + 132] = 128
                    mem[_3294 + 164] = mem[_3294]
                    s = 0
                    while s < mem[_3294]:
                        mem[s + _3294 + 196] = mem[s + _3294 + 32]
                        s = s + 32
                        continue 
                    if ceil32(mem[_3294]) > mem[_3294]:
                        mem[_3294 + mem[_3294] + 196] = 0
                    require ext_code.size(address(_2260))
                    call address(_2260).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                         gas gas_remaining wei
                        args _3252, 0, address(this.address), 128, mem[_3294], mem[_3294 + 196 len ceil32(mem[_3294])]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[_3294 + 36] = this.address
                    require ext_code.size(address(_2266))
                    staticcall address(_2266).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args this.address
                    mem[_3294 + 32] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = _3294 + ceil32(return_data.size) + 32
                    require return_data.size >= 32
                    idx = idx + 2
                    s = ext_call.return_data[0] - _2292
                    continue 
                _3293 = mem[64]
                mem[mem[64]] = 0
                mem[64] = mem[64] + 32
                mem[_3293 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[_3293 + 36] = 0
                mem[_3293 + 68] = _3252
                mem[_3293 + 100] = this.address
                mem[_3293 + 132] = 128
                mem[_3293 + 164] = mem[_3293]
                s = 0
                while s < mem[_3293]:
                    mem[s + _3293 + 196] = mem[s + _3293 + 32]
                    s = s + 32
                    continue 
                if ceil32(mem[_3293]) <= mem[_3293]:
                    require ext_code.size(address(_2260))
                    call address(_2260).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_3293]) + _3293 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(_2266))
                    staticcall address(_2266).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3933 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    idx = idx + 2
                    s = mem[_3933] - _2292
                    continue 
                mem[_3293 + mem[_3293] + 196] = 0
                require ext_code.size(address(_2260))
                call address(_2260).mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len ceil32(mem[_3293]) + _3293 + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(_2266))
                staticcall address(_2266).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3965 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                idx = idx + 2
                s = mem[_3965] - _2292
                continue 
            _3104 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 96
            _3112 = mem[_3104]
            require mem[_3104] == mem[_3104 + 18 len 14]
            _3122 = mem[_3104 + 32]
            require mem[_3104 + 32] == mem[_3104 + 50 len 14]
            require mem[_3104 + 64] == mem[_3104 + 92 len 4]
            mem[mem[64] + 4] = address(_2260)
            require ext_code.size(address(_2263))
            staticcall address(_2263).balanceOf(address rg1) with:
                    gas gas_remaining wei
                   args address(_2260)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if address(_2263) == address(_2266):
                _3177 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[mem[64] + 4] = mem[_3177] - Mask(112, 0, _3112)
                mem[mem[64] + 36] = Mask(112, 0, _3112)
                mem[mem[64] + 68] = Mask(112, 0, _3122)
                require ext_code.size(address(_2252))
                staticcall address(_2252).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                        gas gas_remaining wei
                       args mem[mem[64] + 4], _3112 << 144, Mask(112, 0, _3122)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3241 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _3253 = mem[_3241]
                if address(_2263) == address(_2266):
                    _3295 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_3295 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_3295 + 36] = 0
                    mem[_3295 + 68] = _3253
                    mem[_3295 + 100] = this.address
                    mem[_3295 + 132] = 128
                    mem[_3295 + 164] = mem[_3295]
                    s = 0
                    while s < mem[_3295]:
                        mem[s + _3295 + 196] = mem[s + _3295 + 32]
                        s = s + 32
                        continue 
                    if ceil32(mem[_3295]) <= mem[_3295]:
                        require ext_code.size(address(_2260))
                        call address(_2260).mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len ceil32(mem[_3295]) + _3295 + -mem[64] + 192]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(_2266))
                        staticcall address(_2266).balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3935 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        idx = idx + 2
                        s = mem[_3935] - _2292
                        continue 
                    mem[_3295 + mem[_3295] + 196] = 0
                    require ext_code.size(address(_2260))
                    call address(_2260).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_3295]) + _3295 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(_2266))
                    staticcall address(_2266).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3967 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    idx = idx + 2
                    s = mem[_3967] - _2292
                    continue 
                _3296 = mem[64]
                mem[mem[64]] = 0
                mem[64] = mem[64] + 32
                mem[_3296 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[_3296 + 36] = _3253
                mem[_3296 + 68] = 0
                mem[_3296 + 100] = this.address
                mem[_3296 + 132] = 128
                mem[_3296 + 164] = mem[_3296]
                s = 0
                while s < mem[_3296]:
                    mem[s + _3296 + 196] = mem[s + _3296 + 32]
                    s = s + 32
                    continue 
                if ceil32(mem[_3296]) <= mem[_3296]:
                    require ext_code.size(address(_2260))
                    call address(_2260).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_3296]) + _3296 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(_2266))
                    staticcall address(_2266).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3936 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    idx = idx + 2
                    s = mem[_3936] - _2292
                    continue 
                mem[_3296 + mem[_3296] + 196] = 0
                require ext_code.size(address(_2260))
                call address(_2260).mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len ceil32(mem[_3296]) + _3296 + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(_2266))
                staticcall address(_2266).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3968 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                idx = idx + 2
                s = mem[_3968] - _2292
                continue 
            _3178 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            mem[mem[64] + 4] = mem[_3178] - Mask(112, 0, _3122)
            mem[mem[64] + 36] = Mask(112, 0, _3122)
            mem[mem[64] + 68] = Mask(112, 0, _3112)
            require ext_code.size(address(_2252))
            staticcall address(_2252).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                    gas gas_remaining wei
                   args mem[mem[64] + 4], _3122 << 144, Mask(112, 0, _3112)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3242 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _3254 = mem[_3242]
            if address(_2263) == address(_2266):
                _3297 = mem[64]
                mem[mem[64]] = 0
                mem[64] = mem[64] + 32
                mem[_3297 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[_3297 + 36] = 0
                mem[_3297 + 68] = _3254
                mem[_3297 + 100] = this.address
                mem[_3297 + 132] = 128
                mem[_3297 + 164] = mem[_3297]
                s = 0
                while s < mem[_3297]:
                    mem[s + _3297 + 196] = mem[s + _3297 + 32]
                    s = s + 32
                    continue 
                if ceil32(mem[_3297]) > mem[_3297]:
                    mem[_3297 + mem[_3297] + 196] = 0
                require ext_code.size(address(_2260))
                call address(_2260).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                     gas gas_remaining wei
                    args 0, _3254, address(this.address), 128, mem[_3297], mem[_3297 + 196 len ceil32(mem[_3297])]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[_3297 + 36] = this.address
                require ext_code.size(address(_2266))
                staticcall address(_2266).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args this.address
                mem[_3297 + 32] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[64] = _3297 + ceil32(return_data.size) + 32
                require return_data.size >= 32
                idx = idx + 2
                s = ext_call.return_data[0] - _2292
                continue 
            _3298 = mem[64]
            mem[mem[64]] = 0
            mem[64] = mem[64] + 32
            mem[_3298 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
            mem[_3298 + 36] = _3254
            mem[_3298 + 68] = 0
            mem[_3298 + 100] = this.address
            mem[_3298 + 132] = 128
            mem[_3298 + 164] = mem[_3298]
            s = 0
            while s < mem[_3298]:
                mem[s + _3298 + 196] = mem[s + _3298 + 32]
                s = s + 32
                continue 
            if ceil32(mem[_3298]) <= mem[_3298]:
                require ext_code.size(address(_2260))
                call address(_2260).mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len ceil32(mem[_3298]) + _3298 + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(_2266))
                staticcall address(_2266).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3938 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                idx = idx + 2
                s = mem[_3938] - _2292
                continue 
            mem[_3298 + mem[_3298] + 196] = 0
            require ext_code.size(address(_2260))
            call address(_2260).mem[mem[64] len 4] with:
                 gas gas_remaining wei
                args mem[mem[64] + 4 len ceil32(mem[_3298]) + _3298 + -mem[64] + 192]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[mem[64] + 4] = this.address
            require ext_code.size(address(_2266))
            staticcall address(_2266).balanceOf(address rg1) with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3970 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            idx = idx + 2
            s = mem[_3970] - _2292
            continue 
        _2998 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size) + 1
        mem[_2998] = return_data.size
        mem[_2998 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
        if not ext_call.success:
            if return_data.size:
                revert with ext_call.return_data[0 len return_data.size]
            _3025 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = mem[_2305 + 100]
            _3027 = mem[_2305 + 100]
            idx = 0
            while idx < _3027:
                mem[idx + _3025 + 68] = mem[idx + _2305 + 132]
                idx = idx + 32
                continue 
            if not _3027 % 32:
                revert with memory
                  from mem[64]
                   len _3027 + _3025 + -mem[64] + 68
            mem[floor32(_3027) + _3025 + 68] = mem[floor32(_3027) + _3025 + -(_3027 % 32) + 100 len _3027 % 32]
            revert with memory
              from mem[64]
               len floor32(_3027) + _3025 + -mem[64] + 100
        if not return_data.size:
            require ext_code.size(address(_2260))
            staticcall address(_2260).getReserves() with:
                    gas gas_remaining wei
            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if address(_2263) < address(_2266):
                _3097 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 96
                _3109 = mem[_3097]
                require mem[_3097] == mem[_3097 + 18 len 14]
                _3117 = mem[_3097 + 32]
                require mem[_3097 + 32] == mem[_3097 + 50 len 14]
                require mem[_3097 + 64] == mem[_3097 + 92 len 4]
                mem[mem[64] + 4] = address(_2260)
                require ext_code.size(address(_2263))
                staticcall address(_2263).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(_2260)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if address(_2263) == address(_2263):
                    _3163 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    mem[mem[64] + 4] = mem[_3163] - Mask(112, 0, _3109)
                    mem[mem[64] + 36] = Mask(112, 0, _3109)
                    mem[mem[64] + 68] = Mask(112, 0, _3117)
                    require ext_code.size(address(_2252))
                    staticcall address(_2252).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                            gas gas_remaining wei
                           args mem[mem[64] + 4], _3109 << 144, Mask(112, 0, _3117)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3227 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _3243 = mem[_3227]
                    if address(_2263) != address(_2263):
                        _3268 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_3268 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_3268 + 36] = _3243
                        mem[_3268 + 68] = 0
                        mem[_3268 + 100] = this.address
                        mem[_3268 + 132] = 128
                        mem[_3268 + 164] = mem[_3268]
                        s = 0
                        while s < mem[_3268]:
                            mem[s + _3268 + 196] = mem[s + _3268 + 32]
                            s = s + 32
                            continue 
                        if ceil32(mem[_3268]) > mem[_3268]:
                            mem[_3268 + mem[_3268] + 196] = 0
                        require ext_code.size(address(_2260))
                        call address(_2260).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                             gas gas_remaining wei
                            args _3243, 0, address(this.address), 128, mem[_3268], mem[_3268 + 196 len ceil32(mem[_3268])]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_3268 + 36] = this.address
                        require ext_code.size(address(_2266))
                        staticcall address(_2266).balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args this.address
                        mem[_3268 + 32] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[64] = _3268 + ceil32(return_data.size) + 32
                        require return_data.size >= 32
                        idx = idx + 2
                        s = ext_call.return_data[0] - _2292
                        continue 
                    _3267 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_3267 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_3267 + 36] = 0
                    mem[_3267 + 68] = _3243
                    mem[_3267 + 100] = this.address
                    mem[_3267 + 132] = 128
                    mem[_3267 + 164] = mem[_3267]
                    s = 0
                    while s < mem[_3267]:
                        mem[s + _3267 + 196] = mem[s + _3267 + 32]
                        s = s + 32
                        continue 
                    if ceil32(mem[_3267]) <= mem[_3267]:
                        require ext_code.size(address(_2260))
                        call address(_2260).mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len ceil32(mem[_3267]) + _3267 + -mem[64] + 192]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(_2266))
                        staticcall address(_2266).balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3939 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        idx = idx + 2
                        s = mem[_3939] - _2292
                        continue 
                    mem[_3267 + mem[_3267] + 196] = 0
                    require ext_code.size(address(_2260))
                    call address(_2260).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_3267]) + _3267 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(_2266))
                    staticcall address(_2266).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3971 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    idx = idx + 2
                    s = mem[_3971] - _2292
                    continue 
                _3164 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[mem[64] + 4] = mem[_3164] - Mask(112, 0, _3117)
                mem[mem[64] + 36] = Mask(112, 0, _3117)
                mem[mem[64] + 68] = Mask(112, 0, _3109)
                require ext_code.size(address(_2252))
                staticcall address(_2252).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                        gas gas_remaining wei
                       args mem[mem[64] + 4], _3117 << 144, Mask(112, 0, _3109)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3228 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _3244 = mem[_3228]
                if address(_2263) == address(_2263):
                    _3269 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_3269 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_3269 + 36] = 0
                    mem[_3269 + 68] = _3244
                    mem[_3269 + 100] = this.address
                    mem[_3269 + 132] = 128
                    mem[_3269 + 164] = mem[_3269]
                    s = 0
                    while s < mem[_3269]:
                        mem[s + _3269 + 196] = mem[s + _3269 + 32]
                        s = s + 32
                        continue 
                    if ceil32(mem[_3269]) <= mem[_3269]:
                        require ext_code.size(address(_2260))
                        call address(_2260).mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len ceil32(mem[_3269]) + _3269 + -mem[64] + 192]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(_2266))
                        staticcall address(_2266).balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3941 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        idx = idx + 2
                        s = mem[_3941] - _2292
                        continue 
                    mem[_3269 + mem[_3269] + 196] = 0
                    require ext_code.size(address(_2260))
                    call address(_2260).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_3269]) + _3269 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(_2266))
                    staticcall address(_2266).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3973 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    idx = idx + 2
                    s = mem[_3973] - _2292
                    continue 
                _3270 = mem[64]
                mem[mem[64]] = 0
                mem[64] = mem[64] + 32
                mem[_3270 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[_3270 + 36] = _3244
                mem[_3270 + 68] = 0
                mem[_3270 + 100] = this.address
                mem[_3270 + 132] = 128
                mem[_3270 + 164] = mem[_3270]
                s = 0
                while s < mem[_3270]:
                    mem[s + _3270 + 196] = mem[s + _3270 + 32]
                    s = s + 32
                    continue 
                if ceil32(mem[_3270]) <= mem[_3270]:
                    require ext_code.size(address(_2260))
                    call address(_2260).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_3270]) + _3270 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(_2266))
                    staticcall address(_2266).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3942 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    idx = idx + 2
                    s = mem[_3942] - _2292
                    continue 
                mem[_3270 + mem[_3270] + 196] = 0
                require ext_code.size(address(_2260))
                call address(_2260).mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len ceil32(mem[_3270]) + _3270 + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(_2266))
                staticcall address(_2266).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3974 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                idx = idx + 2
                s = mem[_3974] - _2292
                continue 
            _3098 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 96
            _3110 = mem[_3098]
            require mem[_3098] == mem[_3098 + 18 len 14]
            _3118 = mem[_3098 + 32]
            require mem[_3098 + 32] == mem[_3098 + 50 len 14]
            require mem[_3098 + 64] == mem[_3098 + 92 len 4]
            mem[mem[64] + 4] = address(_2260)
            require ext_code.size(address(_2263))
            staticcall address(_2263).balanceOf(address rg1) with:
                    gas gas_remaining wei
                   args address(_2260)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if address(_2263) == address(_2266):
                _3165 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[mem[64] + 4] = mem[_3165] - Mask(112, 0, _3110)
                mem[mem[64] + 36] = Mask(112, 0, _3110)
                mem[mem[64] + 68] = Mask(112, 0, _3118)
                require ext_code.size(address(_2252))
                staticcall address(_2252).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                        gas gas_remaining wei
                       args mem[mem[64] + 4], _3110 << 144, Mask(112, 0, _3118)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3229 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _3245 = mem[_3229]
                if address(_2263) == address(_2266):
                    _3271 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_3271 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_3271 + 36] = 0
                    mem[_3271 + 68] = _3245
                    mem[_3271 + 100] = this.address
                    mem[_3271 + 132] = 128
                    mem[_3271 + 164] = mem[_3271]
                    s = 0
                    while s < mem[_3271]:
                        mem[s + _3271 + 196] = mem[s + _3271 + 32]
                        s = s + 32
                        continue 
                    if ceil32(mem[_3271]) > mem[_3271]:
                        mem[_3271 + mem[_3271] + 196] = 0
                    require ext_code.size(address(_2260))
                    call address(_2260).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                         gas gas_remaining wei
                        args 0, _3245, address(this.address), 128, mem[_3271], mem[_3271 + 196 len ceil32(mem[_3271])]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[_3271 + 36] = this.address
                    require ext_code.size(address(_2266))
                    staticcall address(_2266).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args this.address
                    mem[_3271 + 32] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = _3271 + ceil32(return_data.size) + 32
                else:
                    _3272 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_3272 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_3272 + 36] = _3245
                    mem[_3272 + 68] = 0
                    mem[_3272 + 100] = this.address
                    mem[_3272 + 132] = 128
                    mem[_3272 + 164] = mem[_3272]
                    s = 0
                    while s < mem[_3272]:
                        mem[s + _3272 + 196] = mem[s + _3272 + 32]
                        s = s + 32
                        continue 
                    if ceil32(mem[_3272]) > mem[_3272]:
                        mem[_3272 + mem[_3272] + 196] = 0
                    require ext_code.size(address(_2260))
                    call address(_2260).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                         gas gas_remaining wei
                        args _3245, 0, address(this.address), 128, mem[_3272], mem[_3272 + 196 len ceil32(mem[_3272])]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[_3272 + 36] = this.address
                    require ext_code.size(address(_2266))
                    staticcall address(_2266).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args this.address
                    mem[_3272 + 32] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = _3272 + ceil32(return_data.size) + 32
                require return_data.size >= 32
                idx = idx + 2
                s = ext_call.return_data[0] - _2292
                continue 
            _3166 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            mem[mem[64] + 4] = mem[_3166] - Mask(112, 0, _3118)
            mem[mem[64] + 36] = Mask(112, 0, _3118)
            mem[mem[64] + 68] = Mask(112, 0, _3110)
            require ext_code.size(address(_2252))
            staticcall address(_2252).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                    gas gas_remaining wei
                   args mem[mem[64] + 4], _3118 << 144, Mask(112, 0, _3110)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3230 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _3246 = mem[_3230]
            if address(_2263) == address(_2266):
                _3273 = mem[64]
                mem[mem[64]] = 0
                mem[64] = mem[64] + 32
                mem[_3273 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[_3273 + 36] = 0
                mem[_3273 + 68] = _3246
                mem[_3273 + 100] = this.address
                mem[_3273 + 132] = 128
                mem[_3273 + 164] = mem[_3273]
                s = 0
                while s < mem[_3273]:
                    mem[s + _3273 + 196] = mem[s + _3273 + 32]
                    s = s + 32
                    continue 
                if ceil32(mem[_3273]) <= mem[_3273]:
                    require ext_code.size(address(_2260))
                    call address(_2260).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_3273]) + _3273 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(_2266))
                    staticcall address(_2266).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3945 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    idx = idx + 2
                    s = mem[_3945] - _2292
                    continue 
                mem[_3273 + mem[_3273] + 196] = 0
                require ext_code.size(address(_2260))
                call address(_2260).mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len ceil32(mem[_3273]) + _3273 + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(_2266))
                staticcall address(_2266).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3977 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                idx = idx + 2
                s = mem[_3977] - _2292
                continue 
            _3274 = mem[64]
            mem[mem[64]] = 0
            mem[64] = mem[64] + 32
            mem[_3274 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
            mem[_3274 + 36] = _3246
            mem[_3274 + 68] = 0
            mem[_3274 + 100] = this.address
            mem[_3274 + 132] = 128
            mem[_3274 + 164] = mem[_3274]
            s = 0
            while s < mem[_3274]:
                mem[s + _3274 + 196] = mem[s + _3274 + 32]
                s = s + 32
                continue 
            if ceil32(mem[_3274]) <= mem[_3274]:
                require ext_code.size(address(_2260))
                call address(_2260).mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len ceil32(mem[_3274]) + _3274 + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(_2266))
                staticcall address(_2266).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3946 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                idx = idx + 2
                s = mem[_3946] - _2292
                continue 
            mem[_3274 + mem[_3274] + 196] = 0
            require ext_code.size(address(_2260))
            call address(_2260).mem[mem[64] len 4] with:
                 gas gas_remaining wei
                args mem[mem[64] + 4 len ceil32(mem[_3274]) + _3274 + -mem[64] + 192]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[mem[64] + 4] = this.address
            require ext_code.size(address(_2266))
            staticcall address(_2266).balanceOf(address rg1) with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3978 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            idx = idx + 2
            s = mem[_3978] - _2292
            continue 
        require return_data.size >= 32
        if not mem[_2998 + 32]:
            revert with 0, 
                        32,
                        42,
                        0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                        mem[mem[64] + 110 len 22]
        require ext_code.size(address(_2260))
        staticcall address(_2260).getReserves() with:
                gas gas_remaining wei
        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        if address(_2263) < address(_2266):
            _3105 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 96
            _3113 = mem[_3105]
            require mem[_3105] == mem[_3105 + 18 len 14]
            _3125 = mem[_3105 + 32]
            require mem[_3105 + 32] == mem[_3105 + 50 len 14]
            require mem[_3105 + 64] == mem[_3105 + 92 len 4]
            mem[mem[64] + 4] = address(_2260)
            require ext_code.size(address(_2263))
            staticcall address(_2263).balanceOf(address rg1) with:
                    gas gas_remaining wei
                   args address(_2260)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if address(_2263) == address(_2263):
                _3183 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[mem[64] + 4] = mem[_3183] - Mask(112, 0, _3113)
                mem[mem[64] + 36] = Mask(112, 0, _3113)
                mem[mem[64] + 68] = Mask(112, 0, _3125)
                require ext_code.size(address(_2252))
                staticcall address(_2252).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                        gas gas_remaining wei
                       args mem[mem[64] + 4], _3113 << 144, Mask(112, 0, _3125)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3247 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _3255 = mem[_3247]
                if address(_2263) == address(_2263):
                    _3299 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_3299 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_3299 + 36] = 0
                    mem[_3299 + 68] = _3255
                    mem[_3299 + 100] = this.address
                    mem[_3299 + 132] = 128
                    mem[_3299 + 164] = mem[_3299]
                    s = 0
                    while s < mem[_3299]:
                        mem[s + _3299 + 196] = mem[s + _3299 + 32]
                        s = s + 32
                        continue 
                    if ceil32(mem[_3299]) > mem[_3299]:
                        mem[_3299 + mem[_3299] + 196] = 0
                    require ext_code.size(address(_2260))
                    call address(_2260).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                         gas gas_remaining wei
                        args 0, _3255, address(this.address), 128, mem[_3299], mem[_3299 + 196 len ceil32(mem[_3299])]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[_3299 + 36] = this.address
                    require ext_code.size(address(_2266))
                    staticcall address(_2266).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args this.address
                    mem[_3299 + 32] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = _3299 + ceil32(return_data.size) + 32
                    require return_data.size >= 32
                    idx = idx + 2
                    s = ext_call.return_data[0] - _2292
                    continue 
                _3300 = mem[64]
                mem[mem[64]] = 0
                mem[64] = mem[64] + 32
                mem[_3300 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[_3300 + 36] = _3255
                mem[_3300 + 68] = 0
                mem[_3300 + 100] = this.address
                mem[_3300 + 132] = 128
                mem[_3300 + 164] = mem[_3300]
                s = 0
                while s < mem[_3300]:
                    mem[s + _3300 + 196] = mem[s + _3300 + 32]
                    s = s + 32
                    continue 
                if ceil32(mem[_3300]) <= mem[_3300]:
                    require ext_code.size(address(_2260))
                    call address(_2260).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_3300]) + _3300 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(_2266))
                    staticcall address(_2266).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3948 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    idx = idx + 2
                    s = mem[_3948] - _2292
                    continue 
                mem[_3300 + mem[_3300] + 196] = 0
                require ext_code.size(address(_2260))
                call address(_2260).mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len ceil32(mem[_3300]) + _3300 + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(_2266))
                staticcall address(_2266).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3980 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                idx = idx + 2
                s = mem[_3980] - _2292
                continue 
            _3184 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            mem[mem[64] + 4] = mem[_3184] - Mask(112, 0, _3125)
            mem[mem[64] + 36] = Mask(112, 0, _3125)
            mem[mem[64] + 68] = Mask(112, 0, _3113)
            require ext_code.size(address(_2252))
            staticcall address(_2252).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                    gas gas_remaining wei
                   args mem[mem[64] + 4], _3125 << 144, Mask(112, 0, _3113)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3248 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _3256 = mem[_3248]
            if address(_2263) == address(_2263):
                _3301 = mem[64]
                mem[mem[64]] = 0
                mem[64] = mem[64] + 32
                mem[_3301 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[_3301 + 36] = 0
                mem[_3301 + 68] = _3256
                mem[_3301 + 100] = this.address
                mem[_3301 + 132] = 128
                mem[_3301 + 164] = mem[_3301]
                s = 0
                while s < mem[_3301]:
                    mem[s + _3301 + 196] = mem[s + _3301 + 32]
                    s = s + 32
                    continue 
                if ceil32(mem[_3301]) <= mem[_3301]:
                    require ext_code.size(address(_2260))
                    call address(_2260).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_3301]) + _3301 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(_2266))
                    staticcall address(_2266).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3949 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    idx = idx + 2
                    s = mem[_3949] - _2292
                    continue 
                mem[_3301 + mem[_3301] + 196] = 0
                require ext_code.size(address(_2260))
                call address(_2260).mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len ceil32(mem[_3301]) + _3301 + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(_2266))
                staticcall address(_2266).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3981 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                idx = idx + 2
                s = mem[_3981] - _2292
                continue 
            _3302 = mem[64]
            mem[mem[64]] = 0
            mem[64] = mem[64] + 32
            mem[_3302 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
            mem[_3302 + 36] = _3256
            mem[_3302 + 68] = 0
            mem[_3302 + 100] = this.address
            mem[_3302 + 132] = 128
            mem[_3302 + 164] = mem[_3302]
            s = 0
            while s < mem[_3302]:
                mem[s + _3302 + 196] = mem[s + _3302 + 32]
                s = s + 32
                continue 
            if ceil32(mem[_3302]) <= mem[_3302]:
                require ext_code.size(address(_2260))
                call address(_2260).mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len ceil32(mem[_3302]) + _3302 + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(_2266))
                staticcall address(_2266).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3950 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                idx = idx + 2
                s = mem[_3950] - _2292
                continue 
            mem[_3302 + mem[_3302] + 196] = 0
            require ext_code.size(address(_2260))
            call address(_2260).mem[mem[64] len 4] with:
                 gas gas_remaining wei
                args mem[mem[64] + 4 len ceil32(mem[_3302]) + _3302 + -mem[64] + 192]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[mem[64] + 4] = this.address
            require ext_code.size(address(_2266))
            staticcall address(_2266).balanceOf(address rg1) with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3982 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            idx = idx + 2
            s = mem[_3982] - _2292
            continue 
        _3106 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 96
        _3114 = mem[_3106]
        require mem[_3106] == mem[_3106 + 18 len 14]
        _3126 = mem[_3106 + 32]
        require mem[_3106 + 32] == mem[_3106 + 50 len 14]
        require mem[_3106 + 64] == mem[_3106 + 92 len 4]
        mem[mem[64] + 4] = address(_2260)
        require ext_code.size(address(_2263))
        staticcall address(_2263).balanceOf(address rg1) with:
                gas gas_remaining wei
               args address(_2260)
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        if address(_2263) != address(_2266):
            _3186 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            mem[mem[64] + 4] = mem[_3186] - Mask(112, 0, _3126)
            mem[mem[64] + 36] = Mask(112, 0, _3126)
            mem[mem[64] + 68] = Mask(112, 0, _3114)
            require ext_code.size(address(_2252))
            staticcall address(_2252).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                    gas gas_remaining wei
                   args mem[mem[64] + 4], _3126 << 144, Mask(112, 0, _3114)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3250 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _3258 = mem[_3250]
            if address(_2263) == address(_2266):
                _3305 = mem[64]
                mem[mem[64]] = 0
                mem[64] = mem[64] + 32
                mem[_3305 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[_3305 + 36] = 0
                mem[_3305 + 68] = _3258
                mem[_3305 + 100] = this.address
                mem[_3305 + 132] = 128
                mem[_3305 + 164] = mem[_3305]
                s = 0
                while s < mem[_3305]:
                    mem[s + _3305 + 196] = mem[s + _3305 + 32]
                    s = s + 32
                    continue 
                if ceil32(mem[_3305]) > mem[_3305]:
                    mem[_3305 + mem[_3305] + 196] = 0
                require ext_code.size(address(_2260))
                call address(_2260).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                     gas gas_remaining wei
                    args 0, _3258, address(this.address), 128, mem[_3305], mem[_3305 + 196 len ceil32(mem[_3305])]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[_3305 + 36] = this.address
                require ext_code.size(address(_2266))
                staticcall address(_2266).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args this.address
                mem[_3305 + 32] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[64] = _3305 + ceil32(return_data.size) + 32
            else:
                _3306 = mem[64]
                mem[mem[64]] = 0
                mem[64] = mem[64] + 32
                mem[_3306 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[_3306 + 36] = _3258
                mem[_3306 + 68] = 0
                mem[_3306 + 100] = this.address
                mem[_3306 + 132] = 128
                mem[_3306 + 164] = mem[_3306]
                s = 0
                while s < mem[_3306]:
                    mem[s + _3306 + 196] = mem[s + _3306 + 32]
                    s = s + 32
                    continue 
                if ceil32(mem[_3306]) > mem[_3306]:
                    mem[_3306 + mem[_3306] + 196] = 0
                require ext_code.size(address(_2260))
                call address(_2260).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                     gas gas_remaining wei
                    args _3258, 0, address(this.address), 128, mem[_3306], mem[_3306 + 196 len ceil32(mem[_3306])]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[_3306 + 36] = this.address
                require ext_code.size(address(_2266))
                staticcall address(_2266).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args this.address
                mem[_3306 + 32] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[64] = _3306 + ceil32(return_data.size) + 32
            require return_data.size >= 32
            idx = idx + 2
            s = ext_call.return_data[0] - _2292
            continue 
        _3185 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        mem[mem[64] + 4] = mem[_3185] - Mask(112, 0, _3114)
        mem[mem[64] + 36] = Mask(112, 0, _3114)
        mem[mem[64] + 68] = Mask(112, 0, _3126)
        require ext_code.size(address(_2252))
        staticcall address(_2252).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                gas gas_remaining wei
               args mem[mem[64] + 4], _3114 << 144, Mask(112, 0, _3126)
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _3249 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _3257 = mem[_3249]
        if address(_2263) == address(_2266):
            _3303 = mem[64]
            mem[mem[64]] = 0
            mem[64] = mem[64] + 32
            mem[_3303 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
            mem[_3303 + 36] = 0
            mem[_3303 + 68] = _3257
            mem[_3303 + 100] = this.address
            mem[_3303 + 132] = 128
            mem[_3303 + 164] = mem[_3303]
            s = 0
            while s < mem[_3303]:
                mem[s + _3303 + 196] = mem[s + _3303 + 32]
                s = s + 32
                continue 
            if ceil32(mem[_3303]) <= mem[_3303]:
                require ext_code.size(address(_2260))
                call address(_2260).mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len ceil32(mem[_3303]) + _3303 + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(_2266))
                staticcall address(_2266).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3951 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                idx = idx + 2
                s = mem[_3951] - _2292
                continue 
            mem[_3303 + mem[_3303] + 196] = 0
            require ext_code.size(address(_2260))
            call address(_2260).mem[mem[64] len 4] with:
                 gas gas_remaining wei
                args mem[mem[64] + 4 len ceil32(mem[_3303]) + _3303 + -mem[64] + 192]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[mem[64] + 4] = this.address
            require ext_code.size(address(_2266))
            staticcall address(_2266).balanceOf(address rg1) with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3983 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            idx = idx + 2
            s = mem[_3983] - _2292
            continue 
        _3304 = mem[64]
        mem[mem[64]] = 0
        mem[64] = mem[64] + 32
        mem[_3304 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[_3304 + 36] = _3257
        mem[_3304 + 68] = 0
        mem[_3304 + 100] = this.address
        mem[_3304 + 132] = 128
        mem[_3304 + 164] = mem[_3304]
        s = 0
        while s < mem[_3304]:
            mem[s + _3304 + 196] = mem[s + _3304 + 32]
            s = s + 32
            continue 
        if ceil32(mem[_3304]) <= mem[_3304]:
            require ext_code.size(address(_2260))
            call address(_2260).mem[mem[64] len 4] with:
                 gas gas_remaining wei
                args mem[mem[64] + 4 len ceil32(mem[_3304]) + _3304 + -mem[64] + 192]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[mem[64] + 4] = this.address
            require ext_code.size(address(_2266))
            staticcall address(_2266).balanceOf(address rg1) with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3952 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            idx = idx + 2
            s = mem[_3952] - _2292
            continue 
        mem[_3304 + mem[_3304] + 196] = 0
        require ext_code.size(address(_2260))
        call address(_2260).mem[mem[64] len 4] with:
             gas gas_remaining wei
            args mem[mem[64] + 4 len ceil32(mem[_3304]) + _3304 + -mem[64] + 192]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[mem[64] + 4] = this.address
        require ext_code.size(address(_2266))
        staticcall address(_2266).balanceOf(address rg1) with:
                gas gas_remaining wei
               args address(this.address)
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _3984 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        idx = idx + 2
        s = mem[_3984] - _2292
        continue 
    if not arg2:
        _2249 = mem[64]
        mem[mem[64] + 36] = msg.sender
        mem[mem[64] + 68] = cd[(arg4 + 36)]
        _2250 = mem[64]
        mem[mem[64]] = 68
        mem[mem[64] + 32 len 4] = transfer(address rg1, uint256 rg2)
        mem[64] = mem[64] + 164
        mem[_2249 + 100] = 32
        mem[_2249 + 132] = 'SafeERC20: low-level call failed'
        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(address(ext_call.return_data[0])):
            revert with 0, 'Address: call to non-contract'
        if not ext_code.hash(address(ext_call.return_data[0])):
            revert with 0, 'Address: call to non-contract'
        _2271 = mem[_2250]
        mem[_2249 + 164 len floor32(mem[_2250])] = mem[_2250 + 32 len floor32(mem[_2250])]
        mem[_2249 + floor32(mem[_2250]) + -(mem[_2250] % 32) + 196 len mem[_2250] % 32] = mem[_2250 + floor32(mem[_2250]) + -(mem[_2250] % 32) + 64 len mem[_2250] % 32]
        call address(ext_call.return_data[0]) with:
             gas gas_remaining wei
            args mem[_2249 + 168 len _2271 - 4]
        if not return_data.size:
            if not ext_call.success:
                if mem[96]:
                    revert with memory
                      from 128
                       len mem[96]
                revert with 0, 'SafeERC20: low-level call failed'
            if mem[96]:
                require mem[96] >= 32
                if not mem[128]:
                    revert with 0, 
                                32,
                                42,
                                0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                mem[_2249 + 274 len 22]
        else:
            mem[_2249 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not ext_call.success:
                if return_data.size:
                    revert with ext_call.return_data[0 len return_data.size]
                revert with 0, 'SafeERC20: low-level call failed'
            if return_data.size:
                require return_data.size >= 32
                if not mem[_2249 + 196]:
                    revert with 0, 
                                32,
                                42,
                                0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                mem[_2249 + ceil32(return_data.size) + 275 len 22]
    else:
        _2255 = mem[64]
        mem[mem[64] + 36] = msg.sender
        mem[mem[64] + 68] = cd[(arg4 + 36)]
        _2256 = mem[64]
        mem[mem[64]] = 68
        mem[mem[64] + 32 len 4] = transfer(address rg1, uint256 rg2)
        mem[64] = mem[64] + 164
        mem[_2255 + 100] = 32
        mem[_2255 + 132] = 'SafeERC20: low-level call failed'
        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(address(ext_call.return_data[0])):
            revert with 0, 'Address: call to non-contract'
        if not ext_code.hash(address(ext_call.return_data[0])):
            revert with 0, 'Address: call to non-contract'
        _2278 = mem[_2256]
        mem[_2255 + 164 len floor32(mem[_2256])] = mem[_2256 + 32 len floor32(mem[_2256])]
        mem[_2255 + floor32(mem[_2256]) + -(mem[_2256] % 32) + 196 len mem[_2256] % 32] = mem[_2256 + floor32(mem[_2256]) + -(mem[_2256] % 32) + 64 len mem[_2256] % 32]
        call address(ext_call.return_data[0]) with:
             gas gas_remaining wei
            args mem[_2255 + 168 len _2278 - 4]
        if not return_data.size:
            if not ext_call.success:
                if mem[96]:
                    revert with memory
                      from 128
                       len mem[96]
                revert with 0, 'SafeERC20: low-level call failed'
            if mem[96]:
                require mem[96] >= 32
                if not mem[128]:
                    revert with 0, 
                                32,
                                42,
                                0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                mem[_2255 + 274 len 22]
        else:
            mem[_2255 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not ext_call.success:
                if return_data.size:
                    revert with ext_call.return_data[0 len return_data.size]
                revert with 0, 'SafeERC20: low-level call failed'
            if return_data.size:
                require return_data.size >= 32
                if not mem[_2255 + 196]:
                    revert with 0, 
                                32,
                                42,
                                0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                mem[_2255 + ceil32(return_data.size) + 275 len 22]
}

function uniswapV2Call(address arg1, uint256 arg2, uint256 arg3, bytes arg4) {
    require calldata.size - 4 >= 128
    require arg1 == arg1
    require arg4 <= test266151307()
    require arg4 + 35 < calldata.size
    require arg4.length <= test266151307()
    require arg4 + arg4.length + 36 <= calldata.size
    require ext_code.size(msg.sender)
    staticcall msg.sender.token0() with:
            gas gas_remaining wei
    mem[96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    require ext_code.size(msg.sender)
    staticcall msg.sender.token1() with:
            gas gas_remaining wei
    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    require arg4.length >= 96
    require cd[(arg4 + 100)] <= test266151307()
    require arg4 + arg4.length + 36 > arg4 + cd[(arg4 + 100)] + 67
    require cd[(arg4 + cd[(arg4 + 100)] + 36)] <= test266151307()
    require (32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 128 >= 96 and (2 * ceil32(return_data.size)) + (32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 128 <= test266151307()
    mem[64] = (2 * ceil32(return_data.size)) + (32 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 128
    mem[(2 * ceil32(return_data.size)) + 96] = cd[(arg4 + cd[(arg4 + 100)] + 36)]
    require arg4.length + 36 >= cd[(arg4 + 100)] + (64 * cd[(arg4 + cd[(arg4 + 100)] + 36)]) + 68
    s = arg4 + cd[(arg4 + 100)] + 68
    t = (2 * ceil32(return_data.size)) + 128
    idx = 0
    while idx < cd[(arg4 + cd[(arg4 + 100)] + 36)]:
        require s + 31 < arg4 + arg4.length + 36
        _1499 = mem[64]
        require mem[64] + 64 >= mem[64] and mem[64] + 64 <= test266151307()
        mem[64] = mem[64] + 64
        require s + 64 <= arg4 + arg4.length + 36
        u = 0
        v = s
        w = _1499
        while u < 2:
            require cd[v] == address(cd[v])
            mem[w] = cd[v]
            u = u + 1
            v = v + 32
            w = w + 32
            continue 
        mem[t] = _1499
        s = s + 64
        t = t + 32
        idx = idx + 1
        continue 
    require 0 < mem[(2 * ceil32(return_data.size)) + 96]
    require msg.sender == mem[mem[(2 * ceil32(return_data.size)) + 128] + 44 len 20]
    require 3 < mem[(2 * ceil32(return_data.size)) + 96]
    _1503 = mem[mem[(2 * ceil32(return_data.size)) + 224]]
    mem[mem[64] + 4] = this.address
    require ext_code.size(address(_1503))
    staticcall address(_1503).balanceOf(address rg1) with:
            gas gas_remaining wei
           args address(this.address)
    mem[mem[64]] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _1506 = mem[64]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    _2246 = mem[(2 * ceil32(return_data.size)) + 96]
    idx = 2
    s = mem[_1506] - cd[(arg4 + 68)]
    while idx < _2246:
        require idx < mem[(2 * ceil32(return_data.size)) + 96]
        _2252 = mem[mem[(32 * idx) + (2 * ceil32(return_data.size)) + 128]]
        require idx < mem[(2 * ceil32(return_data.size)) + 96]
        _2260 = mem[mem[(32 * idx) + (2 * ceil32(return_data.size)) + 128] + 32]
        require idx + 1 < mem[(2 * ceil32(return_data.size)) + 96]
        _2263 = mem[mem[(32 * idx + 1) + (2 * ceil32(return_data.size)) + 128]]
        require idx + 1 < mem[(2 * ceil32(return_data.size)) + 96]
        _2266 = mem[mem[(32 * idx + 1) + (2 * ceil32(return_data.size)) + 128] + 32]
        mem[mem[64] + 4] = this.address
        require ext_code.size(address(_2266))
        staticcall address(_2266).balanceOf(address rg1) with:
                gas gas_remaining wei
               args address(this.address)
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _2285 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _2292 = mem[_2285]
        _2305 = mem[64]
        mem[mem[64] + 36] = address(_2260)
        mem[mem[64] + 68] = s
        _2306 = mem[64]
        mem[mem[64]] = 68
        mem[64] = mem[64] + 100
        mem[_2306 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_2306 + 36 len 28]
        mem[64] = _2305 + 164
        mem[_2305 + 100] = 32
        mem[_2305 + 132] = 'SafeERC20: low-level call failed'
        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(address(_2263)):
            revert with 0, 'Address: call to non-contract'
        if not ext_code.hash(address(_2263)):
            revert with 0, 'Address: call to non-contract'
        _2356 = mem[_2306]
        t = _2306 + 32
        u = mem[64]
        s = mem[_2306]
        while s >= 32:
            mem[u] = mem[t]
            t = t + 32
            u = u + 32
            s = s - 32
            continue 
        mem[mem[64] + floor32(mem[_2306])] = mem[_2306 + floor32(mem[_2306]) + -(mem[_2306] % 32) + 64 len mem[_2306] % 32] or Mask(8 * -(mem[_2306] % 32) + 32, -(8 * -(mem[_2306] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_2306])])
        call address(_2263).mem[mem[64] len 4] with:
             gas gas_remaining wei
            args mem[mem[64] + 4 len _2356 + _2305 + -mem[64] + 160]
        if not return_data.size:
            if not ext_call.success:
                if mem[96]:
                    revert with memory
                      from 128
                       len mem[96]
                _3021 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = mem[_2305 + 100]
                _3023 = mem[_2305 + 100]
                idx = 0
                while idx < _3023:
                    mem[idx + _3021 + 68] = mem[idx + _2305 + 132]
                    idx = idx + 32
                    continue 
                if not _3023 % 32:
                    revert with memory
                      from mem[64]
                       len _3023 + _3021 + -mem[64] + 68
                mem[floor32(_3023) + _3021 + 68] = mem[floor32(_3023) + _3021 + -(_3023 % 32) + 100 len _3023 % 32]
                revert with memory
                  from mem[64]
                   len floor32(_3023) + _3021 + -mem[64] + 100
            if not mem[96]:
                require ext_code.size(address(_2260))
                staticcall address(_2260).getReserves() with:
                        gas gas_remaining wei
                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if address(_2263) < address(_2266):
                    _3091 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 96
                    _3107 = mem[_3091]
                    require mem[_3091] == mem[_3091 + 18 len 14]
                    _3115 = mem[_3091 + 32]
                    require mem[_3091 + 32] == mem[_3091 + 50 len 14]
                    require mem[_3091 + 64] == mem[_3091 + 92 len 4]
                    mem[mem[64] + 4] = address(_2260)
                    require ext_code.size(address(_2263))
                    staticcall address(_2263).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(_2260)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if address(_2263) != address(_2263):
                        _3156 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        mem[mem[64] + 4] = mem[_3156] - Mask(112, 0, _3115)
                        mem[mem[64] + 36] = Mask(112, 0, _3115)
                        mem[mem[64] + 68] = Mask(112, 0, _3107)
                        require ext_code.size(address(_2252))
                        staticcall address(_2252).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                                gas gas_remaining wei
                               args mem[mem[64] + 4], _3115 << 144, Mask(112, 0, _3107)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3220 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _3236 = mem[_3220]
                        if address(_2263) == address(_2263):
                            _3261 = mem[64]
                            mem[mem[64]] = 0
                            mem[64] = mem[64] + 32
                            mem[_3261 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                            mem[_3261 + 36] = 0
                            mem[_3261 + 68] = _3236
                            mem[_3261 + 100] = this.address
                            mem[_3261 + 132] = 128
                            mem[_3261 + 164] = mem[_3261]
                            s = 0
                            while s < mem[_3261]:
                                mem[s + _3261 + 196] = mem[s + _3261 + 32]
                                s = s + 32
                                continue 
                            if ceil32(mem[_3261]) > mem[_3261]:
                                mem[_3261 + mem[_3261] + 196] = 0
                            require ext_code.size(address(_2260))
                            call address(_2260).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                                 gas gas_remaining wei
                                args 0, _3236, address(this.address), 128, mem[_3261], mem[_3261 + 196 len ceil32(mem[_3261])]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_3261 + 36] = this.address
                            require ext_code.size(address(_2266))
                            staticcall address(_2266).balanceOf(address rg1) with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[_3261 + 32] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = _3261 + ceil32(return_data.size) + 32
                        else:
                            _3262 = mem[64]
                            mem[mem[64]] = 0
                            mem[64] = mem[64] + 32
                            mem[_3262 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                            mem[_3262 + 36] = _3236
                            mem[_3262 + 68] = 0
                            mem[_3262 + 100] = this.address
                            mem[_3262 + 132] = 128
                            mem[_3262 + 164] = mem[_3262]
                            s = 0
                            while s < mem[_3262]:
                                mem[s + _3262 + 196] = mem[s + _3262 + 32]
                                s = s + 32
                                continue 
                            if ceil32(mem[_3262]) > mem[_3262]:
                                mem[_3262 + mem[_3262] + 196] = 0
                            require ext_code.size(address(_2260))
                            call address(_2260).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                                 gas gas_remaining wei
                                args _3236, 0, address(this.address), 128, mem[_3262], mem[_3262 + 196 len ceil32(mem[_3262])]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_3262 + 36] = this.address
                            require ext_code.size(address(_2266))
                            staticcall address(_2266).balanceOf(address rg1) with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[_3262 + 32] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = _3262 + ceil32(return_data.size) + 32
                        require return_data.size >= 32
                        idx = idx + 2
                        s = ext_call.return_data[0] - _2292
                        continue 
                    _3155 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    mem[mem[64] + 4] = mem[_3155] - Mask(112, 0, _3107)
                    mem[mem[64] + 36] = Mask(112, 0, _3107)
                    mem[mem[64] + 68] = Mask(112, 0, _3115)
                    require ext_code.size(address(_2252))
                    staticcall address(_2252).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                            gas gas_remaining wei
                           args mem[mem[64] + 4], _3107 << 144, Mask(112, 0, _3115)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3219 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _3235 = mem[_3219]
                    if address(_2263) != address(_2263):
                        _3260 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_3260 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_3260 + 36] = _3235
                        mem[_3260 + 68] = 0
                        mem[_3260 + 100] = this.address
                        mem[_3260 + 132] = 128
                        mem[_3260 + 164] = mem[_3260]
                        s = 0
                        while s < mem[_3260]:
                            mem[s + _3260 + 196] = mem[s + _3260 + 32]
                            s = s + 32
                            continue 
                        if ceil32(mem[_3260]) > mem[_3260]:
                            mem[_3260 + mem[_3260] + 196] = 0
                        require ext_code.size(address(_2260))
                        call address(_2260).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                             gas gas_remaining wei
                            args _3235, 0, address(this.address), 128, mem[_3260], mem[_3260 + 196 len ceil32(mem[_3260])]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_3260 + 36] = this.address
                        require ext_code.size(address(_2266))
                        staticcall address(_2266).balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args this.address
                        mem[_3260 + 32] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[64] = _3260 + ceil32(return_data.size) + 32
                        require return_data.size >= 32
                        idx = idx + 2
                        s = ext_call.return_data[0] - _2292
                        continue 
                    _3259 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_3259 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_3259 + 36] = 0
                    mem[_3259 + 68] = _3235
                    mem[_3259 + 100] = this.address
                    mem[_3259 + 132] = 128
                    mem[_3259 + 164] = mem[_3259]
                    s = 0
                    while s < mem[_3259]:
                        mem[s + _3259 + 196] = mem[s + _3259 + 32]
                        s = s + 32
                        continue 
                    if ceil32(mem[_3259]) <= mem[_3259]:
                        require ext_code.size(address(_2260))
                        call address(_2260).mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len ceil32(mem[_3259]) + _3259 + -mem[64] + 192]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(_2266))
                        staticcall address(_2266).balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3923 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        idx = idx + 2
                        s = mem[_3923] - _2292
                        continue 
                    mem[_3259 + mem[_3259] + 196] = 0
                    require ext_code.size(address(_2260))
                    call address(_2260).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_3259]) + _3259 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(_2266))
                    staticcall address(_2266).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3955 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    idx = idx + 2
                    s = mem[_3955] - _2292
                    continue 
                _3092 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 96
                _3108 = mem[_3092]
                require mem[_3092] == mem[_3092 + 18 len 14]
                _3116 = mem[_3092 + 32]
                require mem[_3092 + 32] == mem[_3092 + 50 len 14]
                require mem[_3092 + 64] == mem[_3092 + 92 len 4]
                mem[mem[64] + 4] = address(_2260)
                require ext_code.size(address(_2263))
                staticcall address(_2263).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(_2260)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if address(_2263) == address(_2266):
                    _3157 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    mem[mem[64] + 4] = mem[_3157] - Mask(112, 0, _3108)
                    mem[mem[64] + 36] = Mask(112, 0, _3108)
                    mem[mem[64] + 68] = Mask(112, 0, _3116)
                    require ext_code.size(address(_2252))
                    staticcall address(_2252).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                            gas gas_remaining wei
                           args mem[mem[64] + 4], _3108 << 144, Mask(112, 0, _3116)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3221 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _3237 = mem[_3221]
                    if address(_2263) == address(_2266):
                        _3263 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_3263 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_3263 + 36] = 0
                        mem[_3263 + 68] = _3237
                        mem[_3263 + 100] = this.address
                        mem[_3263 + 132] = 128
                        mem[_3263 + 164] = mem[_3263]
                        s = 0
                        while s < mem[_3263]:
                            mem[s + _3263 + 196] = mem[s + _3263 + 32]
                            s = s + 32
                            continue 
                        if ceil32(mem[_3263]) <= mem[_3263]:
                            require ext_code.size(address(_2260))
                            call address(_2260).mem[mem[64] len 4] with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len ceil32(mem[_3263]) + _3263 + -mem[64] + 192]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(address(_2266))
                            staticcall address(_2266).balanceOf(address rg1) with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3927 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            idx = idx + 2
                            s = mem[_3927] - _2292
                            continue 
                        mem[_3263 + mem[_3263] + 196] = 0
                        require ext_code.size(address(_2260))
                        call address(_2260).mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len ceil32(mem[_3263]) + _3263 + -mem[64] + 192]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(_2266))
                        staticcall address(_2266).balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3959 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        idx = idx + 2
                        s = mem[_3959] - _2292
                        continue 
                    _3264 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_3264 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_3264 + 36] = _3237
                    mem[_3264 + 68] = 0
                    mem[_3264 + 100] = this.address
                    mem[_3264 + 132] = 128
                    mem[_3264 + 164] = mem[_3264]
                    s = 0
                    while s < mem[_3264]:
                        mem[s + _3264 + 196] = mem[s + _3264 + 32]
                        s = s + 32
                        continue 
                    if ceil32(mem[_3264]) <= mem[_3264]:
                        require ext_code.size(address(_2260))
                        call address(_2260).mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len ceil32(mem[_3264]) + _3264 + -mem[64] + 192]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(_2266))
                        staticcall address(_2266).balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3928 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        idx = idx + 2
                        s = mem[_3928] - _2292
                        continue 
                    mem[_3264 + mem[_3264] + 196] = 0
                    require ext_code.size(address(_2260))
                    call address(_2260).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_3264]) + _3264 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(_2266))
                    staticcall address(_2266).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3960 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    idx = idx + 2
                    s = mem[_3960] - _2292
                    continue 
                _3158 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[mem[64] + 4] = mem[_3158] - Mask(112, 0, _3116)
                mem[mem[64] + 36] = Mask(112, 0, _3116)
                mem[mem[64] + 68] = Mask(112, 0, _3108)
                require ext_code.size(address(_2252))
                staticcall address(_2252).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                        gas gas_remaining wei
                       args mem[mem[64] + 4], _3116 << 144, Mask(112, 0, _3108)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3222 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _3238 = mem[_3222]
                if address(_2263) == address(_2266):
                    _3265 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_3265 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_3265 + 36] = 0
                    mem[_3265 + 68] = _3238
                    mem[_3265 + 100] = this.address
                    mem[_3265 + 132] = 128
                    mem[_3265 + 164] = mem[_3265]
                    s = 0
                    while s < mem[_3265]:
                        mem[s + _3265 + 196] = mem[s + _3265 + 32]
                        s = s + 32
                        continue 
                    if ceil32(mem[_3265]) <= mem[_3265]:
                        require ext_code.size(address(_2260))
                        call address(_2260).mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len ceil32(mem[_3265]) + _3265 + -mem[64] + 192]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(_2266))
                        staticcall address(_2266).balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3929 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        idx = idx + 2
                        s = mem[_3929] - _2292
                        continue 
                    mem[_3265 + mem[_3265] + 196] = 0
                    require ext_code.size(address(_2260))
                    call address(_2260).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_3265]) + _3265 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(_2266))
                    staticcall address(_2266).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3961 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    idx = idx + 2
                    s = mem[_3961] - _2292
                    continue 
                _3266 = mem[64]
                mem[mem[64]] = 0
                mem[64] = mem[64] + 32
                mem[_3266 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[_3266 + 36] = _3238
                mem[_3266 + 68] = 0
                mem[_3266 + 100] = this.address
                mem[_3266 + 132] = 128
                mem[_3266 + 164] = mem[_3266]
                s = 0
                while s < mem[_3266]:
                    mem[s + _3266 + 196] = mem[s + _3266 + 32]
                    s = s + 32
                    continue 
                if ceil32(mem[_3266]) <= mem[_3266]:
                    require ext_code.size(address(_2260))
                    call address(_2260).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_3266]) + _3266 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(_2266))
                    staticcall address(_2266).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3930 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    idx = idx + 2
                    s = mem[_3930] - _2292
                    continue 
                mem[_3266 + mem[_3266] + 196] = 0
                require ext_code.size(address(_2260))
                call address(_2260).mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len ceil32(mem[_3266]) + _3266 + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(_2266))
                staticcall address(_2266).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3962 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                idx = idx + 2
                s = mem[_3962] - _2292
                continue 
            require mem[96] >= 32
            if not mem[128]:
                revert with 0, 
                            32,
                            42,
                            0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                            mem[mem[64] + 110 len 22]
            require ext_code.size(address(_2260))
            staticcall address(_2260).getReserves() with:
                    gas gas_remaining wei
            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if address(_2263) < address(_2266):
                _3103 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 96
                _3111 = mem[_3103]
                require mem[_3103] == mem[_3103 + 18 len 14]
                _3121 = mem[_3103 + 32]
                require mem[_3103 + 32] == mem[_3103 + 50 len 14]
                require mem[_3103 + 64] == mem[_3103 + 92 len 4]
                mem[mem[64] + 4] = address(_2260)
                require ext_code.size(address(_2263))
                staticcall address(_2263).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(_2260)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if address(_2263) == address(_2263):
                    _3175 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    mem[mem[64] + 4] = mem[_3175] - Mask(112, 0, _3111)
                    mem[mem[64] + 36] = Mask(112, 0, _3111)
                    mem[mem[64] + 68] = Mask(112, 0, _3121)
                    require ext_code.size(address(_2252))
                    staticcall address(_2252).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                            gas gas_remaining wei
                           args mem[mem[64] + 4], _3111 << 144, Mask(112, 0, _3121)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3239 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _3251 = mem[_3239]
                    if address(_2263) == address(_2263):
                        _3291 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_3291 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_3291 + 36] = 0
                        mem[_3291 + 68] = _3251
                        mem[_3291 + 100] = this.address
                        mem[_3291 + 132] = 128
                        mem[_3291 + 164] = mem[_3291]
                        s = 0
                        while s < mem[_3291]:
                            mem[s + _3291 + 196] = mem[s + _3291 + 32]
                            s = s + 32
                            continue 
                        if ceil32(mem[_3291]) > mem[_3291]:
                            mem[_3291 + mem[_3291] + 196] = 0
                        require ext_code.size(address(_2260))
                        call address(_2260).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                             gas gas_remaining wei
                            args 0, _3251, address(this.address), 128, mem[_3291], mem[_3291 + 196 len ceil32(mem[_3291])]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_3291 + 36] = this.address
                        require ext_code.size(address(_2266))
                        staticcall address(_2266).balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args this.address
                        mem[_3291 + 32] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[64] = _3291 + ceil32(return_data.size) + 32
                    else:
                        _3292 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_3292 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_3292 + 36] = _3251
                        mem[_3292 + 68] = 0
                        mem[_3292 + 100] = this.address
                        mem[_3292 + 132] = 128
                        mem[_3292 + 164] = mem[_3292]
                        s = 0
                        while s < mem[_3292]:
                            mem[s + _3292 + 196] = mem[s + _3292 + 32]
                            s = s + 32
                            continue 
                        if ceil32(mem[_3292]) > mem[_3292]:
                            mem[_3292 + mem[_3292] + 196] = 0
                        require ext_code.size(address(_2260))
                        call address(_2260).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                             gas gas_remaining wei
                            args _3251, 0, address(this.address), 128, mem[_3292], mem[_3292 + 196 len ceil32(mem[_3292])]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_3292 + 36] = this.address
                        require ext_code.size(address(_2266))
                        staticcall address(_2266).balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args this.address
                        mem[_3292 + 32] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[64] = _3292 + ceil32(return_data.size) + 32
                    require return_data.size >= 32
                    idx = idx + 2
                    s = ext_call.return_data[0] - _2292
                    continue 
                _3176 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[mem[64] + 4] = mem[_3176] - Mask(112, 0, _3121)
                mem[mem[64] + 36] = Mask(112, 0, _3121)
                mem[mem[64] + 68] = Mask(112, 0, _3111)
                require ext_code.size(address(_2252))
                staticcall address(_2252).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                        gas gas_remaining wei
                       args mem[mem[64] + 4], _3121 << 144, Mask(112, 0, _3111)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3240 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _3252 = mem[_3240]
                if address(_2263) != address(_2263):
                    _3294 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_3294 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_3294 + 36] = _3252
                    mem[_3294 + 68] = 0
                    mem[_3294 + 100] = this.address
                    mem[_3294 + 132] = 128
                    mem[_3294 + 164] = mem[_3294]
                    s = 0
                    while s < mem[_3294]:
                        mem[s + _3294 + 196] = mem[s + _3294 + 32]
                        s = s + 32
                        continue 
                    if ceil32(mem[_3294]) > mem[_3294]:
                        mem[_3294 + mem[_3294] + 196] = 0
                    require ext_code.size(address(_2260))
                    call address(_2260).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                         gas gas_remaining wei
                        args _3252, 0, address(this.address), 128, mem[_3294], mem[_3294 + 196 len ceil32(mem[_3294])]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[_3294 + 36] = this.address
                    require ext_code.size(address(_2266))
                    staticcall address(_2266).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args this.address
                    mem[_3294 + 32] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = _3294 + ceil32(return_data.size) + 32
                    require return_data.size >= 32
                    idx = idx + 2
                    s = ext_call.return_data[0] - _2292
                    continue 
                _3293 = mem[64]
                mem[mem[64]] = 0
                mem[64] = mem[64] + 32
                mem[_3293 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[_3293 + 36] = 0
                mem[_3293 + 68] = _3252
                mem[_3293 + 100] = this.address
                mem[_3293 + 132] = 128
                mem[_3293 + 164] = mem[_3293]
                s = 0
                while s < mem[_3293]:
                    mem[s + _3293 + 196] = mem[s + _3293 + 32]
                    s = s + 32
                    continue 
                if ceil32(mem[_3293]) <= mem[_3293]:
                    require ext_code.size(address(_2260))
                    call address(_2260).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_3293]) + _3293 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(_2266))
                    staticcall address(_2266).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3933 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    idx = idx + 2
                    s = mem[_3933] - _2292
                    continue 
                mem[_3293 + mem[_3293] + 196] = 0
                require ext_code.size(address(_2260))
                call address(_2260).mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len ceil32(mem[_3293]) + _3293 + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(_2266))
                staticcall address(_2266).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3965 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                idx = idx + 2
                s = mem[_3965] - _2292
                continue 
            _3104 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 96
            _3112 = mem[_3104]
            require mem[_3104] == mem[_3104 + 18 len 14]
            _3122 = mem[_3104 + 32]
            require mem[_3104 + 32] == mem[_3104 + 50 len 14]
            require mem[_3104 + 64] == mem[_3104 + 92 len 4]
            mem[mem[64] + 4] = address(_2260)
            require ext_code.size(address(_2263))
            staticcall address(_2263).balanceOf(address rg1) with:
                    gas gas_remaining wei
                   args address(_2260)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if address(_2263) == address(_2266):
                _3177 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[mem[64] + 4] = mem[_3177] - Mask(112, 0, _3112)
                mem[mem[64] + 36] = Mask(112, 0, _3112)
                mem[mem[64] + 68] = Mask(112, 0, _3122)
                require ext_code.size(address(_2252))
                staticcall address(_2252).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                        gas gas_remaining wei
                       args mem[mem[64] + 4], _3112 << 144, Mask(112, 0, _3122)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3241 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _3253 = mem[_3241]
                if address(_2263) == address(_2266):
                    _3295 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_3295 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_3295 + 36] = 0
                    mem[_3295 + 68] = _3253
                    mem[_3295 + 100] = this.address
                    mem[_3295 + 132] = 128
                    mem[_3295 + 164] = mem[_3295]
                    s = 0
                    while s < mem[_3295]:
                        mem[s + _3295 + 196] = mem[s + _3295 + 32]
                        s = s + 32
                        continue 
                    if ceil32(mem[_3295]) <= mem[_3295]:
                        require ext_code.size(address(_2260))
                        call address(_2260).mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len ceil32(mem[_3295]) + _3295 + -mem[64] + 192]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(_2266))
                        staticcall address(_2266).balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3935 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        idx = idx + 2
                        s = mem[_3935] - _2292
                        continue 
                    mem[_3295 + mem[_3295] + 196] = 0
                    require ext_code.size(address(_2260))
                    call address(_2260).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_3295]) + _3295 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(_2266))
                    staticcall address(_2266).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3967 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    idx = idx + 2
                    s = mem[_3967] - _2292
                    continue 
                _3296 = mem[64]
                mem[mem[64]] = 0
                mem[64] = mem[64] + 32
                mem[_3296 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[_3296 + 36] = _3253
                mem[_3296 + 68] = 0
                mem[_3296 + 100] = this.address
                mem[_3296 + 132] = 128
                mem[_3296 + 164] = mem[_3296]
                s = 0
                while s < mem[_3296]:
                    mem[s + _3296 + 196] = mem[s + _3296 + 32]
                    s = s + 32
                    continue 
                if ceil32(mem[_3296]) <= mem[_3296]:
                    require ext_code.size(address(_2260))
                    call address(_2260).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_3296]) + _3296 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(_2266))
                    staticcall address(_2266).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3936 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    idx = idx + 2
                    s = mem[_3936] - _2292
                    continue 
                mem[_3296 + mem[_3296] + 196] = 0
                require ext_code.size(address(_2260))
                call address(_2260).mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len ceil32(mem[_3296]) + _3296 + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(_2266))
                staticcall address(_2266).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3968 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                idx = idx + 2
                s = mem[_3968] - _2292
                continue 
            _3178 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            mem[mem[64] + 4] = mem[_3178] - Mask(112, 0, _3122)
            mem[mem[64] + 36] = Mask(112, 0, _3122)
            mem[mem[64] + 68] = Mask(112, 0, _3112)
            require ext_code.size(address(_2252))
            staticcall address(_2252).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                    gas gas_remaining wei
                   args mem[mem[64] + 4], _3122 << 144, Mask(112, 0, _3112)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3242 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _3254 = mem[_3242]
            if address(_2263) == address(_2266):
                _3297 = mem[64]
                mem[mem[64]] = 0
                mem[64] = mem[64] + 32
                mem[_3297 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[_3297 + 36] = 0
                mem[_3297 + 68] = _3254
                mem[_3297 + 100] = this.address
                mem[_3297 + 132] = 128
                mem[_3297 + 164] = mem[_3297]
                s = 0
                while s < mem[_3297]:
                    mem[s + _3297 + 196] = mem[s + _3297 + 32]
                    s = s + 32
                    continue 
                if ceil32(mem[_3297]) > mem[_3297]:
                    mem[_3297 + mem[_3297] + 196] = 0
                require ext_code.size(address(_2260))
                call address(_2260).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                     gas gas_remaining wei
                    args 0, _3254, address(this.address), 128, mem[_3297], mem[_3297 + 196 len ceil32(mem[_3297])]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[_3297 + 36] = this.address
                require ext_code.size(address(_2266))
                staticcall address(_2266).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args this.address
                mem[_3297 + 32] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[64] = _3297 + ceil32(return_data.size) + 32
                require return_data.size >= 32
                idx = idx + 2
                s = ext_call.return_data[0] - _2292
                continue 
            _3298 = mem[64]
            mem[mem[64]] = 0
            mem[64] = mem[64] + 32
            mem[_3298 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
            mem[_3298 + 36] = _3254
            mem[_3298 + 68] = 0
            mem[_3298 + 100] = this.address
            mem[_3298 + 132] = 128
            mem[_3298 + 164] = mem[_3298]
            s = 0
            while s < mem[_3298]:
                mem[s + _3298 + 196] = mem[s + _3298 + 32]
                s = s + 32
                continue 
            if ceil32(mem[_3298]) <= mem[_3298]:
                require ext_code.size(address(_2260))
                call address(_2260).mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len ceil32(mem[_3298]) + _3298 + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(_2266))
                staticcall address(_2266).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3938 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                idx = idx + 2
                s = mem[_3938] - _2292
                continue 
            mem[_3298 + mem[_3298] + 196] = 0
            require ext_code.size(address(_2260))
            call address(_2260).mem[mem[64] len 4] with:
                 gas gas_remaining wei
                args mem[mem[64] + 4 len ceil32(mem[_3298]) + _3298 + -mem[64] + 192]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[mem[64] + 4] = this.address
            require ext_code.size(address(_2266))
            staticcall address(_2266).balanceOf(address rg1) with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3970 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            idx = idx + 2
            s = mem[_3970] - _2292
            continue 
        _2998 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size) + 1
        mem[_2998] = return_data.size
        mem[_2998 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
        if not ext_call.success:
            if return_data.size:
                revert with ext_call.return_data[0 len return_data.size]
            _3025 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = mem[_2305 + 100]
            _3027 = mem[_2305 + 100]
            idx = 0
            while idx < _3027:
                mem[idx + _3025 + 68] = mem[idx + _2305 + 132]
                idx = idx + 32
                continue 
            if not _3027 % 32:
                revert with memory
                  from mem[64]
                   len _3027 + _3025 + -mem[64] + 68
            mem[floor32(_3027) + _3025 + 68] = mem[floor32(_3027) + _3025 + -(_3027 % 32) + 100 len _3027 % 32]
            revert with memory
              from mem[64]
               len floor32(_3027) + _3025 + -mem[64] + 100
        if not return_data.size:
            require ext_code.size(address(_2260))
            staticcall address(_2260).getReserves() with:
                    gas gas_remaining wei
            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if address(_2263) < address(_2266):
                _3097 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 96
                _3109 = mem[_3097]
                require mem[_3097] == mem[_3097 + 18 len 14]
                _3117 = mem[_3097 + 32]
                require mem[_3097 + 32] == mem[_3097 + 50 len 14]
                require mem[_3097 + 64] == mem[_3097 + 92 len 4]
                mem[mem[64] + 4] = address(_2260)
                require ext_code.size(address(_2263))
                staticcall address(_2263).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(_2260)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if address(_2263) == address(_2263):
                    _3163 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    mem[mem[64] + 4] = mem[_3163] - Mask(112, 0, _3109)
                    mem[mem[64] + 36] = Mask(112, 0, _3109)
                    mem[mem[64] + 68] = Mask(112, 0, _3117)
                    require ext_code.size(address(_2252))
                    staticcall address(_2252).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                            gas gas_remaining wei
                           args mem[mem[64] + 4], _3109 << 144, Mask(112, 0, _3117)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3227 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _3243 = mem[_3227]
                    if address(_2263) != address(_2263):
                        _3268 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_3268 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_3268 + 36] = _3243
                        mem[_3268 + 68] = 0
                        mem[_3268 + 100] = this.address
                        mem[_3268 + 132] = 128
                        mem[_3268 + 164] = mem[_3268]
                        s = 0
                        while s < mem[_3268]:
                            mem[s + _3268 + 196] = mem[s + _3268 + 32]
                            s = s + 32
                            continue 
                        if ceil32(mem[_3268]) > mem[_3268]:
                            mem[_3268 + mem[_3268] + 196] = 0
                        require ext_code.size(address(_2260))
                        call address(_2260).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                             gas gas_remaining wei
                            args _3243, 0, address(this.address), 128, mem[_3268], mem[_3268 + 196 len ceil32(mem[_3268])]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_3268 + 36] = this.address
                        require ext_code.size(address(_2266))
                        staticcall address(_2266).balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args this.address
                        mem[_3268 + 32] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[64] = _3268 + ceil32(return_data.size) + 32
                        require return_data.size >= 32
                        idx = idx + 2
                        s = ext_call.return_data[0] - _2292
                        continue 
                    _3267 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_3267 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_3267 + 36] = 0
                    mem[_3267 + 68] = _3243
                    mem[_3267 + 100] = this.address
                    mem[_3267 + 132] = 128
                    mem[_3267 + 164] = mem[_3267]
                    s = 0
                    while s < mem[_3267]:
                        mem[s + _3267 + 196] = mem[s + _3267 + 32]
                        s = s + 32
                        continue 
                    if ceil32(mem[_3267]) <= mem[_3267]:
                        require ext_code.size(address(_2260))
                        call address(_2260).mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len ceil32(mem[_3267]) + _3267 + -mem[64] + 192]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(_2266))
                        staticcall address(_2266).balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3939 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        idx = idx + 2
                        s = mem[_3939] - _2292
                        continue 
                    mem[_3267 + mem[_3267] + 196] = 0
                    require ext_code.size(address(_2260))
                    call address(_2260).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_3267]) + _3267 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(_2266))
                    staticcall address(_2266).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3971 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    idx = idx + 2
                    s = mem[_3971] - _2292
                    continue 
                _3164 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[mem[64] + 4] = mem[_3164] - Mask(112, 0, _3117)
                mem[mem[64] + 36] = Mask(112, 0, _3117)
                mem[mem[64] + 68] = Mask(112, 0, _3109)
                require ext_code.size(address(_2252))
                staticcall address(_2252).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                        gas gas_remaining wei
                       args mem[mem[64] + 4], _3117 << 144, Mask(112, 0, _3109)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3228 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _3244 = mem[_3228]
                if address(_2263) == address(_2263):
                    _3269 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_3269 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_3269 + 36] = 0
                    mem[_3269 + 68] = _3244
                    mem[_3269 + 100] = this.address
                    mem[_3269 + 132] = 128
                    mem[_3269 + 164] = mem[_3269]
                    s = 0
                    while s < mem[_3269]:
                        mem[s + _3269 + 196] = mem[s + _3269 + 32]
                        s = s + 32
                        continue 
                    if ceil32(mem[_3269]) <= mem[_3269]:
                        require ext_code.size(address(_2260))
                        call address(_2260).mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len ceil32(mem[_3269]) + _3269 + -mem[64] + 192]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(_2266))
                        staticcall address(_2266).balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3941 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        idx = idx + 2
                        s = mem[_3941] - _2292
                        continue 
                    mem[_3269 + mem[_3269] + 196] = 0
                    require ext_code.size(address(_2260))
                    call address(_2260).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_3269]) + _3269 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(_2266))
                    staticcall address(_2266).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3973 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    idx = idx + 2
                    s = mem[_3973] - _2292
                    continue 
                _3270 = mem[64]
                mem[mem[64]] = 0
                mem[64] = mem[64] + 32
                mem[_3270 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[_3270 + 36] = _3244
                mem[_3270 + 68] = 0
                mem[_3270 + 100] = this.address
                mem[_3270 + 132] = 128
                mem[_3270 + 164] = mem[_3270]
                s = 0
                while s < mem[_3270]:
                    mem[s + _3270 + 196] = mem[s + _3270 + 32]
                    s = s + 32
                    continue 
                if ceil32(mem[_3270]) <= mem[_3270]:
                    require ext_code.size(address(_2260))
                    call address(_2260).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_3270]) + _3270 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(_2266))
                    staticcall address(_2266).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3942 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    idx = idx + 2
                    s = mem[_3942] - _2292
                    continue 
                mem[_3270 + mem[_3270] + 196] = 0
                require ext_code.size(address(_2260))
                call address(_2260).mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len ceil32(mem[_3270]) + _3270 + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(_2266))
                staticcall address(_2266).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3974 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                idx = idx + 2
                s = mem[_3974] - _2292
                continue 
            _3098 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 96
            _3110 = mem[_3098]
            require mem[_3098] == mem[_3098 + 18 len 14]
            _3118 = mem[_3098 + 32]
            require mem[_3098 + 32] == mem[_3098 + 50 len 14]
            require mem[_3098 + 64] == mem[_3098 + 92 len 4]
            mem[mem[64] + 4] = address(_2260)
            require ext_code.size(address(_2263))
            staticcall address(_2263).balanceOf(address rg1) with:
                    gas gas_remaining wei
                   args address(_2260)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if address(_2263) == address(_2266):
                _3165 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[mem[64] + 4] = mem[_3165] - Mask(112, 0, _3110)
                mem[mem[64] + 36] = Mask(112, 0, _3110)
                mem[mem[64] + 68] = Mask(112, 0, _3118)
                require ext_code.size(address(_2252))
                staticcall address(_2252).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                        gas gas_remaining wei
                       args mem[mem[64] + 4], _3110 << 144, Mask(112, 0, _3118)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3229 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _3245 = mem[_3229]
                if address(_2263) == address(_2266):
                    _3271 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_3271 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_3271 + 36] = 0
                    mem[_3271 + 68] = _3245
                    mem[_3271 + 100] = this.address
                    mem[_3271 + 132] = 128
                    mem[_3271 + 164] = mem[_3271]
                    s = 0
                    while s < mem[_3271]:
                        mem[s + _3271 + 196] = mem[s + _3271 + 32]
                        s = s + 32
                        continue 
                    if ceil32(mem[_3271]) > mem[_3271]:
                        mem[_3271 + mem[_3271] + 196] = 0
                    require ext_code.size(address(_2260))
                    call address(_2260).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                         gas gas_remaining wei
                        args 0, _3245, address(this.address), 128, mem[_3271], mem[_3271 + 196 len ceil32(mem[_3271])]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[_3271 + 36] = this.address
                    require ext_code.size(address(_2266))
                    staticcall address(_2266).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args this.address
                    mem[_3271 + 32] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = _3271 + ceil32(return_data.size) + 32
                else:
                    _3272 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_3272 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_3272 + 36] = _3245
                    mem[_3272 + 68] = 0
                    mem[_3272 + 100] = this.address
                    mem[_3272 + 132] = 128
                    mem[_3272 + 164] = mem[_3272]
                    s = 0
                    while s < mem[_3272]:
                        mem[s + _3272 + 196] = mem[s + _3272 + 32]
                        s = s + 32
                        continue 
                    if ceil32(mem[_3272]) > mem[_3272]:
                        mem[_3272 + mem[_3272] + 196] = 0
                    require ext_code.size(address(_2260))
                    call address(_2260).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                         gas gas_remaining wei
                        args _3245, 0, address(this.address), 128, mem[_3272], mem[_3272 + 196 len ceil32(mem[_3272])]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[_3272 + 36] = this.address
                    require ext_code.size(address(_2266))
                    staticcall address(_2266).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args this.address
                    mem[_3272 + 32] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = _3272 + ceil32(return_data.size) + 32
                require return_data.size >= 32
                idx = idx + 2
                s = ext_call.return_data[0] - _2292
                continue 
            _3166 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            mem[mem[64] + 4] = mem[_3166] - Mask(112, 0, _3118)
            mem[mem[64] + 36] = Mask(112, 0, _3118)
            mem[mem[64] + 68] = Mask(112, 0, _3110)
            require ext_code.size(address(_2252))
            staticcall address(_2252).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                    gas gas_remaining wei
                   args mem[mem[64] + 4], _3118 << 144, Mask(112, 0, _3110)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3230 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _3246 = mem[_3230]
            if address(_2263) == address(_2266):
                _3273 = mem[64]
                mem[mem[64]] = 0
                mem[64] = mem[64] + 32
                mem[_3273 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[_3273 + 36] = 0
                mem[_3273 + 68] = _3246
                mem[_3273 + 100] = this.address
                mem[_3273 + 132] = 128
                mem[_3273 + 164] = mem[_3273]
                s = 0
                while s < mem[_3273]:
                    mem[s + _3273 + 196] = mem[s + _3273 + 32]
                    s = s + 32
                    continue 
                if ceil32(mem[_3273]) <= mem[_3273]:
                    require ext_code.size(address(_2260))
                    call address(_2260).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_3273]) + _3273 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(_2266))
                    staticcall address(_2266).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3945 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    idx = idx + 2
                    s = mem[_3945] - _2292
                    continue 
                mem[_3273 + mem[_3273] + 196] = 0
                require ext_code.size(address(_2260))
                call address(_2260).mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len ceil32(mem[_3273]) + _3273 + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(_2266))
                staticcall address(_2266).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3977 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                idx = idx + 2
                s = mem[_3977] - _2292
                continue 
            _3274 = mem[64]
            mem[mem[64]] = 0
            mem[64] = mem[64] + 32
            mem[_3274 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
            mem[_3274 + 36] = _3246
            mem[_3274 + 68] = 0
            mem[_3274 + 100] = this.address
            mem[_3274 + 132] = 128
            mem[_3274 + 164] = mem[_3274]
            s = 0
            while s < mem[_3274]:
                mem[s + _3274 + 196] = mem[s + _3274 + 32]
                s = s + 32
                continue 
            if ceil32(mem[_3274]) <= mem[_3274]:
                require ext_code.size(address(_2260))
                call address(_2260).mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len ceil32(mem[_3274]) + _3274 + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(_2266))
                staticcall address(_2266).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3946 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                idx = idx + 2
                s = mem[_3946] - _2292
                continue 
            mem[_3274 + mem[_3274] + 196] = 0
            require ext_code.size(address(_2260))
            call address(_2260).mem[mem[64] len 4] with:
                 gas gas_remaining wei
                args mem[mem[64] + 4 len ceil32(mem[_3274]) + _3274 + -mem[64] + 192]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[mem[64] + 4] = this.address
            require ext_code.size(address(_2266))
            staticcall address(_2266).balanceOf(address rg1) with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3978 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            idx = idx + 2
            s = mem[_3978] - _2292
            continue 
        require return_data.size >= 32
        if not mem[_2998 + 32]:
            revert with 0, 
                        32,
                        42,
                        0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                        mem[mem[64] + 110 len 22]
        require ext_code.size(address(_2260))
        staticcall address(_2260).getReserves() with:
                gas gas_remaining wei
        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        if address(_2263) < address(_2266):
            _3105 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 96
            _3113 = mem[_3105]
            require mem[_3105] == mem[_3105 + 18 len 14]
            _3125 = mem[_3105 + 32]
            require mem[_3105 + 32] == mem[_3105 + 50 len 14]
            require mem[_3105 + 64] == mem[_3105 + 92 len 4]
            mem[mem[64] + 4] = address(_2260)
            require ext_code.size(address(_2263))
            staticcall address(_2263).balanceOf(address rg1) with:
                    gas gas_remaining wei
                   args address(_2260)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if address(_2263) == address(_2263):
                _3183 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[mem[64] + 4] = mem[_3183] - Mask(112, 0, _3113)
                mem[mem[64] + 36] = Mask(112, 0, _3113)
                mem[mem[64] + 68] = Mask(112, 0, _3125)
                require ext_code.size(address(_2252))
                staticcall address(_2252).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                        gas gas_remaining wei
                       args mem[mem[64] + 4], _3113 << 144, Mask(112, 0, _3125)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3247 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _3255 = mem[_3247]
                if address(_2263) == address(_2263):
                    _3299 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_3299 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_3299 + 36] = 0
                    mem[_3299 + 68] = _3255
                    mem[_3299 + 100] = this.address
                    mem[_3299 + 132] = 128
                    mem[_3299 + 164] = mem[_3299]
                    s = 0
                    while s < mem[_3299]:
                        mem[s + _3299 + 196] = mem[s + _3299 + 32]
                        s = s + 32
                        continue 
                    if ceil32(mem[_3299]) > mem[_3299]:
                        mem[_3299 + mem[_3299] + 196] = 0
                    require ext_code.size(address(_2260))
                    call address(_2260).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                         gas gas_remaining wei
                        args 0, _3255, address(this.address), 128, mem[_3299], mem[_3299 + 196 len ceil32(mem[_3299])]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[_3299 + 36] = this.address
                    require ext_code.size(address(_2266))
                    staticcall address(_2266).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args this.address
                    mem[_3299 + 32] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = _3299 + ceil32(return_data.size) + 32
                    require return_data.size >= 32
                    idx = idx + 2
                    s = ext_call.return_data[0] - _2292
                    continue 
                _3300 = mem[64]
                mem[mem[64]] = 0
                mem[64] = mem[64] + 32
                mem[_3300 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[_3300 + 36] = _3255
                mem[_3300 + 68] = 0
                mem[_3300 + 100] = this.address
                mem[_3300 + 132] = 128
                mem[_3300 + 164] = mem[_3300]
                s = 0
                while s < mem[_3300]:
                    mem[s + _3300 + 196] = mem[s + _3300 + 32]
                    s = s + 32
                    continue 
                if ceil32(mem[_3300]) <= mem[_3300]:
                    require ext_code.size(address(_2260))
                    call address(_2260).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_3300]) + _3300 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(_2266))
                    staticcall address(_2266).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3948 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    idx = idx + 2
                    s = mem[_3948] - _2292
                    continue 
                mem[_3300 + mem[_3300] + 196] = 0
                require ext_code.size(address(_2260))
                call address(_2260).mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len ceil32(mem[_3300]) + _3300 + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(_2266))
                staticcall address(_2266).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3980 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                idx = idx + 2
                s = mem[_3980] - _2292
                continue 
            _3184 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            mem[mem[64] + 4] = mem[_3184] - Mask(112, 0, _3125)
            mem[mem[64] + 36] = Mask(112, 0, _3125)
            mem[mem[64] + 68] = Mask(112, 0, _3113)
            require ext_code.size(address(_2252))
            staticcall address(_2252).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                    gas gas_remaining wei
                   args mem[mem[64] + 4], _3125 << 144, Mask(112, 0, _3113)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3248 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _3256 = mem[_3248]
            if address(_2263) == address(_2263):
                _3301 = mem[64]
                mem[mem[64]] = 0
                mem[64] = mem[64] + 32
                mem[_3301 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[_3301 + 36] = 0
                mem[_3301 + 68] = _3256
                mem[_3301 + 100] = this.address
                mem[_3301 + 132] = 128
                mem[_3301 + 164] = mem[_3301]
                s = 0
                while s < mem[_3301]:
                    mem[s + _3301 + 196] = mem[s + _3301 + 32]
                    s = s + 32
                    continue 
                if ceil32(mem[_3301]) <= mem[_3301]:
                    require ext_code.size(address(_2260))
                    call address(_2260).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_3301]) + _3301 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(_2266))
                    staticcall address(_2266).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3949 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    idx = idx + 2
                    s = mem[_3949] - _2292
                    continue 
                mem[_3301 + mem[_3301] + 196] = 0
                require ext_code.size(address(_2260))
                call address(_2260).mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len ceil32(mem[_3301]) + _3301 + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(_2266))
                staticcall address(_2266).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3981 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                idx = idx + 2
                s = mem[_3981] - _2292
                continue 
            _3302 = mem[64]
            mem[mem[64]] = 0
            mem[64] = mem[64] + 32
            mem[_3302 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
            mem[_3302 + 36] = _3256
            mem[_3302 + 68] = 0
            mem[_3302 + 100] = this.address
            mem[_3302 + 132] = 128
            mem[_3302 + 164] = mem[_3302]
            s = 0
            while s < mem[_3302]:
                mem[s + _3302 + 196] = mem[s + _3302 + 32]
                s = s + 32
                continue 
            if ceil32(mem[_3302]) <= mem[_3302]:
                require ext_code.size(address(_2260))
                call address(_2260).mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len ceil32(mem[_3302]) + _3302 + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(_2266))
                staticcall address(_2266).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3950 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                idx = idx + 2
                s = mem[_3950] - _2292
                continue 
            mem[_3302 + mem[_3302] + 196] = 0
            require ext_code.size(address(_2260))
            call address(_2260).mem[mem[64] len 4] with:
                 gas gas_remaining wei
                args mem[mem[64] + 4 len ceil32(mem[_3302]) + _3302 + -mem[64] + 192]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[mem[64] + 4] = this.address
            require ext_code.size(address(_2266))
            staticcall address(_2266).balanceOf(address rg1) with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3982 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            idx = idx + 2
            s = mem[_3982] - _2292
            continue 
        _3106 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 96
        _3114 = mem[_3106]
        require mem[_3106] == mem[_3106 + 18 len 14]
        _3126 = mem[_3106 + 32]
        require mem[_3106 + 32] == mem[_3106 + 50 len 14]
        require mem[_3106 + 64] == mem[_3106 + 92 len 4]
        mem[mem[64] + 4] = address(_2260)
        require ext_code.size(address(_2263))
        staticcall address(_2263).balanceOf(address rg1) with:
                gas gas_remaining wei
               args address(_2260)
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        if address(_2263) != address(_2266):
            _3186 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            mem[mem[64] + 4] = mem[_3186] - Mask(112, 0, _3126)
            mem[mem[64] + 36] = Mask(112, 0, _3126)
            mem[mem[64] + 68] = Mask(112, 0, _3114)
            require ext_code.size(address(_2252))
            staticcall address(_2252).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                    gas gas_remaining wei
                   args mem[mem[64] + 4], _3126 << 144, Mask(112, 0, _3114)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3250 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _3258 = mem[_3250]
            if address(_2263) == address(_2266):
                _3305 = mem[64]
                mem[mem[64]] = 0
                mem[64] = mem[64] + 32
                mem[_3305 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[_3305 + 36] = 0
                mem[_3305 + 68] = _3258
                mem[_3305 + 100] = this.address
                mem[_3305 + 132] = 128
                mem[_3305 + 164] = mem[_3305]
                s = 0
                while s < mem[_3305]:
                    mem[s + _3305 + 196] = mem[s + _3305 + 32]
                    s = s + 32
                    continue 
                if ceil32(mem[_3305]) > mem[_3305]:
                    mem[_3305 + mem[_3305] + 196] = 0
                require ext_code.size(address(_2260))
                call address(_2260).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                     gas gas_remaining wei
                    args 0, _3258, address(this.address), 128, mem[_3305], mem[_3305 + 196 len ceil32(mem[_3305])]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[_3305 + 36] = this.address
                require ext_code.size(address(_2266))
                staticcall address(_2266).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args this.address
                mem[_3305 + 32] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[64] = _3305 + ceil32(return_data.size) + 32
            else:
                _3306 = mem[64]
                mem[mem[64]] = 0
                mem[64] = mem[64] + 32
                mem[_3306 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[_3306 + 36] = _3258
                mem[_3306 + 68] = 0
                mem[_3306 + 100] = this.address
                mem[_3306 + 132] = 128
                mem[_3306 + 164] = mem[_3306]
                s = 0
                while s < mem[_3306]:
                    mem[s + _3306 + 196] = mem[s + _3306 + 32]
                    s = s + 32
                    continue 
                if ceil32(mem[_3306]) > mem[_3306]:
                    mem[_3306 + mem[_3306] + 196] = 0
                require ext_code.size(address(_2260))
                call address(_2260).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                     gas gas_remaining wei
                    args _3258, 0, address(this.address), 128, mem[_3306], mem[_3306 + 196 len ceil32(mem[_3306])]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[_3306 + 36] = this.address
                require ext_code.size(address(_2266))
                staticcall address(_2266).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args this.address
                mem[_3306 + 32] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[64] = _3306 + ceil32(return_data.size) + 32
            require return_data.size >= 32
            idx = idx + 2
            s = ext_call.return_data[0] - _2292
            continue 
        _3185 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        mem[mem[64] + 4] = mem[_3185] - Mask(112, 0, _3114)
        mem[mem[64] + 36] = Mask(112, 0, _3114)
        mem[mem[64] + 68] = Mask(112, 0, _3126)
        require ext_code.size(address(_2252))
        staticcall address(_2252).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                gas gas_remaining wei
               args mem[mem[64] + 4], _3114 << 144, Mask(112, 0, _3126)
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _3249 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _3257 = mem[_3249]
        if address(_2263) == address(_2266):
            _3303 = mem[64]
            mem[mem[64]] = 0
            mem[64] = mem[64] + 32
            mem[_3303 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
            mem[_3303 + 36] = 0
            mem[_3303 + 68] = _3257
            mem[_3303 + 100] = this.address
            mem[_3303 + 132] = 128
            mem[_3303 + 164] = mem[_3303]
            s = 0
            while s < mem[_3303]:
                mem[s + _3303 + 196] = mem[s + _3303 + 32]
                s = s + 32
                continue 
            if ceil32(mem[_3303]) <= mem[_3303]:
                require ext_code.size(address(_2260))
                call address(_2260).mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len ceil32(mem[_3303]) + _3303 + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(_2266))
                staticcall address(_2266).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3951 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                idx = idx + 2
                s = mem[_3951] - _2292
                continue 
            mem[_3303 + mem[_3303] + 196] = 0
            require ext_code.size(address(_2260))
            call address(_2260).mem[mem[64] len 4] with:
                 gas gas_remaining wei
                args mem[mem[64] + 4 len ceil32(mem[_3303]) + _3303 + -mem[64] + 192]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[mem[64] + 4] = this.address
            require ext_code.size(address(_2266))
            staticcall address(_2266).balanceOf(address rg1) with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3983 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            idx = idx + 2
            s = mem[_3983] - _2292
            continue 
        _3304 = mem[64]
        mem[mem[64]] = 0
        mem[64] = mem[64] + 32
        mem[_3304 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[_3304 + 36] = _3257
        mem[_3304 + 68] = 0
        mem[_3304 + 100] = this.address
        mem[_3304 + 132] = 128
        mem[_3304 + 164] = mem[_3304]
        s = 0
        while s < mem[_3304]:
            mem[s + _3304 + 196] = mem[s + _3304 + 32]
            s = s + 32
            continue 
        if ceil32(mem[_3304]) <= mem[_3304]:
            require ext_code.size(address(_2260))
            call address(_2260).mem[mem[64] len 4] with:
                 gas gas_remaining wei
                args mem[mem[64] + 4 len ceil32(mem[_3304]) + _3304 + -mem[64] + 192]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[mem[64] + 4] = this.address
            require ext_code.size(address(_2266))
            staticcall address(_2266).balanceOf(address rg1) with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3952 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            idx = idx + 2
            s = mem[_3952] - _2292
            continue 
        mem[_3304 + mem[_3304] + 196] = 0
        require ext_code.size(address(_2260))
        call address(_2260).mem[mem[64] len 4] with:
             gas gas_remaining wei
            args mem[mem[64] + 4 len ceil32(mem[_3304]) + _3304 + -mem[64] + 192]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[mem[64] + 4] = this.address
        require ext_code.size(address(_2266))
        staticcall address(_2266).balanceOf(address rg1) with:
                gas gas_remaining wei
               args address(this.address)
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _3984 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        idx = idx + 2
        s = mem[_3984] - _2292
        continue 
    if not arg2:
        _2249 = mem[64]
        mem[mem[64] + 36] = msg.sender
        mem[mem[64] + 68] = cd[(arg4 + 36)]
        _2250 = mem[64]
        mem[mem[64]] = 68
        mem[mem[64] + 32 len 4] = transfer(address rg1, uint256 rg2)
        mem[64] = mem[64] + 164
        mem[_2249 + 100] = 32
        mem[_2249 + 132] = 'SafeERC20: low-level call failed'
        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(address(ext_call.return_data[0])):
            revert with 0, 'Address: call to non-contract'
        if not ext_code.hash(address(ext_call.return_data[0])):
            revert with 0, 'Address: call to non-contract'
        _2271 = mem[_2250]
        mem[_2249 + 164 len floor32(mem[_2250])] = mem[_2250 + 32 len floor32(mem[_2250])]
        mem[_2249 + floor32(mem[_2250]) + -(mem[_2250] % 32) + 196 len mem[_2250] % 32] = mem[_2250 + floor32(mem[_2250]) + -(mem[_2250] % 32) + 64 len mem[_2250] % 32]
        call address(ext_call.return_data[0]) with:
             gas gas_remaining wei
            args mem[_2249 + 168 len _2271 - 4]
        if not return_data.size:
            if not ext_call.success:
                if mem[96]:
                    revert with memory
                      from 128
                       len mem[96]
                revert with 0, 'SafeERC20: low-level call failed'
            if mem[96]:
                require mem[96] >= 32
                if not mem[128]:
                    revert with 0, 
                                32,
                                42,
                                0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                mem[_2249 + 274 len 22]
        else:
            mem[_2249 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not ext_call.success:
                if return_data.size:
                    revert with ext_call.return_data[0 len return_data.size]
                revert with 0, 'SafeERC20: low-level call failed'
            if return_data.size:
                require return_data.size >= 32
                if not mem[_2249 + 196]:
                    revert with 0, 
                                32,
                                42,
                                0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                mem[_2249 + ceil32(return_data.size) + 275 len 22]
    else:
        _2255 = mem[64]
        mem[mem[64] + 36] = msg.sender
        mem[mem[64] + 68] = cd[(arg4 + 36)]
        _2256 = mem[64]
        mem[mem[64]] = 68
        mem[mem[64] + 32 len 4] = transfer(address rg1, uint256 rg2)
        mem[64] = mem[64] + 164
        mem[_2255 + 100] = 32
        mem[_2255 + 132] = 'SafeERC20: low-level call failed'
        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(address(ext_call.return_data[0])):
            revert with 0, 'Address: call to non-contract'
        if not ext_code.hash(address(ext_call.return_data[0])):
            revert with 0, 'Address: call to non-contract'
        _2278 = mem[_2256]
        mem[_2255 + 164 len floor32(mem[_2256])] = mem[_2256 + 32 len floor32(mem[_2256])]
        mem[_2255 + floor32(mem[_2256]) + -(mem[_2256] % 32) + 196 len mem[_2256] % 32] = mem[_2256 + floor32(mem[_2256]) + -(mem[_2256] % 32) + 64 len mem[_2256] % 32]
        call address(ext_call.return_data[0]) with:
             gas gas_remaining wei
            args mem[_2255 + 168 len _2278 - 4]
        if not return_data.size:
            if not ext_call.success:
                if mem[96]:
                    revert with memory
                      from 128
                       len mem[96]
                revert with 0, 'SafeERC20: low-level call failed'
            if mem[96]:
                require mem[96] >= 32
                if not mem[128]:
                    revert with 0, 
                                32,
                                42,
                                0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                mem[_2255 + 274 len 22]
        else:
            mem[_2255 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not ext_call.success:
                if return_data.size:
                    revert with ext_call.return_data[0 len return_data.size]
                revert with 0, 'SafeERC20: low-level call failed'
            if return_data.size:
                require return_data.size >= 32
                if not mem[_2255 + 196]:
                    revert with 0, 
                                32,
                                42,
                                0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                mem[_2255 + ceil32(return_data.size) + 275 len 22]
}

function sub_3b1365d8(?) {
    require calldata.size - 4 >= 128
    require cd[4] == address(cd[4])
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    require cd[100] + ('cd', 100).length + 36 <= calldata.size
    require ext_code.size(msg.sender)
    staticcall msg.sender.token0() with:
            gas gas_remaining wei
    mem[96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    require ext_code.size(msg.sender)
    staticcall msg.sender.token1() with:
            gas gas_remaining wei
    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    require ('cd', 100).length >= 96
    require ('cd', 100)[2] <= test266151307()
    require cd[100] + ('cd', 100).length + 36 > cd[100] + ('cd', 100)[2] + 67
    require cd[(cd[100] + ('cd', 100)[2] + 36)] <= test266151307()
    require (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 128 >= 96 and (2 * ceil32(return_data.size)) + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 128 <= test266151307()
    mem[64] = (2 * ceil32(return_data.size)) + (32 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 128
    mem[(2 * ceil32(return_data.size)) + 96] = cd[(cd[100] + ('cd', 100)[2] + 36)]
    require ('cd', 100).length + 36 >= ('cd', 100)[2] + (64 * cd[(cd[100] + ('cd', 100)[2] + 36)]) + 68
    s = cd[100] + ('cd', 100)[2] + 68
    t = (2 * ceil32(return_data.size)) + 128
    idx = 0
    while idx < cd[(cd[100] + ('cd', 100)[2] + 36)]:
        require s + 31 < cd[100] + ('cd', 100).length + 36
        _1499 = mem[64]
        require mem[64] + 64 >= mem[64] and mem[64] + 64 <= test266151307()
        mem[64] = mem[64] + 64
        require s + 64 <= cd[100] + ('cd', 100).length + 36
        u = 0
        v = s
        w = _1499
        while u < 2:
            require cd[v] == address(cd[v])
            mem[w] = cd[v]
            u = u + 1
            v = v + 32
            w = w + 32
            continue 
        mem[t] = _1499
        s = s + 64
        t = t + 32
        idx = idx + 1
        continue 
    require 0 < mem[(2 * ceil32(return_data.size)) + 96]
    require msg.sender == mem[mem[(2 * ceil32(return_data.size)) + 128] + 44 len 20]
    require 3 < mem[(2 * ceil32(return_data.size)) + 96]
    _1503 = mem[mem[(2 * ceil32(return_data.size)) + 224]]
    mem[mem[64] + 4] = this.address
    require ext_code.size(address(_1503))
    staticcall address(_1503).balanceOf(address rg1) with:
            gas gas_remaining wei
           args address(this.address)
    mem[mem[64]] = ext_call.return_data[0]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _1506 = mem[64]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 32
    _2246 = mem[(2 * ceil32(return_data.size)) + 96]
    idx = 2
    s = mem[_1506] - ('cd', 100)[1]
    while idx < _2246:
        require idx < mem[(2 * ceil32(return_data.size)) + 96]
        _2252 = mem[mem[(32 * idx) + (2 * ceil32(return_data.size)) + 128]]
        require idx < mem[(2 * ceil32(return_data.size)) + 96]
        _2260 = mem[mem[(32 * idx) + (2 * ceil32(return_data.size)) + 128] + 32]
        require idx + 1 < mem[(2 * ceil32(return_data.size)) + 96]
        _2263 = mem[mem[(32 * idx + 1) + (2 * ceil32(return_data.size)) + 128]]
        require idx + 1 < mem[(2 * ceil32(return_data.size)) + 96]
        _2266 = mem[mem[(32 * idx + 1) + (2 * ceil32(return_data.size)) + 128] + 32]
        mem[mem[64] + 4] = this.address
        require ext_code.size(address(_2266))
        staticcall address(_2266).balanceOf(address rg1) with:
                gas gas_remaining wei
               args address(this.address)
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _2285 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _2292 = mem[_2285]
        _2305 = mem[64]
        mem[mem[64] + 36] = address(_2260)
        mem[mem[64] + 68] = s
        _2306 = mem[64]
        mem[mem[64]] = 68
        mem[64] = mem[64] + 100
        mem[_2306 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_2306 + 36 len 28]
        mem[64] = _2305 + 164
        mem[_2305 + 100] = 32
        mem[_2305 + 132] = 'SafeERC20: low-level call failed'
        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(address(_2263)):
            revert with 0, 'Address: call to non-contract'
        if not ext_code.hash(address(_2263)):
            revert with 0, 'Address: call to non-contract'
        _2356 = mem[_2306]
        t = _2306 + 32
        u = mem[64]
        s = mem[_2306]
        while s >= 32:
            mem[u] = mem[t]
            t = t + 32
            u = u + 32
            s = s - 32
            continue 
        mem[mem[64] + floor32(mem[_2306])] = mem[_2306 + floor32(mem[_2306]) + -(mem[_2306] % 32) + 64 len mem[_2306] % 32] or Mask(8 * -(mem[_2306] % 32) + 32, -(8 * -(mem[_2306] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_2306])])
        call address(_2263).mem[mem[64] len 4] with:
             gas gas_remaining wei
            args mem[mem[64] + 4 len _2356 + _2305 + -mem[64] + 160]
        if not return_data.size:
            if not ext_call.success:
                if mem[96]:
                    revert with memory
                      from 128
                       len mem[96]
                _3021 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = mem[_2305 + 100]
                _3023 = mem[_2305 + 100]
                idx = 0
                while idx < _3023:
                    mem[idx + _3021 + 68] = mem[idx + _2305 + 132]
                    idx = idx + 32
                    continue 
                if not _3023 % 32:
                    revert with memory
                      from mem[64]
                       len _3023 + _3021 + -mem[64] + 68
                mem[floor32(_3023) + _3021 + 68] = mem[floor32(_3023) + _3021 + -(_3023 % 32) + 100 len _3023 % 32]
                revert with memory
                  from mem[64]
                   len floor32(_3023) + _3021 + -mem[64] + 100
            if not mem[96]:
                require ext_code.size(address(_2260))
                staticcall address(_2260).getReserves() with:
                        gas gas_remaining wei
                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if address(_2263) < address(_2266):
                    _3091 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 96
                    _3107 = mem[_3091]
                    require mem[_3091] == mem[_3091 + 18 len 14]
                    _3115 = mem[_3091 + 32]
                    require mem[_3091 + 32] == mem[_3091 + 50 len 14]
                    require mem[_3091 + 64] == mem[_3091 + 92 len 4]
                    mem[mem[64] + 4] = address(_2260)
                    require ext_code.size(address(_2263))
                    staticcall address(_2263).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(_2260)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if address(_2263) != address(_2263):
                        _3156 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        mem[mem[64] + 4] = mem[_3156] - Mask(112, 0, _3115)
                        mem[mem[64] + 36] = Mask(112, 0, _3115)
                        mem[mem[64] + 68] = Mask(112, 0, _3107)
                        require ext_code.size(address(_2252))
                        staticcall address(_2252).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                                gas gas_remaining wei
                               args mem[mem[64] + 4], _3115 << 144, Mask(112, 0, _3107)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3220 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _3236 = mem[_3220]
                        if address(_2263) == address(_2263):
                            _3261 = mem[64]
                            mem[mem[64]] = 0
                            mem[64] = mem[64] + 32
                            mem[_3261 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                            mem[_3261 + 36] = 0
                            mem[_3261 + 68] = _3236
                            mem[_3261 + 100] = this.address
                            mem[_3261 + 132] = 128
                            mem[_3261 + 164] = mem[_3261]
                            s = 0
                            while s < mem[_3261]:
                                mem[s + _3261 + 196] = mem[s + _3261 + 32]
                                s = s + 32
                                continue 
                            if ceil32(mem[_3261]) > mem[_3261]:
                                mem[_3261 + mem[_3261] + 196] = 0
                            require ext_code.size(address(_2260))
                            call address(_2260).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                                 gas gas_remaining wei
                                args 0, _3236, address(this.address), 128, mem[_3261], mem[_3261 + 196 len ceil32(mem[_3261])]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_3261 + 36] = this.address
                            require ext_code.size(address(_2266))
                            staticcall address(_2266).balanceOf(address rg1) with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[_3261 + 32] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = _3261 + ceil32(return_data.size) + 32
                        else:
                            _3262 = mem[64]
                            mem[mem[64]] = 0
                            mem[64] = mem[64] + 32
                            mem[_3262 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                            mem[_3262 + 36] = _3236
                            mem[_3262 + 68] = 0
                            mem[_3262 + 100] = this.address
                            mem[_3262 + 132] = 128
                            mem[_3262 + 164] = mem[_3262]
                            s = 0
                            while s < mem[_3262]:
                                mem[s + _3262 + 196] = mem[s + _3262 + 32]
                                s = s + 32
                                continue 
                            if ceil32(mem[_3262]) > mem[_3262]:
                                mem[_3262 + mem[_3262] + 196] = 0
                            require ext_code.size(address(_2260))
                            call address(_2260).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                                 gas gas_remaining wei
                                args _3236, 0, address(this.address), 128, mem[_3262], mem[_3262 + 196 len ceil32(mem[_3262])]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_3262 + 36] = this.address
                            require ext_code.size(address(_2266))
                            staticcall address(_2266).balanceOf(address rg1) with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[_3262 + 32] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = _3262 + ceil32(return_data.size) + 32
                        require return_data.size >= 32
                        idx = idx + 2
                        s = ext_call.return_data[0] - _2292
                        continue 
                    _3155 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    mem[mem[64] + 4] = mem[_3155] - Mask(112, 0, _3107)
                    mem[mem[64] + 36] = Mask(112, 0, _3107)
                    mem[mem[64] + 68] = Mask(112, 0, _3115)
                    require ext_code.size(address(_2252))
                    staticcall address(_2252).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                            gas gas_remaining wei
                           args mem[mem[64] + 4], _3107 << 144, Mask(112, 0, _3115)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3219 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _3235 = mem[_3219]
                    if address(_2263) != address(_2263):
                        _3260 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_3260 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_3260 + 36] = _3235
                        mem[_3260 + 68] = 0
                        mem[_3260 + 100] = this.address
                        mem[_3260 + 132] = 128
                        mem[_3260 + 164] = mem[_3260]
                        s = 0
                        while s < mem[_3260]:
                            mem[s + _3260 + 196] = mem[s + _3260 + 32]
                            s = s + 32
                            continue 
                        if ceil32(mem[_3260]) > mem[_3260]:
                            mem[_3260 + mem[_3260] + 196] = 0
                        require ext_code.size(address(_2260))
                        call address(_2260).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                             gas gas_remaining wei
                            args _3235, 0, address(this.address), 128, mem[_3260], mem[_3260 + 196 len ceil32(mem[_3260])]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_3260 + 36] = this.address
                        require ext_code.size(address(_2266))
                        staticcall address(_2266).balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args this.address
                        mem[_3260 + 32] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[64] = _3260 + ceil32(return_data.size) + 32
                        require return_data.size >= 32
                        idx = idx + 2
                        s = ext_call.return_data[0] - _2292
                        continue 
                    _3259 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_3259 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_3259 + 36] = 0
                    mem[_3259 + 68] = _3235
                    mem[_3259 + 100] = this.address
                    mem[_3259 + 132] = 128
                    mem[_3259 + 164] = mem[_3259]
                    s = 0
                    while s < mem[_3259]:
                        mem[s + _3259 + 196] = mem[s + _3259 + 32]
                        s = s + 32
                        continue 
                    if ceil32(mem[_3259]) <= mem[_3259]:
                        require ext_code.size(address(_2260))
                        call address(_2260).mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len ceil32(mem[_3259]) + _3259 + -mem[64] + 192]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(_2266))
                        staticcall address(_2266).balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3923 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        idx = idx + 2
                        s = mem[_3923] - _2292
                        continue 
                    mem[_3259 + mem[_3259] + 196] = 0
                    require ext_code.size(address(_2260))
                    call address(_2260).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_3259]) + _3259 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(_2266))
                    staticcall address(_2266).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3955 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    idx = idx + 2
                    s = mem[_3955] - _2292
                    continue 
                _3092 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 96
                _3108 = mem[_3092]
                require mem[_3092] == mem[_3092 + 18 len 14]
                _3116 = mem[_3092 + 32]
                require mem[_3092 + 32] == mem[_3092 + 50 len 14]
                require mem[_3092 + 64] == mem[_3092 + 92 len 4]
                mem[mem[64] + 4] = address(_2260)
                require ext_code.size(address(_2263))
                staticcall address(_2263).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(_2260)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if address(_2263) == address(_2266):
                    _3157 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    mem[mem[64] + 4] = mem[_3157] - Mask(112, 0, _3108)
                    mem[mem[64] + 36] = Mask(112, 0, _3108)
                    mem[mem[64] + 68] = Mask(112, 0, _3116)
                    require ext_code.size(address(_2252))
                    staticcall address(_2252).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                            gas gas_remaining wei
                           args mem[mem[64] + 4], _3108 << 144, Mask(112, 0, _3116)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3221 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _3237 = mem[_3221]
                    if address(_2263) == address(_2266):
                        _3263 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_3263 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_3263 + 36] = 0
                        mem[_3263 + 68] = _3237
                        mem[_3263 + 100] = this.address
                        mem[_3263 + 132] = 128
                        mem[_3263 + 164] = mem[_3263]
                        s = 0
                        while s < mem[_3263]:
                            mem[s + _3263 + 196] = mem[s + _3263 + 32]
                            s = s + 32
                            continue 
                        if ceil32(mem[_3263]) <= mem[_3263]:
                            require ext_code.size(address(_2260))
                            call address(_2260).mem[mem[64] len 4] with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len ceil32(mem[_3263]) + _3263 + -mem[64] + 192]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(address(_2266))
                            staticcall address(_2266).balanceOf(address rg1) with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _3927 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            idx = idx + 2
                            s = mem[_3927] - _2292
                            continue 
                        mem[_3263 + mem[_3263] + 196] = 0
                        require ext_code.size(address(_2260))
                        call address(_2260).mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len ceil32(mem[_3263]) + _3263 + -mem[64] + 192]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(_2266))
                        staticcall address(_2266).balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3959 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        idx = idx + 2
                        s = mem[_3959] - _2292
                        continue 
                    _3264 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_3264 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_3264 + 36] = _3237
                    mem[_3264 + 68] = 0
                    mem[_3264 + 100] = this.address
                    mem[_3264 + 132] = 128
                    mem[_3264 + 164] = mem[_3264]
                    s = 0
                    while s < mem[_3264]:
                        mem[s + _3264 + 196] = mem[s + _3264 + 32]
                        s = s + 32
                        continue 
                    if ceil32(mem[_3264]) <= mem[_3264]:
                        require ext_code.size(address(_2260))
                        call address(_2260).mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len ceil32(mem[_3264]) + _3264 + -mem[64] + 192]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(_2266))
                        staticcall address(_2266).balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3928 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        idx = idx + 2
                        s = mem[_3928] - _2292
                        continue 
                    mem[_3264 + mem[_3264] + 196] = 0
                    require ext_code.size(address(_2260))
                    call address(_2260).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_3264]) + _3264 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(_2266))
                    staticcall address(_2266).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3960 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    idx = idx + 2
                    s = mem[_3960] - _2292
                    continue 
                _3158 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[mem[64] + 4] = mem[_3158] - Mask(112, 0, _3116)
                mem[mem[64] + 36] = Mask(112, 0, _3116)
                mem[mem[64] + 68] = Mask(112, 0, _3108)
                require ext_code.size(address(_2252))
                staticcall address(_2252).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                        gas gas_remaining wei
                       args mem[mem[64] + 4], _3116 << 144, Mask(112, 0, _3108)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3222 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _3238 = mem[_3222]
                if address(_2263) == address(_2266):
                    _3265 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_3265 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_3265 + 36] = 0
                    mem[_3265 + 68] = _3238
                    mem[_3265 + 100] = this.address
                    mem[_3265 + 132] = 128
                    mem[_3265 + 164] = mem[_3265]
                    s = 0
                    while s < mem[_3265]:
                        mem[s + _3265 + 196] = mem[s + _3265 + 32]
                        s = s + 32
                        continue 
                    if ceil32(mem[_3265]) <= mem[_3265]:
                        require ext_code.size(address(_2260))
                        call address(_2260).mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len ceil32(mem[_3265]) + _3265 + -mem[64] + 192]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(_2266))
                        staticcall address(_2266).balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3929 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        idx = idx + 2
                        s = mem[_3929] - _2292
                        continue 
                    mem[_3265 + mem[_3265] + 196] = 0
                    require ext_code.size(address(_2260))
                    call address(_2260).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_3265]) + _3265 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(_2266))
                    staticcall address(_2266).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3961 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    idx = idx + 2
                    s = mem[_3961] - _2292
                    continue 
                _3266 = mem[64]
                mem[mem[64]] = 0
                mem[64] = mem[64] + 32
                mem[_3266 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[_3266 + 36] = _3238
                mem[_3266 + 68] = 0
                mem[_3266 + 100] = this.address
                mem[_3266 + 132] = 128
                mem[_3266 + 164] = mem[_3266]
                s = 0
                while s < mem[_3266]:
                    mem[s + _3266 + 196] = mem[s + _3266 + 32]
                    s = s + 32
                    continue 
                if ceil32(mem[_3266]) <= mem[_3266]:
                    require ext_code.size(address(_2260))
                    call address(_2260).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_3266]) + _3266 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(_2266))
                    staticcall address(_2266).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3930 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    idx = idx + 2
                    s = mem[_3930] - _2292
                    continue 
                mem[_3266 + mem[_3266] + 196] = 0
                require ext_code.size(address(_2260))
                call address(_2260).mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len ceil32(mem[_3266]) + _3266 + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(_2266))
                staticcall address(_2266).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3962 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                idx = idx + 2
                s = mem[_3962] - _2292
                continue 
            require mem[96] >= 32
            if not mem[128]:
                revert with 0, 
                            32,
                            42,
                            0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                            mem[mem[64] + 110 len 22]
            require ext_code.size(address(_2260))
            staticcall address(_2260).getReserves() with:
                    gas gas_remaining wei
            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if address(_2263) < address(_2266):
                _3103 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 96
                _3111 = mem[_3103]
                require mem[_3103] == mem[_3103 + 18 len 14]
                _3121 = mem[_3103 + 32]
                require mem[_3103 + 32] == mem[_3103 + 50 len 14]
                require mem[_3103 + 64] == mem[_3103 + 92 len 4]
                mem[mem[64] + 4] = address(_2260)
                require ext_code.size(address(_2263))
                staticcall address(_2263).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(_2260)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if address(_2263) == address(_2263):
                    _3175 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    mem[mem[64] + 4] = mem[_3175] - Mask(112, 0, _3111)
                    mem[mem[64] + 36] = Mask(112, 0, _3111)
                    mem[mem[64] + 68] = Mask(112, 0, _3121)
                    require ext_code.size(address(_2252))
                    staticcall address(_2252).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                            gas gas_remaining wei
                           args mem[mem[64] + 4], _3111 << 144, Mask(112, 0, _3121)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3239 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _3251 = mem[_3239]
                    if address(_2263) == address(_2263):
                        _3291 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_3291 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_3291 + 36] = 0
                        mem[_3291 + 68] = _3251
                        mem[_3291 + 100] = this.address
                        mem[_3291 + 132] = 128
                        mem[_3291 + 164] = mem[_3291]
                        s = 0
                        while s < mem[_3291]:
                            mem[s + _3291 + 196] = mem[s + _3291 + 32]
                            s = s + 32
                            continue 
                        if ceil32(mem[_3291]) > mem[_3291]:
                            mem[_3291 + mem[_3291] + 196] = 0
                        require ext_code.size(address(_2260))
                        call address(_2260).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                             gas gas_remaining wei
                            args 0, _3251, address(this.address), 128, mem[_3291], mem[_3291 + 196 len ceil32(mem[_3291])]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_3291 + 36] = this.address
                        require ext_code.size(address(_2266))
                        staticcall address(_2266).balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args this.address
                        mem[_3291 + 32] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[64] = _3291 + ceil32(return_data.size) + 32
                    else:
                        _3292 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_3292 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_3292 + 36] = _3251
                        mem[_3292 + 68] = 0
                        mem[_3292 + 100] = this.address
                        mem[_3292 + 132] = 128
                        mem[_3292 + 164] = mem[_3292]
                        s = 0
                        while s < mem[_3292]:
                            mem[s + _3292 + 196] = mem[s + _3292 + 32]
                            s = s + 32
                            continue 
                        if ceil32(mem[_3292]) > mem[_3292]:
                            mem[_3292 + mem[_3292] + 196] = 0
                        require ext_code.size(address(_2260))
                        call address(_2260).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                             gas gas_remaining wei
                            args _3251, 0, address(this.address), 128, mem[_3292], mem[_3292 + 196 len ceil32(mem[_3292])]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_3292 + 36] = this.address
                        require ext_code.size(address(_2266))
                        staticcall address(_2266).balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args this.address
                        mem[_3292 + 32] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[64] = _3292 + ceil32(return_data.size) + 32
                    require return_data.size >= 32
                    idx = idx + 2
                    s = ext_call.return_data[0] - _2292
                    continue 
                _3176 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[mem[64] + 4] = mem[_3176] - Mask(112, 0, _3121)
                mem[mem[64] + 36] = Mask(112, 0, _3121)
                mem[mem[64] + 68] = Mask(112, 0, _3111)
                require ext_code.size(address(_2252))
                staticcall address(_2252).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                        gas gas_remaining wei
                       args mem[mem[64] + 4], _3121 << 144, Mask(112, 0, _3111)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3240 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _3252 = mem[_3240]
                if address(_2263) != address(_2263):
                    _3294 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_3294 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_3294 + 36] = _3252
                    mem[_3294 + 68] = 0
                    mem[_3294 + 100] = this.address
                    mem[_3294 + 132] = 128
                    mem[_3294 + 164] = mem[_3294]
                    s = 0
                    while s < mem[_3294]:
                        mem[s + _3294 + 196] = mem[s + _3294 + 32]
                        s = s + 32
                        continue 
                    if ceil32(mem[_3294]) > mem[_3294]:
                        mem[_3294 + mem[_3294] + 196] = 0
                    require ext_code.size(address(_2260))
                    call address(_2260).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                         gas gas_remaining wei
                        args _3252, 0, address(this.address), 128, mem[_3294], mem[_3294 + 196 len ceil32(mem[_3294])]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[_3294 + 36] = this.address
                    require ext_code.size(address(_2266))
                    staticcall address(_2266).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args this.address
                    mem[_3294 + 32] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = _3294 + ceil32(return_data.size) + 32
                    require return_data.size >= 32
                    idx = idx + 2
                    s = ext_call.return_data[0] - _2292
                    continue 
                _3293 = mem[64]
                mem[mem[64]] = 0
                mem[64] = mem[64] + 32
                mem[_3293 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[_3293 + 36] = 0
                mem[_3293 + 68] = _3252
                mem[_3293 + 100] = this.address
                mem[_3293 + 132] = 128
                mem[_3293 + 164] = mem[_3293]
                s = 0
                while s < mem[_3293]:
                    mem[s + _3293 + 196] = mem[s + _3293 + 32]
                    s = s + 32
                    continue 
                if ceil32(mem[_3293]) <= mem[_3293]:
                    require ext_code.size(address(_2260))
                    call address(_2260).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_3293]) + _3293 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(_2266))
                    staticcall address(_2266).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3933 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    idx = idx + 2
                    s = mem[_3933] - _2292
                    continue 
                mem[_3293 + mem[_3293] + 196] = 0
                require ext_code.size(address(_2260))
                call address(_2260).mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len ceil32(mem[_3293]) + _3293 + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(_2266))
                staticcall address(_2266).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3965 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                idx = idx + 2
                s = mem[_3965] - _2292
                continue 
            _3104 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 96
            _3112 = mem[_3104]
            require mem[_3104] == mem[_3104 + 18 len 14]
            _3122 = mem[_3104 + 32]
            require mem[_3104 + 32] == mem[_3104 + 50 len 14]
            require mem[_3104 + 64] == mem[_3104 + 92 len 4]
            mem[mem[64] + 4] = address(_2260)
            require ext_code.size(address(_2263))
            staticcall address(_2263).balanceOf(address rg1) with:
                    gas gas_remaining wei
                   args address(_2260)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if address(_2263) == address(_2266):
                _3177 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[mem[64] + 4] = mem[_3177] - Mask(112, 0, _3112)
                mem[mem[64] + 36] = Mask(112, 0, _3112)
                mem[mem[64] + 68] = Mask(112, 0, _3122)
                require ext_code.size(address(_2252))
                staticcall address(_2252).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                        gas gas_remaining wei
                       args mem[mem[64] + 4], _3112 << 144, Mask(112, 0, _3122)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3241 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _3253 = mem[_3241]
                if address(_2263) == address(_2266):
                    _3295 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_3295 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_3295 + 36] = 0
                    mem[_3295 + 68] = _3253
                    mem[_3295 + 100] = this.address
                    mem[_3295 + 132] = 128
                    mem[_3295 + 164] = mem[_3295]
                    s = 0
                    while s < mem[_3295]:
                        mem[s + _3295 + 196] = mem[s + _3295 + 32]
                        s = s + 32
                        continue 
                    if ceil32(mem[_3295]) <= mem[_3295]:
                        require ext_code.size(address(_2260))
                        call address(_2260).mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len ceil32(mem[_3295]) + _3295 + -mem[64] + 192]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(_2266))
                        staticcall address(_2266).balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3935 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        idx = idx + 2
                        s = mem[_3935] - _2292
                        continue 
                    mem[_3295 + mem[_3295] + 196] = 0
                    require ext_code.size(address(_2260))
                    call address(_2260).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_3295]) + _3295 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(_2266))
                    staticcall address(_2266).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3967 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    idx = idx + 2
                    s = mem[_3967] - _2292
                    continue 
                _3296 = mem[64]
                mem[mem[64]] = 0
                mem[64] = mem[64] + 32
                mem[_3296 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[_3296 + 36] = _3253
                mem[_3296 + 68] = 0
                mem[_3296 + 100] = this.address
                mem[_3296 + 132] = 128
                mem[_3296 + 164] = mem[_3296]
                s = 0
                while s < mem[_3296]:
                    mem[s + _3296 + 196] = mem[s + _3296 + 32]
                    s = s + 32
                    continue 
                if ceil32(mem[_3296]) <= mem[_3296]:
                    require ext_code.size(address(_2260))
                    call address(_2260).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_3296]) + _3296 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(_2266))
                    staticcall address(_2266).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3936 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    idx = idx + 2
                    s = mem[_3936] - _2292
                    continue 
                mem[_3296 + mem[_3296] + 196] = 0
                require ext_code.size(address(_2260))
                call address(_2260).mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len ceil32(mem[_3296]) + _3296 + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(_2266))
                staticcall address(_2266).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3968 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                idx = idx + 2
                s = mem[_3968] - _2292
                continue 
            _3178 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            mem[mem[64] + 4] = mem[_3178] - Mask(112, 0, _3122)
            mem[mem[64] + 36] = Mask(112, 0, _3122)
            mem[mem[64] + 68] = Mask(112, 0, _3112)
            require ext_code.size(address(_2252))
            staticcall address(_2252).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                    gas gas_remaining wei
                   args mem[mem[64] + 4], _3122 << 144, Mask(112, 0, _3112)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3242 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _3254 = mem[_3242]
            if address(_2263) == address(_2266):
                _3297 = mem[64]
                mem[mem[64]] = 0
                mem[64] = mem[64] + 32
                mem[_3297 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[_3297 + 36] = 0
                mem[_3297 + 68] = _3254
                mem[_3297 + 100] = this.address
                mem[_3297 + 132] = 128
                mem[_3297 + 164] = mem[_3297]
                s = 0
                while s < mem[_3297]:
                    mem[s + _3297 + 196] = mem[s + _3297 + 32]
                    s = s + 32
                    continue 
                if ceil32(mem[_3297]) > mem[_3297]:
                    mem[_3297 + mem[_3297] + 196] = 0
                require ext_code.size(address(_2260))
                call address(_2260).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                     gas gas_remaining wei
                    args 0, _3254, address(this.address), 128, mem[_3297], mem[_3297 + 196 len ceil32(mem[_3297])]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[_3297 + 36] = this.address
                require ext_code.size(address(_2266))
                staticcall address(_2266).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args this.address
                mem[_3297 + 32] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[64] = _3297 + ceil32(return_data.size) + 32
                require return_data.size >= 32
                idx = idx + 2
                s = ext_call.return_data[0] - _2292
                continue 
            _3298 = mem[64]
            mem[mem[64]] = 0
            mem[64] = mem[64] + 32
            mem[_3298 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
            mem[_3298 + 36] = _3254
            mem[_3298 + 68] = 0
            mem[_3298 + 100] = this.address
            mem[_3298 + 132] = 128
            mem[_3298 + 164] = mem[_3298]
            s = 0
            while s < mem[_3298]:
                mem[s + _3298 + 196] = mem[s + _3298 + 32]
                s = s + 32
                continue 
            if ceil32(mem[_3298]) <= mem[_3298]:
                require ext_code.size(address(_2260))
                call address(_2260).mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len ceil32(mem[_3298]) + _3298 + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(_2266))
                staticcall address(_2266).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3938 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                idx = idx + 2
                s = mem[_3938] - _2292
                continue 
            mem[_3298 + mem[_3298] + 196] = 0
            require ext_code.size(address(_2260))
            call address(_2260).mem[mem[64] len 4] with:
                 gas gas_remaining wei
                args mem[mem[64] + 4 len ceil32(mem[_3298]) + _3298 + -mem[64] + 192]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[mem[64] + 4] = this.address
            require ext_code.size(address(_2266))
            staticcall address(_2266).balanceOf(address rg1) with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3970 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            idx = idx + 2
            s = mem[_3970] - _2292
            continue 
        _2998 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size) + 1
        mem[_2998] = return_data.size
        mem[_2998 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
        if not ext_call.success:
            if return_data.size:
                revert with ext_call.return_data[0 len return_data.size]
            _3025 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = mem[_2305 + 100]
            _3027 = mem[_2305 + 100]
            idx = 0
            while idx < _3027:
                mem[idx + _3025 + 68] = mem[idx + _2305 + 132]
                idx = idx + 32
                continue 
            if not _3027 % 32:
                revert with memory
                  from mem[64]
                   len _3027 + _3025 + -mem[64] + 68
            mem[floor32(_3027) + _3025 + 68] = mem[floor32(_3027) + _3025 + -(_3027 % 32) + 100 len _3027 % 32]
            revert with memory
              from mem[64]
               len floor32(_3027) + _3025 + -mem[64] + 100
        if not return_data.size:
            require ext_code.size(address(_2260))
            staticcall address(_2260).getReserves() with:
                    gas gas_remaining wei
            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if address(_2263) < address(_2266):
                _3097 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 96
                _3109 = mem[_3097]
                require mem[_3097] == mem[_3097 + 18 len 14]
                _3117 = mem[_3097 + 32]
                require mem[_3097 + 32] == mem[_3097 + 50 len 14]
                require mem[_3097 + 64] == mem[_3097 + 92 len 4]
                mem[mem[64] + 4] = address(_2260)
                require ext_code.size(address(_2263))
                staticcall address(_2263).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(_2260)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if address(_2263) == address(_2263):
                    _3163 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    mem[mem[64] + 4] = mem[_3163] - Mask(112, 0, _3109)
                    mem[mem[64] + 36] = Mask(112, 0, _3109)
                    mem[mem[64] + 68] = Mask(112, 0, _3117)
                    require ext_code.size(address(_2252))
                    staticcall address(_2252).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                            gas gas_remaining wei
                           args mem[mem[64] + 4], _3109 << 144, Mask(112, 0, _3117)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3227 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _3243 = mem[_3227]
                    if address(_2263) != address(_2263):
                        _3268 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_3268 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_3268 + 36] = _3243
                        mem[_3268 + 68] = 0
                        mem[_3268 + 100] = this.address
                        mem[_3268 + 132] = 128
                        mem[_3268 + 164] = mem[_3268]
                        s = 0
                        while s < mem[_3268]:
                            mem[s + _3268 + 196] = mem[s + _3268 + 32]
                            s = s + 32
                            continue 
                        if ceil32(mem[_3268]) > mem[_3268]:
                            mem[_3268 + mem[_3268] + 196] = 0
                        require ext_code.size(address(_2260))
                        call address(_2260).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                             gas gas_remaining wei
                            args _3243, 0, address(this.address), 128, mem[_3268], mem[_3268 + 196 len ceil32(mem[_3268])]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_3268 + 36] = this.address
                        require ext_code.size(address(_2266))
                        staticcall address(_2266).balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args this.address
                        mem[_3268 + 32] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[64] = _3268 + ceil32(return_data.size) + 32
                        require return_data.size >= 32
                        idx = idx + 2
                        s = ext_call.return_data[0] - _2292
                        continue 
                    _3267 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_3267 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_3267 + 36] = 0
                    mem[_3267 + 68] = _3243
                    mem[_3267 + 100] = this.address
                    mem[_3267 + 132] = 128
                    mem[_3267 + 164] = mem[_3267]
                    s = 0
                    while s < mem[_3267]:
                        mem[s + _3267 + 196] = mem[s + _3267 + 32]
                        s = s + 32
                        continue 
                    if ceil32(mem[_3267]) <= mem[_3267]:
                        require ext_code.size(address(_2260))
                        call address(_2260).mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len ceil32(mem[_3267]) + _3267 + -mem[64] + 192]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(_2266))
                        staticcall address(_2266).balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3939 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        idx = idx + 2
                        s = mem[_3939] - _2292
                        continue 
                    mem[_3267 + mem[_3267] + 196] = 0
                    require ext_code.size(address(_2260))
                    call address(_2260).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_3267]) + _3267 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(_2266))
                    staticcall address(_2266).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3971 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    idx = idx + 2
                    s = mem[_3971] - _2292
                    continue 
                _3164 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[mem[64] + 4] = mem[_3164] - Mask(112, 0, _3117)
                mem[mem[64] + 36] = Mask(112, 0, _3117)
                mem[mem[64] + 68] = Mask(112, 0, _3109)
                require ext_code.size(address(_2252))
                staticcall address(_2252).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                        gas gas_remaining wei
                       args mem[mem[64] + 4], _3117 << 144, Mask(112, 0, _3109)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3228 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _3244 = mem[_3228]
                if address(_2263) == address(_2263):
                    _3269 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_3269 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_3269 + 36] = 0
                    mem[_3269 + 68] = _3244
                    mem[_3269 + 100] = this.address
                    mem[_3269 + 132] = 128
                    mem[_3269 + 164] = mem[_3269]
                    s = 0
                    while s < mem[_3269]:
                        mem[s + _3269 + 196] = mem[s + _3269 + 32]
                        s = s + 32
                        continue 
                    if ceil32(mem[_3269]) <= mem[_3269]:
                        require ext_code.size(address(_2260))
                        call address(_2260).mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len ceil32(mem[_3269]) + _3269 + -mem[64] + 192]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(_2266))
                        staticcall address(_2266).balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _3941 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        idx = idx + 2
                        s = mem[_3941] - _2292
                        continue 
                    mem[_3269 + mem[_3269] + 196] = 0
                    require ext_code.size(address(_2260))
                    call address(_2260).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_3269]) + _3269 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(_2266))
                    staticcall address(_2266).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3973 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    idx = idx + 2
                    s = mem[_3973] - _2292
                    continue 
                _3270 = mem[64]
                mem[mem[64]] = 0
                mem[64] = mem[64] + 32
                mem[_3270 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[_3270 + 36] = _3244
                mem[_3270 + 68] = 0
                mem[_3270 + 100] = this.address
                mem[_3270 + 132] = 128
                mem[_3270 + 164] = mem[_3270]
                s = 0
                while s < mem[_3270]:
                    mem[s + _3270 + 196] = mem[s + _3270 + 32]
                    s = s + 32
                    continue 
                if ceil32(mem[_3270]) <= mem[_3270]:
                    require ext_code.size(address(_2260))
                    call address(_2260).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_3270]) + _3270 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(_2266))
                    staticcall address(_2266).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3942 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    idx = idx + 2
                    s = mem[_3942] - _2292
                    continue 
                mem[_3270 + mem[_3270] + 196] = 0
                require ext_code.size(address(_2260))
                call address(_2260).mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len ceil32(mem[_3270]) + _3270 + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(_2266))
                staticcall address(_2266).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3974 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                idx = idx + 2
                s = mem[_3974] - _2292
                continue 
            _3098 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 96
            _3110 = mem[_3098]
            require mem[_3098] == mem[_3098 + 18 len 14]
            _3118 = mem[_3098 + 32]
            require mem[_3098 + 32] == mem[_3098 + 50 len 14]
            require mem[_3098 + 64] == mem[_3098 + 92 len 4]
            mem[mem[64] + 4] = address(_2260)
            require ext_code.size(address(_2263))
            staticcall address(_2263).balanceOf(address rg1) with:
                    gas gas_remaining wei
                   args address(_2260)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if address(_2263) == address(_2266):
                _3165 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[mem[64] + 4] = mem[_3165] - Mask(112, 0, _3110)
                mem[mem[64] + 36] = Mask(112, 0, _3110)
                mem[mem[64] + 68] = Mask(112, 0, _3118)
                require ext_code.size(address(_2252))
                staticcall address(_2252).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                        gas gas_remaining wei
                       args mem[mem[64] + 4], _3110 << 144, Mask(112, 0, _3118)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3229 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _3245 = mem[_3229]
                if address(_2263) == address(_2266):
                    _3271 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_3271 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_3271 + 36] = 0
                    mem[_3271 + 68] = _3245
                    mem[_3271 + 100] = this.address
                    mem[_3271 + 132] = 128
                    mem[_3271 + 164] = mem[_3271]
                    s = 0
                    while s < mem[_3271]:
                        mem[s + _3271 + 196] = mem[s + _3271 + 32]
                        s = s + 32
                        continue 
                    if ceil32(mem[_3271]) > mem[_3271]:
                        mem[_3271 + mem[_3271] + 196] = 0
                    require ext_code.size(address(_2260))
                    call address(_2260).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                         gas gas_remaining wei
                        args 0, _3245, address(this.address), 128, mem[_3271], mem[_3271 + 196 len ceil32(mem[_3271])]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[_3271 + 36] = this.address
                    require ext_code.size(address(_2266))
                    staticcall address(_2266).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args this.address
                    mem[_3271 + 32] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = _3271 + ceil32(return_data.size) + 32
                else:
                    _3272 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_3272 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_3272 + 36] = _3245
                    mem[_3272 + 68] = 0
                    mem[_3272 + 100] = this.address
                    mem[_3272 + 132] = 128
                    mem[_3272 + 164] = mem[_3272]
                    s = 0
                    while s < mem[_3272]:
                        mem[s + _3272 + 196] = mem[s + _3272 + 32]
                        s = s + 32
                        continue 
                    if ceil32(mem[_3272]) > mem[_3272]:
                        mem[_3272 + mem[_3272] + 196] = 0
                    require ext_code.size(address(_2260))
                    call address(_2260).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                         gas gas_remaining wei
                        args _3245, 0, address(this.address), 128, mem[_3272], mem[_3272 + 196 len ceil32(mem[_3272])]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[_3272 + 36] = this.address
                    require ext_code.size(address(_2266))
                    staticcall address(_2266).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args this.address
                    mem[_3272 + 32] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = _3272 + ceil32(return_data.size) + 32
                require return_data.size >= 32
                idx = idx + 2
                s = ext_call.return_data[0] - _2292
                continue 
            _3166 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            mem[mem[64] + 4] = mem[_3166] - Mask(112, 0, _3118)
            mem[mem[64] + 36] = Mask(112, 0, _3118)
            mem[mem[64] + 68] = Mask(112, 0, _3110)
            require ext_code.size(address(_2252))
            staticcall address(_2252).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                    gas gas_remaining wei
                   args mem[mem[64] + 4], _3118 << 144, Mask(112, 0, _3110)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3230 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _3246 = mem[_3230]
            if address(_2263) == address(_2266):
                _3273 = mem[64]
                mem[mem[64]] = 0
                mem[64] = mem[64] + 32
                mem[_3273 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[_3273 + 36] = 0
                mem[_3273 + 68] = _3246
                mem[_3273 + 100] = this.address
                mem[_3273 + 132] = 128
                mem[_3273 + 164] = mem[_3273]
                s = 0
                while s < mem[_3273]:
                    mem[s + _3273 + 196] = mem[s + _3273 + 32]
                    s = s + 32
                    continue 
                if ceil32(mem[_3273]) <= mem[_3273]:
                    require ext_code.size(address(_2260))
                    call address(_2260).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_3273]) + _3273 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(_2266))
                    staticcall address(_2266).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3945 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    idx = idx + 2
                    s = mem[_3945] - _2292
                    continue 
                mem[_3273 + mem[_3273] + 196] = 0
                require ext_code.size(address(_2260))
                call address(_2260).mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len ceil32(mem[_3273]) + _3273 + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(_2266))
                staticcall address(_2266).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3977 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                idx = idx + 2
                s = mem[_3977] - _2292
                continue 
            _3274 = mem[64]
            mem[mem[64]] = 0
            mem[64] = mem[64] + 32
            mem[_3274 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
            mem[_3274 + 36] = _3246
            mem[_3274 + 68] = 0
            mem[_3274 + 100] = this.address
            mem[_3274 + 132] = 128
            mem[_3274 + 164] = mem[_3274]
            s = 0
            while s < mem[_3274]:
                mem[s + _3274 + 196] = mem[s + _3274 + 32]
                s = s + 32
                continue 
            if ceil32(mem[_3274]) <= mem[_3274]:
                require ext_code.size(address(_2260))
                call address(_2260).mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len ceil32(mem[_3274]) + _3274 + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(_2266))
                staticcall address(_2266).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3946 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                idx = idx + 2
                s = mem[_3946] - _2292
                continue 
            mem[_3274 + mem[_3274] + 196] = 0
            require ext_code.size(address(_2260))
            call address(_2260).mem[mem[64] len 4] with:
                 gas gas_remaining wei
                args mem[mem[64] + 4 len ceil32(mem[_3274]) + _3274 + -mem[64] + 192]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[mem[64] + 4] = this.address
            require ext_code.size(address(_2266))
            staticcall address(_2266).balanceOf(address rg1) with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3978 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            idx = idx + 2
            s = mem[_3978] - _2292
            continue 
        require return_data.size >= 32
        if not mem[_2998 + 32]:
            revert with 0, 
                        32,
                        42,
                        0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                        mem[mem[64] + 110 len 22]
        require ext_code.size(address(_2260))
        staticcall address(_2260).getReserves() with:
                gas gas_remaining wei
        mem[mem[64] len 96] = ext_call.return_data[0 len 96]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        if address(_2263) < address(_2266):
            _3105 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 96
            _3113 = mem[_3105]
            require mem[_3105] == mem[_3105 + 18 len 14]
            _3125 = mem[_3105 + 32]
            require mem[_3105 + 32] == mem[_3105 + 50 len 14]
            require mem[_3105 + 64] == mem[_3105 + 92 len 4]
            mem[mem[64] + 4] = address(_2260)
            require ext_code.size(address(_2263))
            staticcall address(_2263).balanceOf(address rg1) with:
                    gas gas_remaining wei
                   args address(_2260)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if address(_2263) == address(_2263):
                _3183 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[mem[64] + 4] = mem[_3183] - Mask(112, 0, _3113)
                mem[mem[64] + 36] = Mask(112, 0, _3113)
                mem[mem[64] + 68] = Mask(112, 0, _3125)
                require ext_code.size(address(_2252))
                staticcall address(_2252).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                        gas gas_remaining wei
                       args mem[mem[64] + 4], _3113 << 144, Mask(112, 0, _3125)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3247 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _3255 = mem[_3247]
                if address(_2263) == address(_2263):
                    _3299 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_3299 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_3299 + 36] = 0
                    mem[_3299 + 68] = _3255
                    mem[_3299 + 100] = this.address
                    mem[_3299 + 132] = 128
                    mem[_3299 + 164] = mem[_3299]
                    s = 0
                    while s < mem[_3299]:
                        mem[s + _3299 + 196] = mem[s + _3299 + 32]
                        s = s + 32
                        continue 
                    if ceil32(mem[_3299]) > mem[_3299]:
                        mem[_3299 + mem[_3299] + 196] = 0
                    require ext_code.size(address(_2260))
                    call address(_2260).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                         gas gas_remaining wei
                        args 0, _3255, address(this.address), 128, mem[_3299], mem[_3299 + 196 len ceil32(mem[_3299])]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[_3299 + 36] = this.address
                    require ext_code.size(address(_2266))
                    staticcall address(_2266).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args this.address
                    mem[_3299 + 32] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = _3299 + ceil32(return_data.size) + 32
                    require return_data.size >= 32
                    idx = idx + 2
                    s = ext_call.return_data[0] - _2292
                    continue 
                _3300 = mem[64]
                mem[mem[64]] = 0
                mem[64] = mem[64] + 32
                mem[_3300 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[_3300 + 36] = _3255
                mem[_3300 + 68] = 0
                mem[_3300 + 100] = this.address
                mem[_3300 + 132] = 128
                mem[_3300 + 164] = mem[_3300]
                s = 0
                while s < mem[_3300]:
                    mem[s + _3300 + 196] = mem[s + _3300 + 32]
                    s = s + 32
                    continue 
                if ceil32(mem[_3300]) <= mem[_3300]:
                    require ext_code.size(address(_2260))
                    call address(_2260).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_3300]) + _3300 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(_2266))
                    staticcall address(_2266).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3948 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    idx = idx + 2
                    s = mem[_3948] - _2292
                    continue 
                mem[_3300 + mem[_3300] + 196] = 0
                require ext_code.size(address(_2260))
                call address(_2260).mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len ceil32(mem[_3300]) + _3300 + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(_2266))
                staticcall address(_2266).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3980 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                idx = idx + 2
                s = mem[_3980] - _2292
                continue 
            _3184 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            mem[mem[64] + 4] = mem[_3184] - Mask(112, 0, _3125)
            mem[mem[64] + 36] = Mask(112, 0, _3125)
            mem[mem[64] + 68] = Mask(112, 0, _3113)
            require ext_code.size(address(_2252))
            staticcall address(_2252).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                    gas gas_remaining wei
                   args mem[mem[64] + 4], _3125 << 144, Mask(112, 0, _3113)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3248 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _3256 = mem[_3248]
            if address(_2263) == address(_2263):
                _3301 = mem[64]
                mem[mem[64]] = 0
                mem[64] = mem[64] + 32
                mem[_3301 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[_3301 + 36] = 0
                mem[_3301 + 68] = _3256
                mem[_3301 + 100] = this.address
                mem[_3301 + 132] = 128
                mem[_3301 + 164] = mem[_3301]
                s = 0
                while s < mem[_3301]:
                    mem[s + _3301 + 196] = mem[s + _3301 + 32]
                    s = s + 32
                    continue 
                if ceil32(mem[_3301]) <= mem[_3301]:
                    require ext_code.size(address(_2260))
                    call address(_2260).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_3301]) + _3301 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(_2266))
                    staticcall address(_2266).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3949 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    idx = idx + 2
                    s = mem[_3949] - _2292
                    continue 
                mem[_3301 + mem[_3301] + 196] = 0
                require ext_code.size(address(_2260))
                call address(_2260).mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len ceil32(mem[_3301]) + _3301 + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(_2266))
                staticcall address(_2266).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3981 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                idx = idx + 2
                s = mem[_3981] - _2292
                continue 
            _3302 = mem[64]
            mem[mem[64]] = 0
            mem[64] = mem[64] + 32
            mem[_3302 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
            mem[_3302 + 36] = _3256
            mem[_3302 + 68] = 0
            mem[_3302 + 100] = this.address
            mem[_3302 + 132] = 128
            mem[_3302 + 164] = mem[_3302]
            s = 0
            while s < mem[_3302]:
                mem[s + _3302 + 196] = mem[s + _3302 + 32]
                s = s + 32
                continue 
            if ceil32(mem[_3302]) <= mem[_3302]:
                require ext_code.size(address(_2260))
                call address(_2260).mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len ceil32(mem[_3302]) + _3302 + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(_2266))
                staticcall address(_2266).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3950 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                idx = idx + 2
                s = mem[_3950] - _2292
                continue 
            mem[_3302 + mem[_3302] + 196] = 0
            require ext_code.size(address(_2260))
            call address(_2260).mem[mem[64] len 4] with:
                 gas gas_remaining wei
                args mem[mem[64] + 4 len ceil32(mem[_3302]) + _3302 + -mem[64] + 192]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[mem[64] + 4] = this.address
            require ext_code.size(address(_2266))
            staticcall address(_2266).balanceOf(address rg1) with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3982 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            idx = idx + 2
            s = mem[_3982] - _2292
            continue 
        _3106 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 96
        _3114 = mem[_3106]
        require mem[_3106] == mem[_3106 + 18 len 14]
        _3126 = mem[_3106 + 32]
        require mem[_3106 + 32] == mem[_3106 + 50 len 14]
        require mem[_3106 + 64] == mem[_3106 + 92 len 4]
        mem[mem[64] + 4] = address(_2260)
        require ext_code.size(address(_2263))
        staticcall address(_2263).balanceOf(address rg1) with:
                gas gas_remaining wei
               args address(_2260)
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        if address(_2263) != address(_2266):
            _3186 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            mem[mem[64] + 4] = mem[_3186] - Mask(112, 0, _3126)
            mem[mem[64] + 36] = Mask(112, 0, _3126)
            mem[mem[64] + 68] = Mask(112, 0, _3114)
            require ext_code.size(address(_2252))
            staticcall address(_2252).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                    gas gas_remaining wei
                   args mem[mem[64] + 4], _3126 << 144, Mask(112, 0, _3114)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3250 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _3258 = mem[_3250]
            if address(_2263) == address(_2266):
                _3305 = mem[64]
                mem[mem[64]] = 0
                mem[64] = mem[64] + 32
                mem[_3305 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[_3305 + 36] = 0
                mem[_3305 + 68] = _3258
                mem[_3305 + 100] = this.address
                mem[_3305 + 132] = 128
                mem[_3305 + 164] = mem[_3305]
                s = 0
                while s < mem[_3305]:
                    mem[s + _3305 + 196] = mem[s + _3305 + 32]
                    s = s + 32
                    continue 
                if ceil32(mem[_3305]) > mem[_3305]:
                    mem[_3305 + mem[_3305] + 196] = 0
                require ext_code.size(address(_2260))
                call address(_2260).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                     gas gas_remaining wei
                    args 0, _3258, address(this.address), 128, mem[_3305], mem[_3305 + 196 len ceil32(mem[_3305])]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[_3305 + 36] = this.address
                require ext_code.size(address(_2266))
                staticcall address(_2266).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args this.address
                mem[_3305 + 32] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[64] = _3305 + ceil32(return_data.size) + 32
            else:
                _3306 = mem[64]
                mem[mem[64]] = 0
                mem[64] = mem[64] + 32
                mem[_3306 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[_3306 + 36] = _3258
                mem[_3306 + 68] = 0
                mem[_3306 + 100] = this.address
                mem[_3306 + 132] = 128
                mem[_3306 + 164] = mem[_3306]
                s = 0
                while s < mem[_3306]:
                    mem[s + _3306 + 196] = mem[s + _3306 + 32]
                    s = s + 32
                    continue 
                if ceil32(mem[_3306]) > mem[_3306]:
                    mem[_3306 + mem[_3306] + 196] = 0
                require ext_code.size(address(_2260))
                call address(_2260).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                     gas gas_remaining wei
                    args _3258, 0, address(this.address), 128, mem[_3306], mem[_3306 + 196 len ceil32(mem[_3306])]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[_3306 + 36] = this.address
                require ext_code.size(address(_2266))
                staticcall address(_2266).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args this.address
                mem[_3306 + 32] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[64] = _3306 + ceil32(return_data.size) + 32
            require return_data.size >= 32
            idx = idx + 2
            s = ext_call.return_data[0] - _2292
            continue 
        _3185 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        mem[mem[64] + 4] = mem[_3185] - Mask(112, 0, _3114)
        mem[mem[64] + 36] = Mask(112, 0, _3114)
        mem[mem[64] + 68] = Mask(112, 0, _3126)
        require ext_code.size(address(_2252))
        staticcall address(_2252).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                gas gas_remaining wei
               args mem[mem[64] + 4], _3114 << 144, Mask(112, 0, _3126)
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _3249 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _3257 = mem[_3249]
        if address(_2263) == address(_2266):
            _3303 = mem[64]
            mem[mem[64]] = 0
            mem[64] = mem[64] + 32
            mem[_3303 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
            mem[_3303 + 36] = 0
            mem[_3303 + 68] = _3257
            mem[_3303 + 100] = this.address
            mem[_3303 + 132] = 128
            mem[_3303 + 164] = mem[_3303]
            s = 0
            while s < mem[_3303]:
                mem[s + _3303 + 196] = mem[s + _3303 + 32]
                s = s + 32
                continue 
            if ceil32(mem[_3303]) <= mem[_3303]:
                require ext_code.size(address(_2260))
                call address(_2260).mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len ceil32(mem[_3303]) + _3303 + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(_2266))
                staticcall address(_2266).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3951 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                idx = idx + 2
                s = mem[_3951] - _2292
                continue 
            mem[_3303 + mem[_3303] + 196] = 0
            require ext_code.size(address(_2260))
            call address(_2260).mem[mem[64] len 4] with:
                 gas gas_remaining wei
                args mem[mem[64] + 4 len ceil32(mem[_3303]) + _3303 + -mem[64] + 192]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[mem[64] + 4] = this.address
            require ext_code.size(address(_2266))
            staticcall address(_2266).balanceOf(address rg1) with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3983 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            idx = idx + 2
            s = mem[_3983] - _2292
            continue 
        _3304 = mem[64]
        mem[mem[64]] = 0
        mem[64] = mem[64] + 32
        mem[_3304 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
        mem[_3304 + 36] = _3257
        mem[_3304 + 68] = 0
        mem[_3304 + 100] = this.address
        mem[_3304 + 132] = 128
        mem[_3304 + 164] = mem[_3304]
        s = 0
        while s < mem[_3304]:
            mem[s + _3304 + 196] = mem[s + _3304 + 32]
            s = s + 32
            continue 
        if ceil32(mem[_3304]) <= mem[_3304]:
            require ext_code.size(address(_2260))
            call address(_2260).mem[mem[64] len 4] with:
                 gas gas_remaining wei
                args mem[mem[64] + 4 len ceil32(mem[_3304]) + _3304 + -mem[64] + 192]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[mem[64] + 4] = this.address
            require ext_code.size(address(_2266))
            staticcall address(_2266).balanceOf(address rg1) with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3952 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            idx = idx + 2
            s = mem[_3952] - _2292
            continue 
        mem[_3304 + mem[_3304] + 196] = 0
        require ext_code.size(address(_2260))
        call address(_2260).mem[mem[64] len 4] with:
             gas gas_remaining wei
            args mem[mem[64] + 4 len ceil32(mem[_3304]) + _3304 + -mem[64] + 192]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[mem[64] + 4] = this.address
        require ext_code.size(address(_2266))
        staticcall address(_2266).balanceOf(address rg1) with:
                gas gas_remaining wei
               args address(this.address)
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _3984 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        idx = idx + 2
        s = mem[_3984] - _2292
        continue 
    if not cd[36]:
        _2249 = mem[64]
        mem[mem[64] + 36] = msg.sender
        mem[mem[64] + 68] = ('cd', 100)[0]
        _2250 = mem[64]
        mem[mem[64]] = 68
        mem[mem[64] + 32 len 4] = transfer(address rg1, uint256 rg2)
        mem[64] = mem[64] + 164
        mem[_2249 + 100] = 32
        mem[_2249 + 132] = 'SafeERC20: low-level call failed'
        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(address(ext_call.return_data[0])):
            revert with 0, 'Address: call to non-contract'
        if not ext_code.hash(address(ext_call.return_data[0])):
            revert with 0, 'Address: call to non-contract'
        _2271 = mem[_2250]
        mem[_2249 + 164 len floor32(mem[_2250])] = mem[_2250 + 32 len floor32(mem[_2250])]
        mem[_2249 + floor32(mem[_2250]) + -(mem[_2250] % 32) + 196 len mem[_2250] % 32] = mem[_2250 + floor32(mem[_2250]) + -(mem[_2250] % 32) + 64 len mem[_2250] % 32]
        call address(ext_call.return_data[0]) with:
             gas gas_remaining wei
            args mem[_2249 + 168 len _2271 - 4]
        if not return_data.size:
            if not ext_call.success:
                if mem[96]:
                    revert with memory
                      from 128
                       len mem[96]
                revert with 0, 'SafeERC20: low-level call failed'
            if mem[96]:
                require mem[96] >= 32
                if not mem[128]:
                    revert with 0, 
                                32,
                                42,
                                0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                mem[_2249 + 274 len 22]
        else:
            mem[_2249 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not ext_call.success:
                if return_data.size:
                    revert with ext_call.return_data[0 len return_data.size]
                revert with 0, 'SafeERC20: low-level call failed'
            if return_data.size:
                require return_data.size >= 32
                if not mem[_2249 + 196]:
                    revert with 0, 
                                32,
                                42,
                                0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                mem[_2249 + ceil32(return_data.size) + 275 len 22]
    else:
        _2255 = mem[64]
        mem[mem[64] + 36] = msg.sender
        mem[mem[64] + 68] = ('cd', 100)[0]
        _2256 = mem[64]
        mem[mem[64]] = 68
        mem[mem[64] + 32 len 4] = transfer(address rg1, uint256 rg2)
        mem[64] = mem[64] + 164
        mem[_2255 + 100] = 32
        mem[_2255 + 132] = 'SafeERC20: low-level call failed'
        if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(address(ext_call.return_data[0])):
            revert with 0, 'Address: call to non-contract'
        if not ext_code.hash(address(ext_call.return_data[0])):
            revert with 0, 'Address: call to non-contract'
        _2278 = mem[_2256]
        mem[_2255 + 164 len floor32(mem[_2256])] = mem[_2256 + 32 len floor32(mem[_2256])]
        mem[_2255 + floor32(mem[_2256]) + -(mem[_2256] % 32) + 196 len mem[_2256] % 32] = mem[_2256 + floor32(mem[_2256]) + -(mem[_2256] % 32) + 64 len mem[_2256] % 32]
        call address(ext_call.return_data[0]) with:
             gas gas_remaining wei
            args mem[_2255 + 168 len _2278 - 4]
        if not return_data.size:
            if not ext_call.success:
                if mem[96]:
                    revert with memory
                      from 128
                       len mem[96]
                revert with 0, 'SafeERC20: low-level call failed'
            if mem[96]:
                require mem[96] >= 32
                if not mem[128]:
                    revert with 0, 
                                32,
                                42,
                                0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                mem[_2255 + 274 len 22]
        else:
            mem[_2255 + 196 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not ext_call.success:
                if return_data.size:
                    revert with ext_call.return_data[0 len return_data.size]
                revert with 0, 'SafeERC20: low-level call failed'
            if return_data.size:
                require return_data.size >= 32
                if not mem[_2255 + 196]:
                    revert with 0, 
                                32,
                                42,
                                0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                mem[_2255 + ceil32(return_data.size) + 275 len 22]
}

function sub_f29ad6fe(?) payable {
    mem[64] = 96
    require not msg.value
    require calldata.size - 4 >= 64
    require cd[4] <= test266151307()
    require cd[4] + 35 < calldata.size
    require ('cd', 4).length <= test266151307()
    require cd[4] + (32 * ('cd', 4).length) + 36 <= calldata.size
    require cd[36] <= test266151307()
    require cd[36] + 35 < calldata.size
    require ('cd', 36).length <= test266151307()
    require cd[36] + (32 * ('cd', 36).length) + 36 <= calldata.size
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    idx = 0
    while idx < ('cd', 4).length:
        require cd[(cd[4] + (32 * idx) + 36)] < calldata.size + -cd[4] - 67
        require cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 36)] <= test266151307()
        require cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68 <= calldata.size - (64 * cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 36)])
        require idx < ('cd', 36).length
        if owner != msg.sender:
            revert with 0, 'Ownable: caller is not the owner'
        s = 0
        t = cd[((32 * idx) + cd[36] + 36)]
        while s < cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 36)]:
            require cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)] == address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)])
            require s < cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 36)]
            require cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)] == address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)])
            require s + 1 < cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 36)]
            require cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)] == address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)])
            require s + 1 < cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 36)]
            require cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)] == address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)])
            mem[mem[64] + 4] = this.address
            require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
            staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).balanceOf(address rg1) with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1287 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _1288 = mem[_1287]
            _1289 = mem[64]
            mem[mem[64] + 36] = address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)])
            mem[mem[64] + 68] = t
            _1290 = mem[64]
            mem[mem[64]] = 68
            mem[64] = mem[64] + 100
            mem[_1290 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_1290 + 36 len 28]
            mem[64] = _1289 + 164
            mem[_1289 + 100] = 32
            mem[_1289 + 132] = 'SafeERC20: low-level call failed'
            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)])):
                revert with 0, 'Address: call to non-contract'
            if not ext_code.hash(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)])):
                revert with 0, 'Address: call to non-contract'
            _1296 = mem[_1290]
            u = _1290 + 32
            v = mem[64]
            t = mem[_1290]
            while t >= 32:
                mem[v] = mem[u]
                u = u + 32
                v = v + 32
                t = t - 32
                continue 
            mem[mem[64] + floor32(mem[_1290])] = mem[_1290 + floor32(mem[_1290]) + -(mem[_1290] % 32) + 64 len mem[_1290] % 32] or Mask(8 * -(mem[_1290] % 32) + 32, -(8 * -(mem[_1290] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_1290])])
            call address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]).mem[mem[64] len 4] with:
                 gas gas_remaining wei
                args mem[mem[64] + 4 len _1296 + _1289 + -mem[64] + 160]
            if not return_data.size:
                if not ext_call.success:
                    if mem[96]:
                        revert with memory
                          from 128
                           len mem[96]
                    _1931 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = mem[_1289 + 100]
                    _1933 = mem[_1289 + 100]
                    idx = 0
                    while idx < _1933:
                        mem[idx + _1931 + 68] = mem[idx + _1289 + 132]
                        idx = idx + 32
                        continue 
                    if not _1933 % 32:
                        revert with memory
                          from mem[64]
                           len _1933 + _1931 + -mem[64] + 68
                    mem[floor32(_1933) + _1931 + 68] = mem[floor32(_1933) + _1931 + -(_1933 % 32) + 100 len _1933 % 32]
                    revert with memory
                      from mem[64]
                       len floor32(_1933) + _1931 + -mem[64] + 100
                if not mem[96]:
                    require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                    staticcall address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).getReserves() with:
                            gas gas_remaining wei
                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]) < address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]):
                        _1965 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 96
                        _1981 = mem[_1965]
                        require mem[_1965] == mem[_1965 + 18 len 14]
                        _1989 = mem[_1965 + 32]
                        require mem[_1965 + 32] == mem[_1965 + 50 len 14]
                        require mem[_1965 + 64] == mem[_1965 + 92 len 4]
                        mem[mem[64] + 4] = address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)])
                        require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]))
                        staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]).balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)])
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]) == address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]):
                            _2029 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            mem[mem[64] + 4] = mem[_2029] - Mask(112, 0, _1981)
                            mem[mem[64] + 36] = Mask(112, 0, _1981)
                            mem[mem[64] + 68] = Mask(112, 0, _1989)
                            require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]))
                            staticcall address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4], _1981 << 144, Mask(112, 0, _1989)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2093 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _2109 = mem[_2093]
                            if address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]) != address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]):
                                _2134 = mem[64]
                                mem[mem[64]] = 0
                                mem[64] = mem[64] + 32
                                mem[_2134 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                mem[_2134 + 36] = _2109
                                mem[_2134 + 68] = 0
                                mem[_2134 + 100] = this.address
                                mem[_2134 + 132] = 128
                                mem[_2134 + 164] = mem[_2134]
                                t = 0
                                while t < mem[_2134]:
                                    mem[t + _2134 + 196] = mem[t + _2134 + 32]
                                    t = t + 32
                                    continue 
                                if ceil32(mem[_2134]) > mem[_2134]:
                                    mem[_2134 + mem[_2134] + 196] = 0
                                require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                                call address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                                     gas gas_remaining wei
                                    args _2109, 0, address(this.address), 128, mem[_2134], mem[_2134 + 196 len ceil32(mem[_2134])]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[_2134 + 36] = this.address
                                require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                                staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).balanceOf(address rg1) with:
                                        gas gas_remaining wei
                                       args this.address
                                mem[_2134 + 32] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = _2134 + ceil32(return_data.size) + 32
                                require return_data.size >= 32
                                s = s + 2
                                t = ext_call.return_data[0] - _1288
                                continue 
                            _2133 = mem[64]
                            mem[mem[64]] = 0
                            mem[64] = mem[64] + 32
                            mem[_2133 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                            mem[_2133 + 36] = 0
                            mem[_2133 + 68] = _2109
                            mem[_2133 + 100] = this.address
                            mem[_2133 + 132] = 128
                            mem[_2133 + 164] = mem[_2133]
                            t = 0
                            while t < mem[_2133]:
                                mem[t + _2133 + 196] = mem[t + _2133 + 32]
                                t = t + 32
                                continue 
                            if ceil32(mem[_2133]) <= mem[_2133]:
                                require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                                call address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).mem[mem[64] len 4] with:
                                     gas gas_remaining wei
                                    args mem[mem[64] + 4 len ceil32(mem[_2133]) + _2133 + -mem[64] + 192]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[mem[64] + 4] = this.address
                                require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                                staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).balanceOf(address rg1) with:
                                        gas gas_remaining wei
                                       args address(this.address)
                                mem[mem[64]] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _2781 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 32
                                s = s + 2
                                t = mem[_2781] - _1288
                                continue 
                            mem[_2133 + mem[_2133] + 196] = 0
                            require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                            call address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).mem[mem[64] len 4] with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len ceil32(mem[_2133]) + _2133 + -mem[64] + 192]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                            staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).balanceOf(address rg1) with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2813 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            s = s + 2
                            t = mem[_2813] - _1288
                            continue 
                        _2030 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        mem[mem[64] + 4] = mem[_2030] - Mask(112, 0, _1989)
                        mem[mem[64] + 36] = Mask(112, 0, _1989)
                        mem[mem[64] + 68] = Mask(112, 0, _1981)
                        require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]))
                        staticcall address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                                gas gas_remaining wei
                               args mem[mem[64] + 4], _1989 << 144, Mask(112, 0, _1981)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2094 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2110 = mem[_2094]
                        if address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]) == address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]):
                            _2135 = mem[64]
                            mem[mem[64]] = 0
                            mem[64] = mem[64] + 32
                            mem[_2135 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                            mem[_2135 + 36] = 0
                            mem[_2135 + 68] = _2110
                            mem[_2135 + 100] = this.address
                            mem[_2135 + 132] = 128
                            mem[_2135 + 164] = mem[_2135]
                            t = 0
                            while t < mem[_2135]:
                                mem[t + _2135 + 196] = mem[t + _2135 + 32]
                                t = t + 32
                                continue 
                            if ceil32(mem[_2135]) > mem[_2135]:
                                mem[_2135 + mem[_2135] + 196] = 0
                            require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                            call address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                                 gas gas_remaining wei
                                args 0, _2110, address(this.address), 128, mem[_2135], mem[_2135 + 196 len ceil32(mem[_2135])]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_2135 + 36] = this.address
                            require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                            staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).balanceOf(address rg1) with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[_2135 + 32] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = _2135 + ceil32(return_data.size) + 32
                            require return_data.size >= 32
                            s = s + 2
                            t = ext_call.return_data[0] - _1288
                            continue 
                        _2136 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_2136 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_2136 + 36] = _2110
                        mem[_2136 + 68] = 0
                        mem[_2136 + 100] = this.address
                        mem[_2136 + 132] = 128
                        mem[_2136 + 164] = mem[_2136]
                        t = 0
                        while t < mem[_2136]:
                            mem[t + _2136 + 196] = mem[t + _2136 + 32]
                            t = t + 32
                            continue 
                        if ceil32(mem[_2136]) <= mem[_2136]:
                            require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                            call address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).mem[mem[64] len 4] with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len ceil32(mem[_2136]) + _2136 + -mem[64] + 192]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                            staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).balanceOf(address rg1) with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2784 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            s = s + 2
                            t = mem[_2784] - _1288
                            continue 
                        mem[_2136 + mem[_2136] + 196] = 0
                        require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                        call address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len ceil32(mem[_2136]) + _2136 + -mem[64] + 192]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                        staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2816 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        s = s + 2
                        t = mem[_2816] - _1288
                        continue 
                    _1966 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 96
                    _1982 = mem[_1966]
                    require mem[_1966] == mem[_1966 + 18 len 14]
                    _1990 = mem[_1966 + 32]
                    require mem[_1966 + 32] == mem[_1966 + 50 len 14]
                    require mem[_1966 + 64] == mem[_1966 + 92 len 4]
                    mem[mem[64] + 4] = address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)])
                    require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]))
                    staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)])
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]) == address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]):
                        _2031 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        mem[mem[64] + 4] = mem[_2031] - Mask(112, 0, _1982)
                        mem[mem[64] + 36] = Mask(112, 0, _1982)
                        mem[mem[64] + 68] = Mask(112, 0, _1990)
                        require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]))
                        staticcall address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                                gas gas_remaining wei
                               args mem[mem[64] + 4], _1982 << 144, Mask(112, 0, _1990)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2095 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2111 = mem[_2095]
                        if address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]) != address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]):
                            _2138 = mem[64]
                            mem[mem[64]] = 0
                            mem[64] = mem[64] + 32
                            mem[_2138 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                            mem[_2138 + 36] = _2111
                            mem[_2138 + 68] = 0
                            mem[_2138 + 100] = this.address
                            mem[_2138 + 132] = 128
                            mem[_2138 + 164] = mem[_2138]
                            t = 0
                            while t < mem[_2138]:
                                mem[t + _2138 + 196] = mem[t + _2138 + 32]
                                t = t + 32
                                continue 
                            if ceil32(mem[_2138]) > mem[_2138]:
                                mem[_2138 + mem[_2138] + 196] = 0
                            require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                            call address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                                 gas gas_remaining wei
                                args _2111, 0, address(this.address), 128, mem[_2138], mem[_2138 + 196 len ceil32(mem[_2138])]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_2138 + 36] = this.address
                            require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                            staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).balanceOf(address rg1) with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[_2138 + 32] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = _2138 + ceil32(return_data.size) + 32
                            require return_data.size >= 32
                            s = s + 2
                            t = ext_call.return_data[0] - _1288
                            continue 
                        _2137 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_2137 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_2137 + 36] = 0
                        mem[_2137 + 68] = _2111
                        mem[_2137 + 100] = this.address
                        mem[_2137 + 132] = 128
                        mem[_2137 + 164] = mem[_2137]
                        t = 0
                        while t < mem[_2137]:
                            mem[t + _2137 + 196] = mem[t + _2137 + 32]
                            t = t + 32
                            continue 
                        if ceil32(mem[_2137]) <= mem[_2137]:
                            require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                            call address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).mem[mem[64] len 4] with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len ceil32(mem[_2137]) + _2137 + -mem[64] + 192]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                            staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).balanceOf(address rg1) with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2785 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            s = s + 2
                            t = mem[_2785] - _1288
                            continue 
                        mem[_2137 + mem[_2137] + 196] = 0
                        require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                        call address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len ceil32(mem[_2137]) + _2137 + -mem[64] + 192]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                        staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2817 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        s = s + 2
                        t = mem[_2817] - _1288
                        continue 
                    _2032 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    mem[mem[64] + 4] = mem[_2032] - Mask(112, 0, _1990)
                    mem[mem[64] + 36] = Mask(112, 0, _1990)
                    mem[mem[64] + 68] = Mask(112, 0, _1982)
                    require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]))
                    staticcall address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                            gas gas_remaining wei
                           args mem[mem[64] + 4], _1990 << 144, Mask(112, 0, _1982)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2096 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2112 = mem[_2096]
                    if address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]) == address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]):
                        _2139 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_2139 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_2139 + 36] = 0
                        mem[_2139 + 68] = _2112
                        mem[_2139 + 100] = this.address
                        mem[_2139 + 132] = 128
                        mem[_2139 + 164] = mem[_2139]
                        t = 0
                        while t < mem[_2139]:
                            mem[t + _2139 + 196] = mem[t + _2139 + 32]
                            t = t + 32
                            continue 
                        if ceil32(mem[_2139]) > mem[_2139]:
                            mem[_2139 + mem[_2139] + 196] = 0
                        require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                        call address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                             gas gas_remaining wei
                            args 0, _2112, address(this.address), 128, mem[_2139], mem[_2139 + 196 len ceil32(mem[_2139])]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_2139 + 36] = this.address
                        require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                        staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args this.address
                        mem[_2139 + 32] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[64] = _2139 + ceil32(return_data.size) + 32
                        require return_data.size >= 32
                        s = s + 2
                        t = ext_call.return_data[0] - _1288
                        continue 
                    _2140 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_2140 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_2140 + 36] = _2112
                    mem[_2140 + 68] = 0
                    mem[_2140 + 100] = this.address
                    mem[_2140 + 132] = 128
                    mem[_2140 + 164] = mem[_2140]
                    t = 0
                    while t < mem[_2140]:
                        mem[t + _2140 + 196] = mem[t + _2140 + 32]
                        t = t + 32
                        continue 
                    if ceil32(mem[_2140]) <= mem[_2140]:
                        require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                        call address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len ceil32(mem[_2140]) + _2140 + -mem[64] + 192]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                        staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2788 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        s = s + 2
                        t = mem[_2788] - _1288
                        continue 
                    mem[_2140 + mem[_2140] + 196] = 0
                    require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                    call address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_2140]) + _2140 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                    staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2820 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    s = s + 2
                    t = mem[_2820] - _1288
                    continue 
                require mem[96] >= 32
                if not mem[128]:
                    revert with 0, 
                                32,
                                42,
                                0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                mem[mem[64] + 110 len 22]
                require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                staticcall address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).getReserves() with:
                        gas gas_remaining wei
                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]) < address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]):
                    _1977 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 96
                    _1985 = mem[_1977]
                    require mem[_1977] == mem[_1977 + 18 len 14]
                    _1995 = mem[_1977 + 32]
                    require mem[_1977 + 32] == mem[_1977 + 50 len 14]
                    require mem[_1977 + 64] == mem[_1977 + 92 len 4]
                    mem[mem[64] + 4] = address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)])
                    require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]))
                    staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)])
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]) == address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]):
                        _2049 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        mem[mem[64] + 4] = mem[_2049] - Mask(112, 0, _1985)
                        mem[mem[64] + 36] = Mask(112, 0, _1985)
                        mem[mem[64] + 68] = Mask(112, 0, _1995)
                        require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]))
                        staticcall address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                                gas gas_remaining wei
                               args mem[mem[64] + 4], _1985 << 144, Mask(112, 0, _1995)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2113 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2125 = mem[_2113]
                        if address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]) != address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]):
                            _2166 = mem[64]
                            mem[mem[64]] = 0
                            mem[64] = mem[64] + 32
                            mem[_2166 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                            mem[_2166 + 36] = _2125
                            mem[_2166 + 68] = 0
                            mem[_2166 + 100] = this.address
                            mem[_2166 + 132] = 128
                            mem[_2166 + 164] = mem[_2166]
                            t = 0
                            while t < mem[_2166]:
                                mem[t + _2166 + 196] = mem[t + _2166 + 32]
                                t = t + 32
                                continue 
                            if ceil32(mem[_2166]) > mem[_2166]:
                                mem[_2166 + mem[_2166] + 196] = 0
                            require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                            call address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                                 gas gas_remaining wei
                                args _2125, 0, address(this.address), 128, mem[_2166], mem[_2166 + 196 len ceil32(mem[_2166])]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_2166 + 36] = this.address
                            require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                            staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).balanceOf(address rg1) with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[_2166 + 32] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = _2166 + ceil32(return_data.size) + 32
                            require return_data.size >= 32
                            s = s + 2
                            t = ext_call.return_data[0] - _1288
                            continue 
                        _2165 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_2165 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_2165 + 36] = 0
                        mem[_2165 + 68] = _2125
                        mem[_2165 + 100] = this.address
                        mem[_2165 + 132] = 128
                        mem[_2165 + 164] = mem[_2165]
                        t = 0
                        while t < mem[_2165]:
                            mem[t + _2165 + 196] = mem[t + _2165 + 32]
                            t = t + 32
                            continue 
                        if ceil32(mem[_2165]) <= mem[_2165]:
                            require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                            call address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).mem[mem[64] len 4] with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len ceil32(mem[_2165]) + _2165 + -mem[64] + 192]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                            staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).balanceOf(address rg1) with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2789 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            s = s + 2
                            t = mem[_2789] - _1288
                            continue 
                        mem[_2165 + mem[_2165] + 196] = 0
                        require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                        call address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len ceil32(mem[_2165]) + _2165 + -mem[64] + 192]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                        staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2821 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        s = s + 2
                        t = mem[_2821] - _1288
                        continue 
                    _2050 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    mem[mem[64] + 4] = mem[_2050] - Mask(112, 0, _1995)
                    mem[mem[64] + 36] = Mask(112, 0, _1995)
                    mem[mem[64] + 68] = Mask(112, 0, _1985)
                    require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]))
                    staticcall address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                            gas gas_remaining wei
                           args mem[mem[64] + 4], _1995 << 144, Mask(112, 0, _1985)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2114 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2126 = mem[_2114]
                    if address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]) != address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]):
                        _2168 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_2168 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_2168 + 36] = _2126
                        mem[_2168 + 68] = 0
                        mem[_2168 + 100] = this.address
                        mem[_2168 + 132] = 128
                        mem[_2168 + 164] = mem[_2168]
                        t = 0
                        while t < mem[_2168]:
                            mem[t + _2168 + 196] = mem[t + _2168 + 32]
                            t = t + 32
                            continue 
                        if ceil32(mem[_2168]) > mem[_2168]:
                            mem[_2168 + mem[_2168] + 196] = 0
                        require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                        call address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                             gas gas_remaining wei
                            args _2126, 0, address(this.address), 128, mem[_2168], mem[_2168 + 196 len ceil32(mem[_2168])]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_2168 + 36] = this.address
                        require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                        staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args this.address
                        mem[_2168 + 32] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[64] = _2168 + ceil32(return_data.size) + 32
                        require return_data.size >= 32
                        s = s + 2
                        t = ext_call.return_data[0] - _1288
                        continue 
                    _2167 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_2167 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_2167 + 36] = 0
                    mem[_2167 + 68] = _2126
                    mem[_2167 + 100] = this.address
                    mem[_2167 + 132] = 128
                    mem[_2167 + 164] = mem[_2167]
                    t = 0
                    while t < mem[_2167]:
                        mem[t + _2167 + 196] = mem[t + _2167 + 32]
                        t = t + 32
                        continue 
                    if ceil32(mem[_2167]) <= mem[_2167]:
                        require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                        call address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len ceil32(mem[_2167]) + _2167 + -mem[64] + 192]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                        staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2791 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        s = s + 2
                        t = mem[_2791] - _1288
                        continue 
                    mem[_2167 + mem[_2167] + 196] = 0
                    require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                    call address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_2167]) + _2167 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                    staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2823 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    s = s + 2
                    t = mem[_2823] - _1288
                    continue 
                _1978 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 96
                _1986 = mem[_1978]
                require mem[_1978] == mem[_1978 + 18 len 14]
                _1996 = mem[_1978 + 32]
                require mem[_1978 + 32] == mem[_1978 + 50 len 14]
                require mem[_1978 + 64] == mem[_1978 + 92 len 4]
                mem[mem[64] + 4] = address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)])
                require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]))
                staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)])
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]) == address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]):
                    _2051 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    mem[mem[64] + 4] = mem[_2051] - Mask(112, 0, _1986)
                    mem[mem[64] + 36] = Mask(112, 0, _1986)
                    mem[mem[64] + 68] = Mask(112, 0, _1996)
                    require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]))
                    staticcall address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                            gas gas_remaining wei
                           args mem[mem[64] + 4], _1986 << 144, Mask(112, 0, _1996)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2115 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2127 = mem[_2115]
                    if address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]) != address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]):
                        _2170 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_2170 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_2170 + 36] = _2127
                        mem[_2170 + 68] = 0
                        mem[_2170 + 100] = this.address
                        mem[_2170 + 132] = 128
                        mem[_2170 + 164] = mem[_2170]
                        t = 0
                        while t < mem[_2170]:
                            mem[t + _2170 + 196] = mem[t + _2170 + 32]
                            t = t + 32
                            continue 
                        if ceil32(mem[_2170]) > mem[_2170]:
                            mem[_2170 + mem[_2170] + 196] = 0
                        require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                        call address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                             gas gas_remaining wei
                            args _2127, 0, address(this.address), 128, mem[_2170], mem[_2170 + 196 len ceil32(mem[_2170])]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_2170 + 36] = this.address
                        require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                        staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args this.address
                        mem[_2170 + 32] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[64] = _2170 + ceil32(return_data.size) + 32
                        require return_data.size >= 32
                        s = s + 2
                        t = ext_call.return_data[0] - _1288
                        continue 
                    _2169 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_2169 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_2169 + 36] = 0
                    mem[_2169 + 68] = _2127
                    mem[_2169 + 100] = this.address
                    mem[_2169 + 132] = 128
                    mem[_2169 + 164] = mem[_2169]
                    t = 0
                    while t < mem[_2169]:
                        mem[t + _2169 + 196] = mem[t + _2169 + 32]
                        t = t + 32
                        continue 
                    if ceil32(mem[_2169]) <= mem[_2169]:
                        require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                        call address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len ceil32(mem[_2169]) + _2169 + -mem[64] + 192]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                        staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2793 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        s = s + 2
                        t = mem[_2793] - _1288
                        continue 
                    mem[_2169 + mem[_2169] + 196] = 0
                    require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                    call address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_2169]) + _2169 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                    staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2825 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    s = s + 2
                    t = mem[_2825] - _1288
                    continue 
                _2052 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[mem[64] + 4] = mem[_2052] - Mask(112, 0, _1996)
                mem[mem[64] + 36] = Mask(112, 0, _1996)
                mem[mem[64] + 68] = Mask(112, 0, _1986)
                require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]))
                staticcall address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                        gas gas_remaining wei
                       args mem[mem[64] + 4], _1996 << 144, Mask(112, 0, _1986)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2116 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _2128 = mem[_2116]
                if address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]) == address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]):
                    _2171 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_2171 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_2171 + 36] = 0
                    mem[_2171 + 68] = _2128
                    mem[_2171 + 100] = this.address
                    mem[_2171 + 132] = 128
                    mem[_2171 + 164] = mem[_2171]
                    t = 0
                    while t < mem[_2171]:
                        mem[t + _2171 + 196] = mem[t + _2171 + 32]
                        t = t + 32
                        continue 
                    if ceil32(mem[_2171]) > mem[_2171]:
                        mem[_2171 + mem[_2171] + 196] = 0
                    require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                    call address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                         gas gas_remaining wei
                        args 0, _2128, address(this.address), 128, mem[_2171], mem[_2171 + 196 len ceil32(mem[_2171])]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[_2171 + 36] = this.address
                    require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                    staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args this.address
                    mem[_2171 + 32] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = _2171 + ceil32(return_data.size) + 32
                    require return_data.size >= 32
                    s = s + 2
                    t = ext_call.return_data[0] - _1288
                    continue 
                _2172 = mem[64]
                mem[mem[64]] = 0
                mem[64] = mem[64] + 32
                mem[_2172 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[_2172 + 36] = _2128
                mem[_2172 + 68] = 0
                mem[_2172 + 100] = this.address
                mem[_2172 + 132] = 128
                mem[_2172 + 164] = mem[_2172]
                t = 0
                while t < mem[_2172]:
                    mem[t + _2172 + 196] = mem[t + _2172 + 32]
                    t = t + 32
                    continue 
                if ceil32(mem[_2172]) <= mem[_2172]:
                    require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                    call address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_2172]) + _2172 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                    staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2796 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    s = s + 2
                    t = mem[_2796] - _1288
                    continue 
                mem[_2172 + mem[_2172] + 196] = 0
                require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                call address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len ceil32(mem[_2172]) + _2172 + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2828 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                s = s + 2
                t = mem[_2828] - _1288
                continue 
            _1928 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size) + 1
            mem[_1928] = return_data.size
            mem[_1928 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not ext_call.success:
                if return_data.size:
                    revert with ext_call.return_data[0 len return_data.size]
                _1935 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = mem[_1289 + 100]
                _1937 = mem[_1289 + 100]
                idx = 0
                while idx < _1937:
                    mem[idx + _1935 + 68] = mem[idx + _1289 + 132]
                    idx = idx + 32
                    continue 
                if not _1937 % 32:
                    revert with memory
                      from mem[64]
                       len _1937 + _1935 + -mem[64] + 68
                mem[floor32(_1937) + _1935 + 68] = mem[floor32(_1937) + _1935 + -(_1937 % 32) + 100 len _1937 % 32]
                revert with memory
                  from mem[64]
                   len floor32(_1937) + _1935 + -mem[64] + 100
            if not return_data.size:
                require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                staticcall address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).getReserves() with:
                        gas gas_remaining wei
                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]) < address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]):
                    _1971 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 96
                    _1983 = mem[_1971]
                    require mem[_1971] == mem[_1971 + 18 len 14]
                    _1991 = mem[_1971 + 32]
                    require mem[_1971 + 32] == mem[_1971 + 50 len 14]
                    require mem[_1971 + 64] == mem[_1971 + 92 len 4]
                    mem[mem[64] + 4] = address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)])
                    require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]))
                    staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)])
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]) == address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]):
                        _2037 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        mem[mem[64] + 4] = mem[_2037] - Mask(112, 0, _1983)
                        mem[mem[64] + 36] = Mask(112, 0, _1983)
                        mem[mem[64] + 68] = Mask(112, 0, _1991)
                        require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]))
                        staticcall address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                                gas gas_remaining wei
                               args mem[mem[64] + 4], _1983 << 144, Mask(112, 0, _1991)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2101 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2117 = mem[_2101]
                        if address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]) == address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]):
                            _2141 = mem[64]
                            mem[mem[64]] = 0
                            mem[64] = mem[64] + 32
                            mem[_2141 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                            mem[_2141 + 36] = 0
                            mem[_2141 + 68] = _2117
                            mem[_2141 + 100] = this.address
                            mem[_2141 + 132] = 128
                            mem[_2141 + 164] = mem[_2141]
                            t = 0
                            while t < mem[_2141]:
                                mem[t + _2141 + 196] = mem[t + _2141 + 32]
                                t = t + 32
                                continue 
                            if ceil32(mem[_2141]) > mem[_2141]:
                                mem[_2141 + mem[_2141] + 196] = 0
                            require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                            call address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                                 gas gas_remaining wei
                                args 0, _2117, address(this.address), 128, mem[_2141], mem[_2141 + 196 len ceil32(mem[_2141])]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_2141 + 36] = this.address
                            require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                            staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).balanceOf(address rg1) with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[_2141 + 32] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = _2141 + ceil32(return_data.size) + 32
                        else:
                            _2142 = mem[64]
                            mem[mem[64]] = 0
                            mem[64] = mem[64] + 32
                            mem[_2142 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                            mem[_2142 + 36] = _2117
                            mem[_2142 + 68] = 0
                            mem[_2142 + 100] = this.address
                            mem[_2142 + 132] = 128
                            mem[_2142 + 164] = mem[_2142]
                            t = 0
                            while t < mem[_2142]:
                                mem[t + _2142 + 196] = mem[t + _2142 + 32]
                                t = t + 32
                                continue 
                            if ceil32(mem[_2142]) > mem[_2142]:
                                mem[_2142 + mem[_2142] + 196] = 0
                            require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                            call address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                                 gas gas_remaining wei
                                args _2117, 0, address(this.address), 128, mem[_2142], mem[_2142 + 196 len ceil32(mem[_2142])]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_2142 + 36] = this.address
                            require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                            staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).balanceOf(address rg1) with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[_2142 + 32] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = _2142 + ceil32(return_data.size) + 32
                    else:
                        _2038 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        mem[mem[64] + 4] = mem[_2038] - Mask(112, 0, _1991)
                        mem[mem[64] + 36] = Mask(112, 0, _1991)
                        mem[mem[64] + 68] = Mask(112, 0, _1983)
                        require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]))
                        staticcall address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                                gas gas_remaining wei
                               args mem[mem[64] + 4], _1991 << 144, Mask(112, 0, _1983)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2102 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2118 = mem[_2102]
                        if address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]) == address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]):
                            _2143 = mem[64]
                            mem[mem[64]] = 0
                            mem[64] = mem[64] + 32
                            mem[_2143 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                            mem[_2143 + 36] = 0
                            mem[_2143 + 68] = _2118
                            mem[_2143 + 100] = this.address
                            mem[_2143 + 132] = 128
                            mem[_2143 + 164] = mem[_2143]
                            t = 0
                            while t < mem[_2143]:
                                mem[t + _2143 + 196] = mem[t + _2143 + 32]
                                t = t + 32
                                continue 
                            if ceil32(mem[_2143]) > mem[_2143]:
                                mem[_2143 + mem[_2143] + 196] = 0
                            require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                            call address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                                 gas gas_remaining wei
                                args 0, _2118, address(this.address), 128, mem[_2143], mem[_2143 + 196 len ceil32(mem[_2143])]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_2143 + 36] = this.address
                            require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                            staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).balanceOf(address rg1) with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[_2143 + 32] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = _2143 + ceil32(return_data.size) + 32
                        else:
                            _2144 = mem[64]
                            mem[mem[64]] = 0
                            mem[64] = mem[64] + 32
                            mem[_2144 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                            mem[_2144 + 36] = _2118
                            mem[_2144 + 68] = 0
                            mem[_2144 + 100] = this.address
                            mem[_2144 + 132] = 128
                            mem[_2144 + 164] = mem[_2144]
                            t = 0
                            while t < mem[_2144]:
                                mem[t + _2144 + 196] = mem[t + _2144 + 32]
                                t = t + 32
                                continue 
                            if ceil32(mem[_2144]) > mem[_2144]:
                                mem[_2144 + mem[_2144] + 196] = 0
                            require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                            call address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                                 gas gas_remaining wei
                                args _2118, 0, address(this.address), 128, mem[_2144], mem[_2144 + 196 len ceil32(mem[_2144])]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_2144 + 36] = this.address
                            require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                            staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).balanceOf(address rg1) with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[_2144 + 32] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = _2144 + ceil32(return_data.size) + 32
                else:
                    _1972 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 96
                    _1984 = mem[_1972]
                    require mem[_1972] == mem[_1972 + 18 len 14]
                    _1992 = mem[_1972 + 32]
                    require mem[_1972 + 32] == mem[_1972 + 50 len 14]
                    require mem[_1972 + 64] == mem[_1972 + 92 len 4]
                    mem[mem[64] + 4] = address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)])
                    require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]))
                    staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)])
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]) == address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]):
                        _2039 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        mem[mem[64] + 4] = mem[_2039] - Mask(112, 0, _1984)
                        mem[mem[64] + 36] = Mask(112, 0, _1984)
                        mem[mem[64] + 68] = Mask(112, 0, _1992)
                        require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]))
                        staticcall address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                                gas gas_remaining wei
                               args mem[mem[64] + 4], _1984 << 144, Mask(112, 0, _1992)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2103 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2119 = mem[_2103]
                        if address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]) == address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]):
                            _2145 = mem[64]
                            mem[mem[64]] = 0
                            mem[64] = mem[64] + 32
                            mem[_2145 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                            mem[_2145 + 36] = 0
                            mem[_2145 + 68] = _2119
                            mem[_2145 + 100] = this.address
                            mem[_2145 + 132] = 128
                            mem[_2145 + 164] = mem[_2145]
                            t = 0
                            while t < mem[_2145]:
                                mem[t + _2145 + 196] = mem[t + _2145 + 32]
                                t = t + 32
                                continue 
                            if ceil32(mem[_2145]) > mem[_2145]:
                                mem[_2145 + mem[_2145] + 196] = 0
                            require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                            call address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                                 gas gas_remaining wei
                                args 0, _2119, address(this.address), 128, mem[_2145], mem[_2145 + 196 len ceil32(mem[_2145])]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_2145 + 36] = this.address
                            require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                            staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).balanceOf(address rg1) with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[_2145 + 32] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = _2145 + ceil32(return_data.size) + 32
                        else:
                            _2146 = mem[64]
                            mem[mem[64]] = 0
                            mem[64] = mem[64] + 32
                            mem[_2146 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                            mem[_2146 + 36] = _2119
                            mem[_2146 + 68] = 0
                            mem[_2146 + 100] = this.address
                            mem[_2146 + 132] = 128
                            mem[_2146 + 164] = mem[_2146]
                            t = 0
                            while t < mem[_2146]:
                                mem[t + _2146 + 196] = mem[t + _2146 + 32]
                                t = t + 32
                                continue 
                            if ceil32(mem[_2146]) > mem[_2146]:
                                mem[_2146 + mem[_2146] + 196] = 0
                            require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                            call address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                                 gas gas_remaining wei
                                args _2119, 0, address(this.address), 128, mem[_2146], mem[_2146 + 196 len ceil32(mem[_2146])]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_2146 + 36] = this.address
                            require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                            staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).balanceOf(address rg1) with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[_2146 + 32] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = _2146 + ceil32(return_data.size) + 32
                    else:
                        _2040 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        mem[mem[64] + 4] = mem[_2040] - Mask(112, 0, _1992)
                        mem[mem[64] + 36] = Mask(112, 0, _1992)
                        mem[mem[64] + 68] = Mask(112, 0, _1984)
                        require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]))
                        staticcall address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                                gas gas_remaining wei
                               args mem[mem[64] + 4], _1992 << 144, Mask(112, 0, _1984)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2104 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2120 = mem[_2104]
                        if address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]) == address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]):
                            _2147 = mem[64]
                            mem[mem[64]] = 0
                            mem[64] = mem[64] + 32
                            mem[_2147 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                            mem[_2147 + 36] = 0
                            mem[_2147 + 68] = _2120
                            mem[_2147 + 100] = this.address
                            mem[_2147 + 132] = 128
                            mem[_2147 + 164] = mem[_2147]
                            t = 0
                            while t < mem[_2147]:
                                mem[t + _2147 + 196] = mem[t + _2147 + 32]
                                t = t + 32
                                continue 
                            if ceil32(mem[_2147]) > mem[_2147]:
                                mem[_2147 + mem[_2147] + 196] = 0
                            require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                            call address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                                 gas gas_remaining wei
                                args 0, _2120, address(this.address), 128, mem[_2147], mem[_2147 + 196 len ceil32(mem[_2147])]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_2147 + 36] = this.address
                            require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                            staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).balanceOf(address rg1) with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[_2147 + 32] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = _2147 + ceil32(return_data.size) + 32
                        else:
                            _2148 = mem[64]
                            mem[mem[64]] = 0
                            mem[64] = mem[64] + 32
                            mem[_2148 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                            mem[_2148 + 36] = _2120
                            mem[_2148 + 68] = 0
                            mem[_2148 + 100] = this.address
                            mem[_2148 + 132] = 128
                            mem[_2148 + 164] = mem[_2148]
                            t = 0
                            while t < mem[_2148]:
                                mem[t + _2148 + 196] = mem[t + _2148 + 32]
                                t = t + 32
                                continue 
                            if ceil32(mem[_2148]) > mem[_2148]:
                                mem[_2148 + mem[_2148] + 196] = 0
                            require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                            call address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                                 gas gas_remaining wei
                                args _2120, 0, address(this.address), 128, mem[_2148], mem[_2148 + 196 len ceil32(mem[_2148])]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_2148 + 36] = this.address
                            require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                            staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).balanceOf(address rg1) with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[_2148 + 32] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = _2148 + ceil32(return_data.size) + 32
                require return_data.size >= 32
                s = s + 2
                t = ext_call.return_data[0] - _1288
                continue 
            require return_data.size >= 32
            if not mem[_1928 + 32]:
                revert with 0, 
                            32,
                            42,
                            0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                            mem[mem[64] + 110 len 22]
            require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
            staticcall address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).getReserves() with:
                    gas gas_remaining wei
            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]) < address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]):
                _1979 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 96
                _1987 = mem[_1979]
                require mem[_1979] == mem[_1979 + 18 len 14]
                _1999 = mem[_1979 + 32]
                require mem[_1979 + 32] == mem[_1979 + 50 len 14]
                require mem[_1979 + 64] == mem[_1979 + 92 len 4]
                mem[mem[64] + 4] = address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)])
                require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]))
                staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)])
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]) == address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]):
                    _2057 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    mem[mem[64] + 4] = mem[_2057] - Mask(112, 0, _1987)
                    mem[mem[64] + 36] = Mask(112, 0, _1987)
                    mem[mem[64] + 68] = Mask(112, 0, _1999)
                    require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]))
                    staticcall address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                            gas gas_remaining wei
                           args mem[mem[64] + 4], _1987 << 144, Mask(112, 0, _1999)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2121 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2129 = mem[_2121]
                    if address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]) != address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]):
                        _2174 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_2174 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_2174 + 36] = _2129
                        mem[_2174 + 68] = 0
                        mem[_2174 + 100] = this.address
                        mem[_2174 + 132] = 128
                        mem[_2174 + 164] = mem[_2174]
                        t = 0
                        while t < mem[_2174]:
                            mem[t + _2174 + 196] = mem[t + _2174 + 32]
                            t = t + 32
                            continue 
                        if ceil32(mem[_2174]) > mem[_2174]:
                            mem[_2174 + mem[_2174] + 196] = 0
                        require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                        call address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                             gas gas_remaining wei
                            args _2129, 0, address(this.address), 128, mem[_2174], mem[_2174 + 196 len ceil32(mem[_2174])]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_2174 + 36] = this.address
                        require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                        staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args this.address
                        mem[_2174 + 32] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[64] = _2174 + ceil32(return_data.size) + 32
                        require return_data.size >= 32
                        s = s + 2
                        t = ext_call.return_data[0] - _1288
                        continue 
                    _2173 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_2173 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_2173 + 36] = 0
                    mem[_2173 + 68] = _2129
                    mem[_2173 + 100] = this.address
                    mem[_2173 + 132] = 128
                    mem[_2173 + 164] = mem[_2173]
                    t = 0
                    while t < mem[_2173]:
                        mem[t + _2173 + 196] = mem[t + _2173 + 32]
                        t = t + 32
                        continue 
                    if ceil32(mem[_2173]) <= mem[_2173]:
                        require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                        call address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len ceil32(mem[_2173]) + _2173 + -mem[64] + 192]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                        staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2805 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        s = s + 2
                        t = mem[_2805] - _1288
                        continue 
                    mem[_2173 + mem[_2173] + 196] = 0
                    require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                    call address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_2173]) + _2173 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                    staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2837 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    s = s + 2
                    t = mem[_2837] - _1288
                    continue 
                _2058 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[mem[64] + 4] = mem[_2058] - Mask(112, 0, _1999)
                mem[mem[64] + 36] = Mask(112, 0, _1999)
                mem[mem[64] + 68] = Mask(112, 0, _1987)
                require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]))
                staticcall address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                        gas gas_remaining wei
                       args mem[mem[64] + 4], _1999 << 144, Mask(112, 0, _1987)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2122 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _2130 = mem[_2122]
                if address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]) != address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]):
                    _2176 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_2176 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_2176 + 36] = _2130
                    mem[_2176 + 68] = 0
                    mem[_2176 + 100] = this.address
                    mem[_2176 + 132] = 128
                    mem[_2176 + 164] = mem[_2176]
                    t = 0
                    while t < mem[_2176]:
                        mem[t + _2176 + 196] = mem[t + _2176 + 32]
                        t = t + 32
                        continue 
                    if ceil32(mem[_2176]) > mem[_2176]:
                        mem[_2176 + mem[_2176] + 196] = 0
                    require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                    call address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                         gas gas_remaining wei
                        args _2130, 0, address(this.address), 128, mem[_2176], mem[_2176 + 196 len ceil32(mem[_2176])]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[_2176 + 36] = this.address
                    require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                    staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args this.address
                    mem[_2176 + 32] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = _2176 + ceil32(return_data.size) + 32
                    require return_data.size >= 32
                    s = s + 2
                    t = ext_call.return_data[0] - _1288
                    continue 
                _2175 = mem[64]
                mem[mem[64]] = 0
                mem[64] = mem[64] + 32
                mem[_2175 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[_2175 + 36] = 0
                mem[_2175 + 68] = _2130
                mem[_2175 + 100] = this.address
                mem[_2175 + 132] = 128
                mem[_2175 + 164] = mem[_2175]
                t = 0
                while t < mem[_2175]:
                    mem[t + _2175 + 196] = mem[t + _2175 + 32]
                    t = t + 32
                    continue 
                if ceil32(mem[_2175]) <= mem[_2175]:
                    require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                    call address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_2175]) + _2175 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                    staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2807 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    s = s + 2
                    t = mem[_2807] - _1288
                    continue 
                mem[_2175 + mem[_2175] + 196] = 0
                require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                call address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len ceil32(mem[_2175]) + _2175 + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2839 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                s = s + 2
                t = mem[_2839] - _1288
                continue 
            _1980 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 96
            _1988 = mem[_1980]
            require mem[_1980] == mem[_1980 + 18 len 14]
            _2000 = mem[_1980 + 32]
            require mem[_1980 + 32] == mem[_1980 + 50 len 14]
            require mem[_1980 + 64] == mem[_1980 + 92 len 4]
            mem[mem[64] + 4] = address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)])
            require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]))
            staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]).balanceOf(address rg1) with:
                    gas gas_remaining wei
                   args address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)])
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]) == address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]):
                _2059 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[mem[64] + 4] = mem[_2059] - Mask(112, 0, _1988)
                mem[mem[64] + 36] = Mask(112, 0, _1988)
                mem[mem[64] + 68] = Mask(112, 0, _2000)
                require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]))
                staticcall address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                        gas gas_remaining wei
                       args mem[mem[64] + 4], _1988 << 144, Mask(112, 0, _2000)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2123 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _2131 = mem[_2123]
                if address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]) == address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]):
                    _2177 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_2177 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_2177 + 36] = 0
                    mem[_2177 + 68] = _2131
                    mem[_2177 + 100] = this.address
                    mem[_2177 + 132] = 128
                    mem[_2177 + 164] = mem[_2177]
                    t = 0
                    while t < mem[_2177]:
                        mem[t + _2177 + 196] = mem[t + _2177 + 32]
                        t = t + 32
                        continue 
                    if ceil32(mem[_2177]) > mem[_2177]:
                        mem[_2177 + mem[_2177] + 196] = 0
                    require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                    call address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                         gas gas_remaining wei
                        args 0, _2131, address(this.address), 128, mem[_2177], mem[_2177 + 196 len ceil32(mem[_2177])]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[_2177 + 36] = this.address
                    require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                    staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args this.address
                    mem[_2177 + 32] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = _2177 + ceil32(return_data.size) + 32
                    require return_data.size >= 32
                    s = s + 2
                    t = ext_call.return_data[0] - _1288
                    continue 
                _2178 = mem[64]
                mem[mem[64]] = 0
                mem[64] = mem[64] + 32
                mem[_2178 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[_2178 + 36] = _2131
                mem[_2178 + 68] = 0
                mem[_2178 + 100] = this.address
                mem[_2178 + 132] = 128
                mem[_2178 + 164] = mem[_2178]
                t = 0
                while t < mem[_2178]:
                    mem[t + _2178 + 196] = mem[t + _2178 + 32]
                    t = t + 32
                    continue 
                if ceil32(mem[_2178]) <= mem[_2178]:
                    require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                    call address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_2178]) + _2178 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                    staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2810 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    s = s + 2
                    t = mem[_2810] - _1288
                    continue 
                mem[_2178 + mem[_2178] + 196] = 0
                require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                call address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len ceil32(mem[_2178]) + _2178 + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2842 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                s = s + 2
                t = mem[_2842] - _1288
                continue 
            _2060 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            mem[mem[64] + 4] = mem[_2060] - Mask(112, 0, _2000)
            mem[mem[64] + 36] = Mask(112, 0, _2000)
            mem[mem[64] + 68] = Mask(112, 0, _1988)
            require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]))
            staticcall address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                    gas gas_remaining wei
                   args mem[mem[64] + 4], _2000 << 144, Mask(112, 0, _1988)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _2124 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _2132 = mem[_2124]
            if address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]) == address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]):
                _2179 = mem[64]
                mem[mem[64]] = 0
                mem[64] = mem[64] + 32
                mem[_2179 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[_2179 + 36] = 0
                mem[_2179 + 68] = _2132
                mem[_2179 + 100] = this.address
                mem[_2179 + 132] = 128
                mem[_2179 + 164] = mem[_2179]
                t = 0
                while t < mem[_2179]:
                    mem[t + _2179 + 196] = mem[t + _2179 + 32]
                    t = t + 32
                    continue 
                if ceil32(mem[_2179]) > mem[_2179]:
                    mem[_2179 + mem[_2179] + 196] = 0
                require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                call address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                     gas gas_remaining wei
                    args 0, _2132, address(this.address), 128, mem[_2179], mem[_2179 + 196 len ceil32(mem[_2179])]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[_2179 + 36] = this.address
                require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args this.address
                mem[_2179 + 32] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[64] = _2179 + ceil32(return_data.size) + 32
                require return_data.size >= 32
                s = s + 2
                t = ext_call.return_data[0] - _1288
                continue 
            _2180 = mem[64]
            mem[mem[64]] = 0
            mem[64] = mem[64] + 32
            mem[_2180 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
            mem[_2180 + 36] = _2132
            mem[_2180 + 68] = 0
            mem[_2180 + 100] = this.address
            mem[_2180 + 132] = 128
            mem[_2180 + 164] = mem[_2180]
            t = 0
            while t < mem[_2180]:
                mem[t + _2180 + 196] = mem[t + _2180 + 32]
                t = t + 32
                continue 
            if ceil32(mem[_2180]) <= mem[_2180]:
                require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                call address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len ceil32(mem[_2180]) + _2180 + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2812 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                s = s + 2
                t = mem[_2812] - _1288
                continue 
            mem[_2180 + mem[_2180] + 196] = 0
            require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
            call address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).mem[mem[64] len 4] with:
                 gas gas_remaining wei
                args mem[mem[64] + 4 len ceil32(mem[_2180]) + _2180 + -mem[64] + 192]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[mem[64] + 4] = this.address
            require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
            staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).balanceOf(address rg1) with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _2844 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            s = s + 2
            t = mem[_2844] - _1288
            continue 
        idx = idx + 1
        continue 
}

function sub_12703980(?) payable {
    mem[64] = 96
    require not msg.value
    require calldata.size - 4 >= 64
    require cd[4] <= test266151307()
    require cd[4] + 35 < calldata.size
    require ('cd', 4).length <= test266151307()
    require cd[4] + (32 * ('cd', 4).length) + 36 <= calldata.size
    require cd[36] <= test266151307()
    require cd[36] + 35 < calldata.size
    require ('cd', 36).length <= test266151307()
    require cd[36] + (32 * ('cd', 36).length) + 36 <= calldata.size
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    idx = 0
    while idx < ('cd', 4).length:
        require cd[(cd[4] + (32 * idx) + 36)] < calldata.size + -cd[4] - 67
        require cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 36)] <= test266151307()
        require cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68 <= calldata.size - (64 * cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 36)])
        require idx < ('cd', 36).length
        if owner != msg.sender:
            revert with 0, 'Ownable: caller is not the owner'
        require 1 < cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 36)]
        require cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 132)] == address(cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 132)])
        mem[mem[64] + 4] = this.address
        require ext_code.size(address(cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 132)]))
        staticcall address(cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 132)]).balanceOf(address rg1) with:
                gas gas_remaining wei
               args address(this.address)
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _658 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        _659 = mem[_658]
        s = 0
        t = cd[((32 * idx) + cd[36] + 36)]
        while s < cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 36)]:
            require cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)] == address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)])
            require s < cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 36)]
            require cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)] == address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)])
            require s + 1 < cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 36)]
            require cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)] == address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)])
            require s + 1 < cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 36)]
            require cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)] == address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)])
            mem[mem[64] + 4] = this.address
            require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
            staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).balanceOf(address rg1) with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1313 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _1314 = mem[_1313]
            _1315 = mem[64]
            mem[mem[64] + 36] = address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)])
            mem[mem[64] + 68] = t
            _1316 = mem[64]
            mem[mem[64]] = 68
            mem[64] = mem[64] + 100
            mem[_1316 + 32] = 0xa9059cbb00000000000000000000000000000000000000000000000000000000 or mem[_1316 + 36 len 28]
            mem[64] = _1315 + 164
            mem[_1315 + 100] = 32
            mem[_1315 + 132] = 'SafeERC20: low-level call failed'
            if 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 == ext_code.hash(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)])):
                revert with 0, 'Address: call to non-contract'
            if not ext_code.hash(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)])):
                revert with 0, 'Address: call to non-contract'
            _1322 = mem[_1316]
            u = _1316 + 32
            v = mem[64]
            t = mem[_1316]
            while t >= 32:
                mem[v] = mem[u]
                u = u + 32
                v = v + 32
                t = t - 32
                continue 
            mem[mem[64] + floor32(mem[_1316])] = mem[_1316 + floor32(mem[_1316]) + -(mem[_1316] % 32) + 64 len mem[_1316] % 32] or Mask(8 * -(mem[_1316] % 32) + 32, -(8 * -(mem[_1316] % 32) + 32) + 256, mem[mem[64] + floor32(mem[_1316])])
            call address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]).mem[mem[64] len 4] with:
                 gas gas_remaining wei
                args mem[mem[64] + 4 len _1322 + _1315 + -mem[64] + 160]
            if not return_data.size:
                if not ext_call.success:
                    if mem[96]:
                        revert with memory
                          from 128
                           len mem[96]
                    _1957 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = mem[_1315 + 100]
                    _1959 = mem[_1315 + 100]
                    idx = 0
                    while idx < _1959:
                        mem[idx + _1957 + 68] = mem[idx + _1315 + 132]
                        idx = idx + 32
                        continue 
                    if not _1959 % 32:
                        revert with memory
                          from mem[64]
                           len _1959 + _1957 + -mem[64] + 68
                    mem[floor32(_1959) + _1957 + 68] = mem[floor32(_1959) + _1957 + -(_1959 % 32) + 100 len _1959 % 32]
                    revert with memory
                      from mem[64]
                       len floor32(_1959) + _1957 + -mem[64] + 100
                if not mem[96]:
                    require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                    staticcall address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).getReserves() with:
                            gas gas_remaining wei
                    mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]) < address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]):
                        _1991 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 96
                        _2007 = mem[_1991]
                        require mem[_1991] == mem[_1991 + 18 len 14]
                        _2015 = mem[_1991 + 32]
                        require mem[_1991 + 32] == mem[_1991 + 50 len 14]
                        require mem[_1991 + 64] == mem[_1991 + 92 len 4]
                        mem[mem[64] + 4] = address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)])
                        require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]))
                        staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]).balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)])
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]) == address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]):
                            _2055 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            mem[mem[64] + 4] = mem[_2055] - Mask(112, 0, _2007)
                            mem[mem[64] + 36] = Mask(112, 0, _2007)
                            mem[mem[64] + 68] = Mask(112, 0, _2015)
                            require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]))
                            staticcall address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                                    gas gas_remaining wei
                                   args mem[mem[64] + 4], _2007 << 144, Mask(112, 0, _2015)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2119 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            _2135 = mem[_2119]
                            if address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]) == address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]):
                                _2159 = mem[64]
                                mem[mem[64]] = 0
                                mem[64] = mem[64] + 32
                                mem[_2159 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                mem[_2159 + 36] = 0
                                mem[_2159 + 68] = _2135
                                mem[_2159 + 100] = this.address
                                mem[_2159 + 132] = 128
                                mem[_2159 + 164] = mem[_2159]
                                t = 0
                                while t < mem[_2159]:
                                    mem[t + _2159 + 196] = mem[t + _2159 + 32]
                                    t = t + 32
                                    continue 
                                if ceil32(mem[_2159]) > mem[_2159]:
                                    mem[_2159 + mem[_2159] + 196] = 0
                                require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                                call address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                                     gas gas_remaining wei
                                    args 0, _2135, address(this.address), 128, mem[_2159], mem[_2159 + 196 len ceil32(mem[_2159])]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[_2159 + 36] = this.address
                                require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                                staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).balanceOf(address rg1) with:
                                        gas gas_remaining wei
                                       args this.address
                                mem[_2159 + 32] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = _2159 + ceil32(return_data.size) + 32
                            else:
                                _2160 = mem[64]
                                mem[mem[64]] = 0
                                mem[64] = mem[64] + 32
                                mem[_2160 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                                mem[_2160 + 36] = _2135
                                mem[_2160 + 68] = 0
                                mem[_2160 + 100] = this.address
                                mem[_2160 + 132] = 128
                                mem[_2160 + 164] = mem[_2160]
                                t = 0
                                while t < mem[_2160]:
                                    mem[t + _2160 + 196] = mem[t + _2160 + 32]
                                    t = t + 32
                                    continue 
                                if ceil32(mem[_2160]) > mem[_2160]:
                                    mem[_2160 + mem[_2160] + 196] = 0
                                require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                                call address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                                     gas gas_remaining wei
                                    args _2135, 0, address(this.address), 128, mem[_2160], mem[_2160 + 196 len ceil32(mem[_2160])]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[_2160 + 36] = this.address
                                require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                                staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).balanceOf(address rg1) with:
                                        gas gas_remaining wei
                                       args this.address
                                mem[_2160 + 32] = ext_call.return_data[0]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[64] = _2160 + ceil32(return_data.size) + 32
                            require return_data.size >= 32
                            s = s + 2
                            t = ext_call.return_data[0] - _1314
                            continue 
                        _2056 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        mem[mem[64] + 4] = mem[_2056] - Mask(112, 0, _2015)
                        mem[mem[64] + 36] = Mask(112, 0, _2015)
                        mem[mem[64] + 68] = Mask(112, 0, _2007)
                        require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]))
                        staticcall address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                                gas gas_remaining wei
                               args mem[mem[64] + 4], _2015 << 144, Mask(112, 0, _2007)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2120 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2136 = mem[_2120]
                        if address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]) == address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]):
                            _2161 = mem[64]
                            mem[mem[64]] = 0
                            mem[64] = mem[64] + 32
                            mem[_2161 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                            mem[_2161 + 36] = 0
                            mem[_2161 + 68] = _2136
                            mem[_2161 + 100] = this.address
                            mem[_2161 + 132] = 128
                            mem[_2161 + 164] = mem[_2161]
                            t = 0
                            while t < mem[_2161]:
                                mem[t + _2161 + 196] = mem[t + _2161 + 32]
                                t = t + 32
                                continue 
                            if ceil32(mem[_2161]) > mem[_2161]:
                                mem[_2161 + mem[_2161] + 196] = 0
                            require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                            call address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                                 gas gas_remaining wei
                                args 0, _2136, address(this.address), 128, mem[_2161], mem[_2161 + 196 len ceil32(mem[_2161])]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_2161 + 36] = this.address
                            require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                            staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).balanceOf(address rg1) with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[_2161 + 32] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = _2161 + ceil32(return_data.size) + 32
                            require return_data.size >= 32
                            s = s + 2
                            t = ext_call.return_data[0] - _1314
                            continue 
                        _2162 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_2162 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_2162 + 36] = _2136
                        mem[_2162 + 68] = 0
                        mem[_2162 + 100] = this.address
                        mem[_2162 + 132] = 128
                        mem[_2162 + 164] = mem[_2162]
                        t = 0
                        while t < mem[_2162]:
                            mem[t + _2162 + 196] = mem[t + _2162 + 32]
                            t = t + 32
                            continue 
                        if ceil32(mem[_2162]) <= mem[_2162]:
                            require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                            call address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).mem[mem[64] len 4] with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len ceil32(mem[_2162]) + _2162 + -mem[64] + 192]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                            staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).balanceOf(address rg1) with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2810 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            s = s + 2
                            t = mem[_2810] - _1314
                            continue 
                        mem[_2162 + mem[_2162] + 196] = 0
                        require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                        call address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len ceil32(mem[_2162]) + _2162 + -mem[64] + 192]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                        staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2842 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        s = s + 2
                        t = mem[_2842] - _1314
                        continue 
                    _1992 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 96
                    _2008 = mem[_1992]
                    require mem[_1992] == mem[_1992 + 18 len 14]
                    _2016 = mem[_1992 + 32]
                    require mem[_1992 + 32] == mem[_1992 + 50 len 14]
                    require mem[_1992 + 64] == mem[_1992 + 92 len 4]
                    mem[mem[64] + 4] = address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)])
                    require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]))
                    staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)])
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]) == address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]):
                        _2057 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        mem[mem[64] + 4] = mem[_2057] - Mask(112, 0, _2008)
                        mem[mem[64] + 36] = Mask(112, 0, _2008)
                        mem[mem[64] + 68] = Mask(112, 0, _2016)
                        require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]))
                        staticcall address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                                gas gas_remaining wei
                               args mem[mem[64] + 4], _2008 << 144, Mask(112, 0, _2016)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2121 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2137 = mem[_2121]
                        if address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]) == address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]):
                            _2163 = mem[64]
                            mem[mem[64]] = 0
                            mem[64] = mem[64] + 32
                            mem[_2163 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                            mem[_2163 + 36] = 0
                            mem[_2163 + 68] = _2137
                            mem[_2163 + 100] = this.address
                            mem[_2163 + 132] = 128
                            mem[_2163 + 164] = mem[_2163]
                            t = 0
                            while t < mem[_2163]:
                                mem[t + _2163 + 196] = mem[t + _2163 + 32]
                                t = t + 32
                                continue 
                            if ceil32(mem[_2163]) > mem[_2163]:
                                mem[_2163 + mem[_2163] + 196] = 0
                            require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                            call address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                                 gas gas_remaining wei
                                args 0, _2137, address(this.address), 128, mem[_2163], mem[_2163 + 196 len ceil32(mem[_2163])]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_2163 + 36] = this.address
                            require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                            staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).balanceOf(address rg1) with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[_2163 + 32] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = _2163 + ceil32(return_data.size) + 32
                            require return_data.size >= 32
                            s = s + 2
                            t = ext_call.return_data[0] - _1314
                            continue 
                        _2164 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_2164 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_2164 + 36] = _2137
                        mem[_2164 + 68] = 0
                        mem[_2164 + 100] = this.address
                        mem[_2164 + 132] = 128
                        mem[_2164 + 164] = mem[_2164]
                        t = 0
                        while t < mem[_2164]:
                            mem[t + _2164 + 196] = mem[t + _2164 + 32]
                            t = t + 32
                            continue 
                        if ceil32(mem[_2164]) <= mem[_2164]:
                            require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                            call address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).mem[mem[64] len 4] with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len ceil32(mem[_2164]) + _2164 + -mem[64] + 192]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                            staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).balanceOf(address rg1) with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2812 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            s = s + 2
                            t = mem[_2812] - _1314
                            continue 
                        mem[_2164 + mem[_2164] + 196] = 0
                        require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                        call address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len ceil32(mem[_2164]) + _2164 + -mem[64] + 192]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                        staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2844 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        s = s + 2
                        t = mem[_2844] - _1314
                        continue 
                    _2058 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    mem[mem[64] + 4] = mem[_2058] - Mask(112, 0, _2016)
                    mem[mem[64] + 36] = Mask(112, 0, _2016)
                    mem[mem[64] + 68] = Mask(112, 0, _2008)
                    require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]))
                    staticcall address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                            gas gas_remaining wei
                           args mem[mem[64] + 4], _2016 << 144, Mask(112, 0, _2008)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2122 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2138 = mem[_2122]
                    if address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]) != address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]):
                        _2166 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_2166 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_2166 + 36] = _2138
                        mem[_2166 + 68] = 0
                        mem[_2166 + 100] = this.address
                        mem[_2166 + 132] = 128
                        mem[_2166 + 164] = mem[_2166]
                        t = 0
                        while t < mem[_2166]:
                            mem[t + _2166 + 196] = mem[t + _2166 + 32]
                            t = t + 32
                            continue 
                        if ceil32(mem[_2166]) > mem[_2166]:
                            mem[_2166 + mem[_2166] + 196] = 0
                        require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                        call address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                             gas gas_remaining wei
                            args _2138, 0, address(this.address), 128, mem[_2166], mem[_2166 + 196 len ceil32(mem[_2166])]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_2166 + 36] = this.address
                        require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                        staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args this.address
                        mem[_2166 + 32] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[64] = _2166 + ceil32(return_data.size) + 32
                        require return_data.size >= 32
                        s = s + 2
                        t = ext_call.return_data[0] - _1314
                        continue 
                    _2165 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_2165 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_2165 + 36] = 0
                    mem[_2165 + 68] = _2138
                    mem[_2165 + 100] = this.address
                    mem[_2165 + 132] = 128
                    mem[_2165 + 164] = mem[_2165]
                    t = 0
                    while t < mem[_2165]:
                        mem[t + _2165 + 196] = mem[t + _2165 + 32]
                        t = t + 32
                        continue 
                    if ceil32(mem[_2165]) <= mem[_2165]:
                        require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                        call address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len ceil32(mem[_2165]) + _2165 + -mem[64] + 192]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                        staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2813 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        s = s + 2
                        t = mem[_2813] - _1314
                        continue 
                    mem[_2165 + mem[_2165] + 196] = 0
                    require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                    call address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_2165]) + _2165 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                    staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2845 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    s = s + 2
                    t = mem[_2845] - _1314
                    continue 
                require mem[96] >= 32
                if not mem[128]:
                    revert with 0, 
                                32,
                                42,
                                0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                mem[mem[64] + 110 len 22]
                require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                staticcall address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).getReserves() with:
                        gas gas_remaining wei
                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]) < address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]):
                    _2003 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 96
                    _2011 = mem[_2003]
                    require mem[_2003] == mem[_2003 + 18 len 14]
                    _2021 = mem[_2003 + 32]
                    require mem[_2003 + 32] == mem[_2003 + 50 len 14]
                    require mem[_2003 + 64] == mem[_2003 + 92 len 4]
                    mem[mem[64] + 4] = address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)])
                    require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]))
                    staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)])
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]) == address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]):
                        _2075 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        mem[mem[64] + 4] = mem[_2075] - Mask(112, 0, _2011)
                        mem[mem[64] + 36] = Mask(112, 0, _2011)
                        mem[mem[64] + 68] = Mask(112, 0, _2021)
                        require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]))
                        staticcall address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                                gas gas_remaining wei
                               args mem[mem[64] + 4], _2011 << 144, Mask(112, 0, _2021)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2139 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2151 = mem[_2139]
                        if address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]) == address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]):
                            _2191 = mem[64]
                            mem[mem[64]] = 0
                            mem[64] = mem[64] + 32
                            mem[_2191 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                            mem[_2191 + 36] = 0
                            mem[_2191 + 68] = _2151
                            mem[_2191 + 100] = this.address
                            mem[_2191 + 132] = 128
                            mem[_2191 + 164] = mem[_2191]
                            t = 0
                            while t < mem[_2191]:
                                mem[t + _2191 + 196] = mem[t + _2191 + 32]
                                t = t + 32
                                continue 
                            if ceil32(mem[_2191]) > mem[_2191]:
                                mem[_2191 + mem[_2191] + 196] = 0
                            require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                            call address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                                 gas gas_remaining wei
                                args 0, _2151, address(this.address), 128, mem[_2191], mem[_2191 + 196 len ceil32(mem[_2191])]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_2191 + 36] = this.address
                            require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                            staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).balanceOf(address rg1) with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[_2191 + 32] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = _2191 + ceil32(return_data.size) + 32
                            require return_data.size >= 32
                            s = s + 2
                            t = ext_call.return_data[0] - _1314
                            continue 
                        _2192 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_2192 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_2192 + 36] = _2151
                        mem[_2192 + 68] = 0
                        mem[_2192 + 100] = this.address
                        mem[_2192 + 132] = 128
                        mem[_2192 + 164] = mem[_2192]
                        t = 0
                        while t < mem[_2192]:
                            mem[t + _2192 + 196] = mem[t + _2192 + 32]
                            t = t + 32
                            continue 
                        if ceil32(mem[_2192]) <= mem[_2192]:
                            require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                            call address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).mem[mem[64] len 4] with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len ceil32(mem[_2192]) + _2192 + -mem[64] + 192]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                            staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).balanceOf(address rg1) with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2816 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            s = s + 2
                            t = mem[_2816] - _1314
                            continue 
                        mem[_2192 + mem[_2192] + 196] = 0
                        require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                        call address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len ceil32(mem[_2192]) + _2192 + -mem[64] + 192]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                        staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2848 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        s = s + 2
                        t = mem[_2848] - _1314
                        continue 
                    _2076 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    mem[mem[64] + 4] = mem[_2076] - Mask(112, 0, _2021)
                    mem[mem[64] + 36] = Mask(112, 0, _2021)
                    mem[mem[64] + 68] = Mask(112, 0, _2011)
                    require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]))
                    staticcall address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                            gas gas_remaining wei
                           args mem[mem[64] + 4], _2021 << 144, Mask(112, 0, _2011)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2140 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2152 = mem[_2140]
                    if address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]) != address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]):
                        _2194 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_2194 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_2194 + 36] = _2152
                        mem[_2194 + 68] = 0
                        mem[_2194 + 100] = this.address
                        mem[_2194 + 132] = 128
                        mem[_2194 + 164] = mem[_2194]
                        t = 0
                        while t < mem[_2194]:
                            mem[t + _2194 + 196] = mem[t + _2194 + 32]
                            t = t + 32
                            continue 
                        if ceil32(mem[_2194]) > mem[_2194]:
                            mem[_2194 + mem[_2194] + 196] = 0
                        require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                        call address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                             gas gas_remaining wei
                            args _2152, 0, address(this.address), 128, mem[_2194], mem[_2194 + 196 len ceil32(mem[_2194])]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_2194 + 36] = this.address
                        require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                        staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args this.address
                        mem[_2194 + 32] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[64] = _2194 + ceil32(return_data.size) + 32
                        require return_data.size >= 32
                        s = s + 2
                        t = ext_call.return_data[0] - _1314
                        continue 
                    _2193 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_2193 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_2193 + 36] = 0
                    mem[_2193 + 68] = _2152
                    mem[_2193 + 100] = this.address
                    mem[_2193 + 132] = 128
                    mem[_2193 + 164] = mem[_2193]
                    t = 0
                    while t < mem[_2193]:
                        mem[t + _2193 + 196] = mem[t + _2193 + 32]
                        t = t + 32
                        continue 
                    if ceil32(mem[_2193]) <= mem[_2193]:
                        require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                        call address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len ceil32(mem[_2193]) + _2193 + -mem[64] + 192]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                        staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2817 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        s = s + 2
                        t = mem[_2817] - _1314
                        continue 
                    mem[_2193 + mem[_2193] + 196] = 0
                    require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                    call address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_2193]) + _2193 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                    staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2849 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    s = s + 2
                    t = mem[_2849] - _1314
                    continue 
                _2004 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 96
                _2012 = mem[_2004]
                require mem[_2004] == mem[_2004 + 18 len 14]
                _2022 = mem[_2004 + 32]
                require mem[_2004 + 32] == mem[_2004 + 50 len 14]
                require mem[_2004 + 64] == mem[_2004 + 92 len 4]
                mem[mem[64] + 4] = address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)])
                require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]))
                staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)])
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]) == address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]):
                    _2077 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    mem[mem[64] + 4] = mem[_2077] - Mask(112, 0, _2012)
                    mem[mem[64] + 36] = Mask(112, 0, _2012)
                    mem[mem[64] + 68] = Mask(112, 0, _2022)
                    require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]))
                    staticcall address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                            gas gas_remaining wei
                           args mem[mem[64] + 4], _2012 << 144, Mask(112, 0, _2022)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2141 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2153 = mem[_2141]
                    if address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]) == address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]):
                        _2195 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_2195 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_2195 + 36] = 0
                        mem[_2195 + 68] = _2153
                        mem[_2195 + 100] = this.address
                        mem[_2195 + 132] = 128
                        mem[_2195 + 164] = mem[_2195]
                        t = 0
                        while t < mem[_2195]:
                            mem[t + _2195 + 196] = mem[t + _2195 + 32]
                            t = t + 32
                            continue 
                        if ceil32(mem[_2195]) > mem[_2195]:
                            mem[_2195 + mem[_2195] + 196] = 0
                        require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                        call address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                             gas gas_remaining wei
                            args 0, _2153, address(this.address), 128, mem[_2195], mem[_2195 + 196 len ceil32(mem[_2195])]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_2195 + 36] = this.address
                        require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                        staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args this.address
                        mem[_2195 + 32] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[64] = _2195 + ceil32(return_data.size) + 32
                    else:
                        _2196 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_2196 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_2196 + 36] = _2153
                        mem[_2196 + 68] = 0
                        mem[_2196 + 100] = this.address
                        mem[_2196 + 132] = 128
                        mem[_2196 + 164] = mem[_2196]
                        t = 0
                        while t < mem[_2196]:
                            mem[t + _2196 + 196] = mem[t + _2196 + 32]
                            t = t + 32
                            continue 
                        if ceil32(mem[_2196]) > mem[_2196]:
                            mem[_2196 + mem[_2196] + 196] = 0
                        require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                        call address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                             gas gas_remaining wei
                            args _2153, 0, address(this.address), 128, mem[_2196], mem[_2196 + 196 len ceil32(mem[_2196])]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_2196 + 36] = this.address
                        require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                        staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args this.address
                        mem[_2196 + 32] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[64] = _2196 + ceil32(return_data.size) + 32
                    require return_data.size >= 32
                    s = s + 2
                    t = ext_call.return_data[0] - _1314
                    continue 
                _2078 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[mem[64] + 4] = mem[_2078] - Mask(112, 0, _2022)
                mem[mem[64] + 36] = Mask(112, 0, _2022)
                mem[mem[64] + 68] = Mask(112, 0, _2012)
                require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]))
                staticcall address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                        gas gas_remaining wei
                       args mem[mem[64] + 4], _2022 << 144, Mask(112, 0, _2012)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2142 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _2154 = mem[_2142]
                if address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]) != address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]):
                    _2198 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_2198 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_2198 + 36] = _2154
                    mem[_2198 + 68] = 0
                    mem[_2198 + 100] = this.address
                    mem[_2198 + 132] = 128
                    mem[_2198 + 164] = mem[_2198]
                    t = 0
                    while t < mem[_2198]:
                        mem[t + _2198 + 196] = mem[t + _2198 + 32]
                        t = t + 32
                        continue 
                    if ceil32(mem[_2198]) > mem[_2198]:
                        mem[_2198 + mem[_2198] + 196] = 0
                    require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                    call address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                         gas gas_remaining wei
                        args _2154, 0, address(this.address), 128, mem[_2198], mem[_2198 + 196 len ceil32(mem[_2198])]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[_2198 + 36] = this.address
                    require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                    staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args this.address
                    mem[_2198 + 32] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = _2198 + ceil32(return_data.size) + 32
                    require return_data.size >= 32
                    s = s + 2
                    t = ext_call.return_data[0] - _1314
                    continue 
                _2197 = mem[64]
                mem[mem[64]] = 0
                mem[64] = mem[64] + 32
                mem[_2197 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[_2197 + 36] = 0
                mem[_2197 + 68] = _2154
                mem[_2197 + 100] = this.address
                mem[_2197 + 132] = 128
                mem[_2197 + 164] = mem[_2197]
                t = 0
                while t < mem[_2197]:
                    mem[t + _2197 + 196] = mem[t + _2197 + 32]
                    t = t + 32
                    continue 
                if ceil32(mem[_2197]) <= mem[_2197]:
                    require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                    call address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_2197]) + _2197 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                    staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2821 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    s = s + 2
                    t = mem[_2821] - _1314
                    continue 
                mem[_2197 + mem[_2197] + 196] = 0
                require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                call address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len ceil32(mem[_2197]) + _2197 + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2853 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                s = s + 2
                t = mem[_2853] - _1314
                continue 
            _1954 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size) + 1
            mem[_1954] = return_data.size
            mem[_1954 + 32 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not ext_call.success:
                if return_data.size:
                    revert with ext_call.return_data[0 len return_data.size]
                _1961 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = mem[_1315 + 100]
                _1963 = mem[_1315 + 100]
                idx = 0
                while idx < _1963:
                    mem[idx + _1961 + 68] = mem[idx + _1315 + 132]
                    idx = idx + 32
                    continue 
                if not _1963 % 32:
                    revert with memory
                      from mem[64]
                       len _1963 + _1961 + -mem[64] + 68
                mem[floor32(_1963) + _1961 + 68] = mem[floor32(_1963) + _1961 + -(_1963 % 32) + 100 len _1963 % 32]
                revert with memory
                  from mem[64]
                   len floor32(_1963) + _1961 + -mem[64] + 100
            if not return_data.size:
                require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                staticcall address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).getReserves() with:
                        gas gas_remaining wei
                mem[mem[64] len 96] = ext_call.return_data[0 len 96]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]) < address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]):
                    _1997 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 96
                    _2009 = mem[_1997]
                    require mem[_1997] == mem[_1997 + 18 len 14]
                    _2017 = mem[_1997 + 32]
                    require mem[_1997 + 32] == mem[_1997 + 50 len 14]
                    require mem[_1997 + 64] == mem[_1997 + 92 len 4]
                    mem[mem[64] + 4] = address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)])
                    require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]))
                    staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)])
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]) == address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]):
                        _2063 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        mem[mem[64] + 4] = mem[_2063] - Mask(112, 0, _2009)
                        mem[mem[64] + 36] = Mask(112, 0, _2009)
                        mem[mem[64] + 68] = Mask(112, 0, _2017)
                        require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]))
                        staticcall address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                                gas gas_remaining wei
                               args mem[mem[64] + 4], _2009 << 144, Mask(112, 0, _2017)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2127 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        _2143 = mem[_2127]
                        if address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]) != address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]):
                            _2168 = mem[64]
                            mem[mem[64]] = 0
                            mem[64] = mem[64] + 32
                            mem[_2168 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                            mem[_2168 + 36] = _2143
                            mem[_2168 + 68] = 0
                            mem[_2168 + 100] = this.address
                            mem[_2168 + 132] = 128
                            mem[_2168 + 164] = mem[_2168]
                            t = 0
                            while t < mem[_2168]:
                                mem[t + _2168 + 196] = mem[t + _2168 + 32]
                                t = t + 32
                                continue 
                            if ceil32(mem[_2168]) > mem[_2168]:
                                mem[_2168 + mem[_2168] + 196] = 0
                            require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                            call address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                                 gas gas_remaining wei
                                args _2143, 0, address(this.address), 128, mem[_2168], mem[_2168 + 196 len ceil32(mem[_2168])]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[_2168 + 36] = this.address
                            require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                            staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).balanceOf(address rg1) with:
                                    gas gas_remaining wei
                                   args this.address
                            mem[_2168 + 32] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[64] = _2168 + ceil32(return_data.size) + 32
                            require return_data.size >= 32
                            s = s + 2
                            t = ext_call.return_data[0] - _1314
                            continue 
                        _2167 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_2167 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_2167 + 36] = 0
                        mem[_2167 + 68] = _2143
                        mem[_2167 + 100] = this.address
                        mem[_2167 + 132] = 128
                        mem[_2167 + 164] = mem[_2167]
                        t = 0
                        while t < mem[_2167]:
                            mem[t + _2167 + 196] = mem[t + _2167 + 32]
                            t = t + 32
                            continue 
                        if ceil32(mem[_2167]) <= mem[_2167]:
                            require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                            call address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).mem[mem[64] len 4] with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len ceil32(mem[_2167]) + _2167 + -mem[64] + 192]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                            staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).balanceOf(address rg1) with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2823 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            s = s + 2
                            t = mem[_2823] - _1314
                            continue 
                        mem[_2167 + mem[_2167] + 196] = 0
                        require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                        call address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len ceil32(mem[_2167]) + _2167 + -mem[64] + 192]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                        staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2855 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        s = s + 2
                        t = mem[_2855] - _1314
                        continue 
                    _2064 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    mem[mem[64] + 4] = mem[_2064] - Mask(112, 0, _2017)
                    mem[mem[64] + 36] = Mask(112, 0, _2017)
                    mem[mem[64] + 68] = Mask(112, 0, _2009)
                    require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]))
                    staticcall address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                            gas gas_remaining wei
                           args mem[mem[64] + 4], _2017 << 144, Mask(112, 0, _2009)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2128 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2144 = mem[_2128]
                    if address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]) != address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]):
                        _2170 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_2170 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_2170 + 36] = _2144
                        mem[_2170 + 68] = 0
                        mem[_2170 + 100] = this.address
                        mem[_2170 + 132] = 128
                        mem[_2170 + 164] = mem[_2170]
                        t = 0
                        while t < mem[_2170]:
                            mem[t + _2170 + 196] = mem[t + _2170 + 32]
                            t = t + 32
                            continue 
                        if ceil32(mem[_2170]) > mem[_2170]:
                            mem[_2170 + mem[_2170] + 196] = 0
                        require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                        call address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                             gas gas_remaining wei
                            args _2144, 0, address(this.address), 128, mem[_2170], mem[_2170 + 196 len ceil32(mem[_2170])]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_2170 + 36] = this.address
                        require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                        staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args this.address
                        mem[_2170 + 32] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[64] = _2170 + ceil32(return_data.size) + 32
                        require return_data.size >= 32
                        s = s + 2
                        t = ext_call.return_data[0] - _1314
                        continue 
                    _2169 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_2169 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_2169 + 36] = 0
                    mem[_2169 + 68] = _2144
                    mem[_2169 + 100] = this.address
                    mem[_2169 + 132] = 128
                    mem[_2169 + 164] = mem[_2169]
                    t = 0
                    while t < mem[_2169]:
                        mem[t + _2169 + 196] = mem[t + _2169 + 32]
                        t = t + 32
                        continue 
                    if ceil32(mem[_2169]) <= mem[_2169]:
                        require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                        call address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len ceil32(mem[_2169]) + _2169 + -mem[64] + 192]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                        staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2825 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        s = s + 2
                        t = mem[_2825] - _1314
                        continue 
                    mem[_2169 + mem[_2169] + 196] = 0
                    require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                    call address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_2169]) + _2169 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                    staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2857 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    s = s + 2
                    t = mem[_2857] - _1314
                    continue 
                _1998 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 96
                _2010 = mem[_1998]
                require mem[_1998] == mem[_1998 + 18 len 14]
                _2018 = mem[_1998 + 32]
                require mem[_1998 + 32] == mem[_1998 + 50 len 14]
                require mem[_1998 + 64] == mem[_1998 + 92 len 4]
                mem[mem[64] + 4] = address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)])
                require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]))
                staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)])
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]) == address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]):
                    _2065 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    mem[mem[64] + 4] = mem[_2065] - Mask(112, 0, _2010)
                    mem[mem[64] + 36] = Mask(112, 0, _2010)
                    mem[mem[64] + 68] = Mask(112, 0, _2018)
                    require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]))
                    staticcall address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                            gas gas_remaining wei
                           args mem[mem[64] + 4], _2010 << 144, Mask(112, 0, _2018)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2129 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2145 = mem[_2129]
                    if address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]) == address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]):
                        _2171 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_2171 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_2171 + 36] = 0
                        mem[_2171 + 68] = _2145
                        mem[_2171 + 100] = this.address
                        mem[_2171 + 132] = 128
                        mem[_2171 + 164] = mem[_2171]
                        t = 0
                        while t < mem[_2171]:
                            mem[t + _2171 + 196] = mem[t + _2171 + 32]
                            t = t + 32
                            continue 
                        if ceil32(mem[_2171]) > mem[_2171]:
                            mem[_2171 + mem[_2171] + 196] = 0
                        require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                        call address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                             gas gas_remaining wei
                            args 0, _2145, address(this.address), 128, mem[_2171], mem[_2171 + 196 len ceil32(mem[_2171])]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[_2171 + 36] = this.address
                        require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                        staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args this.address
                        mem[_2171 + 32] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[64] = _2171 + ceil32(return_data.size) + 32
                        require return_data.size >= 32
                        s = s + 2
                        t = ext_call.return_data[0] - _1314
                        continue 
                    _2172 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_2172 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_2172 + 36] = _2145
                    mem[_2172 + 68] = 0
                    mem[_2172 + 100] = this.address
                    mem[_2172 + 132] = 128
                    mem[_2172 + 164] = mem[_2172]
                    t = 0
                    while t < mem[_2172]:
                        mem[t + _2172 + 196] = mem[t + _2172 + 32]
                        t = t + 32
                        continue 
                    if ceil32(mem[_2172]) <= mem[_2172]:
                        require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                        call address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len ceil32(mem[_2172]) + _2172 + -mem[64] + 192]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                        staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2828 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        s = s + 2
                        t = mem[_2828] - _1314
                        continue 
                    mem[_2172 + mem[_2172] + 196] = 0
                    require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                    call address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_2172]) + _2172 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                    staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2860 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    s = s + 2
                    t = mem[_2860] - _1314
                    continue 
                _2066 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[mem[64] + 4] = mem[_2066] - Mask(112, 0, _2018)
                mem[mem[64] + 36] = Mask(112, 0, _2018)
                mem[mem[64] + 68] = Mask(112, 0, _2010)
                require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]))
                staticcall address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                        gas gas_remaining wei
                       args mem[mem[64] + 4], _2018 << 144, Mask(112, 0, _2010)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2130 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _2146 = mem[_2130]
                if address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]) != address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]):
                    _2174 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_2174 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_2174 + 36] = _2146
                    mem[_2174 + 68] = 0
                    mem[_2174 + 100] = this.address
                    mem[_2174 + 132] = 128
                    mem[_2174 + 164] = mem[_2174]
                    t = 0
                    while t < mem[_2174]:
                        mem[t + _2174 + 196] = mem[t + _2174 + 32]
                        t = t + 32
                        continue 
                    if ceil32(mem[_2174]) > mem[_2174]:
                        mem[_2174 + mem[_2174] + 196] = 0
                    require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                    call address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                         gas gas_remaining wei
                        args _2146, 0, address(this.address), 128, mem[_2174], mem[_2174 + 196 len ceil32(mem[_2174])]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[_2174 + 36] = this.address
                    require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                    staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args this.address
                    mem[_2174 + 32] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = _2174 + ceil32(return_data.size) + 32
                    require return_data.size >= 32
                    s = s + 2
                    t = ext_call.return_data[0] - _1314
                    continue 
                _2173 = mem[64]
                mem[mem[64]] = 0
                mem[64] = mem[64] + 32
                mem[_2173 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[_2173 + 36] = 0
                mem[_2173 + 68] = _2146
                mem[_2173 + 100] = this.address
                mem[_2173 + 132] = 128
                mem[_2173 + 164] = mem[_2173]
                t = 0
                while t < mem[_2173]:
                    mem[t + _2173 + 196] = mem[t + _2173 + 32]
                    t = t + 32
                    continue 
                if ceil32(mem[_2173]) <= mem[_2173]:
                    require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                    call address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_2173]) + _2173 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                    staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2829 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    s = s + 2
                    t = mem[_2829] - _1314
                    continue 
                mem[_2173 + mem[_2173] + 196] = 0
                require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                call address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len ceil32(mem[_2173]) + _2173 + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2861 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                s = s + 2
                t = mem[_2861] - _1314
                continue 
            require return_data.size >= 32
            if not mem[_1954 + 32]:
                revert with 0, 
                            32,
                            42,
                            0x735361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                            mem[mem[64] + 110 len 22]
            require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
            staticcall address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).getReserves() with:
                    gas gas_remaining wei
            mem[mem[64] len 96] = ext_call.return_data[0 len 96]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]) < address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]):
                _2005 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 96
                _2013 = mem[_2005]
                require mem[_2005] == mem[_2005 + 18 len 14]
                _2025 = mem[_2005 + 32]
                require mem[_2005 + 32] == mem[_2005 + 50 len 14]
                require mem[_2005 + 64] == mem[_2005 + 92 len 4]
                mem[mem[64] + 4] = address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)])
                require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]))
                staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)])
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]) == address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]):
                    _2083 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    mem[mem[64] + 4] = mem[_2083] - Mask(112, 0, _2013)
                    mem[mem[64] + 36] = Mask(112, 0, _2013)
                    mem[mem[64] + 68] = Mask(112, 0, _2025)
                    require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]))
                    staticcall address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                            gas gas_remaining wei
                           args mem[mem[64] + 4], _2013 << 144, Mask(112, 0, _2025)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2147 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    _2155 = mem[_2147]
                    if address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]) == address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]):
                        _2199 = mem[64]
                        mem[mem[64]] = 0
                        mem[64] = mem[64] + 32
                        mem[_2199 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                        mem[_2199 + 36] = 0
                        mem[_2199 + 68] = _2155
                        mem[_2199 + 100] = this.address
                        mem[_2199 + 132] = 128
                        mem[_2199 + 164] = mem[_2199]
                        t = 0
                        while t < mem[_2199]:
                            mem[t + _2199 + 196] = mem[t + _2199 + 32]
                            t = t + 32
                            continue 
                        if ceil32(mem[_2199]) <= mem[_2199]:
                            require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                            call address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).mem[mem[64] len 4] with:
                                 gas gas_remaining wei
                                args mem[mem[64] + 4 len ceil32(mem[_2199]) + _2199 + -mem[64] + 192]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64] + 4] = this.address
                            require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                            staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).balanceOf(address rg1) with:
                                    gas gas_remaining wei
                                   args address(this.address)
                            mem[mem[64]] = ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _2831 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 32
                            s = s + 2
                            t = mem[_2831] - _1314
                            continue 
                        mem[_2199 + mem[_2199] + 196] = 0
                        require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                        call address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len ceil32(mem[_2199]) + _2199 + -mem[64] + 192]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                        staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2863 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        s = s + 2
                        t = mem[_2863] - _1314
                        continue 
                    _2200 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_2200 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_2200 + 36] = _2155
                    mem[_2200 + 68] = 0
                    mem[_2200 + 100] = this.address
                    mem[_2200 + 132] = 128
                    mem[_2200 + 164] = mem[_2200]
                    t = 0
                    while t < mem[_2200]:
                        mem[t + _2200 + 196] = mem[t + _2200 + 32]
                        t = t + 32
                        continue 
                    if ceil32(mem[_2200]) <= mem[_2200]:
                        require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                        call address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len ceil32(mem[_2200]) + _2200 + -mem[64] + 192]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                        staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2832 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        s = s + 2
                        t = mem[_2832] - _1314
                        continue 
                    mem[_2200 + mem[_2200] + 196] = 0
                    require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                    call address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_2200]) + _2200 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                    staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2864 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    s = s + 2
                    t = mem[_2864] - _1314
                    continue 
                _2084 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[mem[64] + 4] = mem[_2084] - Mask(112, 0, _2025)
                mem[mem[64] + 36] = Mask(112, 0, _2025)
                mem[mem[64] + 68] = Mask(112, 0, _2013)
                require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]))
                staticcall address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                        gas gas_remaining wei
                       args mem[mem[64] + 4], _2025 << 144, Mask(112, 0, _2013)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2148 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _2156 = mem[_2148]
                if address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]) == address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]):
                    _2201 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_2201 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_2201 + 36] = 0
                    mem[_2201 + 68] = _2156
                    mem[_2201 + 100] = this.address
                    mem[_2201 + 132] = 128
                    mem[_2201 + 164] = mem[_2201]
                    t = 0
                    while t < mem[_2201]:
                        mem[t + _2201 + 196] = mem[t + _2201 + 32]
                        t = t + 32
                        continue 
                    if ceil32(mem[_2201]) <= mem[_2201]:
                        require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                        call address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).mem[mem[64] len 4] with:
                             gas gas_remaining wei
                            args mem[mem[64] + 4 len ceil32(mem[_2201]) + _2201 + -mem[64] + 192]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64] + 4] = this.address
                        require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                        staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).balanceOf(address rg1) with:
                                gas gas_remaining wei
                               args address(this.address)
                        mem[mem[64]] = ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _2833 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 32
                        s = s + 2
                        t = mem[_2833] - _1314
                        continue 
                    mem[_2201 + mem[_2201] + 196] = 0
                    require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                    call address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_2201]) + _2201 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                    staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2865 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    s = s + 2
                    t = mem[_2865] - _1314
                    continue 
                _2202 = mem[64]
                mem[mem[64]] = 0
                mem[64] = mem[64] + 32
                mem[_2202 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[_2202 + 36] = _2156
                mem[_2202 + 68] = 0
                mem[_2202 + 100] = this.address
                mem[_2202 + 132] = 128
                mem[_2202 + 164] = mem[_2202]
                t = 0
                while t < mem[_2202]:
                    mem[t + _2202 + 196] = mem[t + _2202 + 32]
                    t = t + 32
                    continue 
                if ceil32(mem[_2202]) <= mem[_2202]:
                    require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                    call address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_2202]) + _2202 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                    staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2834 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    s = s + 2
                    t = mem[_2834] - _1314
                    continue 
                mem[_2202 + mem[_2202] + 196] = 0
                require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                call address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len ceil32(mem[_2202]) + _2202 + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2866 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                s = s + 2
                t = mem[_2866] - _1314
                continue 
            _2006 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 96
            _2014 = mem[_2006]
            require mem[_2006] == mem[_2006 + 18 len 14]
            _2026 = mem[_2006 + 32]
            require mem[_2006 + 32] == mem[_2006 + 50 len 14]
            require mem[_2006 + 64] == mem[_2006 + 92 len 4]
            mem[mem[64] + 4] = address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)])
            require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]))
            staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]).balanceOf(address rg1) with:
                    gas gas_remaining wei
                   args address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)])
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]) == address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]):
                _2085 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                mem[mem[64] + 4] = mem[_2085] - Mask(112, 0, _2014)
                mem[mem[64] + 36] = Mask(112, 0, _2014)
                mem[mem[64] + 68] = Mask(112, 0, _2026)
                require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]))
                staticcall address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                        gas gas_remaining wei
                       args mem[mem[64] + 4], _2014 << 144, Mask(112, 0, _2026)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2149 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                _2157 = mem[_2149]
                if address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]) != address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]):
                    _2204 = mem[64]
                    mem[mem[64]] = 0
                    mem[64] = mem[64] + 32
                    mem[_2204 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                    mem[_2204 + 36] = _2157
                    mem[_2204 + 68] = 0
                    mem[_2204 + 100] = this.address
                    mem[_2204 + 132] = 128
                    mem[_2204 + 164] = mem[_2204]
                    t = 0
                    while t < mem[_2204]:
                        mem[t + _2204 + 196] = mem[t + _2204 + 32]
                        t = t + 32
                        continue 
                    if ceil32(mem[_2204]) > mem[_2204]:
                        mem[_2204 + mem[_2204] + 196] = 0
                    require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                    call address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).swap(uint256 rg1, uint256 rg2, address rg3, bytes rg4) with:
                         gas gas_remaining wei
                        args _2157, 0, address(this.address), 128, mem[_2204], mem[_2204 + 196 len ceil32(mem[_2204])]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[_2204 + 36] = this.address
                    require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                    staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args this.address
                    mem[_2204 + 32] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[64] = _2204 + ceil32(return_data.size) + 32
                    require return_data.size >= 32
                    s = s + 2
                    t = ext_call.return_data[0] - _1314
                    continue 
                _2203 = mem[64]
                mem[mem[64]] = 0
                mem[64] = mem[64] + 32
                mem[_2203 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[_2203 + 36] = 0
                mem[_2203 + 68] = _2157
                mem[_2203 + 100] = this.address
                mem[_2203 + 132] = 128
                mem[_2203 + 164] = mem[_2203]
                t = 0
                while t < mem[_2203]:
                    mem[t + _2203 + 196] = mem[t + _2203 + 32]
                    t = t + 32
                    continue 
                if ceil32(mem[_2203]) <= mem[_2203]:
                    require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                    call address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_2203]) + _2203 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                    staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2835 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    s = s + 2
                    t = mem[_2835] - _1314
                    continue 
                mem[_2203 + mem[_2203] + 196] = 0
                require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                call address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len ceil32(mem[_2203]) + _2203 + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2867 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                s = s + 2
                t = mem[_2867] - _1314
                continue 
            _2086 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            mem[mem[64] + 4] = mem[_2086] - Mask(112, 0, _2026)
            mem[mem[64] + 36] = Mask(112, 0, _2026)
            mem[mem[64] + 68] = Mask(112, 0, _2014)
            require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]))
            staticcall address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]).getAmountOut(uint256 rg1, uint256 rg2, uint256 rg3) with:
                    gas gas_remaining wei
                   args mem[mem[64] + 4], _2026 << 144, Mask(112, 0, _2014)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _2150 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            _2158 = mem[_2150]
            if address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 68)]) == address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]):
                _2205 = mem[64]
                mem[mem[64]] = 0
                mem[64] = mem[64] + 32
                mem[_2205 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
                mem[_2205 + 36] = 0
                mem[_2205 + 68] = _2158
                mem[_2205 + 100] = this.address
                mem[_2205 + 132] = 128
                mem[_2205 + 164] = mem[_2205]
                t = 0
                while t < mem[_2205]:
                    mem[t + _2205 + 196] = mem[t + _2205 + 32]
                    t = t + 32
                    continue 
                if ceil32(mem[_2205]) <= mem[_2205]:
                    require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                    call address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).mem[mem[64] len 4] with:
                         gas gas_remaining wei
                        args mem[mem[64] + 4 len ceil32(mem[_2205]) + _2205 + -mem[64] + 192]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64] + 4] = this.address
                    require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                    staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).balanceOf(address rg1) with:
                            gas gas_remaining wei
                           args address(this.address)
                    mem[mem[64]] = ext_call.return_data[0]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _2837 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 32
                    s = s + 2
                    t = mem[_2837] - _1314
                    continue 
                mem[_2205 + mem[_2205] + 196] = 0
                require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                call address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len ceil32(mem[_2205]) + _2205 + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2869 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                s = s + 2
                t = mem[_2869] - _1314
                continue 
            _2206 = mem[64]
            mem[mem[64]] = 0
            mem[64] = mem[64] + 32
            mem[_2206 + 32] = 0x22c0d9f00000000000000000000000000000000000000000000000000000000
            mem[_2206 + 36] = _2158
            mem[_2206 + 68] = 0
            mem[_2206 + 100] = this.address
            mem[_2206 + 132] = 128
            mem[_2206 + 164] = mem[_2206]
            t = 0
            while t < mem[_2206]:
                mem[t + _2206 + 196] = mem[t + _2206 + 32]
                t = t + 32
                continue 
            if ceil32(mem[_2206]) <= mem[_2206]:
                require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                call address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).mem[mem[64] len 4] with:
                     gas gas_remaining wei
                    args mem[mem[64] + 4 len ceil32(mem[_2206]) + _2206 + -mem[64] + 192]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64] + 4] = this.address
                require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
                staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).balanceOf(address rg1) with:
                        gas gas_remaining wei
                       args address(this.address)
                mem[mem[64]] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _2838 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 32
                s = s + 2
                t = mem[_2838] - _1314
                continue 
            mem[_2206 + mem[_2206] + 196] = 0
            require ext_code.size(address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
            call address(cd[((64 * s) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).mem[mem[64] len 4] with:
                 gas gas_remaining wei
                args mem[mem[64] + 4 len ceil32(mem[_2206]) + _2206 + -mem[64] + 192]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[mem[64] + 4] = this.address
            require ext_code.size(address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]))
            staticcall address(cd[((64 * s + 1) + cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 100)]).balanceOf(address rg1) with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _2870 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 32
            s = s + 2
            t = mem[_2870] - _1314
            continue 
        require 1 < cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 36)]
        require cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 132)] == address(cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 132)])
        mem[mem[64] + 4] = this.address
        require ext_code.size(address(cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 132)]))
        staticcall address(cd[(cd[4] + cd[(cd[4] + (32 * idx) + 36)] + 132)]).balanceOf(address rg1) with:
                gas gas_remaining wei
               args address(this.address)
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _1307 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 32
        if mem[_1307] <= _659:
            revert with 0, 'sL'
        idx = idx + 1
        continue 
}



}

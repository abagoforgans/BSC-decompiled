contract main {




// =====================  Runtime code  =====================


#
#  - transferFrom(address arg1, address arg2, uint256 arg3)
#  - deliver(uint256 arg1)
#  - transfer(address arg1, uint256 arg2)
#  - _fallback()
#
const name = 'Siderum', 0

const decimals = 18

const symbol = '', 0


address owner;
address stor1;
uint256 unlockTime;
mapping of uint256 stor3;
mapping of uint256 stor4;
mapping of uint8 stor5;
mapping of uint8 stor6;
mapping of uint256 allowance;
mapping of uint8 stor8;
array of address stor9;
address marketingWalletAddress;
uint256 totalSupply;
uint256 stor12;
uint256 totalFees;
uint256 totalBurn;
uint256 _taxFee;
uint256 _liquidityFee;
uint256 _marketingFee;
uint256 _maxTxAmount;
uint256 _numTokensSellToAddToLiquidity;
uint8 _swapAndLiquifyEnabled;
address _uniswapV2RouterAddress; offset 16
address _uniswapV2PairAddress;

function totalFees() {
    return totalFees
}

function totalSupply() {
    return totalSupply
}

function _marketingFee() {
    return _marketingFee
}

function _taxFee() {
    return _taxFee
}

function totalBurn() {
    return totalBurn
}

function isExcludedFromFee(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    return bool(stor5[address(arg1)])
}

function _uniswapV2Router() {
    return _uniswapV2RouterAddress
}

function getUnlockTime() {
    return unlockTime
}

function _liquidityFee() {
    return _liquidityFee
}

function marketingWallet() {
    return marketingWalletAddress
}

function _maxTxAmount() {
    return _maxTxAmount
}

function sub_8268a343(?) {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    return bool(stor8[arg1])
}

function isExcludedFromReward(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    return bool(stor6[address(arg1)])
}

function owner() {
    return owner
}

function _uniswapV2Pair() {
    return _uniswapV2PairAddress
}

function _numTokensSellToAddToLiquidity() {
    return _numTokensSellToAddToLiquidity
}

function _swapAndLiquifyEnabled() {
    return bool(_swapAndLiquifyEnabled)
}

function allowance(address arg1, address arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 == arg2
    return allowance[address(arg1)][address(arg2)]
}

function renounceOwnership() {
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    emit 0x658be007: owner, 0
    owner = 0
}

function setTaxFeePercent(uint256 arg1) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    _taxFee = arg1
}

function setMarketingFeePercent(uint256 arg1) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    _marketingFee = arg1
}

function setLiquidityFeePercent(uint256 arg1) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    _liquidityFee = arg1
}

function includeInFee(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    stor5[address(arg1)] = 0
}

function excludeFromFee(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    stor5[address(arg1)] = 1
}

function setUniswapPair(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    _uniswapV2PairAddress = arg1
}

function setUniswapRouter(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    _uniswapV2RouterAddress = arg1
}

function setIsExcludedFromSwapAndLiquify(address arg1, bool arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 == arg2
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    stor8[address(arg1)] = uint8(arg2)
}

function setSwapAndLiquifyEnabled(bool arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    _swapAndLiquifyEnabled = uint8(arg1)
    emit SwapAndLiquifyEnabledUpdated(arg1);
}

function lock(uint256 arg1) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    stor1 = owner
    owner = 0
    if block.timestamp > !arg1:
        revert with 0, 17
    unlockTime = block.timestamp + arg1
    emit 0x658be007: owner, 0
}

function unlock() {
    if stor1 != msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'You don't have permission to unlock'
    if block.timestamp <= unlockTime:
        revert with 0, 'Contract is still locked'
    emit 0x658be007: owner, stor1
    owner = stor1
}

function transferOwnership(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Ownable: new owner is the zero address'
    emit 0x658be007: owner, arg1
    owner = arg1
}

function approve(address arg1, uint256 arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    if not msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: approve from the zero address'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: approve to the zero address'
    allowance[address(msg.sender)][address(arg1)] = arg2
    emit Approval(arg2, msg.sender, arg1);
    return 1
}

function setMaxTxPercent(uint256 arg1) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not totalSupply:
        _maxTxAmount = 0
    else:
        if totalSupply and arg1 > -1 / totalSupply:
            revert with 0, 17
        if not totalSupply:
            revert with 0, 18
        if totalSupply * arg1 / totalSupply != arg1:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
        _maxTxAmount = totalSupply * arg1 / 100
}

function setMinLiquidityPercent(uint256 arg1) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not totalSupply:
        _numTokensSellToAddToLiquidity = 0
    else:
        if totalSupply and arg1 > -1 / totalSupply:
            revert with 0, 17
        if not totalSupply:
            revert with 0, 18
        if totalSupply * arg1 / totalSupply != arg1:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
        _numTokensSellToAddToLiquidity = totalSupply * arg1 / 1000
}

function decreaseAllowance(address arg1, uint256 arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    if arg2 > allowance[msg.sender][address(arg1)]:
        revert with 0, 32, 37, 0xe042455032303a2064656372656173656420616c6c6f77616e63652062656c6f77207a6572, mem[165 len 27] >> 40, 0
    if allowance[msg.sender][address(arg1)] < arg2:
        revert with 0, 17
    if not msg.sender:
        revert with 0, 'BEP20: approve from the zero address'
    if not arg1:
        revert with 0, 'BEP20: approve to the zero address'
    allowance[address(msg.sender)][address(arg1)] = allowance[msg.sender][address(arg1)] - arg2
    emit Approval((allowance[msg.sender][address(arg1)] - arg2), msg.sender, arg1);
    return 1
}

function increaseAllowance(address arg1, uint256 arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    if allowance[msg.sender][address(arg1)] > !arg2:
        revert with 0, 17
    if allowance[msg.sender][address(arg1)] + arg2 < allowance[msg.sender][address(arg1)]:
        revert with 0, 'SafeMath: addition overflow'
    if not msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: approve from the zero address'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: approve to the zero address'
    allowance[address(msg.sender)][address(arg1)] = allowance[msg.sender][address(arg1)] + arg2
    emit Approval((allowance[msg.sender][address(arg1)] + arg2), msg.sender, arg1);
    return 1
}

function includeInReward(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not stor6[address(arg1)]:
        revert with 0, 'Account is already excluded'
    idx = 0
    while idx < stor9.length:
        mem[0] = 9
        if stor9[idx] != arg1:
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        if stor9.length < 1:
            revert with 0, 17
        if stor9.length - 1 >= stor9.length:
            revert with 0, 50
        if idx >= stor9.length:
            revert with 0, 50
        stor9[idx] = stor9[stor9.length]
        stor4[address(arg1)] = 0
        stor6[address(arg1)] = 0
        if not stor9.length:
            revert with 0, 49
        stor9[stor9.length] = 0
        stor9.length--
}

function tokenFromReflection(uint256 arg1) payable {
    mem[64] = 96
    require not msg.value
    require calldata.size - 4 >= 32
    if arg1 > stor12:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Amount must be less than total reflections'
    idx = 0
    s = totalSupply
    t = stor12
    while idx < stor9.length:
        mem[0] = stor9[idx]
        mem[32] = 3
        if stor3[stor9[idx]] > t:
            _92 = mem[64]
            mem[64] = mem[64] + 64
            mem[_92] = 26
            mem[_92 + 32] = 'SafeMath: division by zero'
            if not totalSupply:
                _96 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _96 + 68] = mem[idx + _92 + 32]
                    idx = idx + 32
                    continue 
                mem[_96 + 94] = 0
                revert with memory
                  from mem[64]
                   len _96 + -mem[64] + 100
            _117 = mem[64]
            mem[64] = mem[64] + 64
            mem[_117] = 26
            mem[_117 + 32] = 'SafeMath: division by zero'
            if stor12 / totalSupply:
                return (arg1 / stor12 / totalSupply)
            _126 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _126 + 68] = mem[idx + _117 + 32]
                idx = idx + 32
                continue 
            mem[_126 + 94] = 0
            revert with memory
              from mem[64]
               len _126 + -mem[64] + 100
        if idx >= stor9.length:
            revert with 0, 50
        mem[0] = stor9[idx]
        mem[32] = 4
        if stor4[stor9[idx]] > s:
            _98 = mem[64]
            mem[64] = mem[64] + 64
            mem[_98] = 26
            mem[_98 + 32] = 'SafeMath: division by zero'
            if not totalSupply:
                _103 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _103 + 68] = mem[idx + _98 + 32]
                    idx = idx + 32
                    continue 
                mem[_103 + 94] = 0
                revert with memory
                  from mem[64]
                   len _103 + -mem[64] + 100
            _128 = mem[64]
            mem[64] = mem[64] + 64
            mem[_128] = 26
            mem[_128 + 32] = 'SafeMath: division by zero'
            if stor12 / totalSupply:
                return (arg1 / stor12 / totalSupply)
            _133 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _133 + 68] = mem[idx + _128 + 32]
                idx = idx + 32
                continue 
            mem[_133 + 94] = 0
            revert with memory
              from mem[64]
               len _133 + -mem[64] + 100
        if idx >= stor9.length:
            revert with 0, 50
        mem[0] = stor9[idx]
        mem[32] = 3
        _97 = mem[64]
        mem[64] = mem[64] + 64
        mem[_97] = 30
        mem[_97 + 32] = 'SafeMath: subtraction overflow'
        if stor3[stor9[idx]] > t:
            _102 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[idx + _102 + 68] = mem[idx + _97 + 32]
                idx = idx + 32
                continue 
            mem[_102 + 98] = 0
            revert with memory
              from mem[64]
               len _102 + -mem[64] + 100
        if t < stor3[stor9[idx]]:
            revert with 0, 17
        if idx >= stor9.length:
            revert with 0, 50
        mem[0] = stor9[idx]
        mem[32] = 4
        _127 = mem[64]
        mem[64] = mem[64] + 64
        mem[_127] = 30
        mem[_127 + 32] = 'SafeMath: subtraction overflow'
        if stor4[stor9[idx]] <= s:
            if s < stor4[stor9[idx]]:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s - stor4[stor9[idx]]
            t = t - stor3[stor9[idx]]
            continue 
        _132 = mem[64]
        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 32
        mem[mem[64] + 36] = 30
        idx = 0
        while idx < 30:
            mem[idx + _132 + 68] = mem[idx + _127 + 32]
            idx = idx + 32
            continue 
        mem[_132 + 98] = 0
        revert with memory
          from mem[64]
           len _132 + -mem[64] + 100
    if not totalSupply:
        revert with 0, 'SafeMath: division by zero', 0
    if t >= stor12 / totalSupply:
        if not s:
            revert with 0, 'SafeMath: division by zero', 0
        if not t / s:
            revert with 0, 'SafeMath: division by zero', 0
        return (arg1 / t / s)
    if not totalSupply:
        revert with 0, 'SafeMath: division by zero', 0
    if not stor12 / totalSupply:
        revert with 0, 'SafeMath: division by zero', 0
    return (arg1 / stor12 / totalSupply)
}

function balanceOf(address arg1) payable {
    mem[64] = 96
    require not msg.value
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if stor6[address(arg1)]:
        return stor4[address(arg1)]
    mem[0] = arg1
    mem[32] = 3
    if stor3[address(arg1)] > stor12:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Amount must be less than total reflections'
    idx = 0
    s = totalSupply
    t = stor12
    while idx < stor9.length:
        mem[0] = stor9[idx]
        mem[32] = 3
        if stor3[stor9[idx]] > t:
            _97 = mem[64]
            mem[64] = mem[64] + 64
            mem[_97] = 26
            mem[_97 + 32] = 'SafeMath: division by zero'
            if not totalSupply:
                _101 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _101 + 68] = mem[idx + _97 + 32]
                    idx = idx + 32
                    continue 
                mem[_101 + 94] = 0
                revert with memory
                  from mem[64]
                   len _101 + -mem[64] + 100
            _122 = mem[64]
            mem[64] = mem[64] + 64
            mem[_122] = 26
            mem[_122 + 32] = 'SafeMath: division by zero'
            if stor12 / totalSupply:
                return (stor3[address(arg1)] / stor12 / totalSupply)
            _131 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _131 + 68] = mem[idx + _122 + 32]
                idx = idx + 32
                continue 
            mem[_131 + 94] = 0
            revert with memory
              from mem[64]
               len _131 + -mem[64] + 100
        if idx >= stor9.length:
            revert with 0, 50
        mem[0] = stor9[idx]
        mem[32] = 4
        if stor4[stor9[idx]] > s:
            _103 = mem[64]
            mem[64] = mem[64] + 64
            mem[_103] = 26
            mem[_103 + 32] = 'SafeMath: division by zero'
            if not totalSupply:
                _108 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _108 + 68] = mem[idx + _103 + 32]
                    idx = idx + 32
                    continue 
                mem[_108 + 94] = 0
                revert with memory
                  from mem[64]
                   len _108 + -mem[64] + 100
            _133 = mem[64]
            mem[64] = mem[64] + 64
            mem[_133] = 26
            mem[_133 + 32] = 'SafeMath: division by zero'
            if stor12 / totalSupply:
                return (stor3[address(arg1)] / stor12 / totalSupply)
            _138 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _138 + 68] = mem[idx + _133 + 32]
                idx = idx + 32
                continue 
            mem[_138 + 94] = 0
            revert with memory
              from mem[64]
               len _138 + -mem[64] + 100
        if idx >= stor9.length:
            revert with 0, 50
        mem[0] = stor9[idx]
        mem[32] = 3
        _102 = mem[64]
        mem[64] = mem[64] + 64
        mem[_102] = 30
        mem[_102 + 32] = 'SafeMath: subtraction overflow'
        if stor3[stor9[idx]] > t:
            _107 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[idx + _107 + 68] = mem[idx + _102 + 32]
                idx = idx + 32
                continue 
            mem[_107 + 98] = 0
            revert with memory
              from mem[64]
               len _107 + -mem[64] + 100
        if t < stor3[stor9[idx]]:
            revert with 0, 17
        if idx >= stor9.length:
            revert with 0, 50
        mem[0] = stor9[idx]
        mem[32] = 4
        _132 = mem[64]
        mem[64] = mem[64] + 64
        mem[_132] = 30
        mem[_132 + 32] = 'SafeMath: subtraction overflow'
        if stor4[stor9[idx]] <= s:
            if s < stor4[stor9[idx]]:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s - stor4[stor9[idx]]
            t = t - stor3[stor9[idx]]
            continue 
        _137 = mem[64]
        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 32
        mem[mem[64] + 36] = 30
        idx = 0
        while idx < 30:
            mem[idx + _137 + 68] = mem[idx + _132 + 32]
            idx = idx + 32
            continue 
        mem[_137 + 98] = 0
        revert with memory
          from mem[64]
           len _137 + -mem[64] + 100
    if not totalSupply:
        revert with 0, 'SafeMath: division by zero', 0
    if t >= stor12 / totalSupply:
        if not s:
            revert with 0, 'SafeMath: division by zero', 0
        if not t / s:
            revert with 0, 'SafeMath: division by zero', 0
        return (stor3[address(arg1)] / t / s)
    if not totalSupply:
        revert with 0, 'SafeMath: division by zero', 0
    if not stor12 / totalSupply:
        revert with 0, 'SafeMath: division by zero', 0
    return (stor3[address(arg1)] / stor12 / totalSupply)
}

function excludeFromReward(address arg1) payable {
    mem[64] = 96
    require not msg.value
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if stor6[address(arg1)]:
        revert with 0, 'Account is already excluded'
    if stor3[address(arg1)]:
        mem[0] = arg1
        mem[32] = 3
        if stor3[address(arg1)] > stor12:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Amount must be less than total reflections'
        idx = 0
        s = totalSupply
        t = stor12
        while idx < stor9.length:
            mem[0] = stor9[idx]
            mem[32] = 3
            if stor3[stor9[idx]] > t:
                _100 = mem[64]
                mem[64] = mem[64] + 64
                mem[_100] = 26
                mem[_100 + 32] = 'SafeMath: division by zero'
                if not totalSupply:
                    _104 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _104 + 68] = mem[idx + _100 + 32]
                        idx = idx + 32
                        continue 
                    mem[_104 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _104 + -mem[64] + 100
                _125 = mem[64]
                mem[64] = mem[64] + 64
                mem[_125] = 26
                mem[_125 + 32] = 'SafeMath: division by zero'
                if stor12 / totalSupply:
                    stor4[address(arg1)] = stor3[address(arg1)] / stor12 / totalSupply
                    stor6[address(arg1)] = 1
                    stor9.length++
                    stor9[stor9.length] = arg1
                _134 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _134 + 68] = mem[idx + _125 + 32]
                    idx = idx + 32
                    continue 
                mem[_134 + 94] = 0
                revert with memory
                  from mem[64]
                   len _134 + -mem[64] + 100
            if idx >= stor9.length:
                revert with 0, 50
            mem[0] = stor9[idx]
            mem[32] = 4
            if stor4[stor9[idx]] > s:
                _106 = mem[64]
                mem[64] = mem[64] + 64
                mem[_106] = 26
                mem[_106 + 32] = 'SafeMath: division by zero'
                if not totalSupply:
                    _111 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _111 + 68] = mem[idx + _106 + 32]
                        idx = idx + 32
                        continue 
                    mem[_111 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _111 + -mem[64] + 100
                _136 = mem[64]
                mem[64] = mem[64] + 64
                mem[_136] = 26
                mem[_136 + 32] = 'SafeMath: division by zero'
                if stor12 / totalSupply:
                    stor4[address(arg1)] = stor3[address(arg1)] / stor12 / totalSupply
                    stor6[address(arg1)] = 1
                    stor9.length++
                    stor9[stor9.length] = arg1
                _141 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _141 + 68] = mem[idx + _136 + 32]
                    idx = idx + 32
                    continue 
                mem[_141 + 94] = 0
                revert with memory
                  from mem[64]
                   len _141 + -mem[64] + 100
            if idx >= stor9.length:
                revert with 0, 50
            mem[0] = stor9[idx]
            mem[32] = 3
            _105 = mem[64]
            mem[64] = mem[64] + 64
            mem[_105] = 30
            mem[_105 + 32] = 'SafeMath: subtraction overflow'
            if stor3[stor9[idx]] > t:
                _110 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _110 + 68] = mem[idx + _105 + 32]
                    idx = idx + 32
                    continue 
                mem[_110 + 98] = 0
                revert with memory
                  from mem[64]
                   len _110 + -mem[64] + 100
            if t < stor3[stor9[idx]]:
                revert with 0, 17
            if idx >= stor9.length:
                revert with 0, 50
            mem[0] = stor9[idx]
            mem[32] = 4
            _135 = mem[64]
            mem[64] = mem[64] + 64
            mem[_135] = 30
            mem[_135 + 32] = 'SafeMath: subtraction overflow'
            if stor4[stor9[idx]] <= s:
                if s < stor4[stor9[idx]]:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s - stor4[stor9[idx]]
                t = t - stor3[stor9[idx]]
                continue 
            _140 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[idx + _140 + 68] = mem[idx + _135 + 32]
                idx = idx + 32
                continue 
            mem[_140 + 98] = 0
            revert with memory
              from mem[64]
               len _140 + -mem[64] + 100
        if not totalSupply:
            revert with 0, 'SafeMath: division by zero', 0
        if t >= stor12 / totalSupply:
            if not s:
                revert with 0, 'SafeMath: division by zero', 0
            if not t / s:
                revert with 0, 'SafeMath: division by zero', 0
            stor4[address(arg1)] = stor3[address(arg1)] / t / s
        else:
            if not totalSupply:
                revert with 0, 'SafeMath: division by zero', 0
            if not stor12 / totalSupply:
                revert with 0, 'SafeMath: division by zero', 0
            stor4[address(arg1)] = stor3[address(arg1)] / stor12 / totalSupply
    stor6[address(arg1)] = 1
    stor9.length++
    stor9[stor9.length] = arg1
}

function reflectionFromToken(uint256 arg1, bool arg2) {
    require calldata.size - 4 >= 64
    require arg2 == arg2
    if arg1 > totalSupply:
        revert with 0, 'Amount must be less than supply'
    if arg2:
        if not arg1:
            mem[96] = 26
            mem[128] = 'SafeMath: division by zero'
            if not arg1:
                mem[160] = 26
                mem[192] = 'SafeMath: division by zero'
                if not arg1:
                    mem[224] = 26
                    mem[256] = 'SafeMath: division by zero'
                    mem[288] = 30
                    mem[320] = 'SafeMath: subtraction overflow'
                    if 0 > arg1:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 < 0:
                        revert with 0, 17
                    mem[352] = 30
                    mem[384] = 'SafeMath: subtraction overflow'
                    if 0 > arg1:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 < 0:
                        revert with 0, 17
                    mem[64] = 480
                    mem[416] = 30
                    mem[448] = 'SafeMath: subtraction overflow'
                    if 0 > arg1:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 < 0:
                        revert with 0, 17
                    idx = 0
                    s = totalSupply
                    t = stor12
                    while idx < stor9.length:
                        mem[0] = stor9[idx]
                        mem[32] = 3
                        if stor3[stor9[idx]] > t:
                            _9266 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_9266] = 26
                            mem[_9266 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                _9344 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _9344 + 68] = mem[idx + _9266 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_9344 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _9344 + -mem[64] + 100
                            if not arg1:
                                return 0
                            if arg1 and stor12 / totalSupply > -1 / arg1:
                                revert with 0, 17
                            if not arg1:
                                revert with 0, 18
                            if arg1 * stor12 / totalSupply / arg1 != stor12 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _10304 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10304] = 30
                            mem[_10304 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor12 / totalSupply:
                                _10446 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _10446 + 68] = mem[idx + _10304 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_10446 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _10446 + -mem[64] + 100
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 0, 17
                            _11065 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11065] = 30
                            mem[_11065 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor12 / totalSupply:
                                _11372 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11372 + 68] = mem[idx + _11065 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11372 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11372 + -mem[64] + 100
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 0, 17
                            _12615 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12615] = 30
                            mem[_12615 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor12 / totalSupply:
                                if arg1 * stor12 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor12 / totalSupply)
                            _13104 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13104 + 68] = mem[idx + _12615 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13104 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13104 + -mem[64] + 100
                        if idx >= stor9.length:
                            revert with 0, 50
                        mem[0] = stor9[idx]
                        mem[32] = 4
                        if stor4[stor9[idx]] <= s:
                            if idx >= stor9.length:
                                revert with 0, 50
                            mem[0] = stor9[idx]
                            mem[32] = 3
                            _9345 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_9345] = 30
                            mem[_9345 + 32] = 'SafeMath: subtraction overflow'
                            if stor3[stor9[idx]] > t:
                                _9425 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _9425 + 68] = mem[idx + _9345 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_9425 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _9425 + -mem[64] + 100
                            if t < stor3[stor9[idx]]:
                                revert with 0, 17
                            if idx >= stor9.length:
                                revert with 0, 50
                            mem[0] = stor9[idx]
                            mem[32] = 4
                            _9778 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_9778] = 30
                            mem[_9778 + 32] = 'SafeMath: subtraction overflow'
                            if stor4[stor9[idx]] <= s:
                                if s < stor4[stor9[idx]]:
                                    revert with 0, 17
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s - stor4[stor9[idx]]
                                t = t - stor3[stor9[idx]]
                                continue 
                            _9826 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _9826 + 68] = mem[idx + _9778 + 32]
                                idx = idx + 32
                                continue 
                            mem[_9826 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _9826 + -mem[64] + 100
                        _9346 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9346] = 26
                        mem[_9346 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _9426 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _9426 + 68] = mem[idx + _9346 + 32]
                                idx = idx + 32
                                continue 
                            mem[_9426 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _9426 + -mem[64] + 100
                        if not arg1:
                            return 0
                        if arg1 and stor12 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor12 / totalSupply / arg1 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _10448 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10448] = 30
                        mem[_10448 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor12 / totalSupply:
                            _10589 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _10589 + 68] = mem[idx + _10448 + 32]
                                idx = idx + 32
                                continue 
                            mem[_10589 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _10589 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 0, 17
                        _11374 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11374] = 30
                        mem[_11374 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor12 / totalSupply:
                            _11729 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11729 + 68] = mem[idx + _11374 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11729 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11729 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 0, 17
                        _13105 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13105] = 30
                        mem[_13105 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= arg1 * stor12 / totalSupply:
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 0, 17
                            return (arg1 * stor12 / totalSupply)
                        _13592 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13592 + 68] = mem[idx + _13105 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13592 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13592 + -mem[64] + 100
                    if not totalSupply:
                        revert with 0, 'SafeMath: division by zero', 0
                    if t >= stor12 / totalSupply:
                        if not s:
                            revert with 0, 'SafeMath: division by zero', 0
                        if not arg1:
                            return 0
                        if arg1 and t / s > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * t / s / arg1 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        return (arg1 * t / s)
                    if not totalSupply:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg1:
                        return 0
                    if arg1 and stor12 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor12 / totalSupply / arg1 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 > arg1 * stor12 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor12 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor12 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 0, 17
                    return (arg1 * stor12 / totalSupply)
                if arg1 and _marketingFee > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * _marketingFee / arg1 != _marketingFee:
                    revert with 0, 'SafeMath: multiplication overflow'
                mem[224] = 26
                mem[256] = 'SafeMath: division by zero'
                mem[288] = 30
                mem[320] = 'SafeMath: subtraction overflow'
                if 0 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < 0:
                    revert with 0, 17
                mem[352] = 30
                mem[384] = 'SafeMath: subtraction overflow'
                if 0 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < 0:
                    revert with 0, 17
                mem[64] = 480
                mem[416] = 30
                mem[448] = 'SafeMath: subtraction overflow'
                if arg1 * _marketingFee / 10000 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < arg1 * _marketingFee / 10000:
                    revert with 0, 17
                idx = 0
                s = totalSupply
                t = stor12
                while idx < stor9.length:
                    mem[0] = stor9[idx]
                    mem[32] = 3
                    if stor3[stor9[idx]] > t:
                        _9265 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9265] = 26
                        mem[_9265 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _9341 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _9341 + 68] = mem[idx + _9265 + 32]
                                idx = idx + 32
                                continue 
                            mem[_9341 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _9341 + -mem[64] + 100
                        if not arg1:
                            if not arg1 * _marketingFee / 10000:
                                return 0
                            if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                                revert with 0, 17
                            if not arg1 * _marketingFee / 10000:
                                revert with 0, 18
                            if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _10300 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10300] = 30
                            mem[_10300 + 32] = 'SafeMath: subtraction overflow'
                            _11059 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11059] = 30
                            mem[_11059 + 32] = 'SafeMath: subtraction overflow'
                            _12608 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12608] = 30
                            mem[_12608 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _marketingFee / 10000 * stor12 / totalSupply <= 0:
                                if 0 < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                                    revert with 0, 17
                                return (-1 * arg1 * _marketingFee / 10000 * stor12 / totalSupply)
                            _13099 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13099 + 68] = mem[idx + _12608 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13099 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13099 + -mem[64] + 100
                        if arg1 and stor12 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor12 / totalSupply / arg1 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _marketingFee / 10000:
                            _10299 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10299] = 30
                            mem[_10299 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor12 / totalSupply:
                                _10442 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _10442 + 68] = mem[idx + _10299 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_10442 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _10442 + -mem[64] + 100
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 0, 17
                            _11057 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11057] = 30
                            mem[_11057 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor12 / totalSupply:
                                _11366 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11366 + 68] = mem[idx + _11057 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11366 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11366 + -mem[64] + 100
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 0, 17
                            _12606 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12606] = 30
                            mem[_12606 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor12 / totalSupply:
                                if arg1 * stor12 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor12 / totalSupply)
                            _13098 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13098 + 68] = mem[idx + _12606 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13098 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13098 + -mem[64] + 100
                        if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                            revert with 0, 17
                        if not arg1 * _marketingFee / 10000:
                            revert with 0, 18
                        if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _10783 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10783] = 30
                        mem[_10783 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor12 / totalSupply:
                            _11056 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11056 + 68] = mem[idx + _10783 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11056 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11056 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 0, 17
                        _12139 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12139] = 30
                        mem[_12139 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor12 / totalSupply:
                            _12605 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12605 + 68] = mem[idx + _12139 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12605 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12605 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 0, 17
                        _14163 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14163] = 30
                        mem[_14163 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _marketingFee / 10000 * stor12 / totalSupply <= arg1 * stor12 / totalSupply:
                            if arg1 * stor12 / totalSupply < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                                revert with 0, 17
                            return ((arg1 * stor12 / totalSupply) - (arg1 * _marketingFee / 10000 * stor12 / totalSupply))
                        _14716 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _14716 + 68] = mem[idx + _14163 + 32]
                            idx = idx + 32
                            continue 
                        mem[_14716 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14716 + -mem[64] + 100
                    if idx >= stor9.length:
                        revert with 0, 50
                    mem[0] = stor9[idx]
                    mem[32] = 4
                    if stor4[stor9[idx]] <= s:
                        if idx >= stor9.length:
                            revert with 0, 50
                        mem[0] = stor9[idx]
                        mem[32] = 3
                        _9342 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9342] = 30
                        mem[_9342 + 32] = 'SafeMath: subtraction overflow'
                        if stor3[stor9[idx]] > t:
                            _9422 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _9422 + 68] = mem[idx + _9342 + 32]
                                idx = idx + 32
                                continue 
                            mem[_9422 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _9422 + -mem[64] + 100
                        if t < stor3[stor9[idx]]:
                            revert with 0, 17
                        if idx >= stor9.length:
                            revert with 0, 50
                        mem[0] = stor9[idx]
                        mem[32] = 4
                        _9775 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9775] = 30
                        mem[_9775 + 32] = 'SafeMath: subtraction overflow'
                        if stor4[stor9[idx]] <= s:
                            if s < stor4[stor9[idx]]:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s - stor4[stor9[idx]]
                            t = t - stor3[stor9[idx]]
                            continue 
                        _9823 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _9823 + 68] = mem[idx + _9775 + 32]
                            idx = idx + 32
                            continue 
                        mem[_9823 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _9823 + -mem[64] + 100
                    _9343 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9343] = 26
                    mem[_9343 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _9423 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _9423 + 68] = mem[idx + _9343 + 32]
                            idx = idx + 32
                            continue 
                        mem[_9423 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _9423 + -mem[64] + 100
                    if not arg1:
                        if not arg1 * _marketingFee / 10000:
                            return 0
                        if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                            revert with 0, 17
                        if not arg1 * _marketingFee / 10000:
                            revert with 0, 18
                        if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _10445 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10445] = 30
                        mem[_10445 + 32] = 'SafeMath: subtraction overflow'
                        _11371 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11371] = 30
                        mem[_11371 + 32] = 'SafeMath: subtraction overflow'
                        _13103 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13103] = 30
                        mem[_13103 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _marketingFee / 10000 * stor12 / totalSupply <= 0:
                            if 0 < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                                revert with 0, 17
                            return (-1 * arg1 * _marketingFee / 10000 * stor12 / totalSupply)
                        _13590 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13590 + 68] = mem[idx + _13103 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13590 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13590 + -mem[64] + 100
                    if arg1 and stor12 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor12 / totalSupply / arg1 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _marketingFee / 10000:
                        _10444 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10444] = 30
                        mem[_10444 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor12 / totalSupply:
                            _10587 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _10587 + 68] = mem[idx + _10444 + 32]
                                idx = idx + 32
                                continue 
                            mem[_10587 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _10587 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 0, 17
                        _11369 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11369] = 30
                        mem[_11369 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor12 / totalSupply:
                            _11727 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11727 + 68] = mem[idx + _11369 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11727 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11727 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 0, 17
                        _13101 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13101] = 30
                        mem[_13101 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= arg1 * stor12 / totalSupply:
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 0, 17
                            return (arg1 * stor12 / totalSupply)
                        _13589 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13589 + 68] = mem[idx + _13101 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13589 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13589 + -mem[64] + 100
                    if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                        revert with 0, 17
                    if not arg1 * _marketingFee / 10000:
                        revert with 0, 18
                    if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _11060 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11060] = 30
                    mem[_11060 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor12 / totalSupply:
                        _11368 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _11368 + 68] = mem[idx + _11060 + 32]
                            idx = idx + 32
                            continue 
                        mem[_11368 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _11368 + -mem[64] + 100
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 0, 17
                    _12609 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12609] = 30
                    mem[_12609 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor12 / totalSupply:
                        _13100 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13100 + 68] = mem[idx + _12609 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13100 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13100 + -mem[64] + 100
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 0, 17
                    _14719 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14719] = 30
                    mem[_14719 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _marketingFee / 10000 * stor12 / totalSupply <= arg1 * stor12 / totalSupply:
                        if arg1 * stor12 / totalSupply < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                            revert with 0, 17
                        return ((arg1 * stor12 / totalSupply) - (arg1 * _marketingFee / 10000 * stor12 / totalSupply))
                    _15234 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _15234 + 68] = mem[idx + _14719 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15234 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _15234 + -mem[64] + 100
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if t >= stor12 / totalSupply:
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg1:
                        if not arg1 * _marketingFee / 10000:
                            return 0
                        if arg1 * _marketingFee / 10000 and t / s > -1 / arg1 * _marketingFee / 10000:
                            revert with 0, 17
                        if not arg1 * _marketingFee / 10000:
                            revert with 0, 18
                        if arg1 * _marketingFee / 10000 * t / s / arg1 * _marketingFee / 10000 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * _marketingFee / 10000 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * _marketingFee / 10000 * t / s:
                            revert with 0, 17
                        return (-1 * arg1 * _marketingFee / 10000 * t / s)
                    if arg1 and t / s > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _marketingFee / 10000:
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        return (arg1 * t / s)
                    if arg1 * _marketingFee / 10000 and t / s > -1 / arg1 * _marketingFee / 10000:
                        revert with 0, 17
                    if not arg1 * _marketingFee / 10000:
                        revert with 0, 18
                    if arg1 * _marketingFee / 10000 * t / s / arg1 * _marketingFee / 10000 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 0, 17
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 0, 17
                    if arg1 * _marketingFee / 10000 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * _marketingFee / 10000 * t / s:
                        revert with 0, 17
                    return ((arg1 * t / s) - (arg1 * _marketingFee / 10000 * t / s))
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if not arg1 * _marketingFee / 10000:
                        return 0
                    if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                        revert with 0, 17
                    if not arg1 * _marketingFee / 10000:
                        revert with 0, 18
                    if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * _marketingFee / 10000 * stor12 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                        revert with 0, 17
                    return (-1 * arg1 * _marketingFee / 10000 * stor12 / totalSupply)
                if arg1 and stor12 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor12 / totalSupply / arg1 != stor12 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _marketingFee / 10000:
                    if 0 > arg1 * stor12 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor12 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor12 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 0, 17
                    return (arg1 * stor12 / totalSupply)
                if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                    revert with 0, 17
                if not arg1 * _marketingFee / 10000:
                    revert with 0, 18
                if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 0 > arg1 * stor12 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor12 / totalSupply < 0:
                    revert with 0, 17
                if 0 > arg1 * stor12 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor12 / totalSupply < 0:
                    revert with 0, 17
                if arg1 * _marketingFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor12 / totalSupply < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                    revert with 0, 17
                return ((arg1 * stor12 / totalSupply) - (arg1 * _marketingFee / 10000 * stor12 / totalSupply))
            if arg1 and _liquidityFee > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * _liquidityFee / arg1 != _liquidityFee:
                revert with 0, 'SafeMath: multiplication overflow'
            mem[160] = 26
            mem[192] = 'SafeMath: division by zero'
            if not arg1:
                mem[224] = 26
                mem[256] = 'SafeMath: division by zero'
                mem[288] = 30
                mem[320] = 'SafeMath: subtraction overflow'
                if 0 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < 0:
                    revert with 0, 17
                mem[352] = 30
                mem[384] = 'SafeMath: subtraction overflow'
                if arg1 * _liquidityFee / 10000 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < arg1 * _liquidityFee / 10000:
                    revert with 0, 17
                mem[64] = 480
                mem[416] = 30
                mem[448] = 'SafeMath: subtraction overflow'
                if 0 > arg1 - (arg1 * _liquidityFee / 10000):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * _liquidityFee / 10000) < 0:
                    revert with 0, 17
                idx = 0
                s = totalSupply
                t = stor12
                while idx < stor9.length:
                    mem[0] = stor9[idx]
                    mem[32] = 3
                    if stor3[stor9[idx]] > t:
                        _9264 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9264] = 26
                        mem[_9264 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _9338 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _9338 + 68] = mem[idx + _9264 + 32]
                                idx = idx + 32
                                continue 
                            mem[_9338 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _9338 + -mem[64] + 100
                        if not arg1:
                            if not arg1 * _liquidityFee / 10000:
                                return 0
                            if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                                revert with 0, 17
                            if not arg1 * _liquidityFee / 10000:
                                revert with 0, 18
                            if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _10296 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10296] = 30
                            mem[_10296 + 32] = 'SafeMath: subtraction overflow'
                            _11050 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11050] = 30
                            mem[_11050 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > 0:
                                _11358 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11358 + 68] = mem[idx + _11050 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11358 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11358 + -mem[64] + 100
                            if 0 < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                revert with 0, 17
                            _12597 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12597] = 30
                            mem[_12597 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                if -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply < 0:
                                    revert with 0, 17
                                return (-1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply)
                            _13092 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13092 + 68] = mem[idx + _12597 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13092 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13092 + -mem[64] + 100
                        if arg1 and stor12 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor12 / totalSupply / arg1 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _liquidityFee / 10000:
                            _10295 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10295] = 30
                            mem[_10295 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor12 / totalSupply:
                                _10437 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _10437 + 68] = mem[idx + _10295 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_10437 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _10437 + -mem[64] + 100
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 0, 17
                            _11048 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11048] = 30
                            mem[_11048 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor12 / totalSupply:
                                _11357 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11357 + 68] = mem[idx + _11048 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11357 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11357 + -mem[64] + 100
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 0, 17
                            _12595 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12595] = 30
                            mem[_12595 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor12 / totalSupply:
                                if arg1 * stor12 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor12 / totalSupply)
                            _13091 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13091 + 68] = mem[idx + _12595 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13091 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13091 + -mem[64] + 100
                        if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                            revert with 0, 17
                        if not arg1 * _liquidityFee / 10000:
                            revert with 0, 18
                        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _10778 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10778] = 30
                        mem[_10778 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor12 / totalSupply:
                            _11047 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11047 + 68] = mem[idx + _10778 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11047 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11047 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 0, 17
                        _12129 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12129] = 30
                        mem[_12129 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                            _12594 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12594 + 68] = mem[idx + _12129 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12594 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12594 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                            revert with 0, 17
                        _14152 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14152] = 30
                        mem[_14152 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                            if (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < 0:
                                revert with 0, 17
                            return ((arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply))
                        _14707 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _14707 + 68] = mem[idx + _14152 + 32]
                            idx = idx + 32
                            continue 
                        mem[_14707 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14707 + -mem[64] + 100
                    if idx >= stor9.length:
                        revert with 0, 50
                    mem[0] = stor9[idx]
                    mem[32] = 4
                    if stor4[stor9[idx]] <= s:
                        if idx >= stor9.length:
                            revert with 0, 50
                        mem[0] = stor9[idx]
                        mem[32] = 3
                        _9339 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9339] = 30
                        mem[_9339 + 32] = 'SafeMath: subtraction overflow'
                        if stor3[stor9[idx]] > t:
                            _9419 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _9419 + 68] = mem[idx + _9339 + 32]
                                idx = idx + 32
                                continue 
                            mem[_9419 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _9419 + -mem[64] + 100
                        if t < stor3[stor9[idx]]:
                            revert with 0, 17
                        if idx >= stor9.length:
                            revert with 0, 50
                        mem[0] = stor9[idx]
                        mem[32] = 4
                        _9772 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9772] = 30
                        mem[_9772 + 32] = 'SafeMath: subtraction overflow'
                        if stor4[stor9[idx]] <= s:
                            if s < stor4[stor9[idx]]:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s - stor4[stor9[idx]]
                            t = t - stor3[stor9[idx]]
                            continue 
                        _9820 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _9820 + 68] = mem[idx + _9772 + 32]
                            idx = idx + 32
                            continue 
                        mem[_9820 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _9820 + -mem[64] + 100
                    _9340 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9340] = 26
                    mem[_9340 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _9420 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _9420 + 68] = mem[idx + _9340 + 32]
                            idx = idx + 32
                            continue 
                        mem[_9420 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _9420 + -mem[64] + 100
                    if not arg1:
                        if not arg1 * _liquidityFee / 10000:
                            return 0
                        if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                            revert with 0, 17
                        if not arg1 * _liquidityFee / 10000:
                            revert with 0, 18
                        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _10441 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10441] = 30
                        mem[_10441 + 32] = 'SafeMath: subtraction overflow'
                        _11363 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11363] = 30
                        mem[_11363 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > 0:
                            _11723 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11723 + 68] = mem[idx + _11363 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11723 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11723 + -mem[64] + 100
                        if 0 < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                            revert with 0, 17
                        _13096 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13096] = 30
                        mem[_13096 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                            if -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply < 0:
                                revert with 0, 17
                            return (-1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply)
                        _13583 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13583 + 68] = mem[idx + _13096 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13583 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13583 + -mem[64] + 100
                    if arg1 and stor12 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor12 / totalSupply / arg1 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _liquidityFee / 10000:
                        _10440 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10440] = 30
                        mem[_10440 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor12 / totalSupply:
                            _10582 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _10582 + 68] = mem[idx + _10440 + 32]
                                idx = idx + 32
                                continue 
                            mem[_10582 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _10582 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 0, 17
                        _11361 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11361] = 30
                        mem[_11361 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor12 / totalSupply:
                            _11722 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11722 + 68] = mem[idx + _11361 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11722 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11722 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 0, 17
                        _13094 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13094] = 30
                        mem[_13094 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= arg1 * stor12 / totalSupply:
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 0, 17
                            return (arg1 * stor12 / totalSupply)
                        _13582 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13582 + 68] = mem[idx + _13094 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13582 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13582 + -mem[64] + 100
                    if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                        revert with 0, 17
                    if not arg1 * _liquidityFee / 10000:
                        revert with 0, 18
                    if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _11051 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11051] = 30
                    mem[_11051 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor12 / totalSupply:
                        _11360 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _11360 + 68] = mem[idx + _11051 + 32]
                            idx = idx + 32
                            continue 
                        mem[_11360 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _11360 + -mem[64] + 100
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 0, 17
                    _12599 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12599] = 30
                    mem[_12599 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                        _13093 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13093 + 68] = mem[idx + _12599 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13093 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13093 + -mem[64] + 100
                    if arg1 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                        revert with 0, 17
                    _14710 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14710] = 30
                    mem[_14710 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                        if (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < 0:
                            revert with 0, 17
                        return ((arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply))
                    _15227 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _15227 + 68] = mem[idx + _14710 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15227 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _15227 + -mem[64] + 100
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if t >= stor12 / totalSupply:
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg1:
                        if not arg1 * _liquidityFee / 10000:
                            return 0
                        if arg1 * _liquidityFee / 10000 and t / s > -1 / arg1 * _liquidityFee / 10000:
                            revert with 0, 17
                        if not arg1 * _liquidityFee / 10000:
                            revert with 0, 18
                        if arg1 * _liquidityFee / 10000 * t / s / arg1 * _liquidityFee / 10000 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * _liquidityFee / 10000 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * _liquidityFee / 10000 * t / s:
                            revert with 0, 17
                        if 0 > -1 * arg1 * _liquidityFee / 10000 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _liquidityFee / 10000 * t / s < 0:
                            revert with 0, 17
                        return (-1 * arg1 * _liquidityFee / 10000 * t / s)
                    if arg1 and t / s > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _liquidityFee / 10000:
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        return (arg1 * t / s)
                    if arg1 * _liquidityFee / 10000 and t / s > -1 / arg1 * _liquidityFee / 10000:
                        revert with 0, 17
                    if not arg1 * _liquidityFee / 10000:
                        revert with 0, 18
                    if arg1 * _liquidityFee / 10000 * t / s / arg1 * _liquidityFee / 10000 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 0, 17
                    if arg1 * _liquidityFee / 10000 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * _liquidityFee / 10000 * t / s:
                        revert with 0, 17
                    if 0 > (arg1 * t / s) - (arg1 * _liquidityFee / 10000 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * _liquidityFee / 10000 * t / s) < 0:
                        revert with 0, 17
                    return ((arg1 * t / s) - (arg1 * _liquidityFee / 10000 * t / s))
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if not arg1 * _liquidityFee / 10000:
                        return 0
                    if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                        revert with 0, 17
                    if not arg1 * _liquidityFee / 10000:
                        revert with 0, 18
                    if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                        revert with 0, 17
                    if 0 > -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply < 0:
                        revert with 0, 17
                    return (-1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply)
                if arg1 and stor12 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor12 / totalSupply / arg1 != stor12 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _liquidityFee / 10000:
                    if 0 > arg1 * stor12 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor12 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor12 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 0, 17
                    return (arg1 * stor12 / totalSupply)
                if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                    revert with 0, 17
                if not arg1 * _liquidityFee / 10000:
                    revert with 0, 18
                if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 0 > arg1 * stor12 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor12 / totalSupply < 0:
                    revert with 0, 17
                if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                    revert with 0, 17
                if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < 0:
                    revert with 0, 17
                return ((arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply))
            if arg1 and _marketingFee > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * _marketingFee / arg1 != _marketingFee:
                revert with 0, 'SafeMath: multiplication overflow'
            mem[224] = 26
            mem[256] = 'SafeMath: division by zero'
            mem[288] = 30
            mem[320] = 'SafeMath: subtraction overflow'
            if 0 > arg1:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 < 0:
                revert with 0, 17
            mem[352] = 30
            mem[384] = 'SafeMath: subtraction overflow'
            if arg1 * _liquidityFee / 10000 > arg1:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 < arg1 * _liquidityFee / 10000:
                revert with 0, 17
            mem[64] = 480
            mem[416] = 30
            mem[448] = 'SafeMath: subtraction overflow'
            if arg1 * _marketingFee / 10000 > arg1 - (arg1 * _liquidityFee / 10000):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 - (arg1 * _liquidityFee / 10000) < arg1 * _marketingFee / 10000:
                revert with 0, 17
            idx = 0
            s = totalSupply
            t = stor12
            while idx < stor9.length:
                mem[0] = stor9[idx]
                mem[32] = 3
                if stor3[stor9[idx]] > t:
                    _9263 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9263] = 26
                    mem[_9263 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _9335 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _9335 + 68] = mem[idx + _9263 + 32]
                            idx = idx + 32
                            continue 
                        mem[_9335 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _9335 + -mem[64] + 100
                    if not arg1:
                        if not arg1 * _liquidityFee / 10000:
                            if not arg1 * _marketingFee / 10000:
                                return 0
                            if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                                revert with 0, 17
                            if not arg1 * _marketingFee / 10000:
                                revert with 0, 18
                            if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _10288 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10288] = 30
                            mem[_10288 + 32] = 'SafeMath: subtraction overflow'
                            _11039 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11039] = 30
                            mem[_11039 + 32] = 'SafeMath: subtraction overflow'
                            _12581 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12581] = 30
                            mem[_12581 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _marketingFee / 10000 * stor12 / totalSupply <= 0:
                                if 0 < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                                    revert with 0, 17
                                return (-1 * arg1 * _marketingFee / 10000 * stor12 / totalSupply)
                            _13082 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13082 + 68] = mem[idx + _12581 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13082 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13082 + -mem[64] + 100
                        if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                            revert with 0, 17
                        if not arg1 * _liquidityFee / 10000:
                            revert with 0, 18
                        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _marketingFee / 10000:
                            _10287 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10287] = 30
                            mem[_10287 + 32] = 'SafeMath: subtraction overflow'
                            _11038 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11038] = 30
                            mem[_11038 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > 0:
                                _11349 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11349 + 68] = mem[idx + _11038 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11349 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11349 + -mem[64] + 100
                            if 0 < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                revert with 0, 17
                            _12579 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12579] = 30
                            mem[_12579 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                if -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply < 0:
                                    revert with 0, 17
                                return (-1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply)
                            _13081 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13081 + 68] = mem[idx + _12579 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13081 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13081 + -mem[64] + 100
                        if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                            revert with 0, 17
                        if not arg1 * _marketingFee / 10000:
                            revert with 0, 18
                        if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _10769 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10769] = 30
                        mem[_10769 + 32] = 'SafeMath: subtraction overflow'
                        _12119 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12119] = 30
                        mem[_12119 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > 0:
                            _12578 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12578 + 68] = mem[idx + _12119 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12578 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12578 + -mem[64] + 100
                        if 0 < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                            revert with 0, 17
                        _14137 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14137] = 30
                        mem[_14137 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _marketingFee / 10000 * stor12 / totalSupply <= -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                            if -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                                revert with 0, 17
                            return ((-1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply) - (arg1 * _marketingFee / 10000 * stor12 / totalSupply))
                        _14693 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _14693 + 68] = mem[idx + _14137 + 32]
                            idx = idx + 32
                            continue 
                        mem[_14693 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14693 + -mem[64] + 100
                    if arg1 and stor12 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor12 / totalSupply / arg1 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _liquidityFee / 10000:
                        if not arg1 * _marketingFee / 10000:
                            _10286 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10286] = 30
                            mem[_10286 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor12 / totalSupply:
                                _10431 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _10431 + 68] = mem[idx + _10286 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_10431 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _10431 + -mem[64] + 100
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 0, 17
                            _11036 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11036] = 30
                            mem[_11036 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor12 / totalSupply:
                                _11348 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11348 + 68] = mem[idx + _11036 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11348 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11348 + -mem[64] + 100
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 0, 17
                            _12576 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12576] = 30
                            mem[_12576 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor12 / totalSupply:
                                if arg1 * stor12 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor12 / totalSupply)
                            _13080 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13080 + 68] = mem[idx + _12576 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13080 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13080 + -mem[64] + 100
                        if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                            revert with 0, 17
                        if not arg1 * _marketingFee / 10000:
                            revert with 0, 18
                        if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _10768 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10768] = 30
                        mem[_10768 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor12 / totalSupply:
                            _11035 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11035 + 68] = mem[idx + _10768 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11035 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11035 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 0, 17
                        _12117 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12117] = 30
                        mem[_12117 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor12 / totalSupply:
                            _12575 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12575 + 68] = mem[idx + _12117 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12575 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12575 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 0, 17
                        _14135 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14135] = 30
                        mem[_14135 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _marketingFee / 10000 * stor12 / totalSupply <= arg1 * stor12 / totalSupply:
                            if arg1 * stor12 / totalSupply < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                                revert with 0, 17
                            return ((arg1 * stor12 / totalSupply) - (arg1 * _marketingFee / 10000 * stor12 / totalSupply))
                        _14691 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _14691 + 68] = mem[idx + _14135 + 32]
                            idx = idx + 32
                            continue 
                        mem[_14691 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14691 + -mem[64] + 100
                    if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                        revert with 0, 17
                    if not arg1 * _liquidityFee / 10000:
                        revert with 0, 18
                    if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _marketingFee / 10000:
                        _10767 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10767] = 30
                        mem[_10767 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor12 / totalSupply:
                            _11034 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11034 + 68] = mem[idx + _10767 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11034 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11034 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 0, 17
                        _12115 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12115] = 30
                        mem[_12115 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                            _12574 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12574 + 68] = mem[idx + _12115 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12574 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12574 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                            revert with 0, 17
                        _14133 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14133] = 30
                        mem[_14133 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                            if (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < 0:
                                revert with 0, 17
                            return ((arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply))
                        _14690 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _14690 + 68] = mem[idx + _14133 + 32]
                            idx = idx + 32
                            continue 
                        mem[_14690 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14690 + -mem[64] + 100
                    if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                        revert with 0, 17
                    if not arg1 * _marketingFee / 10000:
                        revert with 0, 18
                    if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _11715 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11715] = 30
                    mem[_11715 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor12 / totalSupply:
                        _12114 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _12114 + 68] = mem[idx + _11715 + 32]
                            idx = idx + 32
                            continue 
                        mem[_12114 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _12114 + -mem[64] + 100
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 0, 17
                    _13571 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_13571] = 30
                    mem[_13571 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                        _14132 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _14132 + 68] = mem[idx + _13571 + 32]
                            idx = idx + 32
                            continue 
                        mem[_14132 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14132 + -mem[64] + 100
                    if arg1 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                        revert with 0, 17
                    _15782 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_15782] = 30
                    mem[_15782 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _marketingFee / 10000 * stor12 / totalSupply <= (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                        if (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                            revert with 0, 17
                        return ((arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) - (arg1 * _marketingFee / 10000 * stor12 / totalSupply))
                    _16257 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _16257 + 68] = mem[idx + _15782 + 32]
                        idx = idx + 32
                        continue 
                    mem[_16257 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _16257 + -mem[64] + 100
                if idx >= stor9.length:
                    revert with 0, 50
                mem[0] = stor9[idx]
                mem[32] = 4
                if stor4[stor9[idx]] <= s:
                    if idx >= stor9.length:
                        revert with 0, 50
                    mem[0] = stor9[idx]
                    mem[32] = 3
                    _9336 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9336] = 30
                    mem[_9336 + 32] = 'SafeMath: subtraction overflow'
                    if stor3[stor9[idx]] > t:
                        _9416 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _9416 + 68] = mem[idx + _9336 + 32]
                            idx = idx + 32
                            continue 
                        mem[_9416 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _9416 + -mem[64] + 100
                    if t < stor3[stor9[idx]]:
                        revert with 0, 17
                    if idx >= stor9.length:
                        revert with 0, 50
                    mem[0] = stor9[idx]
                    mem[32] = 4
                    _9769 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9769] = 30
                    mem[_9769 + 32] = 'SafeMath: subtraction overflow'
                    if stor4[stor9[idx]] <= s:
                        if s < stor4[stor9[idx]]:
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s - stor4[stor9[idx]]
                        t = t - stor3[stor9[idx]]
                        continue 
                    _9817 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _9817 + 68] = mem[idx + _9769 + 32]
                        idx = idx + 32
                        continue 
                    mem[_9817 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _9817 + -mem[64] + 100
                _9337 = mem[64]
                mem[64] = mem[64] + 64
                mem[_9337] = 26
                mem[_9337 + 32] = 'SafeMath: division by zero'
                if not totalSupply:
                    _9417 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _9417 + 68] = mem[idx + _9337 + 32]
                        idx = idx + 32
                        continue 
                    mem[_9417 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _9417 + -mem[64] + 100
                if not arg1:
                    if not arg1 * _liquidityFee / 10000:
                        if not arg1 * _marketingFee / 10000:
                            return 0
                        if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                            revert with 0, 17
                        if not arg1 * _marketingFee / 10000:
                            revert with 0, 18
                        if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _10436 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10436] = 30
                        mem[_10436 + 32] = 'SafeMath: subtraction overflow'
                        _11356 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11356] = 30
                        mem[_11356 + 32] = 'SafeMath: subtraction overflow'
                        _13090 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13090] = 30
                        mem[_13090 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _marketingFee / 10000 * stor12 / totalSupply <= 0:
                            if 0 < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                                revert with 0, 17
                            return (-1 * arg1 * _marketingFee / 10000 * stor12 / totalSupply)
                        _13576 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13576 + 68] = mem[idx + _13090 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13576 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13576 + -mem[64] + 100
                    if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                        revert with 0, 17
                    if not arg1 * _liquidityFee / 10000:
                        revert with 0, 18
                    if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _marketingFee / 10000:
                        _10435 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10435] = 30
                        mem[_10435 + 32] = 'SafeMath: subtraction overflow'
                        _11355 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11355] = 30
                        mem[_11355 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > 0:
                            _11718 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11718 + 68] = mem[idx + _11355 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11718 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11718 + -mem[64] + 100
                        if 0 < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                            revert with 0, 17
                        _13088 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13088] = 30
                        mem[_13088 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                            if -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply < 0:
                                revert with 0, 17
                            return (-1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply)
                        _13575 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13575 + 68] = mem[idx + _13088 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13575 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13575 + -mem[64] + 100
                    if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                        revert with 0, 17
                    if not arg1 * _marketingFee / 10000:
                        revert with 0, 18
                    if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _11042 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11042] = 30
                    mem[_11042 + 32] = 'SafeMath: subtraction overflow'
                    _12587 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12587] = 30
                    mem[_12587 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > 0:
                        _13087 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13087 + 68] = mem[idx + _12587 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13087 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13087 + -mem[64] + 100
                    if 0 < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                        revert with 0, 17
                    _14701 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14701] = 30
                    mem[_14701 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _marketingFee / 10000 * stor12 / totalSupply <= -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                        if -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                            revert with 0, 17
                        return ((-1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply) - (arg1 * _marketingFee / 10000 * stor12 / totalSupply))
                    _15220 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _15220 + 68] = mem[idx + _14701 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15220 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _15220 + -mem[64] + 100
                if arg1 and stor12 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor12 / totalSupply / arg1 != stor12 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _liquidityFee / 10000:
                    if not arg1 * _marketingFee / 10000:
                        _10434 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10434] = 30
                        mem[_10434 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor12 / totalSupply:
                            _10580 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _10580 + 68] = mem[idx + _10434 + 32]
                                idx = idx + 32
                                continue 
                            mem[_10580 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _10580 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 0, 17
                        _11353 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11353] = 30
                        mem[_11353 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor12 / totalSupply:
                            _11717 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11717 + 68] = mem[idx + _11353 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11717 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11717 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 0, 17
                        _13085 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13085] = 30
                        mem[_13085 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= arg1 * stor12 / totalSupply:
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 0, 17
                            return (arg1 * stor12 / totalSupply)
                        _13574 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13574 + 68] = mem[idx + _13085 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13574 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13574 + -mem[64] + 100
                    if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                        revert with 0, 17
                    if not arg1 * _marketingFee / 10000:
                        revert with 0, 18
                    if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _11041 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11041] = 30
                    mem[_11041 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor12 / totalSupply:
                        _11352 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _11352 + 68] = mem[idx + _11041 + 32]
                            idx = idx + 32
                            continue 
                        mem[_11352 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _11352 + -mem[64] + 100
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 0, 17
                    _12585 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12585] = 30
                    mem[_12585 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor12 / totalSupply:
                        _13084 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13084 + 68] = mem[idx + _12585 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13084 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13084 + -mem[64] + 100
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 0, 17
                    _14699 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14699] = 30
                    mem[_14699 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _marketingFee / 10000 * stor12 / totalSupply <= arg1 * stor12 / totalSupply:
                        if arg1 * stor12 / totalSupply < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                            revert with 0, 17
                        return ((arg1 * stor12 / totalSupply) - (arg1 * _marketingFee / 10000 * stor12 / totalSupply))
                    _15218 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _15218 + 68] = mem[idx + _14699 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15218 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _15218 + -mem[64] + 100
                if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                    revert with 0, 17
                if not arg1 * _liquidityFee / 10000:
                    revert with 0, 18
                if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _marketingFee / 10000:
                    _11040 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11040] = 30
                    mem[_11040 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor12 / totalSupply:
                        _11351 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _11351 + 68] = mem[idx + _11040 + 32]
                            idx = idx + 32
                            continue 
                        mem[_11351 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _11351 + -mem[64] + 100
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 0, 17
                    _12583 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12583] = 30
                    mem[_12583 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                        _13083 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13083 + 68] = mem[idx + _12583 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13083 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13083 + -mem[64] + 100
                    if arg1 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                        revert with 0, 17
                    _14697 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14697] = 30
                    mem[_14697 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                        if (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < 0:
                            revert with 0, 17
                        return ((arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply))
                    _15217 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _15217 + 68] = mem[idx + _14697 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15217 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _15217 + -mem[64] + 100
                if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                    revert with 0, 17
                if not arg1 * _marketingFee / 10000:
                    revert with 0, 18
                if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                _12120 = mem[64]
                mem[64] = mem[64] + 64
                mem[_12120] = 30
                mem[_12120 + 32] = 'SafeMath: subtraction overflow'
                if 0 > arg1 * stor12 / totalSupply:
                    _12582 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _12582 + 68] = mem[idx + _12120 + 32]
                        idx = idx + 32
                        continue 
                    mem[_12582 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _12582 + -mem[64] + 100
                if arg1 * stor12 / totalSupply < 0:
                    revert with 0, 17
                _14139 = mem[64]
                mem[64] = mem[64] + 64
                mem[_14139] = 30
                mem[_14139 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                    _14696 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _14696 + 68] = mem[idx + _14139 + 32]
                        idx = idx + 32
                        continue 
                    mem[_14696 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _14696 + -mem[64] + 100
                if arg1 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                    revert with 0, 17
                _16261 = mem[64]
                mem[64] = mem[64] + 64
                mem[_16261] = 30
                mem[_16261 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * _marketingFee / 10000 * stor12 / totalSupply <= (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                    if (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                        revert with 0, 17
                    return ((arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) - (arg1 * _marketingFee / 10000 * stor12 / totalSupply))
                _16622 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _16622 + 68] = mem[idx + _16261 + 32]
                    idx = idx + 32
                    continue 
                mem[_16622 + 98] = 0
                revert with memory
                  from mem[64]
                   len _16622 + -mem[64] + 100
            if not totalSupply:
                revert with 0, 'SafeMath: division by zero', 0
            if t >= stor12 / totalSupply:
                if not s:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if not arg1 * _liquidityFee / 10000:
                        if not arg1 * _marketingFee / 10000:
                            return 0
                        if arg1 * _marketingFee / 10000 and t / s > -1 / arg1 * _marketingFee / 10000:
                            revert with 0, 17
                        if not arg1 * _marketingFee / 10000:
                            revert with 0, 18
                        if arg1 * _marketingFee / 10000 * t / s / arg1 * _marketingFee / 10000 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * _marketingFee / 10000 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * _marketingFee / 10000 * t / s:
                            revert with 0, 17
                        return (-1 * arg1 * _marketingFee / 10000 * t / s)
                    if arg1 * _liquidityFee / 10000 and t / s > -1 / arg1 * _liquidityFee / 10000:
                        revert with 0, 17
                    if not arg1 * _liquidityFee / 10000:
                        revert with 0, 18
                    if arg1 * _liquidityFee / 10000 * t / s / arg1 * _liquidityFee / 10000 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _marketingFee / 10000:
                        if arg1 * _liquidityFee / 10000 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * _liquidityFee / 10000 * t / s:
                            revert with 0, 17
                        if 0 > -1 * arg1 * _liquidityFee / 10000 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _liquidityFee / 10000 * t / s < 0:
                            revert with 0, 17
                        return (-1 * arg1 * _liquidityFee / 10000 * t / s)
                    if arg1 * _marketingFee / 10000 and t / s > -1 / arg1 * _marketingFee / 10000:
                        revert with 0, 17
                    if not arg1 * _marketingFee / 10000:
                        revert with 0, 18
                    if arg1 * _marketingFee / 10000 * t / s / arg1 * _marketingFee / 10000 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * _liquidityFee / 10000 * t / s > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * _liquidityFee / 10000 * t / s:
                        revert with 0, 17
                    if arg1 * _marketingFee / 10000 * t / s > -1 * arg1 * _liquidityFee / 10000 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _liquidityFee / 10000 * t / s < arg1 * _marketingFee / 10000 * t / s:
                        revert with 0, 17
                    return ((-1 * arg1 * _liquidityFee / 10000 * t / s) - (arg1 * _marketingFee / 10000 * t / s))
                if arg1 and t / s > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * t / s / arg1 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _liquidityFee / 10000:
                    if not arg1 * _marketingFee / 10000:
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        return (arg1 * t / s)
                    if arg1 * _marketingFee / 10000 and t / s > -1 / arg1 * _marketingFee / 10000:
                        revert with 0, 17
                    if not arg1 * _marketingFee / 10000:
                        revert with 0, 18
                    if arg1 * _marketingFee / 10000 * t / s / arg1 * _marketingFee / 10000 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 0, 17
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 0, 17
                    if arg1 * _marketingFee / 10000 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * _marketingFee / 10000 * t / s:
                        revert with 0, 17
                    return ((arg1 * t / s) - (arg1 * _marketingFee / 10000 * t / s))
                if arg1 * _liquidityFee / 10000 and t / s > -1 / arg1 * _liquidityFee / 10000:
                    revert with 0, 17
                if not arg1 * _liquidityFee / 10000:
                    revert with 0, 18
                if arg1 * _liquidityFee / 10000 * t / s / arg1 * _liquidityFee / 10000 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _marketingFee / 10000:
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 0, 17
                    if arg1 * _liquidityFee / 10000 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * _liquidityFee / 10000 * t / s:
                        revert with 0, 17
                    if 0 > (arg1 * t / s) - (arg1 * _liquidityFee / 10000 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * _liquidityFee / 10000 * t / s) < 0:
                        revert with 0, 17
                    return ((arg1 * t / s) - (arg1 * _liquidityFee / 10000 * t / s))
                if arg1 * _marketingFee / 10000 and t / s > -1 / arg1 * _marketingFee / 10000:
                    revert with 0, 17
                if not arg1 * _marketingFee / 10000:
                    revert with 0, 18
                if arg1 * _marketingFee / 10000 * t / s / arg1 * _marketingFee / 10000 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 0 > arg1 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * t / s < 0:
                    revert with 0, 17
                if arg1 * _liquidityFee / 10000 * t / s > arg1 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * t / s < arg1 * _liquidityFee / 10000 * t / s:
                    revert with 0, 17
                if arg1 * _marketingFee / 10000 * t / s > (arg1 * t / s) - (arg1 * _liquidityFee / 10000 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * t / s) - (arg1 * _liquidityFee / 10000 * t / s) < arg1 * _marketingFee / 10000 * t / s:
                    revert with 0, 17
                return ((arg1 * t / s) - (arg1 * _liquidityFee / 10000 * t / s) - (arg1 * _marketingFee / 10000 * t / s))
            if not totalSupply:
                revert with 0, 'SafeMath: division by zero', 0
            if not arg1:
                if not arg1 * _liquidityFee / 10000:
                    if not arg1 * _marketingFee / 10000:
                        return 0
                    if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                        revert with 0, 17
                    if not arg1 * _marketingFee / 10000:
                        revert with 0, 18
                    if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * _marketingFee / 10000 * stor12 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                        revert with 0, 17
                    return (-1 * arg1 * _marketingFee / 10000 * stor12 / totalSupply)
                if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                    revert with 0, 17
                if not arg1 * _liquidityFee / 10000:
                    revert with 0, 18
                if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _marketingFee / 10000:
                    if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                        revert with 0, 17
                    if 0 > -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply < 0:
                        revert with 0, 17
                    return (-1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply)
                if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                    revert with 0, 17
                if not arg1 * _marketingFee / 10000:
                    revert with 0, 18
                if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > 0:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if 0 < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                    revert with 0, 17
                if arg1 * _marketingFee / 10000 * stor12 / totalSupply > -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                    revert with 0, 17
                return ((-1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply) - (arg1 * _marketingFee / 10000 * stor12 / totalSupply))
            if arg1 and stor12 / totalSupply > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * stor12 / totalSupply / arg1 != stor12 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * _liquidityFee / 10000:
                if not arg1 * _marketingFee / 10000:
                    if 0 > arg1 * stor12 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor12 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor12 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 0, 17
                    return (arg1 * stor12 / totalSupply)
                if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                    revert with 0, 17
                if not arg1 * _marketingFee / 10000:
                    revert with 0, 18
                if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 0 > arg1 * stor12 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor12 / totalSupply < 0:
                    revert with 0, 17
                if 0 > arg1 * stor12 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor12 / totalSupply < 0:
                    revert with 0, 17
                if arg1 * _marketingFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor12 / totalSupply < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                    revert with 0, 17
                return ((arg1 * stor12 / totalSupply) - (arg1 * _marketingFee / 10000 * stor12 / totalSupply))
            if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                revert with 0, 17
            if not arg1 * _liquidityFee / 10000:
                revert with 0, 18
            if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * _marketingFee / 10000:
                if 0 > arg1 * stor12 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor12 / totalSupply < 0:
                    revert with 0, 17
                if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                    revert with 0, 17
                if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < 0:
                    revert with 0, 17
                return ((arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply))
            if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                revert with 0, 17
            if not arg1 * _marketingFee / 10000:
                revert with 0, 18
            if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if 0 > arg1 * stor12 / totalSupply:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * stor12 / totalSupply < 0:
                revert with 0, 17
            if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                revert with 0, 17
            if arg1 * _marketingFee / 10000 * stor12 / totalSupply > (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                revert with 0, 17
            return ((arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) - (arg1 * _marketingFee / 10000 * stor12 / totalSupply))
        if arg1 and _taxFee > -1 / arg1:
            revert with 0, 17
        if not arg1:
            revert with 0, 18
        if arg1 * _taxFee / arg1 != _taxFee:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
        mem[96] = 26
        mem[128] = 'SafeMath: division by zero'
        if not arg1:
            mem[160] = 26
            mem[192] = 'SafeMath: division by zero'
            if not arg1:
                mem[224] = 26
                mem[256] = 'SafeMath: division by zero'
                mem[288] = 30
                mem[320] = 'SafeMath: subtraction overflow'
                if arg1 * _taxFee / 10000 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < arg1 * _taxFee / 10000:
                    revert with 0, 17
                mem[352] = 30
                mem[384] = 'SafeMath: subtraction overflow'
                if 0 > arg1 - (arg1 * _taxFee / 10000):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * _taxFee / 10000) < 0:
                    revert with 0, 17
                mem[64] = 480
                mem[416] = 30
                mem[448] = 'SafeMath: subtraction overflow'
                if 0 > arg1 - (arg1 * _taxFee / 10000):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * _taxFee / 10000) < 0:
                    revert with 0, 17
                idx = 0
                s = totalSupply
                t = stor12
                while idx < stor9.length:
                    mem[0] = stor9[idx]
                    mem[32] = 3
                    if stor3[stor9[idx]] > t:
                        _9262 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9262] = 26
                        mem[_9262 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _9332 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _9332 + 68] = mem[idx + _9262 + 32]
                                idx = idx + 32
                                continue 
                            mem[_9332 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _9332 + -mem[64] + 100
                        if not arg1:
                            if not arg1 * _taxFee / 10000:
                                return 0
                            if arg1 * _taxFee / 10000 and stor12 / totalSupply > -1 / arg1 * _taxFee / 10000:
                                revert with 0, 17
                            if not arg1 * _taxFee / 10000:
                                revert with 0, 18
                            if arg1 * _taxFee / 10000 * stor12 / totalSupply / arg1 * _taxFee / 10000 != stor12 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _10280 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10280] = 30
                            mem[_10280 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                                _10427 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _10427 + 68] = mem[idx + _10280 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_10427 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _10427 + -mem[64] + 100
                            if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                revert with 0, 17
                            _11027 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11027] = 30
                            mem[_11027 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                _11336 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11336 + 68] = mem[idx + _11027 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11336 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11336 + -mem[64] + 100
                            if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                                revert with 0, 17
                            _12562 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12562] = 30
                            mem[_12562 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                                    revert with 0, 17
                                return (-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply)
                            _13072 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13072 + 68] = mem[idx + _12562 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13072 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13072 + -mem[64] + 100
                        if arg1 and stor12 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor12 / totalSupply / arg1 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _taxFee / 10000:
                            _10279 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10279] = 30
                            mem[_10279 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor12 / totalSupply:
                                _10426 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _10426 + 68] = mem[idx + _10279 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_10426 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _10426 + -mem[64] + 100
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 0, 17
                            _11025 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11025] = 30
                            mem[_11025 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor12 / totalSupply:
                                _11335 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11335 + 68] = mem[idx + _11025 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11335 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11335 + -mem[64] + 100
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 0, 17
                            _12560 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12560] = 30
                            mem[_12560 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor12 / totalSupply:
                                if arg1 * stor12 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor12 / totalSupply)
                            _13071 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13071 + 68] = mem[idx + _12560 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13071 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13071 + -mem[64] + 100
                        if arg1 * _taxFee / 10000 and stor12 / totalSupply > -1 / arg1 * _taxFee / 10000:
                            revert with 0, 17
                        if not arg1 * _taxFee / 10000:
                            revert with 0, 18
                        if arg1 * _taxFee / 10000 * stor12 / totalSupply / arg1 * _taxFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _10758 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10758] = 30
                        mem[_10758 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                            _11024 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11024 + 68] = mem[idx + _10758 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11024 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11024 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                            revert with 0, 17
                        _12100 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12100] = 30
                        mem[_12100 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                            _12559 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12559 + 68] = mem[idx + _12100 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12559 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12559 + -mem[64] + 100
                        if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                            revert with 0, 17
                        _14113 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14113] = 30
                        mem[_14113 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                            if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                                revert with 0, 17
                            return ((arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply))
                        _14679 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _14679 + 68] = mem[idx + _14113 + 32]
                            idx = idx + 32
                            continue 
                        mem[_14679 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14679 + -mem[64] + 100
                    if idx >= stor9.length:
                        revert with 0, 50
                    mem[0] = stor9[idx]
                    mem[32] = 4
                    if stor4[stor9[idx]] <= s:
                        if idx >= stor9.length:
                            revert with 0, 50
                        mem[0] = stor9[idx]
                        mem[32] = 3
                        _9333 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9333] = 30
                        mem[_9333 + 32] = 'SafeMath: subtraction overflow'
                        if stor3[stor9[idx]] > t:
                            _9413 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _9413 + 68] = mem[idx + _9333 + 32]
                                idx = idx + 32
                                continue 
                            mem[_9413 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _9413 + -mem[64] + 100
                        if t < stor3[stor9[idx]]:
                            revert with 0, 17
                        if idx >= stor9.length:
                            revert with 0, 50
                        mem[0] = stor9[idx]
                        mem[32] = 4
                        _9766 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9766] = 30
                        mem[_9766 + 32] = 'SafeMath: subtraction overflow'
                        if stor4[stor9[idx]] <= s:
                            if s < stor4[stor9[idx]]:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s - stor4[stor9[idx]]
                            t = t - stor3[stor9[idx]]
                            continue 
                        _9814 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _9814 + 68] = mem[idx + _9766 + 32]
                            idx = idx + 32
                            continue 
                        mem[_9814 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _9814 + -mem[64] + 100
                    _9334 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9334] = 26
                    mem[_9334 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _9414 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _9414 + 68] = mem[idx + _9334 + 32]
                            idx = idx + 32
                            continue 
                        mem[_9414 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _9414 + -mem[64] + 100
                    if not arg1:
                        if not arg1 * _taxFee / 10000:
                            return 0
                        if arg1 * _taxFee / 10000 and stor12 / totalSupply > -1 / arg1 * _taxFee / 10000:
                            revert with 0, 17
                        if not arg1 * _taxFee / 10000:
                            revert with 0, 18
                        if arg1 * _taxFee / 10000 * stor12 / totalSupply / arg1 * _taxFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _10430 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10430] = 30
                        mem[_10430 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                            _10574 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _10574 + 68] = mem[idx + _10430 + 32]
                                idx = idx + 32
                                continue 
                            mem[_10574 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _10574 + -mem[64] + 100
                        if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                            revert with 0, 17
                        _11341 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11341] = 30
                        mem[_11341 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                            _11707 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11707 + 68] = mem[idx + _11341 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11707 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11707 + -mem[64] + 100
                        if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                            revert with 0, 17
                        _13076 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13076] = 30
                        mem[_13076 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                            if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                                revert with 0, 17
                            return (-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply)
                        _13558 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13558 + 68] = mem[idx + _13076 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13558 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13558 + -mem[64] + 100
                    if arg1 and stor12 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor12 / totalSupply / arg1 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _taxFee / 10000:
                        _10429 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10429] = 30
                        mem[_10429 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor12 / totalSupply:
                            _10573 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _10573 + 68] = mem[idx + _10429 + 32]
                                idx = idx + 32
                                continue 
                            mem[_10573 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _10573 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 0, 17
                        _11339 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11339] = 30
                        mem[_11339 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor12 / totalSupply:
                            _11706 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11706 + 68] = mem[idx + _11339 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11706 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11706 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 0, 17
                        _13074 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13074] = 30
                        mem[_13074 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= arg1 * stor12 / totalSupply:
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 0, 17
                            return (arg1 * stor12 / totalSupply)
                        _13557 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13557 + 68] = mem[idx + _13074 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13557 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13557 + -mem[64] + 100
                    if arg1 * _taxFee / 10000 and stor12 / totalSupply > -1 / arg1 * _taxFee / 10000:
                        revert with 0, 17
                    if not arg1 * _taxFee / 10000:
                        revert with 0, 18
                    if arg1 * _taxFee / 10000 * stor12 / totalSupply / arg1 * _taxFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _11029 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11029] = 30
                    mem[_11029 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                        _11338 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _11338 + 68] = mem[idx + _11029 + 32]
                            idx = idx + 32
                            continue 
                        mem[_11338 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _11338 + -mem[64] + 100
                    if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                        revert with 0, 17
                    _12564 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12564] = 30
                    mem[_12564 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                        _13073 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13073 + 68] = mem[idx + _12564 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13073 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13073 + -mem[64] + 100
                    if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                        revert with 0, 17
                    _14682 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14682] = 30
                    mem[_14682 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                        if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                            revert with 0, 17
                        return ((arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply))
                    _15205 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _15205 + 68] = mem[idx + _14682 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15205 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _15205 + -mem[64] + 100
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if t >= stor12 / totalSupply:
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg1:
                        if not arg1 * _taxFee / 10000:
                            return 0
                        if arg1 * _taxFee / 10000 and t / s > -1 / arg1 * _taxFee / 10000:
                            revert with 0, 17
                        if not arg1 * _taxFee / 10000:
                            revert with 0, 18
                        if arg1 * _taxFee / 10000 * t / s / arg1 * _taxFee / 10000 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * _taxFee / 10000 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * _taxFee / 10000 * t / s:
                            revert with 0, 17
                        if 0 > -1 * arg1 * _taxFee / 10000 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _taxFee / 10000 * t / s < 0:
                            revert with 0, 17
                        if 0 > -1 * arg1 * _taxFee / 10000 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _taxFee / 10000 * t / s < 0:
                            revert with 0, 17
                        return (-1 * arg1 * _taxFee / 10000 * t / s)
                    if arg1 and t / s > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _taxFee / 10000:
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        return (arg1 * t / s)
                    if arg1 * _taxFee / 10000 and t / s > -1 / arg1 * _taxFee / 10000:
                        revert with 0, 17
                    if not arg1 * _taxFee / 10000:
                        revert with 0, 18
                    if arg1 * _taxFee / 10000 * t / s / arg1 * _taxFee / 10000 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * _taxFee / 10000 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * _taxFee / 10000 * t / s:
                        revert with 0, 17
                    if 0 > (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s) < 0:
                        revert with 0, 17
                    if 0 > (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s) < 0:
                        revert with 0, 17
                    return ((arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s))
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if not arg1 * _taxFee / 10000:
                        return 0
                    if arg1 * _taxFee / 10000 and stor12 / totalSupply > -1 / arg1 * _taxFee / 10000:
                        revert with 0, 17
                    if not arg1 * _taxFee / 10000:
                        revert with 0, 18
                    if arg1 * _taxFee / 10000 * stor12 / totalSupply / arg1 * _taxFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                        revert with 0, 17
                    if 0 > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                        revert with 0, 17
                    return (-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply)
                if arg1 and stor12 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor12 / totalSupply / arg1 != stor12 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _taxFee / 10000:
                    if 0 > arg1 * stor12 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor12 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor12 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 0, 17
                    return (arg1 * stor12 / totalSupply)
                if arg1 * _taxFee / 10000 and stor12 / totalSupply > -1 / arg1 * _taxFee / 10000:
                    revert with 0, 17
                if not arg1 * _taxFee / 10000:
                    revert with 0, 18
                if arg1 * _taxFee / 10000 * stor12 / totalSupply / arg1 * _taxFee / 10000 != stor12 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                    revert with 0, 17
                if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                    revert with 0, 17
                if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                    revert with 0, 17
                return ((arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply))
            if arg1 and _marketingFee > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * _marketingFee / arg1 != _marketingFee:
                revert with 0, 'SafeMath: multiplication overflow'
            mem[224] = 26
            mem[256] = 'SafeMath: division by zero'
            mem[288] = 30
            mem[320] = 'SafeMath: subtraction overflow'
            if arg1 * _taxFee / 10000 > arg1:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 < arg1 * _taxFee / 10000:
                revert with 0, 17
            mem[352] = 30
            mem[384] = 'SafeMath: subtraction overflow'
            if 0 > arg1 - (arg1 * _taxFee / 10000):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 - (arg1 * _taxFee / 10000) < 0:
                revert with 0, 17
            mem[64] = 480
            mem[416] = 30
            mem[448] = 'SafeMath: subtraction overflow'
            if arg1 * _marketingFee / 10000 > arg1 - (arg1 * _taxFee / 10000):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 - (arg1 * _taxFee / 10000) < arg1 * _marketingFee / 10000:
                revert with 0, 17
            idx = 0
            s = totalSupply
            t = stor12
            while idx < stor9.length:
                mem[0] = stor9[idx]
                mem[32] = 3
                if stor3[stor9[idx]] > t:
                    _9261 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9261] = 26
                    mem[_9261 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _9329 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _9329 + 68] = mem[idx + _9261 + 32]
                            idx = idx + 32
                            continue 
                        mem[_9329 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _9329 + -mem[64] + 100
                    if not arg1:
                        if not arg1 * _taxFee / 10000:
                            if not arg1 * _marketingFee / 10000:
                                return 0
                            if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                                revert with 0, 17
                            if not arg1 * _marketingFee / 10000:
                                revert with 0, 18
                            if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _10275 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10275] = 30
                            mem[_10275 + 32] = 'SafeMath: subtraction overflow'
                            _11014 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11014] = 30
                            mem[_11014 + 32] = 'SafeMath: subtraction overflow'
                            _12545 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12545] = 30
                            mem[_12545 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _marketingFee / 10000 * stor12 / totalSupply <= 0:
                                if 0 < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                                    revert with 0, 17
                                return (-1 * arg1 * _marketingFee / 10000 * stor12 / totalSupply)
                            _13062 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13062 + 68] = mem[idx + _12545 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13062 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13062 + -mem[64] + 100
                        if arg1 * _taxFee / 10000 and stor12 / totalSupply > -1 / arg1 * _taxFee / 10000:
                            revert with 0, 17
                        if not arg1 * _taxFee / 10000:
                            revert with 0, 18
                        if arg1 * _taxFee / 10000 * stor12 / totalSupply / arg1 * _taxFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _marketingFee / 10000:
                            _10274 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10274] = 30
                            mem[_10274 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                                _10419 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _10419 + 68] = mem[idx + _10274 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_10419 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _10419 + -mem[64] + 100
                            if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                revert with 0, 17
                            _11012 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11012] = 30
                            mem[_11012 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                _11325 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11325 + 68] = mem[idx + _11012 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11325 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11325 + -mem[64] + 100
                            if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                                revert with 0, 17
                            _12543 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12543] = 30
                            mem[_12543 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                                    revert with 0, 17
                                return (-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply)
                            _13061 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13061 + 68] = mem[idx + _12543 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13061 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13061 + -mem[64] + 100
                        if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                            revert with 0, 17
                        if not arg1 * _marketingFee / 10000:
                            revert with 0, 18
                        if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _10751 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10751] = 30
                        mem[_10751 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                            _11011 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11011 + 68] = mem[idx + _10751 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11011 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11011 + -mem[64] + 100
                        if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                            revert with 0, 17
                        _12087 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12087] = 30
                        mem[_12087 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                            _12542 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12542 + 68] = mem[idx + _12087 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12542 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12542 + -mem[64] + 100
                        if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                            revert with 0, 17
                        _14098 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14098] = 30
                        mem[_14098 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _marketingFee / 10000 * stor12 / totalSupply <= -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                            if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                                revert with 0, 17
                            return ((-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _marketingFee / 10000 * stor12 / totalSupply))
                        _14665 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _14665 + 68] = mem[idx + _14098 + 32]
                            idx = idx + 32
                            continue 
                        mem[_14665 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14665 + -mem[64] + 100
                    if arg1 and stor12 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor12 / totalSupply / arg1 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _taxFee / 10000:
                        if not arg1 * _marketingFee / 10000:
                            _10273 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10273] = 30
                            mem[_10273 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor12 / totalSupply:
                                _10418 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _10418 + 68] = mem[idx + _10273 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_10418 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _10418 + -mem[64] + 100
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 0, 17
                            _11009 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11009] = 30
                            mem[_11009 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor12 / totalSupply:
                                _11324 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11324 + 68] = mem[idx + _11009 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11324 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11324 + -mem[64] + 100
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 0, 17
                            _12540 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12540] = 30
                            mem[_12540 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor12 / totalSupply:
                                if arg1 * stor12 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor12 / totalSupply)
                            _13060 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13060 + 68] = mem[idx + _12540 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13060 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13060 + -mem[64] + 100
                        if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                            revert with 0, 17
                        if not arg1 * _marketingFee / 10000:
                            revert with 0, 18
                        if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _10750 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10750] = 30
                        mem[_10750 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor12 / totalSupply:
                            _11008 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11008 + 68] = mem[idx + _10750 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11008 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11008 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 0, 17
                        _12085 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12085] = 30
                        mem[_12085 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor12 / totalSupply:
                            _12539 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12539 + 68] = mem[idx + _12085 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12539 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12539 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 0, 17
                        _14096 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14096] = 30
                        mem[_14096 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _marketingFee / 10000 * stor12 / totalSupply <= arg1 * stor12 / totalSupply:
                            if arg1 * stor12 / totalSupply < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                                revert with 0, 17
                            return ((arg1 * stor12 / totalSupply) - (arg1 * _marketingFee / 10000 * stor12 / totalSupply))
                        _14663 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _14663 + 68] = mem[idx + _14096 + 32]
                            idx = idx + 32
                            continue 
                        mem[_14663 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14663 + -mem[64] + 100
                    if arg1 * _taxFee / 10000 and stor12 / totalSupply > -1 / arg1 * _taxFee / 10000:
                        revert with 0, 17
                    if not arg1 * _taxFee / 10000:
                        revert with 0, 18
                    if arg1 * _taxFee / 10000 * stor12 / totalSupply / arg1 * _taxFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _marketingFee / 10000:
                        _10749 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10749] = 30
                        mem[_10749 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                            _11007 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11007 + 68] = mem[idx + _10749 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11007 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11007 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                            revert with 0, 17
                        _12083 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12083] = 30
                        mem[_12083 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                            _12538 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12538 + 68] = mem[idx + _12083 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12538 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12538 + -mem[64] + 100
                        if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                            revert with 0, 17
                        _14094 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14094] = 30
                        mem[_14094 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                            if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                                revert with 0, 17
                            return ((arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply))
                        _14662 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _14662 + 68] = mem[idx + _14094 + 32]
                            idx = idx + 32
                            continue 
                        mem[_14662 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14662 + -mem[64] + 100
                    if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                        revert with 0, 17
                    if not arg1 * _marketingFee / 10000:
                        revert with 0, 18
                    if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _11699 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11699] = 30
                    mem[_11699 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                        _12082 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _12082 + 68] = mem[idx + _11699 + 32]
                            idx = idx + 32
                            continue 
                        mem[_12082 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _12082 + -mem[64] + 100
                    if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                        revert with 0, 17
                    _13546 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_13546] = 30
                    mem[_13546 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                        _14093 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _14093 + 68] = mem[idx + _13546 + 32]
                            idx = idx + 32
                            continue 
                        mem[_14093 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14093 + -mem[64] + 100
                    if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                        revert with 0, 17
                    _15757 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_15757] = 30
                    mem[_15757 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _marketingFee / 10000 * stor12 / totalSupply <= (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                        if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                            revert with 0, 17
                        return ((arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _marketingFee / 10000 * stor12 / totalSupply))
                    _16232 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _16232 + 68] = mem[idx + _15757 + 32]
                        idx = idx + 32
                        continue 
                    mem[_16232 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _16232 + -mem[64] + 100
                if idx >= stor9.length:
                    revert with 0, 50
                mem[0] = stor9[idx]
                mem[32] = 4
                if stor4[stor9[idx]] <= s:
                    if idx >= stor9.length:
                        revert with 0, 50
                    mem[0] = stor9[idx]
                    mem[32] = 3
                    _9330 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9330] = 30
                    mem[_9330 + 32] = 'SafeMath: subtraction overflow'
                    if stor3[stor9[idx]] > t:
                        _9410 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _9410 + 68] = mem[idx + _9330 + 32]
                            idx = idx + 32
                            continue 
                        mem[_9410 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _9410 + -mem[64] + 100
                    if t < stor3[stor9[idx]]:
                        revert with 0, 17
                    if idx >= stor9.length:
                        revert with 0, 50
                    mem[0] = stor9[idx]
                    mem[32] = 4
                    _9763 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9763] = 30
                    mem[_9763 + 32] = 'SafeMath: subtraction overflow'
                    if stor4[stor9[idx]] <= s:
                        if s < stor4[stor9[idx]]:
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s - stor4[stor9[idx]]
                        t = t - stor3[stor9[idx]]
                        continue 
                    _9811 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _9811 + 68] = mem[idx + _9763 + 32]
                        idx = idx + 32
                        continue 
                    mem[_9811 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _9811 + -mem[64] + 100
                _9331 = mem[64]
                mem[64] = mem[64] + 64
                mem[_9331] = 26
                mem[_9331 + 32] = 'SafeMath: division by zero'
                if not totalSupply:
                    _9411 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _9411 + 68] = mem[idx + _9331 + 32]
                        idx = idx + 32
                        continue 
                    mem[_9411 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _9411 + -mem[64] + 100
                if not arg1:
                    if not arg1 * _taxFee / 10000:
                        if not arg1 * _marketingFee / 10000:
                            return 0
                        if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                            revert with 0, 17
                        if not arg1 * _marketingFee / 10000:
                            revert with 0, 18
                        if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _10423 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10423] = 30
                        mem[_10423 + 32] = 'SafeMath: subtraction overflow'
                        _11334 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11334] = 30
                        mem[_11334 + 32] = 'SafeMath: subtraction overflow'
                        _13070 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13070] = 30
                        mem[_13070 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _marketingFee / 10000 * stor12 / totalSupply <= 0:
                            if 0 < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                                revert with 0, 17
                            return (-1 * arg1 * _marketingFee / 10000 * stor12 / totalSupply)
                        _13551 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13551 + 68] = mem[idx + _13070 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13551 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13551 + -mem[64] + 100
                    if arg1 * _taxFee / 10000 and stor12 / totalSupply > -1 / arg1 * _taxFee / 10000:
                        revert with 0, 17
                    if not arg1 * _taxFee / 10000:
                        revert with 0, 18
                    if arg1 * _taxFee / 10000 * stor12 / totalSupply / arg1 * _taxFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _marketingFee / 10000:
                        _10422 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10422] = 30
                        mem[_10422 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                            _10571 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _10571 + 68] = mem[idx + _10422 + 32]
                                idx = idx + 32
                                continue 
                            mem[_10571 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _10571 + -mem[64] + 100
                        if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                            revert with 0, 17
                        _11332 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11332] = 30
                        mem[_11332 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                            _11702 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11702 + 68] = mem[idx + _11332 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11702 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11702 + -mem[64] + 100
                        if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                            revert with 0, 17
                        _13068 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13068] = 30
                        mem[_13068 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                            if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                                revert with 0, 17
                            return (-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply)
                        _13550 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13550 + 68] = mem[idx + _13068 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13550 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13550 + -mem[64] + 100
                    if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                        revert with 0, 17
                    if not arg1 * _marketingFee / 10000:
                        revert with 0, 18
                    if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _11017 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11017] = 30
                    mem[_11017 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                        _11331 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _11331 + 68] = mem[idx + _11017 + 32]
                            idx = idx + 32
                            continue 
                        mem[_11331 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _11331 + -mem[64] + 100
                    if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                        revert with 0, 17
                    _12551 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12551] = 30
                    mem[_12551 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                        _13067 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13067 + 68] = mem[idx + _12551 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13067 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13067 + -mem[64] + 100
                    if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                        revert with 0, 17
                    _14673 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14673] = 30
                    mem[_14673 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _marketingFee / 10000 * stor12 / totalSupply <= -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                        if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                            revert with 0, 17
                        return ((-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _marketingFee / 10000 * stor12 / totalSupply))
                    _15198 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _15198 + 68] = mem[idx + _14673 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15198 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _15198 + -mem[64] + 100
                if arg1 and stor12 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor12 / totalSupply / arg1 != stor12 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _taxFee / 10000:
                    if not arg1 * _marketingFee / 10000:
                        _10421 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10421] = 30
                        mem[_10421 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor12 / totalSupply:
                            _10570 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _10570 + 68] = mem[idx + _10421 + 32]
                                idx = idx + 32
                                continue 
                            mem[_10570 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _10570 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 0, 17
                        _11329 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11329] = 30
                        mem[_11329 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor12 / totalSupply:
                            _11701 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11701 + 68] = mem[idx + _11329 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11701 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11701 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 0, 17
                        _13065 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13065] = 30
                        mem[_13065 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= arg1 * stor12 / totalSupply:
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 0, 17
                            return (arg1 * stor12 / totalSupply)
                        _13549 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13549 + 68] = mem[idx + _13065 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13549 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13549 + -mem[64] + 100
                    if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                        revert with 0, 17
                    if not arg1 * _marketingFee / 10000:
                        revert with 0, 18
                    if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _11016 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11016] = 30
                    mem[_11016 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor12 / totalSupply:
                        _11328 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _11328 + 68] = mem[idx + _11016 + 32]
                            idx = idx + 32
                            continue 
                        mem[_11328 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _11328 + -mem[64] + 100
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 0, 17
                    _12549 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12549] = 30
                    mem[_12549 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor12 / totalSupply:
                        _13064 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13064 + 68] = mem[idx + _12549 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13064 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13064 + -mem[64] + 100
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 0, 17
                    _14671 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14671] = 30
                    mem[_14671 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _marketingFee / 10000 * stor12 / totalSupply <= arg1 * stor12 / totalSupply:
                        if arg1 * stor12 / totalSupply < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                            revert with 0, 17
                        return ((arg1 * stor12 / totalSupply) - (arg1 * _marketingFee / 10000 * stor12 / totalSupply))
                    _15196 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _15196 + 68] = mem[idx + _14671 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15196 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _15196 + -mem[64] + 100
                if arg1 * _taxFee / 10000 and stor12 / totalSupply > -1 / arg1 * _taxFee / 10000:
                    revert with 0, 17
                if not arg1 * _taxFee / 10000:
                    revert with 0, 18
                if arg1 * _taxFee / 10000 * stor12 / totalSupply / arg1 * _taxFee / 10000 != stor12 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _marketingFee / 10000:
                    _11015 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11015] = 30
                    mem[_11015 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                        _11327 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _11327 + 68] = mem[idx + _11015 + 32]
                            idx = idx + 32
                            continue 
                        mem[_11327 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _11327 + -mem[64] + 100
                    if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                        revert with 0, 17
                    _12547 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12547] = 30
                    mem[_12547 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                        _13063 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13063 + 68] = mem[idx + _12547 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13063 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13063 + -mem[64] + 100
                    if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                        revert with 0, 17
                    _14669 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14669] = 30
                    mem[_14669 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                        if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                            revert with 0, 17
                        return ((arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply))
                    _15195 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _15195 + 68] = mem[idx + _14669 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15195 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _15195 + -mem[64] + 100
                if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                    revert with 0, 17
                if not arg1 * _marketingFee / 10000:
                    revert with 0, 18
                if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                _12089 = mem[64]
                mem[64] = mem[64] + 64
                mem[_12089] = 30
                mem[_12089 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                    _12546 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _12546 + 68] = mem[idx + _12089 + 32]
                        idx = idx + 32
                        continue 
                    mem[_12546 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _12546 + -mem[64] + 100
                if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                    revert with 0, 17
                _14100 = mem[64]
                mem[64] = mem[64] + 64
                mem[_14100] = 30
                mem[_14100 + 32] = 'SafeMath: subtraction overflow'
                if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                    _14668 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _14668 + 68] = mem[idx + _14100 + 32]
                        idx = idx + 32
                        continue 
                    mem[_14668 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _14668 + -mem[64] + 100
                if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                    revert with 0, 17
                _16236 = mem[64]
                mem[64] = mem[64] + 64
                mem[_16236] = 30
                mem[_16236 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * _marketingFee / 10000 * stor12 / totalSupply <= (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                    if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                        revert with 0, 17
                    return ((arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _marketingFee / 10000 * stor12 / totalSupply))
                _16603 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _16603 + 68] = mem[idx + _16236 + 32]
                    idx = idx + 32
                    continue 
                mem[_16603 + 98] = 0
                revert with memory
                  from mem[64]
                   len _16603 + -mem[64] + 100
            if not totalSupply:
                revert with 0, 'SafeMath: division by zero', 0
            if t >= stor12 / totalSupply:
                if not s:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if not arg1 * _taxFee / 10000:
                        if not arg1 * _marketingFee / 10000:
                            return 0
                        if arg1 * _marketingFee / 10000 and t / s > -1 / arg1 * _marketingFee / 10000:
                            revert with 0, 17
                        if not arg1 * _marketingFee / 10000:
                            revert with 0, 18
                        if arg1 * _marketingFee / 10000 * t / s / arg1 * _marketingFee / 10000 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * _marketingFee / 10000 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * _marketingFee / 10000 * t / s:
                            revert with 0, 17
                        return (-1 * arg1 * _marketingFee / 10000 * t / s)
                    if arg1 * _taxFee / 10000 and t / s > -1 / arg1 * _taxFee / 10000:
                        revert with 0, 17
                    if not arg1 * _taxFee / 10000:
                        revert with 0, 18
                    if arg1 * _taxFee / 10000 * t / s / arg1 * _taxFee / 10000 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _marketingFee / 10000:
                        if arg1 * _taxFee / 10000 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * _taxFee / 10000 * t / s:
                            revert with 0, 17
                        if 0 > -1 * arg1 * _taxFee / 10000 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _taxFee / 10000 * t / s < 0:
                            revert with 0, 17
                        if 0 > -1 * arg1 * _taxFee / 10000 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _taxFee / 10000 * t / s < 0:
                            revert with 0, 17
                        return (-1 * arg1 * _taxFee / 10000 * t / s)
                    if arg1 * _marketingFee / 10000 and t / s > -1 / arg1 * _marketingFee / 10000:
                        revert with 0, 17
                    if not arg1 * _marketingFee / 10000:
                        revert with 0, 18
                    if arg1 * _marketingFee / 10000 * t / s / arg1 * _marketingFee / 10000 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * _taxFee / 10000 * t / s > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * _taxFee / 10000 * t / s:
                        revert with 0, 17
                    if 0 > -1 * arg1 * _taxFee / 10000 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _taxFee / 10000 * t / s < 0:
                        revert with 0, 17
                    if arg1 * _marketingFee / 10000 * t / s > -1 * arg1 * _taxFee / 10000 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _taxFee / 10000 * t / s < arg1 * _marketingFee / 10000 * t / s:
                        revert with 0, 17
                    return ((-1 * arg1 * _taxFee / 10000 * t / s) - (arg1 * _marketingFee / 10000 * t / s))
                if arg1 and t / s > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * t / s / arg1 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _taxFee / 10000:
                    if not arg1 * _marketingFee / 10000:
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        return (arg1 * t / s)
                    if arg1 * _marketingFee / 10000 and t / s > -1 / arg1 * _marketingFee / 10000:
                        revert with 0, 17
                    if not arg1 * _marketingFee / 10000:
                        revert with 0, 18
                    if arg1 * _marketingFee / 10000 * t / s / arg1 * _marketingFee / 10000 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 0, 17
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 0, 17
                    if arg1 * _marketingFee / 10000 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * _marketingFee / 10000 * t / s:
                        revert with 0, 17
                    return ((arg1 * t / s) - (arg1 * _marketingFee / 10000 * t / s))
                if arg1 * _taxFee / 10000 and t / s > -1 / arg1 * _taxFee / 10000:
                    revert with 0, 17
                if not arg1 * _taxFee / 10000:
                    revert with 0, 18
                if arg1 * _taxFee / 10000 * t / s / arg1 * _taxFee / 10000 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _marketingFee / 10000:
                    if arg1 * _taxFee / 10000 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * _taxFee / 10000 * t / s:
                        revert with 0, 17
                    if 0 > (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s) < 0:
                        revert with 0, 17
                    if 0 > (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s) < 0:
                        revert with 0, 17
                    return ((arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s))
                if arg1 * _marketingFee / 10000 and t / s > -1 / arg1 * _marketingFee / 10000:
                    revert with 0, 17
                if not arg1 * _marketingFee / 10000:
                    revert with 0, 18
                if arg1 * _marketingFee / 10000 * t / s / arg1 * _marketingFee / 10000 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg1 * _taxFee / 10000 * t / s > arg1 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * t / s < arg1 * _taxFee / 10000 * t / s:
                    revert with 0, 17
                if 0 > (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s) < 0:
                    revert with 0, 17
                if arg1 * _marketingFee / 10000 * t / s > (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s) < arg1 * _marketingFee / 10000 * t / s:
                    revert with 0, 17
                return ((arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s) - (arg1 * _marketingFee / 10000 * t / s))
            if not totalSupply:
                revert with 0, 'SafeMath: division by zero', 0
            if not arg1:
                if not arg1 * _taxFee / 10000:
                    if not arg1 * _marketingFee / 10000:
                        return 0
                    if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                        revert with 0, 17
                    if not arg1 * _marketingFee / 10000:
                        revert with 0, 18
                    if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * _marketingFee / 10000 * stor12 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                        revert with 0, 17
                    return (-1 * arg1 * _marketingFee / 10000 * stor12 / totalSupply)
                if arg1 * _taxFee / 10000 and stor12 / totalSupply > -1 / arg1 * _taxFee / 10000:
                    revert with 0, 17
                if not arg1 * _taxFee / 10000:
                    revert with 0, 18
                if arg1 * _taxFee / 10000 * stor12 / totalSupply / arg1 * _taxFee / 10000 != stor12 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _marketingFee / 10000:
                    if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                        revert with 0, 17
                    if 0 > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                        revert with 0, 17
                    return (-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply)
                if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                    revert with 0, 17
                if not arg1 * _marketingFee / 10000:
                    revert with 0, 18
                if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                    revert with 0, 17
                if 0 > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                    revert with 0, 17
                if arg1 * _marketingFee / 10000 * stor12 / totalSupply > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                    revert with 0, 17
                return ((-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _marketingFee / 10000 * stor12 / totalSupply))
            if arg1 and stor12 / totalSupply > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * stor12 / totalSupply / arg1 != stor12 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * _taxFee / 10000:
                if not arg1 * _marketingFee / 10000:
                    if 0 > arg1 * stor12 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor12 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor12 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 0, 17
                    return (arg1 * stor12 / totalSupply)
                if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                    revert with 0, 17
                if not arg1 * _marketingFee / 10000:
                    revert with 0, 18
                if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 0 > arg1 * stor12 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor12 / totalSupply < 0:
                    revert with 0, 17
                if 0 > arg1 * stor12 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor12 / totalSupply < 0:
                    revert with 0, 17
                if arg1 * _marketingFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor12 / totalSupply < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                    revert with 0, 17
                return ((arg1 * stor12 / totalSupply) - (arg1 * _marketingFee / 10000 * stor12 / totalSupply))
            if arg1 * _taxFee / 10000 and stor12 / totalSupply > -1 / arg1 * _taxFee / 10000:
                revert with 0, 17
            if not arg1 * _taxFee / 10000:
                revert with 0, 18
            if arg1 * _taxFee / 10000 * stor12 / totalSupply / arg1 * _taxFee / 10000 != stor12 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * _marketingFee / 10000:
                if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                    revert with 0, 17
                if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                    revert with 0, 17
                if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                    revert with 0, 17
                return ((arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply))
            if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                revert with 0, 17
            if not arg1 * _marketingFee / 10000:
                revert with 0, 18
            if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                revert with 0, 17
            if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                revert with 0, 17
            if arg1 * _marketingFee / 10000 * stor12 / totalSupply > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                revert with 0, 17
            return ((arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _marketingFee / 10000 * stor12 / totalSupply))
        if arg1 and _liquidityFee > -1 / arg1:
            revert with 0, 17
        if not arg1:
            revert with 0, 18
        if arg1 * _liquidityFee / arg1 != _liquidityFee:
            revert with 0, 'SafeMath: multiplication overflow'
        mem[160] = 26
        mem[192] = 'SafeMath: division by zero'
        if not arg1:
            mem[224] = 26
            mem[256] = 'SafeMath: division by zero'
            mem[288] = 30
            mem[320] = 'SafeMath: subtraction overflow'
            if arg1 * _taxFee / 10000 > arg1:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 < arg1 * _taxFee / 10000:
                revert with 0, 17
            mem[352] = 30
            mem[384] = 'SafeMath: subtraction overflow'
            if arg1 * _liquidityFee / 10000 > arg1 - (arg1 * _taxFee / 10000):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 - (arg1 * _taxFee / 10000) < arg1 * _liquidityFee / 10000:
                revert with 0, 17
            mem[64] = 480
            mem[416] = 30
            mem[448] = 'SafeMath: subtraction overflow'
            if 0 > arg1 - (arg1 * _taxFee / 10000) - (arg1 * _liquidityFee / 10000):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 - (arg1 * _taxFee / 10000) - (arg1 * _liquidityFee / 10000) < 0:
                revert with 0, 17
            idx = 0
            s = totalSupply
            t = stor12
            while idx < stor9.length:
                mem[0] = stor9[idx]
                mem[32] = 3
                if stor3[stor9[idx]] > t:
                    _9260 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9260] = 26
                    mem[_9260 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _9326 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _9326 + 68] = mem[idx + _9260 + 32]
                            idx = idx + 32
                            continue 
                        mem[_9326 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _9326 + -mem[64] + 100
                    if not arg1:
                        if not arg1 * _taxFee / 10000:
                            if not arg1 * _liquidityFee / 10000:
                                return 0
                            if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                                revert with 0, 17
                            if not arg1 * _liquidityFee / 10000:
                                revert with 0, 18
                            if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _10270 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10270] = 30
                            mem[_10270 + 32] = 'SafeMath: subtraction overflow'
                            _10996 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10996] = 30
                            mem[_10996 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > 0:
                                _11309 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11309 + 68] = mem[idx + _10996 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11309 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11309 + -mem[64] + 100
                            if 0 < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                revert with 0, 17
                            _12521 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12521] = 30
                            mem[_12521 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                if -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply < 0:
                                    revert with 0, 17
                                return (-1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply)
                            _13048 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13048 + 68] = mem[idx + _12521 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13048 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13048 + -mem[64] + 100
                        if arg1 * _taxFee / 10000 and stor12 / totalSupply > -1 / arg1 * _taxFee / 10000:
                            revert with 0, 17
                        if not arg1 * _taxFee / 10000:
                            revert with 0, 18
                        if arg1 * _taxFee / 10000 * stor12 / totalSupply / arg1 * _taxFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _liquidityFee / 10000:
                            _10269 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10269] = 30
                            mem[_10269 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                                _10409 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _10409 + 68] = mem[idx + _10269 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_10409 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _10409 + -mem[64] + 100
                            if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                revert with 0, 17
                            _10994 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10994] = 30
                            mem[_10994 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                _11308 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11308 + 68] = mem[idx + _10994 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11308 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11308 + -mem[64] + 100
                            if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                                revert with 0, 17
                            _12519 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12519] = 30
                            mem[_12519 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                                    revert with 0, 17
                                return (-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply)
                            _13047 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13047 + 68] = mem[idx + _12519 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13047 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13047 + -mem[64] + 100
                        if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                            revert with 0, 17
                        if not arg1 * _liquidityFee / 10000:
                            revert with 0, 18
                        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _10742 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10742] = 30
                        mem[_10742 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                            _10993 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _10993 + 68] = mem[idx + _10742 + 32]
                                idx = idx + 32
                                continue 
                            mem[_10993 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _10993 + -mem[64] + 100
                        if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                            revert with 0, 17
                        _12063 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12063] = 30
                        mem[_12063 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                            _12518 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12518 + 68] = mem[idx + _12063 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12518 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12518 + -mem[64] + 100
                        if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                            revert with 0, 17
                        _14072 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14072] = 30
                        mem[_14072 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                            if (-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < 0:
                                revert with 0, 17
                            return ((-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply))
                        _14646 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _14646 + 68] = mem[idx + _14072 + 32]
                            idx = idx + 32
                            continue 
                        mem[_14646 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14646 + -mem[64] + 100
                    if arg1 and stor12 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor12 / totalSupply / arg1 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _taxFee / 10000:
                        if not arg1 * _liquidityFee / 10000:
                            _10267 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10267] = 30
                            mem[_10267 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor12 / totalSupply:
                                _10408 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _10408 + 68] = mem[idx + _10267 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_10408 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _10408 + -mem[64] + 100
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 0, 17
                            _10991 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10991] = 30
                            mem[_10991 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor12 / totalSupply:
                                _11307 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11307 + 68] = mem[idx + _10991 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11307 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11307 + -mem[64] + 100
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 0, 17
                            _12516 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12516] = 30
                            mem[_12516 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor12 / totalSupply:
                                if arg1 * stor12 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor12 / totalSupply)
                            _13046 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13046 + 68] = mem[idx + _12516 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13046 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13046 + -mem[64] + 100
                        if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                            revert with 0, 17
                        if not arg1 * _liquidityFee / 10000:
                            revert with 0, 18
                        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _10741 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10741] = 30
                        mem[_10741 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor12 / totalSupply:
                            _10990 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _10990 + 68] = mem[idx + _10741 + 32]
                                idx = idx + 32
                                continue 
                            mem[_10990 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _10990 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 0, 17
                        _12061 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12061] = 30
                        mem[_12061 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                            _12515 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12515 + 68] = mem[idx + _12061 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12515 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12515 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                            revert with 0, 17
                        _14070 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14070] = 30
                        mem[_14070 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                            if (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < 0:
                                revert with 0, 17
                            return ((arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply))
                        _14644 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _14644 + 68] = mem[idx + _14070 + 32]
                            idx = idx + 32
                            continue 
                        mem[_14644 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14644 + -mem[64] + 100
                    if arg1 * _taxFee / 10000 and stor12 / totalSupply > -1 / arg1 * _taxFee / 10000:
                        revert with 0, 17
                    if not arg1 * _taxFee / 10000:
                        revert with 0, 18
                    if arg1 * _taxFee / 10000 * stor12 / totalSupply / arg1 * _taxFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _liquidityFee / 10000:
                        _10740 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10740] = 30
                        mem[_10740 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                            _10989 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _10989 + 68] = mem[idx + _10740 + 32]
                                idx = idx + 32
                                continue 
                            mem[_10989 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _10989 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                            revert with 0, 17
                        _12059 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12059] = 30
                        mem[_12059 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                            _12514 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12514 + 68] = mem[idx + _12059 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12514 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12514 + -mem[64] + 100
                        if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                            revert with 0, 17
                        _14068 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14068] = 30
                        mem[_14068 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                            if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                                revert with 0, 17
                            return ((arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply))
                        _14643 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _14643 + 68] = mem[idx + _14068 + 32]
                            idx = idx + 32
                            continue 
                        mem[_14643 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14643 + -mem[64] + 100
                    if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                        revert with 0, 17
                    if not arg1 * _liquidityFee / 10000:
                        revert with 0, 18
                    if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _11688 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11688] = 30
                    mem[_11688 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                        _12058 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _12058 + 68] = mem[idx + _11688 + 32]
                            idx = idx + 32
                            continue 
                        mem[_12058 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _12058 + -mem[64] + 100
                    if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                        revert with 0, 17
                    _13526 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_13526] = 30
                    mem[_13526 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                        _14067 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _14067 + 68] = mem[idx + _13526 + 32]
                            idx = idx + 32
                            continue 
                        mem[_14067 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14067 + -mem[64] + 100
                    if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                        revert with 0, 17
                    _15738 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_15738] = 30
                    mem[_15738 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                        if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < 0:
                            revert with 0, 17
                        return ((arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply))
                    _16214 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _16214 + 68] = mem[idx + _15738 + 32]
                        idx = idx + 32
                        continue 
                    mem[_16214 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _16214 + -mem[64] + 100
                if idx >= stor9.length:
                    revert with 0, 50
                mem[0] = stor9[idx]
                mem[32] = 4
                if stor4[stor9[idx]] <= s:
                    if idx >= stor9.length:
                        revert with 0, 50
                    mem[0] = stor9[idx]
                    mem[32] = 3
                    _9327 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9327] = 30
                    mem[_9327 + 32] = 'SafeMath: subtraction overflow'
                    if stor3[stor9[idx]] > t:
                        _9407 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _9407 + 68] = mem[idx + _9327 + 32]
                            idx = idx + 32
                            continue 
                        mem[_9407 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _9407 + -mem[64] + 100
                    if t < stor3[stor9[idx]]:
                        revert with 0, 17
                    if idx >= stor9.length:
                        revert with 0, 50
                    mem[0] = stor9[idx]
                    mem[32] = 4
                    _9760 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9760] = 30
                    mem[_9760 + 32] = 'SafeMath: subtraction overflow'
                    if stor4[stor9[idx]] <= s:
                        if s < stor4[stor9[idx]]:
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s - stor4[stor9[idx]]
                        t = t - stor3[stor9[idx]]
                        continue 
                    _9808 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _9808 + 68] = mem[idx + _9760 + 32]
                        idx = idx + 32
                        continue 
                    mem[_9808 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _9808 + -mem[64] + 100
                _9328 = mem[64]
                mem[64] = mem[64] + 64
                mem[_9328] = 26
                mem[_9328 + 32] = 'SafeMath: division by zero'
                if not totalSupply:
                    _9408 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _9408 + 68] = mem[idx + _9328 + 32]
                        idx = idx + 32
                        continue 
                    mem[_9408 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _9408 + -mem[64] + 100
                if not arg1:
                    if not arg1 * _taxFee / 10000:
                        if not arg1 * _liquidityFee / 10000:
                            return 0
                        if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                            revert with 0, 17
                        if not arg1 * _liquidityFee / 10000:
                            revert with 0, 18
                        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _10415 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10415] = 30
                        mem[_10415 + 32] = 'SafeMath: subtraction overflow'
                        _11318 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11318] = 30
                        mem[_11318 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > 0:
                            _11691 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11691 + 68] = mem[idx + _11318 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11691 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11691 + -mem[64] + 100
                        if 0 < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                            revert with 0, 17
                        _13056 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13056] = 30
                        mem[_13056 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                            if -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply < 0:
                                revert with 0, 17
                            return (-1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply)
                        _13531 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13531 + 68] = mem[idx + _13056 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13531 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13531 + -mem[64] + 100
                    if arg1 * _taxFee / 10000 and stor12 / totalSupply > -1 / arg1 * _taxFee / 10000:
                        revert with 0, 17
                    if not arg1 * _taxFee / 10000:
                        revert with 0, 18
                    if arg1 * _taxFee / 10000 * stor12 / totalSupply / arg1 * _taxFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _liquidityFee / 10000:
                        _10414 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10414] = 30
                        mem[_10414 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                            _10564 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _10564 + 68] = mem[idx + _10414 + 32]
                                idx = idx + 32
                                continue 
                            mem[_10564 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _10564 + -mem[64] + 100
                        if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                            revert with 0, 17
                        _11316 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11316] = 30
                        mem[_11316 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                            _11690 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11690 + 68] = mem[idx + _11316 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11690 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11690 + -mem[64] + 100
                        if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                            revert with 0, 17
                        _13054 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13054] = 30
                        mem[_13054 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                            if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                                revert with 0, 17
                            return (-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply)
                        _13530 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13530 + 68] = mem[idx + _13054 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13530 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13530 + -mem[64] + 100
                    if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                        revert with 0, 17
                    if not arg1 * _liquidityFee / 10000:
                        revert with 0, 18
                    if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _11000 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11000] = 30
                    mem[_11000 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                        _11315 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _11315 + 68] = mem[idx + _11000 + 32]
                            idx = idx + 32
                            continue 
                        mem[_11315 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _11315 + -mem[64] + 100
                    if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                        revert with 0, 17
                    _12528 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12528] = 30
                    mem[_12528 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                        _13053 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13053 + 68] = mem[idx + _12528 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13053 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13053 + -mem[64] + 100
                    if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                        revert with 0, 17
                    _14654 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14654] = 30
                    mem[_14654 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                        if (-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < 0:
                            revert with 0, 17
                        return ((-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply))
                    _15183 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _15183 + 68] = mem[idx + _14654 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15183 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _15183 + -mem[64] + 100
                if arg1 and stor12 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor12 / totalSupply / arg1 != stor12 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _taxFee / 10000:
                    if not arg1 * _liquidityFee / 10000:
                        _10412 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10412] = 30
                        mem[_10412 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor12 / totalSupply:
                            _10563 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _10563 + 68] = mem[idx + _10412 + 32]
                                idx = idx + 32
                                continue 
                            mem[_10563 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _10563 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 0, 17
                        _11313 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11313] = 30
                        mem[_11313 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor12 / totalSupply:
                            _11689 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11689 + 68] = mem[idx + _11313 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11689 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11689 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 0, 17
                        _13051 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13051] = 30
                        mem[_13051 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= arg1 * stor12 / totalSupply:
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 0, 17
                            return (arg1 * stor12 / totalSupply)
                        _13529 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13529 + 68] = mem[idx + _13051 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13529 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13529 + -mem[64] + 100
                    if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                        revert with 0, 17
                    if not arg1 * _liquidityFee / 10000:
                        revert with 0, 18
                    if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _10999 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_10999] = 30
                    mem[_10999 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor12 / totalSupply:
                        _11312 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _11312 + 68] = mem[idx + _10999 + 32]
                            idx = idx + 32
                            continue 
                        mem[_11312 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _11312 + -mem[64] + 100
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 0, 17
                    _12526 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12526] = 30
                    mem[_12526 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                        _13050 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13050 + 68] = mem[idx + _12526 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13050 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13050 + -mem[64] + 100
                    if arg1 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                        revert with 0, 17
                    _14652 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14652] = 30
                    mem[_14652 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                        if (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < 0:
                            revert with 0, 17
                        return ((arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply))
                    _15181 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _15181 + 68] = mem[idx + _14652 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15181 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _15181 + -mem[64] + 100
                if arg1 * _taxFee / 10000 and stor12 / totalSupply > -1 / arg1 * _taxFee / 10000:
                    revert with 0, 17
                if not arg1 * _taxFee / 10000:
                    revert with 0, 18
                if arg1 * _taxFee / 10000 * stor12 / totalSupply / arg1 * _taxFee / 10000 != stor12 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _liquidityFee / 10000:
                    _10998 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_10998] = 30
                    mem[_10998 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                        _11311 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _11311 + 68] = mem[idx + _10998 + 32]
                            idx = idx + 32
                            continue 
                        mem[_11311 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _11311 + -mem[64] + 100
                    if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                        revert with 0, 17
                    _12524 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12524] = 30
                    mem[_12524 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                        _13049 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13049 + 68] = mem[idx + _12524 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13049 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13049 + -mem[64] + 100
                    if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                        revert with 0, 17
                    _14650 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14650] = 30
                    mem[_14650 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                        if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                            revert with 0, 17
                        return ((arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply))
                    _15180 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _15180 + 68] = mem[idx + _14650 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15180 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _15180 + -mem[64] + 100
                if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                    revert with 0, 17
                if not arg1 * _liquidityFee / 10000:
                    revert with 0, 18
                if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                _12065 = mem[64]
                mem[64] = mem[64] + 64
                mem[_12065] = 30
                mem[_12065 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                    _12523 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _12523 + 68] = mem[idx + _12065 + 32]
                        idx = idx + 32
                        continue 
                    mem[_12523 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _12523 + -mem[64] + 100
                if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                    revert with 0, 17
                _14074 = mem[64]
                mem[64] = mem[64] + 64
                mem[_14074] = 30
                mem[_14074 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                    _14649 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _14649 + 68] = mem[idx + _14074 + 32]
                        idx = idx + 32
                        continue 
                    mem[_14649 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _14649 + -mem[64] + 100
                if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                    revert with 0, 17
                _16218 = mem[64]
                mem[64] = mem[64] + 64
                mem[_16218] = 30
                mem[_16218 + 32] = 'SafeMath: subtraction overflow'
                if 0 <= (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                    if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < 0:
                        revert with 0, 17
                    return ((arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply))
                _16590 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _16590 + 68] = mem[idx + _16218 + 32]
                    idx = idx + 32
                    continue 
                mem[_16590 + 98] = 0
                revert with memory
                  from mem[64]
                   len _16590 + -mem[64] + 100
            if not totalSupply:
                revert with 0, 'SafeMath: division by zero', 0
            if t >= stor12 / totalSupply:
                if not s:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if not arg1 * _taxFee / 10000:
                        if not arg1 * _liquidityFee / 10000:
                            return 0
                        if arg1 * _liquidityFee / 10000 and t / s > -1 / arg1 * _liquidityFee / 10000:
                            revert with 0, 17
                        if not arg1 * _liquidityFee / 10000:
                            revert with 0, 18
                        if arg1 * _liquidityFee / 10000 * t / s / arg1 * _liquidityFee / 10000 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * _liquidityFee / 10000 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * _liquidityFee / 10000 * t / s:
                            revert with 0, 17
                        if 0 > -1 * arg1 * _liquidityFee / 10000 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _liquidityFee / 10000 * t / s < 0:
                            revert with 0, 17
                        return (-1 * arg1 * _liquidityFee / 10000 * t / s)
                    if arg1 * _taxFee / 10000 and t / s > -1 / arg1 * _taxFee / 10000:
                        revert with 0, 17
                    if not arg1 * _taxFee / 10000:
                        revert with 0, 18
                    if arg1 * _taxFee / 10000 * t / s / arg1 * _taxFee / 10000 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _liquidityFee / 10000:
                        if arg1 * _taxFee / 10000 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * _taxFee / 10000 * t / s:
                            revert with 0, 17
                        if 0 > -1 * arg1 * _taxFee / 10000 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _taxFee / 10000 * t / s < 0:
                            revert with 0, 17
                        if 0 > -1 * arg1 * _taxFee / 10000 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _taxFee / 10000 * t / s < 0:
                            revert with 0, 17
                        return (-1 * arg1 * _taxFee / 10000 * t / s)
                    if arg1 * _liquidityFee / 10000 and t / s > -1 / arg1 * _liquidityFee / 10000:
                        revert with 0, 17
                    if not arg1 * _liquidityFee / 10000:
                        revert with 0, 18
                    if arg1 * _liquidityFee / 10000 * t / s / arg1 * _liquidityFee / 10000 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * _taxFee / 10000 * t / s > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * _taxFee / 10000 * t / s:
                        revert with 0, 17
                    if arg1 * _liquidityFee / 10000 * t / s > -1 * arg1 * _taxFee / 10000 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _taxFee / 10000 * t / s < arg1 * _liquidityFee / 10000 * t / s:
                        revert with 0, 17
                    if 0 > (-1 * arg1 * _taxFee / 10000 * t / s) - (arg1 * _liquidityFee / 10000 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (-1 * arg1 * _taxFee / 10000 * t / s) - (arg1 * _liquidityFee / 10000 * t / s) < 0:
                        revert with 0, 17
                    return ((-1 * arg1 * _taxFee / 10000 * t / s) - (arg1 * _liquidityFee / 10000 * t / s))
                if arg1 and t / s > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * t / s / arg1 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _taxFee / 10000:
                    if not arg1 * _liquidityFee / 10000:
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        return (arg1 * t / s)
                    if arg1 * _liquidityFee / 10000 and t / s > -1 / arg1 * _liquidityFee / 10000:
                        revert with 0, 17
                    if not arg1 * _liquidityFee / 10000:
                        revert with 0, 18
                    if arg1 * _liquidityFee / 10000 * t / s / arg1 * _liquidityFee / 10000 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 0, 17
                    if arg1 * _liquidityFee / 10000 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * _liquidityFee / 10000 * t / s:
                        revert with 0, 17
                    if 0 > (arg1 * t / s) - (arg1 * _liquidityFee / 10000 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * _liquidityFee / 10000 * t / s) < 0:
                        revert with 0, 17
                    return ((arg1 * t / s) - (arg1 * _liquidityFee / 10000 * t / s))
                if arg1 * _taxFee / 10000 and t / s > -1 / arg1 * _taxFee / 10000:
                    revert with 0, 17
                if not arg1 * _taxFee / 10000:
                    revert with 0, 18
                if arg1 * _taxFee / 10000 * t / s / arg1 * _taxFee / 10000 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _liquidityFee / 10000:
                    if arg1 * _taxFee / 10000 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * _taxFee / 10000 * t / s:
                        revert with 0, 17
                    if 0 > (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s) < 0:
                        revert with 0, 17
                    if 0 > (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s) < 0:
                        revert with 0, 17
                    return ((arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s))
                if arg1 * _liquidityFee / 10000 and t / s > -1 / arg1 * _liquidityFee / 10000:
                    revert with 0, 17
                if not arg1 * _liquidityFee / 10000:
                    revert with 0, 18
                if arg1 * _liquidityFee / 10000 * t / s / arg1 * _liquidityFee / 10000 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg1 * _taxFee / 10000 * t / s > arg1 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * t / s < arg1 * _taxFee / 10000 * t / s:
                    revert with 0, 17
                if arg1 * _liquidityFee / 10000 * t / s > (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s) < arg1 * _liquidityFee / 10000 * t / s:
                    revert with 0, 17
                if 0 > (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s) - (arg1 * _liquidityFee / 10000 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s) - (arg1 * _liquidityFee / 10000 * t / s) < 0:
                    revert with 0, 17
                return ((arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s) - (arg1 * _liquidityFee / 10000 * t / s))
            if not totalSupply:
                revert with 0, 'SafeMath: division by zero', 0
            if not arg1:
                if not arg1 * _taxFee / 10000:
                    if not arg1 * _liquidityFee / 10000:
                        return 0
                    if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                        revert with 0, 17
                    if not arg1 * _liquidityFee / 10000:
                        revert with 0, 18
                    if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                        revert with 0, 17
                    if 0 > -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply < 0:
                        revert with 0, 17
                    return (-1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply)
                if arg1 * _taxFee / 10000 and stor12 / totalSupply > -1 / arg1 * _taxFee / 10000:
                    revert with 0, 17
                if not arg1 * _taxFee / 10000:
                    revert with 0, 18
                if arg1 * _taxFee / 10000 * stor12 / totalSupply / arg1 * _taxFee / 10000 != stor12 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _liquidityFee / 10000:
                    if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                        revert with 0, 17
                    if 0 > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                        revert with 0, 17
                    return (-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply)
                if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                    revert with 0, 17
                if not arg1 * _liquidityFee / 10000:
                    revert with 0, 18
                if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                    revert with 0, 17
                if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                    revert with 0, 17
                if 0 > (-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < 0:
                    revert with 0, 17
                return ((-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply))
            if arg1 and stor12 / totalSupply > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * stor12 / totalSupply / arg1 != stor12 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * _taxFee / 10000:
                if not arg1 * _liquidityFee / 10000:
                    if 0 > arg1 * stor12 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor12 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor12 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 0, 17
                    return (arg1 * stor12 / totalSupply)
                if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                    revert with 0, 17
                if not arg1 * _liquidityFee / 10000:
                    revert with 0, 18
                if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 0 > arg1 * stor12 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor12 / totalSupply < 0:
                    revert with 0, 17
                if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                    revert with 0, 17
                if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < 0:
                    revert with 0, 17
                return ((arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply))
            if arg1 * _taxFee / 10000 and stor12 / totalSupply > -1 / arg1 * _taxFee / 10000:
                revert with 0, 17
            if not arg1 * _taxFee / 10000:
                revert with 0, 18
            if arg1 * _taxFee / 10000 * stor12 / totalSupply / arg1 * _taxFee / 10000 != stor12 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * _liquidityFee / 10000:
                if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                    revert with 0, 17
                if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                    revert with 0, 17
                if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                    revert with 0, 17
                return ((arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply))
            if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                revert with 0, 17
            if not arg1 * _liquidityFee / 10000:
                revert with 0, 18
            if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                revert with 0, 17
            if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                revert with 0, 17
            if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < 0:
                revert with 0, 17
            return ((arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply))
        if arg1 and _marketingFee > -1 / arg1:
            revert with 0, 17
        if not arg1:
            revert with 0, 18
        if arg1 * _marketingFee / arg1 != _marketingFee:
            revert with 0, 'SafeMath: multiplication overflow'
        mem[224] = 26
        mem[256] = 'SafeMath: division by zero'
        mem[288] = 30
        mem[320] = 'SafeMath: subtraction overflow'
        if arg1 * _taxFee / 10000 > arg1:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if arg1 < arg1 * _taxFee / 10000:
            revert with 0, 17
        mem[352] = 30
        mem[384] = 'SafeMath: subtraction overflow'
        if arg1 * _liquidityFee / 10000 > arg1 - (arg1 * _taxFee / 10000):
            revert with 0, 'SafeMath: subtraction overflow', 0
        if arg1 - (arg1 * _taxFee / 10000) < arg1 * _liquidityFee / 10000:
            revert with 0, 17
        mem[64] = 480
        mem[416] = 30
        mem[448] = 'SafeMath: subtraction overflow'
        if arg1 * _marketingFee / 10000 > arg1 - (arg1 * _taxFee / 10000) - (arg1 * _liquidityFee / 10000):
            revert with 0, 'SafeMath: subtraction overflow', 0
        if arg1 - (arg1 * _taxFee / 10000) - (arg1 * _liquidityFee / 10000) < arg1 * _marketingFee / 10000:
            revert with 0, 17
        idx = 0
        s = totalSupply
        t = stor12
        while idx < stor9.length:
            mem[0] = stor9[idx]
            mem[32] = 3
            if stor3[stor9[idx]] > t:
                _9259 = mem[64]
                mem[64] = mem[64] + 64
                mem[_9259] = 26
                mem[_9259 + 32] = 'SafeMath: division by zero'
                if not totalSupply:
                    _9323 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _9323 + 68] = mem[idx + _9259 + 32]
                        idx = idx + 32
                        continue 
                    mem[_9323 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _9323 + -mem[64] + 100
                if not arg1:
                    if not arg1 * _taxFee / 10000:
                        if not arg1 * _liquidityFee / 10000:
                            if not arg1 * _marketingFee / 10000:
                                return 0
                            if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                                revert with 0, 17
                            if not arg1 * _marketingFee / 10000:
                                revert with 0, 18
                            if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _10260 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10260] = 30
                            mem[_10260 + 32] = 'SafeMath: subtraction overflow'
                            _10975 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10975] = 30
                            mem[_10975 + 32] = 'SafeMath: subtraction overflow'
                            _12490 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12490] = 30
                            mem[_12490 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _marketingFee / 10000 * stor12 / totalSupply <= 0:
                                if 0 < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                                    revert with 0, 17
                                return (-1 * arg1 * _marketingFee / 10000 * stor12 / totalSupply)
                            _13029 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13029 + 68] = mem[idx + _12490 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13029 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13029 + -mem[64] + 100
                        if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                            revert with 0, 17
                        if not arg1 * _liquidityFee / 10000:
                            revert with 0, 18
                        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _marketingFee / 10000:
                            _10259 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10259] = 30
                            mem[_10259 + 32] = 'SafeMath: subtraction overflow'
                            _10974 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10974] = 30
                            mem[_10974 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > 0:
                                _11294 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11294 + 68] = mem[idx + _10974 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11294 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11294 + -mem[64] + 100
                            if 0 < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                revert with 0, 17
                            _12488 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12488] = 30
                            mem[_12488 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                if -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply < 0:
                                    revert with 0, 17
                                return (-1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply)
                            _13028 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13028 + 68] = mem[idx + _12488 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13028 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13028 + -mem[64] + 100
                        if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                            revert with 0, 17
                        if not arg1 * _marketingFee / 10000:
                            revert with 0, 18
                        if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _10725 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10725] = 30
                        mem[_10725 + 32] = 'SafeMath: subtraction overflow'
                        _12037 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12037] = 30
                        mem[_12037 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > 0:
                            _12487 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12487 + 68] = mem[idx + _12037 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12487 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12487 + -mem[64] + 100
                        if 0 < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                            revert with 0, 17
                        _14037 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14037] = 30
                        mem[_14037 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _marketingFee / 10000 * stor12 / totalSupply <= -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                            if -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                                revert with 0, 17
                            return ((-1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply) - (arg1 * _marketingFee / 10000 * stor12 / totalSupply))
                        _14618 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _14618 + 68] = mem[idx + _14037 + 32]
                            idx = idx + 32
                            continue 
                        mem[_14618 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14618 + -mem[64] + 100
                    if arg1 * _taxFee / 10000 and stor12 / totalSupply > -1 / arg1 * _taxFee / 10000:
                        revert with 0, 17
                    if not arg1 * _taxFee / 10000:
                        revert with 0, 18
                    if arg1 * _taxFee / 10000 * stor12 / totalSupply / arg1 * _taxFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _liquidityFee / 10000:
                        if not arg1 * _marketingFee / 10000:
                            _10258 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10258] = 30
                            mem[_10258 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                                _10398 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _10398 + 68] = mem[idx + _10258 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_10398 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _10398 + -mem[64] + 100
                            if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                revert with 0, 17
                            _10972 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10972] = 30
                            mem[_10972 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                _11293 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11293 + 68] = mem[idx + _10972 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11293 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11293 + -mem[64] + 100
                            if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                                revert with 0, 17
                            _12485 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12485] = 30
                            mem[_12485 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                                    revert with 0, 17
                                return (-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply)
                            _13027 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13027 + 68] = mem[idx + _12485 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13027 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13027 + -mem[64] + 100
                        if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                            revert with 0, 17
                        if not arg1 * _marketingFee / 10000:
                            revert with 0, 18
                        if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _10724 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10724] = 30
                        mem[_10724 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                            _10971 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _10971 + 68] = mem[idx + _10724 + 32]
                                idx = idx + 32
                                continue 
                            mem[_10971 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _10971 + -mem[64] + 100
                        if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                            revert with 0, 17
                        _12035 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12035] = 30
                        mem[_12035 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                            _12484 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12484 + 68] = mem[idx + _12035 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12484 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12484 + -mem[64] + 100
                        if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                            revert with 0, 17
                        _14035 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14035] = 30
                        mem[_14035 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _marketingFee / 10000 * stor12 / totalSupply <= -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                            if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                                revert with 0, 17
                            return ((-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _marketingFee / 10000 * stor12 / totalSupply))
                        _14616 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _14616 + 68] = mem[idx + _14035 + 32]
                            idx = idx + 32
                            continue 
                        mem[_14616 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14616 + -mem[64] + 100
                    if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                        revert with 0, 17
                    if not arg1 * _liquidityFee / 10000:
                        revert with 0, 18
                    if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _marketingFee / 10000:
                        _10723 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10723] = 30
                        mem[_10723 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                            _10970 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _10970 + 68] = mem[idx + _10723 + 32]
                                idx = idx + 32
                                continue 
                            mem[_10970 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _10970 + -mem[64] + 100
                        if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                            revert with 0, 17
                        _12033 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12033] = 30
                        mem[_12033 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                            _12483 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12483 + 68] = mem[idx + _12033 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12483 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12483 + -mem[64] + 100
                        if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                            revert with 0, 17
                        _14033 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14033] = 30
                        mem[_14033 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                            if (-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < 0:
                                revert with 0, 17
                            return ((-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply))
                        _14615 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _14615 + 68] = mem[idx + _14033 + 32]
                            idx = idx + 32
                            continue 
                        mem[_14615 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14615 + -mem[64] + 100
                    if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                        revert with 0, 17
                    if not arg1 * _marketingFee / 10000:
                        revert with 0, 18
                    if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _11672 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11672] = 30
                    mem[_11672 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                        _12032 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _12032 + 68] = mem[idx + _11672 + 32]
                            idx = idx + 32
                            continue 
                        mem[_12032 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _12032 + -mem[64] + 100
                    if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                        revert with 0, 17
                    _13504 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_13504] = 30
                    mem[_13504 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                        _14032 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _14032 + 68] = mem[idx + _13504 + 32]
                            idx = idx + 32
                            continue 
                        mem[_14032 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14032 + -mem[64] + 100
                    if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                        revert with 0, 17
                    _15716 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_15716] = 30
                    mem[_15716 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _marketingFee / 10000 * stor12 / totalSupply <= (-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                        if (-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                            revert with 0, 17
                        return ((-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) - (arg1 * _marketingFee / 10000 * stor12 / totalSupply))
                    _16189 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _16189 + 68] = mem[idx + _15716 + 32]
                        idx = idx + 32
                        continue 
                    mem[_16189 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _16189 + -mem[64] + 100
                if arg1 and stor12 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor12 / totalSupply / arg1 != stor12 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _taxFee / 10000:
                    if not arg1 * _liquidityFee / 10000:
                        if not arg1 * _marketingFee / 10000:
                            _10256 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10256] = 30
                            mem[_10256 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor12 / totalSupply:
                                _10397 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _10397 + 68] = mem[idx + _10256 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_10397 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _10397 + -mem[64] + 100
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 0, 17
                            _10968 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10968] = 30
                            mem[_10968 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor12 / totalSupply:
                                _11291 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11291 + 68] = mem[idx + _10968 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11291 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11291 + -mem[64] + 100
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 0, 17
                            _12481 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12481] = 30
                            mem[_12481 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor12 / totalSupply:
                                if arg1 * stor12 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor12 / totalSupply)
                            _13026 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13026 + 68] = mem[idx + _12481 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13026 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13026 + -mem[64] + 100
                        if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                            revert with 0, 17
                        if not arg1 * _marketingFee / 10000:
                            revert with 0, 18
                        if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _10722 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10722] = 30
                        mem[_10722 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor12 / totalSupply:
                            _10967 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _10967 + 68] = mem[idx + _10722 + 32]
                                idx = idx + 32
                                continue 
                            mem[_10967 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _10967 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 0, 17
                        _12030 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12030] = 30
                        mem[_12030 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor12 / totalSupply:
                            _12480 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12480 + 68] = mem[idx + _12030 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12480 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12480 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 0, 17
                        _14030 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14030] = 30
                        mem[_14030 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _marketingFee / 10000 * stor12 / totalSupply <= arg1 * stor12 / totalSupply:
                            if arg1 * stor12 / totalSupply < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                                revert with 0, 17
                            return ((arg1 * stor12 / totalSupply) - (arg1 * _marketingFee / 10000 * stor12 / totalSupply))
                        _14613 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _14613 + 68] = mem[idx + _14030 + 32]
                            idx = idx + 32
                            continue 
                        mem[_14613 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14613 + -mem[64] + 100
                    if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                        revert with 0, 17
                    if not arg1 * _liquidityFee / 10000:
                        revert with 0, 18
                    if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _marketingFee / 10000:
                        _10721 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10721] = 30
                        mem[_10721 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor12 / totalSupply:
                            _10966 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _10966 + 68] = mem[idx + _10721 + 32]
                                idx = idx + 32
                                continue 
                            mem[_10966 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _10966 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 0, 17
                        _12028 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12028] = 30
                        mem[_12028 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                            _12479 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12479 + 68] = mem[idx + _12028 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12479 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12479 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                            revert with 0, 17
                        _14028 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14028] = 30
                        mem[_14028 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                            if (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < 0:
                                revert with 0, 17
                            return ((arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply))
                        _14612 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _14612 + 68] = mem[idx + _14028 + 32]
                            idx = idx + 32
                            continue 
                        mem[_14612 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14612 + -mem[64] + 100
                    if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                        revert with 0, 17
                    if not arg1 * _marketingFee / 10000:
                        revert with 0, 18
                    if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _11671 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11671] = 30
                    mem[_11671 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor12 / totalSupply:
                        _12027 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _12027 + 68] = mem[idx + _11671 + 32]
                            idx = idx + 32
                            continue 
                        mem[_12027 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _12027 + -mem[64] + 100
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 0, 17
                    _13502 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_13502] = 30
                    mem[_13502 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                        _14027 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _14027 + 68] = mem[idx + _13502 + 32]
                            idx = idx + 32
                            continue 
                        mem[_14027 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14027 + -mem[64] + 100
                    if arg1 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                        revert with 0, 17
                    _15714 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_15714] = 30
                    mem[_15714 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _marketingFee / 10000 * stor12 / totalSupply <= (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                        if (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                            revert with 0, 17
                        return ((arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) - (arg1 * _marketingFee / 10000 * stor12 / totalSupply))
                    _16186 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _16186 + 68] = mem[idx + _15714 + 32]
                        idx = idx + 32
                        continue 
                    mem[_16186 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _16186 + -mem[64] + 100
                if arg1 * _taxFee / 10000 and stor12 / totalSupply > -1 / arg1 * _taxFee / 10000:
                    revert with 0, 17
                if not arg1 * _taxFee / 10000:
                    revert with 0, 18
                if arg1 * _taxFee / 10000 * stor12 / totalSupply / arg1 * _taxFee / 10000 != stor12 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _liquidityFee / 10000:
                    if not arg1 * _marketingFee / 10000:
                        _10720 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10720] = 30
                        mem[_10720 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                            _10965 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _10965 + 68] = mem[idx + _10720 + 32]
                                idx = idx + 32
                                continue 
                            mem[_10965 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _10965 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                            revert with 0, 17
                        _12025 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12025] = 30
                        mem[_12025 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                            _12478 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12478 + 68] = mem[idx + _12025 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12478 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12478 + -mem[64] + 100
                        if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                            revert with 0, 17
                        _14025 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14025] = 30
                        mem[_14025 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                            if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                                revert with 0, 17
                            return ((arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply))
                        _14611 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _14611 + 68] = mem[idx + _14025 + 32]
                            idx = idx + 32
                            continue 
                        mem[_14611 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14611 + -mem[64] + 100
                    if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                        revert with 0, 17
                    if not arg1 * _marketingFee / 10000:
                        revert with 0, 18
                    if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _11670 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11670] = 30
                    mem[_11670 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                        _12024 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _12024 + 68] = mem[idx + _11670 + 32]
                            idx = idx + 32
                            continue 
                        mem[_12024 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _12024 + -mem[64] + 100
                    if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                        revert with 0, 17
                    _13500 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_13500] = 30
                    mem[_13500 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                        _14024 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _14024 + 68] = mem[idx + _13500 + 32]
                            idx = idx + 32
                            continue 
                        mem[_14024 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14024 + -mem[64] + 100
                    if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                        revert with 0, 17
                    _15712 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_15712] = 30
                    mem[_15712 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _marketingFee / 10000 * stor12 / totalSupply <= (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                        if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                            revert with 0, 17
                        return ((arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _marketingFee / 10000 * stor12 / totalSupply))
                    _16184 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _16184 + 68] = mem[idx + _15712 + 32]
                        idx = idx + 32
                        continue 
                    mem[_16184 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _16184 + -mem[64] + 100
                if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                    revert with 0, 17
                if not arg1 * _liquidityFee / 10000:
                    revert with 0, 18
                if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _marketingFee / 10000:
                    _11669 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11669] = 30
                    mem[_11669 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                        _12023 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _12023 + 68] = mem[idx + _11669 + 32]
                            idx = idx + 32
                            continue 
                        mem[_12023 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _12023 + -mem[64] + 100
                    if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                        revert with 0, 17
                    _13498 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_13498] = 30
                    mem[_13498 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                        _14023 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _14023 + 68] = mem[idx + _13498 + 32]
                            idx = idx + 32
                            continue 
                        mem[_14023 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14023 + -mem[64] + 100
                    if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                        revert with 0, 17
                    _15710 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_15710] = 30
                    mem[_15710 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                        if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < 0:
                            revert with 0, 17
                        return ((arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply))
                    _16183 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _16183 + 68] = mem[idx + _15710 + 32]
                        idx = idx + 32
                        continue 
                    mem[_16183 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _16183 + -mem[64] + 100
                if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                    revert with 0, 17
                if not arg1 * _marketingFee / 10000:
                    revert with 0, 18
                if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                _13025 = mem[64]
                mem[64] = mem[64] + 64
                mem[_13025] = 30
                mem[_13025 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                    _13497 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _13497 + 68] = mem[idx + _13025 + 32]
                        idx = idx + 32
                        continue 
                    mem[_13497 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _13497 + -mem[64] + 100
                if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                    revert with 0, 17
                _15155 = mem[64]
                mem[64] = mem[64] + 64
                mem[_15155] = 30
                mem[_15155 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                    _15709 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _15709 + 68] = mem[idx + _15155 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15709 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _15709 + -mem[64] + 100
                if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                    revert with 0, 17
                _16993 = mem[64]
                mem[64] = mem[64] + 64
                mem[_16993] = 30
                mem[_16993 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * _marketingFee / 10000 * stor12 / totalSupply <= (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                    if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                        revert with 0, 17
                    return ((arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) - (arg1 * _marketingFee / 10000 * stor12 / totalSupply))
                _17237 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _17237 + 68] = mem[idx + _16993 + 32]
                    idx = idx + 32
                    continue 
                mem[_17237 + 98] = 0
                revert with memory
                  from mem[64]
                   len _17237 + -mem[64] + 100
            if idx >= stor9.length:
                revert with 0, 50
            mem[0] = stor9[idx]
            mem[32] = 4
            if stor4[stor9[idx]] <= s:
                if idx >= stor9.length:
                    revert with 0, 50
                mem[0] = stor9[idx]
                mem[32] = 3
                _9324 = mem[64]
                mem[64] = mem[64] + 64
                mem[_9324] = 30
                mem[_9324 + 32] = 'SafeMath: subtraction overflow'
                if stor3[stor9[idx]] > t:
                    _9404 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _9404 + 68] = mem[idx + _9324 + 32]
                        idx = idx + 32
                        continue 
                    mem[_9404 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _9404 + -mem[64] + 100
                if t < stor3[stor9[idx]]:
                    revert with 0, 17
                if idx >= stor9.length:
                    revert with 0, 50
                mem[0] = stor9[idx]
                mem[32] = 4
                _9757 = mem[64]
                mem[64] = mem[64] + 64
                mem[_9757] = 30
                mem[_9757 + 32] = 'SafeMath: subtraction overflow'
                if stor4[stor9[idx]] <= s:
                    if s < stor4[stor9[idx]]:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s - stor4[stor9[idx]]
                    t = t - stor3[stor9[idx]]
                    continue 
                _9805 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _9805 + 68] = mem[idx + _9757 + 32]
                    idx = idx + 32
                    continue 
                mem[_9805 + 98] = 0
                revert with memory
                  from mem[64]
                   len _9805 + -mem[64] + 100
            _9325 = mem[64]
            mem[64] = mem[64] + 64
            mem[_9325] = 26
            mem[_9325 + 32] = 'SafeMath: division by zero'
            if not totalSupply:
                _9405 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _9405 + 68] = mem[idx + _9325 + 32]
                    idx = idx + 32
                    continue 
                mem[_9405 + 94] = 0
                revert with memory
                  from mem[64]
                   len _9405 + -mem[64] + 100
            if not arg1:
                if not arg1 * _taxFee / 10000:
                    if not arg1 * _liquidityFee / 10000:
                        if not arg1 * _marketingFee / 10000:
                            return 0
                        if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                            revert with 0, 17
                        if not arg1 * _marketingFee / 10000:
                            revert with 0, 18
                        if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _10405 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10405] = 30
                        mem[_10405 + 32] = 'SafeMath: subtraction overflow'
                        _11306 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11306] = 30
                        mem[_11306 + 32] = 'SafeMath: subtraction overflow'
                        _13043 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13043] = 30
                        mem[_13043 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _marketingFee / 10000 * stor12 / totalSupply <= 0:
                            if 0 < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                                revert with 0, 17
                            return (-1 * arg1 * _marketingFee / 10000 * stor12 / totalSupply)
                        _13511 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13511 + 68] = mem[idx + _13043 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13511 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13511 + -mem[64] + 100
                    if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                        revert with 0, 17
                    if not arg1 * _liquidityFee / 10000:
                        revert with 0, 18
                    if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _marketingFee / 10000:
                        _10404 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10404] = 30
                        mem[_10404 + 32] = 'SafeMath: subtraction overflow'
                        _11305 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11305] = 30
                        mem[_11305 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > 0:
                            _11678 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11678 + 68] = mem[idx + _11305 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11678 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11678 + -mem[64] + 100
                        if 0 < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                            revert with 0, 17
                        _13041 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13041] = 30
                        mem[_13041 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                            if -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply < 0:
                                revert with 0, 17
                            return (-1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply)
                        _13510 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13510 + 68] = mem[idx + _13041 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13510 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13510 + -mem[64] + 100
                    if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                        revert with 0, 17
                    if not arg1 * _marketingFee / 10000:
                        revert with 0, 18
                    if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _10982 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_10982] = 30
                    mem[_10982 + 32] = 'SafeMath: subtraction overflow'
                    _12505 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12505] = 30
                    mem[_12505 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > 0:
                        _13040 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13040 + 68] = mem[idx + _12505 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13040 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13040 + -mem[64] + 100
                    if 0 < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                        revert with 0, 17
                    _14635 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14635] = 30
                    mem[_14635 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _marketingFee / 10000 * stor12 / totalSupply <= -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                        if -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                            revert with 0, 17
                        return ((-1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply) - (arg1 * _marketingFee / 10000 * stor12 / totalSupply))
                    _15168 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _15168 + 68] = mem[idx + _14635 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15168 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _15168 + -mem[64] + 100
                if arg1 * _taxFee / 10000 and stor12 / totalSupply > -1 / arg1 * _taxFee / 10000:
                    revert with 0, 17
                if not arg1 * _taxFee / 10000:
                    revert with 0, 18
                if arg1 * _taxFee / 10000 * stor12 / totalSupply / arg1 * _taxFee / 10000 != stor12 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _liquidityFee / 10000:
                    if not arg1 * _marketingFee / 10000:
                        _10403 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10403] = 30
                        mem[_10403 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                            _10561 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _10561 + 68] = mem[idx + _10403 + 32]
                                idx = idx + 32
                                continue 
                            mem[_10561 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _10561 + -mem[64] + 100
                        if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                            revert with 0, 17
                        _11303 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11303] = 30
                        mem[_11303 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                            _11677 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11677 + 68] = mem[idx + _11303 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11677 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11677 + -mem[64] + 100
                        if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                            revert with 0, 17
                        _13038 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13038] = 30
                        mem[_13038 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                            if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                                revert with 0, 17
                            return (-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply)
                        _13509 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13509 + 68] = mem[idx + _13038 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13509 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13509 + -mem[64] + 100
                    if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                        revert with 0, 17
                    if not arg1 * _marketingFee / 10000:
                        revert with 0, 18
                    if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _10981 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_10981] = 30
                    mem[_10981 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                        _11302 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _11302 + 68] = mem[idx + _10981 + 32]
                            idx = idx + 32
                            continue 
                        mem[_11302 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _11302 + -mem[64] + 100
                    if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                        revert with 0, 17
                    _12503 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12503] = 30
                    mem[_12503 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                        _13037 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13037 + 68] = mem[idx + _12503 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13037 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13037 + -mem[64] + 100
                    if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                        revert with 0, 17
                    _14633 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14633] = 30
                    mem[_14633 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _marketingFee / 10000 * stor12 / totalSupply <= -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                        if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                            revert with 0, 17
                        return ((-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _marketingFee / 10000 * stor12 / totalSupply))
                    _15166 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _15166 + 68] = mem[idx + _14633 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15166 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _15166 + -mem[64] + 100
                if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                    revert with 0, 17
                if not arg1 * _liquidityFee / 10000:
                    revert with 0, 18
                if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _marketingFee / 10000:
                    _10980 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_10980] = 30
                    mem[_10980 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                        _11301 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _11301 + 68] = mem[idx + _10980 + 32]
                            idx = idx + 32
                            continue 
                        mem[_11301 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _11301 + -mem[64] + 100
                    if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                        revert with 0, 17
                    _12501 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12501] = 30
                    mem[_12501 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                        _13036 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13036 + 68] = mem[idx + _12501 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13036 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13036 + -mem[64] + 100
                    if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                        revert with 0, 17
                    _14631 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14631] = 30
                    mem[_14631 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                        if (-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < 0:
                            revert with 0, 17
                        return ((-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply))
                    _15165 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _15165 + 68] = mem[idx + _14631 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15165 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _15165 + -mem[64] + 100
                if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                    revert with 0, 17
                if not arg1 * _marketingFee / 10000:
                    revert with 0, 18
                if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                _12041 = mem[64]
                mem[64] = mem[64] + 64
                mem[_12041] = 30
                mem[_12041 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                    _12500 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _12500 + 68] = mem[idx + _12041 + 32]
                        idx = idx + 32
                        continue 
                    mem[_12500 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _12500 + -mem[64] + 100
                if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                    revert with 0, 17
                _14046 = mem[64]
                mem[64] = mem[64] + 64
                mem[_14046] = 30
                mem[_14046 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                    _14630 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _14630 + 68] = mem[idx + _14046 + 32]
                        idx = idx + 32
                        continue 
                    mem[_14630 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _14630 + -mem[64] + 100
                if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                    revert with 0, 17
                _16200 = mem[64]
                mem[64] = mem[64] + 64
                mem[_16200] = 30
                mem[_16200 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * _marketingFee / 10000 * stor12 / totalSupply <= (-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                    if (-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                        revert with 0, 17
                    return ((-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) - (arg1 * _marketingFee / 10000 * stor12 / totalSupply))
                _16577 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _16577 + 68] = mem[idx + _16200 + 32]
                    idx = idx + 32
                    continue 
                mem[_16577 + 98] = 0
                revert with memory
                  from mem[64]
                   len _16577 + -mem[64] + 100
            if arg1 and stor12 / totalSupply > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * stor12 / totalSupply / arg1 != stor12 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * _taxFee / 10000:
                if not arg1 * _liquidityFee / 10000:
                    if not arg1 * _marketingFee / 10000:
                        _10401 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10401] = 30
                        mem[_10401 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor12 / totalSupply:
                            _10560 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _10560 + 68] = mem[idx + _10401 + 32]
                                idx = idx + 32
                                continue 
                            mem[_10560 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _10560 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 0, 17
                        _11299 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11299] = 30
                        mem[_11299 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor12 / totalSupply:
                            _11675 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11675 + 68] = mem[idx + _11299 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11675 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11675 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 0, 17
                        _13034 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13034] = 30
                        mem[_13034 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= arg1 * stor12 / totalSupply:
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 0, 17
                            return (arg1 * stor12 / totalSupply)
                        _13508 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13508 + 68] = mem[idx + _13034 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13508 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13508 + -mem[64] + 100
                    if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                        revert with 0, 17
                    if not arg1 * _marketingFee / 10000:
                        revert with 0, 18
                    if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _10979 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_10979] = 30
                    mem[_10979 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor12 / totalSupply:
                        _11298 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _11298 + 68] = mem[idx + _10979 + 32]
                            idx = idx + 32
                            continue 
                        mem[_11298 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _11298 + -mem[64] + 100
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 0, 17
                    _12498 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12498] = 30
                    mem[_12498 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor12 / totalSupply:
                        _13033 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13033 + 68] = mem[idx + _12498 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13033 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13033 + -mem[64] + 100
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 0, 17
                    _14628 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14628] = 30
                    mem[_14628 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _marketingFee / 10000 * stor12 / totalSupply <= arg1 * stor12 / totalSupply:
                        if arg1 * stor12 / totalSupply < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                            revert with 0, 17
                        return ((arg1 * stor12 / totalSupply) - (arg1 * _marketingFee / 10000 * stor12 / totalSupply))
                    _15163 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _15163 + 68] = mem[idx + _14628 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15163 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _15163 + -mem[64] + 100
                if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                    revert with 0, 17
                if not arg1 * _liquidityFee / 10000:
                    revert with 0, 18
                if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _marketingFee / 10000:
                    _10978 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_10978] = 30
                    mem[_10978 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor12 / totalSupply:
                        _11297 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _11297 + 68] = mem[idx + _10978 + 32]
                            idx = idx + 32
                            continue 
                        mem[_11297 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _11297 + -mem[64] + 100
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 0, 17
                    _12496 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12496] = 30
                    mem[_12496 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                        _13032 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13032 + 68] = mem[idx + _12496 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13032 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13032 + -mem[64] + 100
                    if arg1 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                        revert with 0, 17
                    _14626 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14626] = 30
                    mem[_14626 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                        if (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < 0:
                            revert with 0, 17
                        return ((arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply))
                    _15162 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _15162 + 68] = mem[idx + _14626 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15162 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _15162 + -mem[64] + 100
                if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                    revert with 0, 17
                if not arg1 * _marketingFee / 10000:
                    revert with 0, 18
                if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                _12040 = mem[64]
                mem[64] = mem[64] + 64
                mem[_12040] = 30
                mem[_12040 + 32] = 'SafeMath: subtraction overflow'
                if 0 > arg1 * stor12 / totalSupply:
                    _12495 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _12495 + 68] = mem[idx + _12040 + 32]
                        idx = idx + 32
                        continue 
                    mem[_12495 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _12495 + -mem[64] + 100
                if arg1 * stor12 / totalSupply < 0:
                    revert with 0, 17
                _14044 = mem[64]
                mem[64] = mem[64] + 64
                mem[_14044] = 30
                mem[_14044 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                    _14625 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _14625 + 68] = mem[idx + _14044 + 32]
                        idx = idx + 32
                        continue 
                    mem[_14625 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _14625 + -mem[64] + 100
                if arg1 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                    revert with 0, 17
                _16198 = mem[64]
                mem[64] = mem[64] + 64
                mem[_16198] = 30
                mem[_16198 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * _marketingFee / 10000 * stor12 / totalSupply <= (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                    if (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                        revert with 0, 17
                    return ((arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) - (arg1 * _marketingFee / 10000 * stor12 / totalSupply))
                _16574 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _16574 + 68] = mem[idx + _16198 + 32]
                    idx = idx + 32
                    continue 
                mem[_16574 + 98] = 0
                revert with memory
                  from mem[64]
                   len _16574 + -mem[64] + 100
            if arg1 * _taxFee / 10000 and stor12 / totalSupply > -1 / arg1 * _taxFee / 10000:
                revert with 0, 17
            if not arg1 * _taxFee / 10000:
                revert with 0, 18
            if arg1 * _taxFee / 10000 * stor12 / totalSupply / arg1 * _taxFee / 10000 != stor12 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * _liquidityFee / 10000:
                if not arg1 * _marketingFee / 10000:
                    _10977 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_10977] = 30
                    mem[_10977 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                        _11296 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _11296 + 68] = mem[idx + _10977 + 32]
                            idx = idx + 32
                            continue 
                        mem[_11296 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _11296 + -mem[64] + 100
                    if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                        revert with 0, 17
                    _12493 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12493] = 30
                    mem[_12493 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                        _13031 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13031 + 68] = mem[idx + _12493 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13031 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13031 + -mem[64] + 100
                    if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                        revert with 0, 17
                    _14623 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14623] = 30
                    mem[_14623 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                        if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                            revert with 0, 17
                        return ((arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply))
                    _15161 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _15161 + 68] = mem[idx + _14623 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15161 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _15161 + -mem[64] + 100
                if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                    revert with 0, 17
                if not arg1 * _marketingFee / 10000:
                    revert with 0, 18
                if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                _12039 = mem[64]
                mem[64] = mem[64] + 64
                mem[_12039] = 30
                mem[_12039 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                    _12492 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _12492 + 68] = mem[idx + _12039 + 32]
                        idx = idx + 32
                        continue 
                    mem[_12492 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _12492 + -mem[64] + 100
                if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                    revert with 0, 17
                _14042 = mem[64]
                mem[64] = mem[64] + 64
                mem[_14042] = 30
                mem[_14042 + 32] = 'SafeMath: subtraction overflow'
                if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                    _14622 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _14622 + 68] = mem[idx + _14042 + 32]
                        idx = idx + 32
                        continue 
                    mem[_14622 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _14622 + -mem[64] + 100
                if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                    revert with 0, 17
                _16196 = mem[64]
                mem[64] = mem[64] + 64
                mem[_16196] = 30
                mem[_16196 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * _marketingFee / 10000 * stor12 / totalSupply <= (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                    if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                        revert with 0, 17
                    return ((arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _marketingFee / 10000 * stor12 / totalSupply))
                _16572 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _16572 + 68] = mem[idx + _16196 + 32]
                    idx = idx + 32
                    continue 
                mem[_16572 + 98] = 0
                revert with memory
                  from mem[64]
                   len _16572 + -mem[64] + 100
            if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                revert with 0, 17
            if not arg1 * _liquidityFee / 10000:
                revert with 0, 18
            if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * _marketingFee / 10000:
                _12038 = mem[64]
                mem[64] = mem[64] + 64
                mem[_12038] = 30
                mem[_12038 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                    _12491 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _12491 + 68] = mem[idx + _12038 + 32]
                        idx = idx + 32
                        continue 
                    mem[_12491 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _12491 + -mem[64] + 100
                if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                    revert with 0, 17
                _14040 = mem[64]
                mem[64] = mem[64] + 64
                mem[_14040] = 30
                mem[_14040 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                    _14621 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _14621 + 68] = mem[idx + _14040 + 32]
                        idx = idx + 32
                        continue 
                    mem[_14621 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _14621 + -mem[64] + 100
                if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                    revert with 0, 17
                _16194 = mem[64]
                mem[64] = mem[64] + 64
                mem[_16194] = 30
                mem[_16194 + 32] = 'SafeMath: subtraction overflow'
                if 0 <= (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                    if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < 0:
                        revert with 0, 17
                    return ((arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply))
                _16571 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _16571 + 68] = mem[idx + _16194 + 32]
                    idx = idx + 32
                    continue 
                mem[_16571 + 98] = 0
                revert with memory
                  from mem[64]
                   len _16571 + -mem[64] + 100
            if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                revert with 0, 17
            if not arg1 * _marketingFee / 10000:
                revert with 0, 18
            if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            _13507 = mem[64]
            mem[64] = mem[64] + 64
            mem[_13507] = 30
            mem[_13507 + 32] = 'SafeMath: subtraction overflow'
            if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                _14039 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _14039 + 68] = mem[idx + _13507 + 32]
                    idx = idx + 32
                    continue 
                mem[_14039 + 98] = 0
                revert with memory
                  from mem[64]
                   len _14039 + -mem[64] + 100
            if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                revert with 0, 17
            _15718 = mem[64]
            mem[64] = mem[64] + 64
            mem[_15718] = 30
            mem[_15718 + 32] = 'SafeMath: subtraction overflow'
            if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                _16193 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _16193 + 68] = mem[idx + _15718 + 32]
                    idx = idx + 32
                    continue 
                mem[_16193 + 98] = 0
                revert with memory
                  from mem[64]
                   len _16193 + -mem[64] + 100
            if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                revert with 0, 17
            _17242 = mem[64]
            mem[64] = mem[64] + 64
            mem[_17242] = 30
            mem[_17242 + 32] = 'SafeMath: subtraction overflow'
            if arg1 * _marketingFee / 10000 * stor12 / totalSupply <= (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                    revert with 0, 17
                return ((arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) - (arg1 * _marketingFee / 10000 * stor12 / totalSupply))
            _17401 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[idx + _17401 + 68] = mem[idx + _17242 + 32]
                idx = idx + 32
                continue 
            mem[_17401 + 98] = 0
            revert with memory
              from mem[64]
               len _17401 + -mem[64] + 100
        if not totalSupply:
            revert with 0, 'SafeMath: division by zero', 0
        if t >= stor12 / totalSupply:
            if not s:
                revert with 0, 'SafeMath: division by zero', 0
            if not arg1:
                if not arg1 * _taxFee / 10000:
                    if not arg1 * _liquidityFee / 10000:
                        if not arg1 * _marketingFee / 10000:
                            return 0
                        if arg1 * _marketingFee / 10000 and t / s > -1 / arg1 * _marketingFee / 10000:
                            revert with 0, 17
                        if not arg1 * _marketingFee / 10000:
                            revert with 0, 18
                        if arg1 * _marketingFee / 10000 * t / s / arg1 * _marketingFee / 10000 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * _marketingFee / 10000 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * _marketingFee / 10000 * t / s:
                            revert with 0, 17
                        return (-1 * arg1 * _marketingFee / 10000 * t / s)
                    if arg1 * _liquidityFee / 10000 and t / s > -1 / arg1 * _liquidityFee / 10000:
                        revert with 0, 17
                    if not arg1 * _liquidityFee / 10000:
                        revert with 0, 18
                    if arg1 * _liquidityFee / 10000 * t / s / arg1 * _liquidityFee / 10000 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _marketingFee / 10000:
                        if arg1 * _liquidityFee / 10000 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * _liquidityFee / 10000 * t / s:
                            revert with 0, 17
                        if 0 > -1 * arg1 * _liquidityFee / 10000 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _liquidityFee / 10000 * t / s < 0:
                            revert with 0, 17
                        return (-1 * arg1 * _liquidityFee / 10000 * t / s)
                    if arg1 * _marketingFee / 10000 and t / s > -1 / arg1 * _marketingFee / 10000:
                        revert with 0, 17
                    if not arg1 * _marketingFee / 10000:
                        revert with 0, 18
                    if arg1 * _marketingFee / 10000 * t / s / arg1 * _marketingFee / 10000 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * _liquidityFee / 10000 * t / s > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * _liquidityFee / 10000 * t / s:
                        revert with 0, 17
                    if arg1 * _marketingFee / 10000 * t / s > -1 * arg1 * _liquidityFee / 10000 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _liquidityFee / 10000 * t / s < arg1 * _marketingFee / 10000 * t / s:
                        revert with 0, 17
                    return ((-1 * arg1 * _liquidityFee / 10000 * t / s) - (arg1 * _marketingFee / 10000 * t / s))
                if arg1 * _taxFee / 10000 and t / s > -1 / arg1 * _taxFee / 10000:
                    revert with 0, 17
                if not arg1 * _taxFee / 10000:
                    revert with 0, 18
                if arg1 * _taxFee / 10000 * t / s / arg1 * _taxFee / 10000 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _liquidityFee / 10000:
                    if not arg1 * _marketingFee / 10000:
                        if arg1 * _taxFee / 10000 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * _taxFee / 10000 * t / s:
                            revert with 0, 17
                        if 0 > -1 * arg1 * _taxFee / 10000 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _taxFee / 10000 * t / s < 0:
                            revert with 0, 17
                        if 0 > -1 * arg1 * _taxFee / 10000 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _taxFee / 10000 * t / s < 0:
                            revert with 0, 17
                        return (-1 * arg1 * _taxFee / 10000 * t / s)
                    if arg1 * _marketingFee / 10000 and t / s > -1 / arg1 * _marketingFee / 10000:
                        revert with 0, 17
                    if not arg1 * _marketingFee / 10000:
                        revert with 0, 18
                    if arg1 * _marketingFee / 10000 * t / s / arg1 * _marketingFee / 10000 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * _taxFee / 10000 * t / s > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * _taxFee / 10000 * t / s:
                        revert with 0, 17
                    if 0 > -1 * arg1 * _taxFee / 10000 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _taxFee / 10000 * t / s < 0:
                        revert with 0, 17
                    if arg1 * _marketingFee / 10000 * t / s > -1 * arg1 * _taxFee / 10000 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _taxFee / 10000 * t / s < arg1 * _marketingFee / 10000 * t / s:
                        revert with 0, 17
                    return ((-1 * arg1 * _taxFee / 10000 * t / s) - (arg1 * _marketingFee / 10000 * t / s))
                if arg1 * _liquidityFee / 10000 and t / s > -1 / arg1 * _liquidityFee / 10000:
                    revert with 0, 17
                if not arg1 * _liquidityFee / 10000:
                    revert with 0, 18
                if arg1 * _liquidityFee / 10000 * t / s / arg1 * _liquidityFee / 10000 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _marketingFee / 10000:
                    if arg1 * _taxFee / 10000 * t / s > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * _taxFee / 10000 * t / s:
                        revert with 0, 17
                    if arg1 * _liquidityFee / 10000 * t / s > -1 * arg1 * _taxFee / 10000 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _taxFee / 10000 * t / s < arg1 * _liquidityFee / 10000 * t / s:
                        revert with 0, 17
                    if 0 > (-1 * arg1 * _taxFee / 10000 * t / s) - (arg1 * _liquidityFee / 10000 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (-1 * arg1 * _taxFee / 10000 * t / s) - (arg1 * _liquidityFee / 10000 * t / s) < 0:
                        revert with 0, 17
                    return ((-1 * arg1 * _taxFee / 10000 * t / s) - (arg1 * _liquidityFee / 10000 * t / s))
                if arg1 * _marketingFee / 10000 and t / s > -1 / arg1 * _marketingFee / 10000:
                    revert with 0, 17
                if not arg1 * _marketingFee / 10000:
                    revert with 0, 18
                if arg1 * _marketingFee / 10000 * t / s / arg1 * _marketingFee / 10000 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg1 * _taxFee / 10000 * t / s > 0:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if 0 < arg1 * _taxFee / 10000 * t / s:
                    revert with 0, 17
                if arg1 * _liquidityFee / 10000 * t / s > -1 * arg1 * _taxFee / 10000 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if -1 * arg1 * _taxFee / 10000 * t / s < arg1 * _liquidityFee / 10000 * t / s:
                    revert with 0, 17
                if arg1 * _marketingFee / 10000 * t / s > (-1 * arg1 * _taxFee / 10000 * t / s) - (arg1 * _liquidityFee / 10000 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (-1 * arg1 * _taxFee / 10000 * t / s) - (arg1 * _liquidityFee / 10000 * t / s) < arg1 * _marketingFee / 10000 * t / s:
                    revert with 0, 17
                return ((-1 * arg1 * _taxFee / 10000 * t / s) - (arg1 * _liquidityFee / 10000 * t / s) - (arg1 * _marketingFee / 10000 * t / s))
            if arg1 and t / s > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * t / s / arg1 != t / s:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * _taxFee / 10000:
                if not arg1 * _liquidityFee / 10000:
                    if not arg1 * _marketingFee / 10000:
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        return (arg1 * t / s)
                    if arg1 * _marketingFee / 10000 and t / s > -1 / arg1 * _marketingFee / 10000:
                        revert with 0, 17
                    if not arg1 * _marketingFee / 10000:
                        revert with 0, 18
                    if arg1 * _marketingFee / 10000 * t / s / arg1 * _marketingFee / 10000 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 0, 17
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 0, 17
                    if arg1 * _marketingFee / 10000 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * _marketingFee / 10000 * t / s:
                        revert with 0, 17
                    return ((arg1 * t / s) - (arg1 * _marketingFee / 10000 * t / s))
                if arg1 * _liquidityFee / 10000 and t / s > -1 / arg1 * _liquidityFee / 10000:
                    revert with 0, 17
                if not arg1 * _liquidityFee / 10000:
                    revert with 0, 18
                if arg1 * _liquidityFee / 10000 * t / s / arg1 * _liquidityFee / 10000 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _marketingFee / 10000:
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 0, 17
                    if arg1 * _liquidityFee / 10000 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * _liquidityFee / 10000 * t / s:
                        revert with 0, 17
                    if 0 > (arg1 * t / s) - (arg1 * _liquidityFee / 10000 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * _liquidityFee / 10000 * t / s) < 0:
                        revert with 0, 17
                    return ((arg1 * t / s) - (arg1 * _liquidityFee / 10000 * t / s))
                if arg1 * _marketingFee / 10000 and t / s > -1 / arg1 * _marketingFee / 10000:
                    revert with 0, 17
                if not arg1 * _marketingFee / 10000:
                    revert with 0, 18
                if arg1 * _marketingFee / 10000 * t / s / arg1 * _marketingFee / 10000 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 0 > arg1 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * t / s < 0:
                    revert with 0, 17
                if arg1 * _liquidityFee / 10000 * t / s > arg1 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * t / s < arg1 * _liquidityFee / 10000 * t / s:
                    revert with 0, 17
                if arg1 * _marketingFee / 10000 * t / s > (arg1 * t / s) - (arg1 * _liquidityFee / 10000 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * t / s) - (arg1 * _liquidityFee / 10000 * t / s) < arg1 * _marketingFee / 10000 * t / s:
                    revert with 0, 17
                return ((arg1 * t / s) - (arg1 * _liquidityFee / 10000 * t / s) - (arg1 * _marketingFee / 10000 * t / s))
            if arg1 * _taxFee / 10000 and t / s > -1 / arg1 * _taxFee / 10000:
                revert with 0, 17
            if not arg1 * _taxFee / 10000:
                revert with 0, 18
            if arg1 * _taxFee / 10000 * t / s / arg1 * _taxFee / 10000 != t / s:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * _liquidityFee / 10000:
                if not arg1 * _marketingFee / 10000:
                    if arg1 * _taxFee / 10000 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * _taxFee / 10000 * t / s:
                        revert with 0, 17
                    if 0 > (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s) < 0:
                        revert with 0, 17
                    if 0 > (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s) < 0:
                        revert with 0, 17
                    return ((arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s))
                if arg1 * _marketingFee / 10000 and t / s > -1 / arg1 * _marketingFee / 10000:
                    revert with 0, 17
                if not arg1 * _marketingFee / 10000:
                    revert with 0, 18
                if arg1 * _marketingFee / 10000 * t / s / arg1 * _marketingFee / 10000 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg1 * _taxFee / 10000 * t / s > arg1 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * t / s < arg1 * _taxFee / 10000 * t / s:
                    revert with 0, 17
                if 0 > (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s) < 0:
                    revert with 0, 17
                if arg1 * _marketingFee / 10000 * t / s > (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s) < arg1 * _marketingFee / 10000 * t / s:
                    revert with 0, 17
                return ((arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s) - (arg1 * _marketingFee / 10000 * t / s))
            if arg1 * _liquidityFee / 10000 and t / s > -1 / arg1 * _liquidityFee / 10000:
                revert with 0, 17
            if not arg1 * _liquidityFee / 10000:
                revert with 0, 18
            if arg1 * _liquidityFee / 10000 * t / s / arg1 * _liquidityFee / 10000 != t / s:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * _marketingFee / 10000:
                if arg1 * _taxFee / 10000 * t / s > arg1 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * t / s < arg1 * _taxFee / 10000 * t / s:
                    revert with 0, 17
                if arg1 * _liquidityFee / 10000 * t / s > (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s) < arg1 * _liquidityFee / 10000 * t / s:
                    revert with 0, 17
                if 0 > (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s) - (arg1 * _liquidityFee / 10000 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s) - (arg1 * _liquidityFee / 10000 * t / s) < 0:
                    revert with 0, 17
                return ((arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s) - (arg1 * _liquidityFee / 10000 * t / s))
            if arg1 * _marketingFee / 10000 and t / s > -1 / arg1 * _marketingFee / 10000:
                revert with 0, 17
            if not arg1 * _marketingFee / 10000:
                revert with 0, 18
            if arg1 * _marketingFee / 10000 * t / s / arg1 * _marketingFee / 10000 != t / s:
                revert with 0, 'SafeMath: multiplication overflow'
            if arg1 * _taxFee / 10000 * t / s > arg1 * t / s:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * t / s < arg1 * _taxFee / 10000 * t / s:
                revert with 0, 17
            if arg1 * _liquidityFee / 10000 * t / s > (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s) < arg1 * _liquidityFee / 10000 * t / s:
                revert with 0, 17
            if arg1 * _marketingFee / 10000 * t / s > (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s) - (arg1 * _liquidityFee / 10000 * t / s):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s) - (arg1 * _liquidityFee / 10000 * t / s) < arg1 * _marketingFee / 10000 * t / s:
                revert with 0, 17
            return ((arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s) - (arg1 * _liquidityFee / 10000 * t / s) - (arg1 * _marketingFee / 10000 * t / s))
        if not totalSupply:
            revert with 0, 'SafeMath: division by zero', 0
        if not arg1:
            if not arg1 * _taxFee / 10000:
                if not arg1 * _liquidityFee / 10000:
                    if not arg1 * _marketingFee / 10000:
                        return 0
                    if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                        revert with 0, 17
                    if not arg1 * _marketingFee / 10000:
                        revert with 0, 18
                    if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * _marketingFee / 10000 * stor12 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                        revert with 0, 17
                    return (-1 * arg1 * _marketingFee / 10000 * stor12 / totalSupply)
                if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                    revert with 0, 17
                if not arg1 * _liquidityFee / 10000:
                    revert with 0, 18
                if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _marketingFee / 10000:
                    if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                        revert with 0, 17
                    if 0 > -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply < 0:
                        revert with 0, 17
                    return (-1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply)
                if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                    revert with 0, 17
                if not arg1 * _marketingFee / 10000:
                    revert with 0, 18
                if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > 0:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if 0 < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                    revert with 0, 17
                if arg1 * _marketingFee / 10000 * stor12 / totalSupply > -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                    revert with 0, 17
                return ((-1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply) - (arg1 * _marketingFee / 10000 * stor12 / totalSupply))
            if arg1 * _taxFee / 10000 and stor12 / totalSupply > -1 / arg1 * _taxFee / 10000:
                revert with 0, 17
            if not arg1 * _taxFee / 10000:
                revert with 0, 18
            if arg1 * _taxFee / 10000 * stor12 / totalSupply / arg1 * _taxFee / 10000 != stor12 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * _liquidityFee / 10000:
                if not arg1 * _marketingFee / 10000:
                    if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                        revert with 0, 17
                    if 0 > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                        revert with 0, 17
                    return (-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply)
                if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                    revert with 0, 17
                if not arg1 * _marketingFee / 10000:
                    revert with 0, 18
                if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                    revert with 0, 17
                if 0 > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                    revert with 0, 17
                if arg1 * _marketingFee / 10000 * stor12 / totalSupply > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                    revert with 0, 17
                return ((-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _marketingFee / 10000 * stor12 / totalSupply))
            if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                revert with 0, 17
            if not arg1 * _liquidityFee / 10000:
                revert with 0, 18
            if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * _marketingFee / 10000:
                if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                    revert with 0, 17
                if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                    revert with 0, 17
                if 0 > (-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < 0:
                    revert with 0, 17
                return ((-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply))
            if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                revert with 0, 17
            if not arg1 * _marketingFee / 10000:
                revert with 0, 18
            if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                revert with 0, 17
            if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                revert with 0, 17
            if arg1 * _marketingFee / 10000 * stor12 / totalSupply > (-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                revert with 0, 17
            return ((-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) - (arg1 * _marketingFee / 10000 * stor12 / totalSupply))
        if arg1 and stor12 / totalSupply > -1 / arg1:
            revert with 0, 17
        if not arg1:
            revert with 0, 18
        if arg1 * stor12 / totalSupply / arg1 != stor12 / totalSupply:
            revert with 0, 'SafeMath: multiplication overflow'
        if not arg1 * _taxFee / 10000:
            if not arg1 * _liquidityFee / 10000:
                if not arg1 * _marketingFee / 10000:
                    if 0 > arg1 * stor12 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor12 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor12 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 0, 17
                    return (arg1 * stor12 / totalSupply)
                if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                    revert with 0, 17
                if not arg1 * _marketingFee / 10000:
                    revert with 0, 18
                if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 0 > arg1 * stor12 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor12 / totalSupply < 0:
                    revert with 0, 17
                if 0 > arg1 * stor12 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor12 / totalSupply < 0:
                    revert with 0, 17
                if arg1 * _marketingFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor12 / totalSupply < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                    revert with 0, 17
                return ((arg1 * stor12 / totalSupply) - (arg1 * _marketingFee / 10000 * stor12 / totalSupply))
            if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                revert with 0, 17
            if not arg1 * _liquidityFee / 10000:
                revert with 0, 18
            if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * _marketingFee / 10000:
                if 0 > arg1 * stor12 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor12 / totalSupply < 0:
                    revert with 0, 17
                if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                    revert with 0, 17
                if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < 0:
                    revert with 0, 17
                return ((arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply))
            if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                revert with 0, 17
            if not arg1 * _marketingFee / 10000:
                revert with 0, 18
            if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if 0 > arg1 * stor12 / totalSupply:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * stor12 / totalSupply < 0:
                revert with 0, 17
            if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                revert with 0, 17
            if arg1 * _marketingFee / 10000 * stor12 / totalSupply > (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                revert with 0, 17
            return ((arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) - (arg1 * _marketingFee / 10000 * stor12 / totalSupply))
        if arg1 * _taxFee / 10000 and stor12 / totalSupply > -1 / arg1 * _taxFee / 10000:
            revert with 0, 17
        if not arg1 * _taxFee / 10000:
            revert with 0, 18
        if arg1 * _taxFee / 10000 * stor12 / totalSupply / arg1 * _taxFee / 10000 != stor12 / totalSupply:
            revert with 0, 'SafeMath: multiplication overflow'
        if not arg1 * _liquidityFee / 10000:
            if not arg1 * _marketingFee / 10000:
                if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                    revert with 0, 17
                if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                    revert with 0, 17
                if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                    revert with 0, 17
                return ((arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply))
            if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                revert with 0, 17
            if not arg1 * _marketingFee / 10000:
                revert with 0, 18
            if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                revert with 0, 17
            if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                revert with 0, 17
            if arg1 * _marketingFee / 10000 * stor12 / totalSupply > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                revert with 0, 17
            return ((arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _marketingFee / 10000 * stor12 / totalSupply))
        if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
            revert with 0, 17
        if not arg1 * _liquidityFee / 10000:
            revert with 0, 18
        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
            revert with 0, 'SafeMath: multiplication overflow'
        if not arg1 * _marketingFee / 10000:
            if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                revert with 0, 17
            if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                revert with 0, 17
            if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < 0:
                revert with 0, 17
            return ((arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply))
        if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
            revert with 0, 17
        if not arg1 * _marketingFee / 10000:
            revert with 0, 18
        if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
            revert with 0, 'SafeMath: multiplication overflow'
        if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
            revert with 0, 17
        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
            revert with 0, 'SafeMath: subtraction overflow', 0
        if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
            revert with 0, 17
        if arg1 * _marketingFee / 10000 * stor12 / totalSupply > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
            revert with 0, 'SafeMath: subtraction overflow', 0
        if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
            revert with 0, 17
        return ((arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) - (arg1 * _marketingFee / 10000 * stor12 / totalSupply))
    if not arg1:
        mem[96] = 26
        mem[128] = 'SafeMath: division by zero'
        if not arg1:
            mem[160] = 26
            mem[192] = 'SafeMath: division by zero'
            if not arg1:
                mem[224] = 26
                mem[256] = 'SafeMath: division by zero'
                mem[288] = 30
                mem[320] = 'SafeMath: subtraction overflow'
                if 0 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < 0:
                    revert with 0, 17
                mem[352] = 30
                mem[384] = 'SafeMath: subtraction overflow'
                if 0 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < 0:
                    revert with 0, 17
                mem[64] = 480
                mem[416] = 30
                mem[448] = 'SafeMath: subtraction overflow'
                if 0 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < 0:
                    revert with 0, 17
                idx = 0
                s = totalSupply
                t = stor12
                while idx < stor9.length:
                    mem[0] = stor9[idx]
                    mem[32] = 3
                    if stor3[stor9[idx]] > t:
                        _9274 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9274] = 26
                        mem[_9274 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _9368 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _9368 + 68] = mem[idx + _9274 + 32]
                                idx = idx + 32
                                continue 
                            mem[_9368 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _9368 + -mem[64] + 100
                        if not arg1:
                            return 0
                        if arg1 and stor12 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor12 / totalSupply / arg1 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _10358 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10358] = 30
                        mem[_10358 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor12 / totalSupply:
                            _10500 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _10500 + 68] = mem[idx + _10358 + 32]
                                idx = idx + 32
                                continue 
                            mem[_10500 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _10500 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 0, 17
                        _11173 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11173] = 30
                        mem[_11173 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor12 / totalSupply:
                            _11465 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11465 + 68] = mem[idx + _11173 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11465 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11465 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 0, 17
                        _12769 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12769] = 30
                        mem[_12769 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= arg1 * stor12 / totalSupply:
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 0, 17
                            return (arg1 * stor12 / totalSupply)
                        _13194 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13194 + 68] = mem[idx + _12769 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13194 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13194 + -mem[64] + 100
                    if idx >= stor9.length:
                        revert with 0, 50
                    mem[0] = stor9[idx]
                    mem[32] = 4
                    if stor4[stor9[idx]] <= s:
                        if idx >= stor9.length:
                            revert with 0, 50
                        mem[0] = stor9[idx]
                        mem[32] = 3
                        _9369 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9369] = 30
                        mem[_9369 + 32] = 'SafeMath: subtraction overflow'
                        if stor3[stor9[idx]] > t:
                            _9449 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _9449 + 68] = mem[idx + _9369 + 32]
                                idx = idx + 32
                                continue 
                            mem[_9449 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _9449 + -mem[64] + 100
                        if t < stor3[stor9[idx]]:
                            revert with 0, 17
                        if idx >= stor9.length:
                            revert with 0, 50
                        mem[0] = stor9[idx]
                        mem[32] = 4
                        _9802 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9802] = 30
                        mem[_9802 + 32] = 'SafeMath: subtraction overflow'
                        if stor4[stor9[idx]] <= s:
                            if s < stor4[stor9[idx]]:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s - stor4[stor9[idx]]
                            t = t - stor3[stor9[idx]]
                            continue 
                        _9850 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _9850 + 68] = mem[idx + _9802 + 32]
                            idx = idx + 32
                            continue 
                        mem[_9850 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _9850 + -mem[64] + 100
                    _9370 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9370] = 26
                    mem[_9370 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _9450 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _9450 + 68] = mem[idx + _9370 + 32]
                            idx = idx + 32
                            continue 
                        mem[_9450 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _9450 + -mem[64] + 100
                    if not arg1:
                        return 0
                    if arg1 and stor12 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor12 / totalSupply / arg1 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _10502 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_10502] = 30
                    mem[_10502 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor12 / totalSupply:
                        _10625 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _10625 + 68] = mem[idx + _10502 + 32]
                            idx = idx + 32
                            continue 
                        mem[_10625 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _10625 + -mem[64] + 100
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 0, 17
                    _11467 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11467] = 30
                    mem[_11467 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor12 / totalSupply:
                        _11805 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _11805 + 68] = mem[idx + _11467 + 32]
                            idx = idx + 32
                            continue 
                        mem[_11805 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _11805 + -mem[64] + 100
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 0, 17
                    _13195 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_13195] = 30
                    mem[_13195 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= arg1 * stor12 / totalSupply:
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 0, 17
                        return (arg1 * stor12 / totalSupply)
                    _13718 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _13718 + 68] = mem[idx + _13195 + 32]
                        idx = idx + 32
                        continue 
                    mem[_13718 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _13718 + -mem[64] + 100
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if t >= stor12 / totalSupply:
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg1:
                        return 0
                    if arg1 and t / s > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 0, 17
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 0, 17
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 0, 17
                    return (arg1 * t / s)
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    return 0
                if arg1 and stor12 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor12 / totalSupply / arg1 != stor12 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 0 > arg1 * stor12 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor12 / totalSupply < 0:
                    revert with 0, 17
                if 0 > arg1 * stor12 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor12 / totalSupply < 0:
                    revert with 0, 17
                if 0 > arg1 * stor12 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor12 / totalSupply < 0:
                    revert with 0, 17
            else:
                if arg1 and _marketingFee > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * _marketingFee / arg1 != _marketingFee:
                    revert with 0, 'SafeMath: multiplication overflow'
                mem[224] = 26
                mem[256] = 'SafeMath: division by zero'
                mem[288] = 30
                mem[320] = 'SafeMath: subtraction overflow'
                if 0 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < 0:
                    revert with 0, 17
                mem[352] = 30
                mem[384] = 'SafeMath: subtraction overflow'
                if 0 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < 0:
                    revert with 0, 17
                mem[64] = 480
                mem[416] = 30
                mem[448] = 'SafeMath: subtraction overflow'
                if arg1 * _marketingFee / 10000 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < arg1 * _marketingFee / 10000:
                    revert with 0, 17
                idx = 0
                s = totalSupply
                t = stor12
                while idx < stor9.length:
                    mem[0] = stor9[idx]
                    mem[32] = 3
                    if stor3[stor9[idx]] > t:
                        _9273 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9273] = 26
                        mem[_9273 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _9365 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _9365 + 68] = mem[idx + _9273 + 32]
                                idx = idx + 32
                                continue 
                            mem[_9365 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _9365 + -mem[64] + 100
                        if not arg1:
                            if not arg1 * _marketingFee / 10000:
                                return 0
                            if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                                revert with 0, 17
                            if not arg1 * _marketingFee / 10000:
                                revert with 0, 18
                            if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _10354 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10354] = 30
                            mem[_10354 + 32] = 'SafeMath: subtraction overflow'
                            _11167 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11167] = 30
                            mem[_11167 + 32] = 'SafeMath: subtraction overflow'
                            _12762 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12762] = 30
                            mem[_12762 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _marketingFee / 10000 * stor12 / totalSupply <= 0:
                                if 0 < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _13189 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13189 + 68] = mem[idx + _12762 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13189 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13189 + -mem[64] + 100
                        if arg1 and stor12 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor12 / totalSupply / arg1 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _marketingFee / 10000:
                            _10353 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10353] = 30
                            mem[_10353 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor12 / totalSupply:
                                _10496 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _10496 + 68] = mem[idx + _10353 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_10496 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _10496 + -mem[64] + 100
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 0, 17
                            _11165 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11165] = 30
                            mem[_11165 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor12 / totalSupply:
                                _11459 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11459 + 68] = mem[idx + _11165 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11459 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11459 + -mem[64] + 100
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 0, 17
                            _12760 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12760] = 30
                            mem[_12760 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor12 / totalSupply:
                                if arg1 * stor12 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor12 / totalSupply)
                            _13188 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13188 + 68] = mem[idx + _12760 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13188 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13188 + -mem[64] + 100
                        if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                            revert with 0, 17
                        if not arg1 * _marketingFee / 10000:
                            revert with 0, 18
                        if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _10863 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10863] = 30
                        mem[_10863 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor12 / totalSupply:
                            _11164 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11164 + 68] = mem[idx + _10863 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11164 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11164 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 0, 17
                        _12283 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12283] = 30
                        mem[_12283 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor12 / totalSupply:
                            _12759 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12759 + 68] = mem[idx + _12283 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12759 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12759 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 0, 17
                        _14339 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14339] = 30
                        mem[_14339 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _marketingFee / 10000 * stor12 / totalSupply <= arg1 * stor12 / totalSupply:
                            if arg1 * stor12 / totalSupply < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor12 / totalSupply)
                        _14839 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _14839 + 68] = mem[idx + _14339 + 32]
                            idx = idx + 32
                            continue 
                        mem[_14839 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14839 + -mem[64] + 100
                    if idx >= stor9.length:
                        revert with 0, 50
                    mem[0] = stor9[idx]
                    mem[32] = 4
                    if stor4[stor9[idx]] <= s:
                        if idx >= stor9.length:
                            revert with 0, 50
                        mem[0] = stor9[idx]
                        mem[32] = 3
                        _9366 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9366] = 30
                        mem[_9366 + 32] = 'SafeMath: subtraction overflow'
                        if stor3[stor9[idx]] > t:
                            _9446 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _9446 + 68] = mem[idx + _9366 + 32]
                                idx = idx + 32
                                continue 
                            mem[_9446 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _9446 + -mem[64] + 100
                        if t < stor3[stor9[idx]]:
                            revert with 0, 17
                        if idx >= stor9.length:
                            revert with 0, 50
                        mem[0] = stor9[idx]
                        mem[32] = 4
                        _9799 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9799] = 30
                        mem[_9799 + 32] = 'SafeMath: subtraction overflow'
                        if stor4[stor9[idx]] <= s:
                            if s < stor4[stor9[idx]]:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s - stor4[stor9[idx]]
                            t = t - stor3[stor9[idx]]
                            continue 
                        _9847 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _9847 + 68] = mem[idx + _9799 + 32]
                            idx = idx + 32
                            continue 
                        mem[_9847 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _9847 + -mem[64] + 100
                    _9367 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9367] = 26
                    mem[_9367 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _9447 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _9447 + 68] = mem[idx + _9367 + 32]
                            idx = idx + 32
                            continue 
                        mem[_9447 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _9447 + -mem[64] + 100
                    if not arg1:
                        if not arg1 * _marketingFee / 10000:
                            return 0
                        if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                            revert with 0, 17
                        if not arg1 * _marketingFee / 10000:
                            revert with 0, 18
                        if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _10499 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10499] = 30
                        mem[_10499 + 32] = 'SafeMath: subtraction overflow'
                        _11464 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11464] = 30
                        mem[_11464 + 32] = 'SafeMath: subtraction overflow'
                        _13193 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13193] = 30
                        mem[_13193 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _marketingFee / 10000 * stor12 / totalSupply <= 0:
                            if 0 < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                                revert with 0, 17
                            else:
                                return 0
                        _13716 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13716 + 68] = mem[idx + _13193 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13716 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13716 + -mem[64] + 100
                    if arg1 and stor12 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor12 / totalSupply / arg1 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _marketingFee / 10000:
                        _10498 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10498] = 30
                        mem[_10498 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor12 / totalSupply:
                            _10623 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _10623 + 68] = mem[idx + _10498 + 32]
                                idx = idx + 32
                                continue 
                            mem[_10623 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _10623 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 0, 17
                        _11462 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11462] = 30
                        mem[_11462 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor12 / totalSupply:
                            _11803 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11803 + 68] = mem[idx + _11462 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11803 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11803 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 0, 17
                        _13191 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13191] = 30
                        mem[_13191 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= arg1 * stor12 / totalSupply:
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 0, 17
                            return (arg1 * stor12 / totalSupply)
                        _13715 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13715 + 68] = mem[idx + _13191 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13715 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13715 + -mem[64] + 100
                    if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                        revert with 0, 17
                    if not arg1 * _marketingFee / 10000:
                        revert with 0, 18
                    if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _11168 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11168] = 30
                    mem[_11168 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor12 / totalSupply:
                        _11461 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _11461 + 68] = mem[idx + _11168 + 32]
                            idx = idx + 32
                            continue 
                        mem[_11461 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _11461 + -mem[64] + 100
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 0, 17
                    _12763 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12763] = 30
                    mem[_12763 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor12 / totalSupply:
                        _13190 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13190 + 68] = mem[idx + _12763 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13190 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13190 + -mem[64] + 100
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 0, 17
                    _14842 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14842] = 30
                    mem[_14842 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _marketingFee / 10000 * stor12 / totalSupply <= arg1 * stor12 / totalSupply:
                        if arg1 * stor12 / totalSupply < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                            revert with 0, 17
                        return (arg1 * stor12 / totalSupply)
                    _15340 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _15340 + 68] = mem[idx + _14842 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15340 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _15340 + -mem[64] + 100
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if t >= stor12 / totalSupply:
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg1:
                        if arg1 * _marketingFee / 10000:
                            if arg1 * _marketingFee / 10000 and t / s > -1 / arg1 * _marketingFee / 10000:
                                revert with 0, 17
                            if not arg1 * _marketingFee / 10000:
                                revert with 0, 18
                            if arg1 * _marketingFee / 10000 * t / s / arg1 * _marketingFee / 10000 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * _marketingFee / 10000 * t / s > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * _marketingFee / 10000 * t / s:
                                revert with 0, 17
                            else:
                                return 0
                        else:
                            return 0
                    if arg1 and t / s > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _marketingFee / 10000:
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                    else:
                        if arg1 * _marketingFee / 10000 and t / s > -1 / arg1 * _marketingFee / 10000:
                            revert with 0, 17
                        if not arg1 * _marketingFee / 10000:
                            revert with 0, 18
                        if arg1 * _marketingFee / 10000 * t / s / arg1 * _marketingFee / 10000 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if arg1 * _marketingFee / 10000 * t / s > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < arg1 * _marketingFee / 10000 * t / s:
                            revert with 0, 17
                    return (arg1 * t / s)
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if arg1 * _marketingFee / 10000:
                        if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                            revert with 0, 17
                        if not arg1 * _marketingFee / 10000:
                            revert with 0, 18
                        if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * _marketingFee / 10000 * stor12 / totalSupply > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                            revert with 0, 17
                        else:
                            return 0
                    else:
                        return 0
                if arg1 and stor12 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor12 / totalSupply / arg1 != stor12 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _marketingFee / 10000:
                    if 0 > arg1 * stor12 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor12 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor12 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 0, 17
                else:
                    if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                        revert with 0, 17
                    if not arg1 * _marketingFee / 10000:
                        revert with 0, 18
                    if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 > arg1 * stor12 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor12 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 0, 17
                    if arg1 * _marketingFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor12 / totalSupply < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                        revert with 0, 17
        else:
            if arg1 and _liquidityFee > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * _liquidityFee / arg1 != _liquidityFee:
                revert with 0, 'SafeMath: multiplication overflow'
            mem[160] = 26
            mem[192] = 'SafeMath: division by zero'
            if not arg1:
                mem[224] = 26
                mem[256] = 'SafeMath: division by zero'
                mem[288] = 30
                mem[320] = 'SafeMath: subtraction overflow'
                if 0 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < 0:
                    revert with 0, 17
                mem[352] = 30
                mem[384] = 'SafeMath: subtraction overflow'
                if arg1 * _liquidityFee / 10000 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < arg1 * _liquidityFee / 10000:
                    revert with 0, 17
                mem[64] = 480
                mem[416] = 30
                mem[448] = 'SafeMath: subtraction overflow'
                if 0 > arg1 - (arg1 * _liquidityFee / 10000):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * _liquidityFee / 10000) < 0:
                    revert with 0, 17
                idx = 0
                s = totalSupply
                t = stor12
                while idx < stor9.length:
                    mem[0] = stor9[idx]
                    mem[32] = 3
                    if stor3[stor9[idx]] > t:
                        _9272 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9272] = 26
                        mem[_9272 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _9362 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _9362 + 68] = mem[idx + _9272 + 32]
                                idx = idx + 32
                                continue 
                            mem[_9362 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _9362 + -mem[64] + 100
                        if not arg1:
                            if not arg1 * _liquidityFee / 10000:
                                return 0
                            if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                                revert with 0, 17
                            if not arg1 * _liquidityFee / 10000:
                                revert with 0, 18
                            if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _10350 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10350] = 30
                            mem[_10350 + 32] = 'SafeMath: subtraction overflow'
                            _11158 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11158] = 30
                            mem[_11158 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > 0:
                                _11451 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11451 + 68] = mem[idx + _11158 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11451 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11451 + -mem[64] + 100
                            if 0 < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                revert with 0, 17
                            _12751 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12751] = 30
                            mem[_12751 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                if -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply < 0:
                                    revert with 0, 17
                                else:
                                    return 0
                            _13182 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13182 + 68] = mem[idx + _12751 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13182 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13182 + -mem[64] + 100
                        if arg1 and stor12 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor12 / totalSupply / arg1 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _liquidityFee / 10000:
                            _10349 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10349] = 30
                            mem[_10349 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor12 / totalSupply:
                                _10491 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _10491 + 68] = mem[idx + _10349 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_10491 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _10491 + -mem[64] + 100
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 0, 17
                            _11156 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11156] = 30
                            mem[_11156 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor12 / totalSupply:
                                _11450 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11450 + 68] = mem[idx + _11156 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11450 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11450 + -mem[64] + 100
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 0, 17
                            _12749 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12749] = 30
                            mem[_12749 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor12 / totalSupply:
                                if arg1 * stor12 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor12 / totalSupply)
                            _13181 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13181 + 68] = mem[idx + _12749 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13181 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13181 + -mem[64] + 100
                        if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                            revert with 0, 17
                        if not arg1 * _liquidityFee / 10000:
                            revert with 0, 18
                        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _10858 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10858] = 30
                        mem[_10858 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor12 / totalSupply:
                            _11155 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11155 + 68] = mem[idx + _10858 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11155 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11155 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 0, 17
                        _12273 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12273] = 30
                        mem[_12273 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                            _12748 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12748 + 68] = mem[idx + _12273 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12748 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12748 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                            revert with 0, 17
                        _14328 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14328] = 30
                        mem[_14328 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                            if (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < 0:
                                revert with 0, 17
                            return (arg1 * stor12 / totalSupply)
                        _14830 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _14830 + 68] = mem[idx + _14328 + 32]
                            idx = idx + 32
                            continue 
                        mem[_14830 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14830 + -mem[64] + 100
                    if idx >= stor9.length:
                        revert with 0, 50
                    mem[0] = stor9[idx]
                    mem[32] = 4
                    if stor4[stor9[idx]] <= s:
                        if idx >= stor9.length:
                            revert with 0, 50
                        mem[0] = stor9[idx]
                        mem[32] = 3
                        _9363 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9363] = 30
                        mem[_9363 + 32] = 'SafeMath: subtraction overflow'
                        if stor3[stor9[idx]] > t:
                            _9443 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _9443 + 68] = mem[idx + _9363 + 32]
                                idx = idx + 32
                                continue 
                            mem[_9443 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _9443 + -mem[64] + 100
                        if t < stor3[stor9[idx]]:
                            revert with 0, 17
                        if idx >= stor9.length:
                            revert with 0, 50
                        mem[0] = stor9[idx]
                        mem[32] = 4
                        _9796 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9796] = 30
                        mem[_9796 + 32] = 'SafeMath: subtraction overflow'
                        if stor4[stor9[idx]] <= s:
                            if s < stor4[stor9[idx]]:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s - stor4[stor9[idx]]
                            t = t - stor3[stor9[idx]]
                            continue 
                        _9844 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _9844 + 68] = mem[idx + _9796 + 32]
                            idx = idx + 32
                            continue 
                        mem[_9844 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _9844 + -mem[64] + 100
                    _9364 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9364] = 26
                    mem[_9364 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _9444 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _9444 + 68] = mem[idx + _9364 + 32]
                            idx = idx + 32
                            continue 
                        mem[_9444 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _9444 + -mem[64] + 100
                    if not arg1:
                        if not arg1 * _liquidityFee / 10000:
                            return 0
                        if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                            revert with 0, 17
                        if not arg1 * _liquidityFee / 10000:
                            revert with 0, 18
                        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _10495 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10495] = 30
                        mem[_10495 + 32] = 'SafeMath: subtraction overflow'
                        _11456 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11456] = 30
                        mem[_11456 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > 0:
                            _11799 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11799 + 68] = mem[idx + _11456 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11799 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11799 + -mem[64] + 100
                        if 0 < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                            revert with 0, 17
                        _13186 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13186] = 30
                        mem[_13186 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                            if -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply < 0:
                                revert with 0, 17
                            else:
                                return 0
                        _13709 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13709 + 68] = mem[idx + _13186 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13709 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13709 + -mem[64] + 100
                    if arg1 and stor12 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor12 / totalSupply / arg1 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _liquidityFee / 10000:
                        _10494 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10494] = 30
                        mem[_10494 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor12 / totalSupply:
                            _10618 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _10618 + 68] = mem[idx + _10494 + 32]
                                idx = idx + 32
                                continue 
                            mem[_10618 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _10618 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 0, 17
                        _11454 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11454] = 30
                        mem[_11454 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor12 / totalSupply:
                            _11798 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11798 + 68] = mem[idx + _11454 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11798 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11798 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 0, 17
                        _13184 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13184] = 30
                        mem[_13184 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= arg1 * stor12 / totalSupply:
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 0, 17
                            return (arg1 * stor12 / totalSupply)
                        _13708 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13708 + 68] = mem[idx + _13184 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13708 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13708 + -mem[64] + 100
                    if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                        revert with 0, 17
                    if not arg1 * _liquidityFee / 10000:
                        revert with 0, 18
                    if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _11159 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11159] = 30
                    mem[_11159 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor12 / totalSupply:
                        _11453 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _11453 + 68] = mem[idx + _11159 + 32]
                            idx = idx + 32
                            continue 
                        mem[_11453 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _11453 + -mem[64] + 100
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 0, 17
                    _12753 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12753] = 30
                    mem[_12753 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                        _13183 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13183 + 68] = mem[idx + _12753 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13183 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13183 + -mem[64] + 100
                    if arg1 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                        revert with 0, 17
                    _14833 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14833] = 30
                    mem[_14833 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                        if (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < 0:
                            revert with 0, 17
                        return (arg1 * stor12 / totalSupply)
                    _15333 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _15333 + 68] = mem[idx + _14833 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15333 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _15333 + -mem[64] + 100
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if t >= stor12 / totalSupply:
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg1:
                        if arg1 * _liquidityFee / 10000:
                            if arg1 * _liquidityFee / 10000 and t / s > -1 / arg1 * _liquidityFee / 10000:
                                revert with 0, 17
                            if not arg1 * _liquidityFee / 10000:
                                revert with 0, 18
                            if arg1 * _liquidityFee / 10000 * t / s / arg1 * _liquidityFee / 10000 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * _liquidityFee / 10000 * t / s > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * _liquidityFee / 10000 * t / s:
                                revert with 0, 17
                            if 0 > -1 * arg1 * _liquidityFee / 10000 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * _liquidityFee / 10000 * t / s < 0:
                                revert with 0, 17
                            else:
                                return 0
                        else:
                            return 0
                    if arg1 and t / s > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _liquidityFee / 10000:
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                    else:
                        if arg1 * _liquidityFee / 10000 and t / s > -1 / arg1 * _liquidityFee / 10000:
                            revert with 0, 17
                        if not arg1 * _liquidityFee / 10000:
                            revert with 0, 18
                        if arg1 * _liquidityFee / 10000 * t / s / arg1 * _liquidityFee / 10000 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if arg1 * _liquidityFee / 10000 * t / s > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < arg1 * _liquidityFee / 10000 * t / s:
                            revert with 0, 17
                        if 0 > (arg1 * t / s) - (arg1 * _liquidityFee / 10000 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (arg1 * _liquidityFee / 10000 * t / s) < 0:
                            revert with 0, 17
                    return (arg1 * t / s)
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if arg1 * _liquidityFee / 10000:
                        if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                            revert with 0, 17
                        if not arg1 * _liquidityFee / 10000:
                            revert with 0, 18
                        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                            revert with 0, 17
                        if 0 > -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply < 0:
                            revert with 0, 17
                        else:
                            return 0
                    else:
                        return 0
                if arg1 and stor12 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor12 / totalSupply / arg1 != stor12 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _liquidityFee / 10000:
                    if 0 > arg1 * stor12 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor12 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor12 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 0, 17
                else:
                    if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                        revert with 0, 17
                    if not arg1 * _liquidityFee / 10000:
                        revert with 0, 18
                    if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 > arg1 * stor12 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 0, 17
                    if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                        revert with 0, 17
                    if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < 0:
                        revert with 0, 17
            else:
                if arg1 and _marketingFee > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * _marketingFee / arg1 != _marketingFee:
                    revert with 0, 'SafeMath: multiplication overflow'
                mem[224] = 26
                mem[256] = 'SafeMath: division by zero'
                mem[288] = 30
                mem[320] = 'SafeMath: subtraction overflow'
                if 0 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < 0:
                    revert with 0, 17
                mem[352] = 30
                mem[384] = 'SafeMath: subtraction overflow'
                if arg1 * _liquidityFee / 10000 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < arg1 * _liquidityFee / 10000:
                    revert with 0, 17
                mem[64] = 480
                mem[416] = 30
                mem[448] = 'SafeMath: subtraction overflow'
                if arg1 * _marketingFee / 10000 > arg1 - (arg1 * _liquidityFee / 10000):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * _liquidityFee / 10000) < arg1 * _marketingFee / 10000:
                    revert with 0, 17
                idx = 0
                s = totalSupply
                t = stor12
                while idx < stor9.length:
                    mem[0] = stor9[idx]
                    mem[32] = 3
                    if stor3[stor9[idx]] > t:
                        _9271 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9271] = 26
                        mem[_9271 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _9359 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _9359 + 68] = mem[idx + _9271 + 32]
                                idx = idx + 32
                                continue 
                            mem[_9359 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _9359 + -mem[64] + 100
                        if not arg1:
                            if not arg1 * _liquidityFee / 10000:
                                if not arg1 * _marketingFee / 10000:
                                    return 0
                                if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                                    revert with 0, 17
                                if not arg1 * _marketingFee / 10000:
                                    revert with 0, 18
                                if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _10342 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10342] = 30
                                mem[_10342 + 32] = 'SafeMath: subtraction overflow'
                                _11147 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11147] = 30
                                mem[_11147 + 32] = 'SafeMath: subtraction overflow'
                                _12735 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12735] = 30
                                mem[_12735 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _marketingFee / 10000 * stor12 / totalSupply <= 0:
                                    if 0 < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _13172 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _13172 + 68] = mem[idx + _12735 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13172 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13172 + -mem[64] + 100
                            if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                                revert with 0, 17
                            if not arg1 * _liquidityFee / 10000:
                                revert with 0, 18
                            if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _marketingFee / 10000:
                                _10341 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10341] = 30
                                mem[_10341 + 32] = 'SafeMath: subtraction overflow'
                                _11146 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11146] = 30
                                mem[_11146 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > 0:
                                    _11442 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _11442 + 68] = mem[idx + _11146 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_11442 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _11442 + -mem[64] + 100
                                if 0 < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                    revert with 0, 17
                                _12733 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12733] = 30
                                mem[_12733 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                    if -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _13171 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _13171 + 68] = mem[idx + _12733 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13171 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13171 + -mem[64] + 100
                            if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                                revert with 0, 17
                            if not arg1 * _marketingFee / 10000:
                                revert with 0, 18
                            if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _10849 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10849] = 30
                            mem[_10849 + 32] = 'SafeMath: subtraction overflow'
                            _12263 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12263] = 30
                            mem[_12263 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > 0:
                                _12732 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _12732 + 68] = mem[idx + _12263 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12732 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12732 + -mem[64] + 100
                            if 0 < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                revert with 0, 17
                            _14313 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14313] = 30
                            mem[_14313 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _marketingFee / 10000 * stor12 / totalSupply <= -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                if -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _14816 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _14816 + 68] = mem[idx + _14313 + 32]
                                idx = idx + 32
                                continue 
                            mem[_14816 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _14816 + -mem[64] + 100
                        if arg1 and stor12 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor12 / totalSupply / arg1 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _liquidityFee / 10000:
                            if not arg1 * _marketingFee / 10000:
                                _10340 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10340] = 30
                                mem[_10340 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor12 / totalSupply:
                                    _10485 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _10485 + 68] = mem[idx + _10340 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_10485 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _10485 + -mem[64] + 100
                                if arg1 * stor12 / totalSupply < 0:
                                    revert with 0, 17
                                _11144 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11144] = 30
                                mem[_11144 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor12 / totalSupply:
                                    _11441 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _11441 + 68] = mem[idx + _11144 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_11441 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _11441 + -mem[64] + 100
                                if arg1 * stor12 / totalSupply < 0:
                                    revert with 0, 17
                                _12730 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12730] = 30
                                mem[_12730 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= arg1 * stor12 / totalSupply:
                                    if arg1 * stor12 / totalSupply < 0:
                                        revert with 0, 17
                                    return (arg1 * stor12 / totalSupply)
                                _13170 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _13170 + 68] = mem[idx + _12730 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13170 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13170 + -mem[64] + 100
                            if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                                revert with 0, 17
                            if not arg1 * _marketingFee / 10000:
                                revert with 0, 18
                            if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _10848 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10848] = 30
                            mem[_10848 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor12 / totalSupply:
                                _11143 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11143 + 68] = mem[idx + _10848 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11143 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11143 + -mem[64] + 100
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 0, 17
                            _12261 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12261] = 30
                            mem[_12261 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor12 / totalSupply:
                                _12729 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _12729 + 68] = mem[idx + _12261 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12729 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12729 + -mem[64] + 100
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 0, 17
                            _14311 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14311] = 30
                            mem[_14311 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _marketingFee / 10000 * stor12 / totalSupply <= arg1 * stor12 / totalSupply:
                                if arg1 * stor12 / totalSupply < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                                    revert with 0, 17
                                return (arg1 * stor12 / totalSupply)
                            _14814 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _14814 + 68] = mem[idx + _14311 + 32]
                                idx = idx + 32
                                continue 
                            mem[_14814 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _14814 + -mem[64] + 100
                        if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                            revert with 0, 17
                        if not arg1 * _liquidityFee / 10000:
                            revert with 0, 18
                        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _marketingFee / 10000:
                            _10847 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10847] = 30
                            mem[_10847 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor12 / totalSupply:
                                _11142 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11142 + 68] = mem[idx + _10847 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11142 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11142 + -mem[64] + 100
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 0, 17
                            _12259 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12259] = 30
                            mem[_12259 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                                _12728 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _12728 + 68] = mem[idx + _12259 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12728 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12728 + -mem[64] + 100
                            if arg1 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                revert with 0, 17
                            _14309 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14309] = 30
                            mem[_14309 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                                if (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor12 / totalSupply)
                            _14813 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _14813 + 68] = mem[idx + _14309 + 32]
                                idx = idx + 32
                                continue 
                            mem[_14813 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _14813 + -mem[64] + 100
                        if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                            revert with 0, 17
                        if not arg1 * _marketingFee / 10000:
                            revert with 0, 18
                        if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _11791 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11791] = 30
                        mem[_11791 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor12 / totalSupply:
                            _12258 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12258 + 68] = mem[idx + _11791 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12258 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12258 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 0, 17
                        _13697 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13697] = 30
                        mem[_13697 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                            _14308 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _14308 + 68] = mem[idx + _13697 + 32]
                                idx = idx + 32
                                continue 
                            mem[_14308 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _14308 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                            revert with 0, 17
                        _15905 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_15905] = 30
                        mem[_15905 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _marketingFee / 10000 * stor12 / totalSupply <= (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                            if (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor12 / totalSupply)
                        _16373 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _16373 + 68] = mem[idx + _15905 + 32]
                            idx = idx + 32
                            continue 
                        mem[_16373 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _16373 + -mem[64] + 100
                    if idx >= stor9.length:
                        revert with 0, 50
                    mem[0] = stor9[idx]
                    mem[32] = 4
                    if stor4[stor9[idx]] <= s:
                        if idx >= stor9.length:
                            revert with 0, 50
                        mem[0] = stor9[idx]
                        mem[32] = 3
                        _9360 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9360] = 30
                        mem[_9360 + 32] = 'SafeMath: subtraction overflow'
                        if stor3[stor9[idx]] > t:
                            _9440 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _9440 + 68] = mem[idx + _9360 + 32]
                                idx = idx + 32
                                continue 
                            mem[_9440 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _9440 + -mem[64] + 100
                        if t < stor3[stor9[idx]]:
                            revert with 0, 17
                        if idx >= stor9.length:
                            revert with 0, 50
                        mem[0] = stor9[idx]
                        mem[32] = 4
                        _9793 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9793] = 30
                        mem[_9793 + 32] = 'SafeMath: subtraction overflow'
                        if stor4[stor9[idx]] <= s:
                            if s < stor4[stor9[idx]]:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s - stor4[stor9[idx]]
                            t = t - stor3[stor9[idx]]
                            continue 
                        _9841 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _9841 + 68] = mem[idx + _9793 + 32]
                            idx = idx + 32
                            continue 
                        mem[_9841 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _9841 + -mem[64] + 100
                    _9361 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9361] = 26
                    mem[_9361 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _9441 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _9441 + 68] = mem[idx + _9361 + 32]
                            idx = idx + 32
                            continue 
                        mem[_9441 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _9441 + -mem[64] + 100
                    if not arg1:
                        if not arg1 * _liquidityFee / 10000:
                            if not arg1 * _marketingFee / 10000:
                                return 0
                            if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                                revert with 0, 17
                            if not arg1 * _marketingFee / 10000:
                                revert with 0, 18
                            if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _10490 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10490] = 30
                            mem[_10490 + 32] = 'SafeMath: subtraction overflow'
                            _11449 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11449] = 30
                            mem[_11449 + 32] = 'SafeMath: subtraction overflow'
                            _13180 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13180] = 30
                            mem[_13180 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _marketingFee / 10000 * stor12 / totalSupply <= 0:
                                if 0 < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _13702 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13702 + 68] = mem[idx + _13180 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13702 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13702 + -mem[64] + 100
                        if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                            revert with 0, 17
                        if not arg1 * _liquidityFee / 10000:
                            revert with 0, 18
                        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _marketingFee / 10000:
                            _10489 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10489] = 30
                            mem[_10489 + 32] = 'SafeMath: subtraction overflow'
                            _11448 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11448] = 30
                            mem[_11448 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > 0:
                                _11794 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11794 + 68] = mem[idx + _11448 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11794 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11794 + -mem[64] + 100
                            if 0 < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                revert with 0, 17
                            _13178 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13178] = 30
                            mem[_13178 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                if -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply < 0:
                                    revert with 0, 17
                                else:
                                    return 0
                            _13701 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13701 + 68] = mem[idx + _13178 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13701 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13701 + -mem[64] + 100
                        if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                            revert with 0, 17
                        if not arg1 * _marketingFee / 10000:
                            revert with 0, 18
                        if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _11150 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11150] = 30
                        mem[_11150 + 32] = 'SafeMath: subtraction overflow'
                        _12741 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12741] = 30
                        mem[_12741 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > 0:
                            _13177 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13177 + 68] = mem[idx + _12741 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13177 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13177 + -mem[64] + 100
                        if 0 < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                            revert with 0, 17
                        _14824 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14824] = 30
                        mem[_14824 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _marketingFee / 10000 * stor12 / totalSupply <= -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                            if -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                                revert with 0, 17
                            else:
                                return 0
                        _15326 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _15326 + 68] = mem[idx + _14824 + 32]
                            idx = idx + 32
                            continue 
                        mem[_15326 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _15326 + -mem[64] + 100
                    if arg1 and stor12 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor12 / totalSupply / arg1 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _liquidityFee / 10000:
                        if not arg1 * _marketingFee / 10000:
                            _10488 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10488] = 30
                            mem[_10488 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor12 / totalSupply:
                                _10616 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _10616 + 68] = mem[idx + _10488 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_10616 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _10616 + -mem[64] + 100
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 0, 17
                            _11446 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11446] = 30
                            mem[_11446 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor12 / totalSupply:
                                _11793 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11793 + 68] = mem[idx + _11446 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11793 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11793 + -mem[64] + 100
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 0, 17
                            _13175 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13175] = 30
                            mem[_13175 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor12 / totalSupply:
                                if arg1 * stor12 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor12 / totalSupply)
                            _13700 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13700 + 68] = mem[idx + _13175 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13700 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13700 + -mem[64] + 100
                        if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                            revert with 0, 17
                        if not arg1 * _marketingFee / 10000:
                            revert with 0, 18
                        if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _11149 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11149] = 30
                        mem[_11149 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor12 / totalSupply:
                            _11445 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11445 + 68] = mem[idx + _11149 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11445 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11445 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 0, 17
                        _12739 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12739] = 30
                        mem[_12739 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor12 / totalSupply:
                            _13174 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13174 + 68] = mem[idx + _12739 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13174 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13174 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 0, 17
                        _14822 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14822] = 30
                        mem[_14822 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _marketingFee / 10000 * stor12 / totalSupply <= arg1 * stor12 / totalSupply:
                            if arg1 * stor12 / totalSupply < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor12 / totalSupply)
                        _15324 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _15324 + 68] = mem[idx + _14822 + 32]
                            idx = idx + 32
                            continue 
                        mem[_15324 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _15324 + -mem[64] + 100
                    if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                        revert with 0, 17
                    if not arg1 * _liquidityFee / 10000:
                        revert with 0, 18
                    if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _marketingFee / 10000:
                        _11148 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11148] = 30
                        mem[_11148 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor12 / totalSupply:
                            _11444 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11444 + 68] = mem[idx + _11148 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11444 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11444 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 0, 17
                        _12737 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12737] = 30
                        mem[_12737 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                            _13173 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13173 + 68] = mem[idx + _12737 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13173 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13173 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                            revert with 0, 17
                        _14820 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14820] = 30
                        mem[_14820 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                            if (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < 0:
                                revert with 0, 17
                            return (arg1 * stor12 / totalSupply)
                        _15323 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _15323 + 68] = mem[idx + _14820 + 32]
                            idx = idx + 32
                            continue 
                        mem[_15323 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _15323 + -mem[64] + 100
                    if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                        revert with 0, 17
                    if not arg1 * _marketingFee / 10000:
                        revert with 0, 18
                    if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _12264 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12264] = 30
                    mem[_12264 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor12 / totalSupply:
                        _12736 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _12736 + 68] = mem[idx + _12264 + 32]
                            idx = idx + 32
                            continue 
                        mem[_12736 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _12736 + -mem[64] + 100
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 0, 17
                    _14315 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14315] = 30
                    mem[_14315 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                        _14819 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _14819 + 68] = mem[idx + _14315 + 32]
                            idx = idx + 32
                            continue 
                        mem[_14819 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14819 + -mem[64] + 100
                    if arg1 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                        revert with 0, 17
                    _16377 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_16377] = 30
                    mem[_16377 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _marketingFee / 10000 * stor12 / totalSupply <= (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                        if (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                            revert with 0, 17
                        return (arg1 * stor12 / totalSupply)
                    _16709 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _16709 + 68] = mem[idx + _16377 + 32]
                        idx = idx + 32
                        continue 
                    mem[_16709 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _16709 + -mem[64] + 100
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if t >= stor12 / totalSupply:
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg1:
                        if not arg1 * _liquidityFee / 10000:
                            if arg1 * _marketingFee / 10000:
                                if arg1 * _marketingFee / 10000 and t / s > -1 / arg1 * _marketingFee / 10000:
                                    revert with 0, 17
                                if not arg1 * _marketingFee / 10000:
                                    revert with 0, 18
                                if arg1 * _marketingFee / 10000 * t / s / arg1 * _marketingFee / 10000 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _marketingFee / 10000 * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _marketingFee / 10000 * t / s:
                                    revert with 0, 17
                        else:
                            if arg1 * _liquidityFee / 10000 and t / s > -1 / arg1 * _liquidityFee / 10000:
                                revert with 0, 17
                            if not arg1 * _liquidityFee / 10000:
                                revert with 0, 18
                            if arg1 * _liquidityFee / 10000 * t / s / arg1 * _liquidityFee / 10000 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _marketingFee / 10000:
                                if arg1 * _liquidityFee / 10000 * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _liquidityFee / 10000 * t / s:
                                    revert with 0, 17
                                if 0 > -1 * arg1 * _liquidityFee / 10000 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _liquidityFee / 10000 * t / s < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * _marketingFee / 10000 and t / s > -1 / arg1 * _marketingFee / 10000:
                                    revert with 0, 17
                                if not arg1 * _marketingFee / 10000:
                                    revert with 0, 18
                                if arg1 * _marketingFee / 10000 * t / s / arg1 * _marketingFee / 10000 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _liquidityFee / 10000 * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _liquidityFee / 10000 * t / s:
                                    revert with 0, 17
                                if arg1 * _marketingFee / 10000 * t / s > -1 * arg1 * _liquidityFee / 10000 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _liquidityFee / 10000 * t / s < arg1 * _marketingFee / 10000 * t / s:
                                    revert with 0, 17
                        return 0
                    if arg1 and t / s > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _liquidityFee / 10000:
                        if not arg1 * _marketingFee / 10000:
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                        else:
                            if arg1 * _marketingFee / 10000 and t / s > -1 / arg1 * _marketingFee / 10000:
                                revert with 0, 17
                            if not arg1 * _marketingFee / 10000:
                                revert with 0, 18
                            if arg1 * _marketingFee / 10000 * t / s / arg1 * _marketingFee / 10000 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if arg1 * _marketingFee / 10000 * t / s > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < arg1 * _marketingFee / 10000 * t / s:
                                revert with 0, 17
                    else:
                        if arg1 * _liquidityFee / 10000 and t / s > -1 / arg1 * _liquidityFee / 10000:
                            revert with 0, 17
                        if not arg1 * _liquidityFee / 10000:
                            revert with 0, 18
                        if arg1 * _liquidityFee / 10000 * t / s / arg1 * _liquidityFee / 10000 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _marketingFee / 10000:
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if arg1 * _liquidityFee / 10000 * t / s > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < arg1 * _liquidityFee / 10000 * t / s:
                                revert with 0, 17
                            if 0 > (arg1 * t / s) - (arg1 * _liquidityFee / 10000 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (arg1 * _liquidityFee / 10000 * t / s) < 0:
                                revert with 0, 17
                        else:
                            if arg1 * _marketingFee / 10000 and t / s > -1 / arg1 * _marketingFee / 10000:
                                revert with 0, 17
                            if not arg1 * _marketingFee / 10000:
                                revert with 0, 18
                            if arg1 * _marketingFee / 10000 * t / s / arg1 * _marketingFee / 10000 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if arg1 * _liquidityFee / 10000 * t / s > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < arg1 * _liquidityFee / 10000 * t / s:
                                revert with 0, 17
                            if arg1 * _marketingFee / 10000 * t / s > (arg1 * t / s) - (arg1 * _liquidityFee / 10000 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (arg1 * _liquidityFee / 10000 * t / s) < arg1 * _marketingFee / 10000 * t / s:
                                revert with 0, 17
                    return (arg1 * t / s)
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if not arg1 * _liquidityFee / 10000:
                        if arg1 * _marketingFee / 10000:
                            if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                                revert with 0, 17
                            if not arg1 * _marketingFee / 10000:
                                revert with 0, 18
                            if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * _marketingFee / 10000 * stor12 / totalSupply > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                                revert with 0, 17
                    else:
                        if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                            revert with 0, 17
                        if not arg1 * _liquidityFee / 10000:
                            revert with 0, 18
                        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _marketingFee / 10000:
                            if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                revert with 0, 17
                            if 0 > -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply < 0:
                                revert with 0, 17
                        else:
                            if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                                revert with 0, 17
                            if not arg1 * _marketingFee / 10000:
                                revert with 0, 18
                            if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                revert with 0, 17
                            if arg1 * _marketingFee / 10000 * stor12 / totalSupply > -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                                revert with 0, 17
                    return 0
                if arg1 and stor12 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor12 / totalSupply / arg1 != stor12 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _liquidityFee / 10000:
                    if not arg1 * _marketingFee / 10000:
                        if 0 > arg1 * stor12 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > arg1 * stor12 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > arg1 * stor12 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 0, 17
                    else:
                        if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                            revert with 0, 17
                        if not arg1 * _marketingFee / 10000:
                            revert with 0, 18
                        if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 > arg1 * stor12 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > arg1 * stor12 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 0, 17
                        if arg1 * _marketingFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor12 / totalSupply < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                            revert with 0, 17
                else:
                    if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                        revert with 0, 17
                    if not arg1 * _liquidityFee / 10000:
                        revert with 0, 18
                    if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _marketingFee / 10000:
                        if 0 > arg1 * stor12 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 0, 17
                        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                            revert with 0, 17
                        if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < 0:
                            revert with 0, 17
                    else:
                        if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                            revert with 0, 17
                        if not arg1 * _marketingFee / 10000:
                            revert with 0, 18
                        if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 > arg1 * stor12 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 0, 17
                        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                            revert with 0, 17
                        if arg1 * _marketingFee / 10000 * stor12 / totalSupply > (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                            revert with 0, 17
    else:
        if arg1 and _taxFee > -1 / arg1:
            revert with 0, 17
        if not arg1:
            revert with 0, 18
        if arg1 * _taxFee / arg1 != _taxFee:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
        mem[96] = 26
        mem[128] = 'SafeMath: division by zero'
        if not arg1:
            mem[160] = 26
            mem[192] = 'SafeMath: division by zero'
            if not arg1:
                mem[224] = 26
                mem[256] = 'SafeMath: division by zero'
                mem[288] = 30
                mem[320] = 'SafeMath: subtraction overflow'
                if arg1 * _taxFee / 10000 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < arg1 * _taxFee / 10000:
                    revert with 0, 17
                mem[352] = 30
                mem[384] = 'SafeMath: subtraction overflow'
                if 0 > arg1 - (arg1 * _taxFee / 10000):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * _taxFee / 10000) < 0:
                    revert with 0, 17
                mem[64] = 480
                mem[416] = 30
                mem[448] = 'SafeMath: subtraction overflow'
                if 0 > arg1 - (arg1 * _taxFee / 10000):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * _taxFee / 10000) < 0:
                    revert with 0, 17
                idx = 0
                s = totalSupply
                t = stor12
                while idx < stor9.length:
                    mem[0] = stor9[idx]
                    mem[32] = 3
                    if stor3[stor9[idx]] > t:
                        _9270 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9270] = 26
                        mem[_9270 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _9356 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _9356 + 68] = mem[idx + _9270 + 32]
                                idx = idx + 32
                                continue 
                            mem[_9356 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _9356 + -mem[64] + 100
                        if not arg1:
                            if not arg1 * _taxFee / 10000:
                                return 0
                            if arg1 * _taxFee / 10000 and stor12 / totalSupply > -1 / arg1 * _taxFee / 10000:
                                revert with 0, 17
                            if not arg1 * _taxFee / 10000:
                                revert with 0, 18
                            if arg1 * _taxFee / 10000 * stor12 / totalSupply / arg1 * _taxFee / 10000 != stor12 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _10334 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10334] = 30
                            mem[_10334 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                                _10481 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _10481 + 68] = mem[idx + _10334 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_10481 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _10481 + -mem[64] + 100
                            if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                revert with 0, 17
                            _11135 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11135] = 30
                            mem[_11135 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                _11429 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11429 + 68] = mem[idx + _11135 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11429 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11429 + -mem[64] + 100
                            if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                                revert with 0, 17
                            _12716 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12716] = 30
                            mem[_12716 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                                    revert with 0, 17
                                else:
                                    return 0
                            _13162 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13162 + 68] = mem[idx + _12716 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13162 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13162 + -mem[64] + 100
                        if arg1 and stor12 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor12 / totalSupply / arg1 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _taxFee / 10000:
                            _10333 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10333] = 30
                            mem[_10333 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor12 / totalSupply:
                                _10480 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _10480 + 68] = mem[idx + _10333 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_10480 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _10480 + -mem[64] + 100
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 0, 17
                            _11133 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11133] = 30
                            mem[_11133 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor12 / totalSupply:
                                _11428 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11428 + 68] = mem[idx + _11133 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11428 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11428 + -mem[64] + 100
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 0, 17
                            _12714 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12714] = 30
                            mem[_12714 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor12 / totalSupply:
                                if arg1 * stor12 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor12 / totalSupply)
                            _13161 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13161 + 68] = mem[idx + _12714 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13161 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13161 + -mem[64] + 100
                        if arg1 * _taxFee / 10000 and stor12 / totalSupply > -1 / arg1 * _taxFee / 10000:
                            revert with 0, 17
                        if not arg1 * _taxFee / 10000:
                            revert with 0, 18
                        if arg1 * _taxFee / 10000 * stor12 / totalSupply / arg1 * _taxFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _10838 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10838] = 30
                        mem[_10838 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                            _11132 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11132 + 68] = mem[idx + _10838 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11132 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11132 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                            revert with 0, 17
                        _12244 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12244] = 30
                        mem[_12244 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                            _12713 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12713 + 68] = mem[idx + _12244 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12713 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12713 + -mem[64] + 100
                        if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                            revert with 0, 17
                        _14289 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14289] = 30
                        mem[_14289 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                            if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                                revert with 0, 17
                            return (arg1 * stor12 / totalSupply)
                        _14802 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _14802 + 68] = mem[idx + _14289 + 32]
                            idx = idx + 32
                            continue 
                        mem[_14802 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14802 + -mem[64] + 100
                    if idx >= stor9.length:
                        revert with 0, 50
                    mem[0] = stor9[idx]
                    mem[32] = 4
                    if stor4[stor9[idx]] <= s:
                        if idx >= stor9.length:
                            revert with 0, 50
                        mem[0] = stor9[idx]
                        mem[32] = 3
                        _9357 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9357] = 30
                        mem[_9357 + 32] = 'SafeMath: subtraction overflow'
                        if stor3[stor9[idx]] > t:
                            _9437 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _9437 + 68] = mem[idx + _9357 + 32]
                                idx = idx + 32
                                continue 
                            mem[_9437 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _9437 + -mem[64] + 100
                        if t < stor3[stor9[idx]]:
                            revert with 0, 17
                        if idx >= stor9.length:
                            revert with 0, 50
                        mem[0] = stor9[idx]
                        mem[32] = 4
                        _9790 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9790] = 30
                        mem[_9790 + 32] = 'SafeMath: subtraction overflow'
                        if stor4[stor9[idx]] <= s:
                            if s < stor4[stor9[idx]]:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s - stor4[stor9[idx]]
                            t = t - stor3[stor9[idx]]
                            continue 
                        _9838 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _9838 + 68] = mem[idx + _9790 + 32]
                            idx = idx + 32
                            continue 
                        mem[_9838 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _9838 + -mem[64] + 100
                    _9358 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9358] = 26
                    mem[_9358 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _9438 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _9438 + 68] = mem[idx + _9358 + 32]
                            idx = idx + 32
                            continue 
                        mem[_9438 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _9438 + -mem[64] + 100
                    if not arg1:
                        if not arg1 * _taxFee / 10000:
                            return 0
                        if arg1 * _taxFee / 10000 and stor12 / totalSupply > -1 / arg1 * _taxFee / 10000:
                            revert with 0, 17
                        if not arg1 * _taxFee / 10000:
                            revert with 0, 18
                        if arg1 * _taxFee / 10000 * stor12 / totalSupply / arg1 * _taxFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _10484 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10484] = 30
                        mem[_10484 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                            _10610 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _10610 + 68] = mem[idx + _10484 + 32]
                                idx = idx + 32
                                continue 
                            mem[_10610 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _10610 + -mem[64] + 100
                        if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                            revert with 0, 17
                        _11434 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11434] = 30
                        mem[_11434 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                            _11783 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11783 + 68] = mem[idx + _11434 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11783 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11783 + -mem[64] + 100
                        if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                            revert with 0, 17
                        _13166 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13166] = 30
                        mem[_13166 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                            if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                                revert with 0, 17
                            else:
                                return 0
                        _13684 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13684 + 68] = mem[idx + _13166 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13684 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13684 + -mem[64] + 100
                    if arg1 and stor12 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor12 / totalSupply / arg1 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _taxFee / 10000:
                        _10483 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_10483] = 30
                        mem[_10483 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor12 / totalSupply:
                            _10609 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _10609 + 68] = mem[idx + _10483 + 32]
                                idx = idx + 32
                                continue 
                            mem[_10609 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _10609 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 0, 17
                        _11432 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11432] = 30
                        mem[_11432 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor12 / totalSupply:
                            _11782 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11782 + 68] = mem[idx + _11432 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11782 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11782 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 0, 17
                        _13164 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13164] = 30
                        mem[_13164 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= arg1 * stor12 / totalSupply:
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 0, 17
                            return (arg1 * stor12 / totalSupply)
                        _13683 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13683 + 68] = mem[idx + _13164 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13683 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13683 + -mem[64] + 100
                    if arg1 * _taxFee / 10000 and stor12 / totalSupply > -1 / arg1 * _taxFee / 10000:
                        revert with 0, 17
                    if not arg1 * _taxFee / 10000:
                        revert with 0, 18
                    if arg1 * _taxFee / 10000 * stor12 / totalSupply / arg1 * _taxFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _11137 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11137] = 30
                    mem[_11137 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                        _11431 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _11431 + 68] = mem[idx + _11137 + 32]
                            idx = idx + 32
                            continue 
                        mem[_11431 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _11431 + -mem[64] + 100
                    if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                        revert with 0, 17
                    _12718 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12718] = 30
                    mem[_12718 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                        _13163 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _13163 + 68] = mem[idx + _12718 + 32]
                            idx = idx + 32
                            continue 
                        mem[_13163 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _13163 + -mem[64] + 100
                    if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                        revert with 0, 17
                    _14805 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14805] = 30
                    mem[_14805 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                        if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                            revert with 0, 17
                        return (arg1 * stor12 / totalSupply)
                    _15311 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _15311 + 68] = mem[idx + _14805 + 32]
                        idx = idx + 32
                        continue 
                    mem[_15311 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _15311 + -mem[64] + 100
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if t >= stor12 / totalSupply:
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg1:
                        if arg1 * _taxFee / 10000:
                            if arg1 * _taxFee / 10000 and t / s > -1 / arg1 * _taxFee / 10000:
                                revert with 0, 17
                            if not arg1 * _taxFee / 10000:
                                revert with 0, 18
                            if arg1 * _taxFee / 10000 * t / s / arg1 * _taxFee / 10000 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * _taxFee / 10000 * t / s > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * _taxFee / 10000 * t / s:
                                revert with 0, 17
                            if 0 > -1 * arg1 * _taxFee / 10000 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * _taxFee / 10000 * t / s < 0:
                                revert with 0, 17
                            if 0 > -1 * arg1 * _taxFee / 10000 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * _taxFee / 10000 * t / s < 0:
                                revert with 0, 17
                            else:
                                return 0
                        else:
                            return 0
                    if arg1 and t / s > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _taxFee / 10000:
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                    else:
                        if arg1 * _taxFee / 10000 and t / s > -1 / arg1 * _taxFee / 10000:
                            revert with 0, 17
                        if not arg1 * _taxFee / 10000:
                            revert with 0, 18
                        if arg1 * _taxFee / 10000 * t / s / arg1 * _taxFee / 10000 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * _taxFee / 10000 * t / s > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < arg1 * _taxFee / 10000 * t / s:
                            revert with 0, 17
                        if 0 > (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s) < 0:
                            revert with 0, 17
                        if 0 > (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s) < 0:
                            revert with 0, 17
                    return (arg1 * t / s)
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if arg1 * _taxFee / 10000:
                        if arg1 * _taxFee / 10000 and stor12 / totalSupply > -1 / arg1 * _taxFee / 10000:
                            revert with 0, 17
                        if not arg1 * _taxFee / 10000:
                            revert with 0, 18
                        if arg1 * _taxFee / 10000 * stor12 / totalSupply / arg1 * _taxFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                            revert with 0, 17
                        if 0 > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                            revert with 0, 17
                        else:
                            return 0
                    else:
                        return 0
                if arg1 and stor12 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor12 / totalSupply / arg1 != stor12 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _taxFee / 10000:
                    if 0 > arg1 * stor12 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor12 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor12 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor12 / totalSupply < 0:
                        revert with 0, 17
                else:
                    if arg1 * _taxFee / 10000 and stor12 / totalSupply > -1 / arg1 * _taxFee / 10000:
                        revert with 0, 17
                    if not arg1 * _taxFee / 10000:
                        revert with 0, 18
                    if arg1 * _taxFee / 10000 * stor12 / totalSupply / arg1 * _taxFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                        revert with 0, 17
                    if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                        revert with 0, 17
                    if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                        revert with 0, 17
            else:
                if arg1 and _marketingFee > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * _marketingFee / arg1 != _marketingFee:
                    revert with 0, 'SafeMath: multiplication overflow'
                mem[224] = 26
                mem[256] = 'SafeMath: division by zero'
                mem[288] = 30
                mem[320] = 'SafeMath: subtraction overflow'
                if arg1 * _taxFee / 10000 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < arg1 * _taxFee / 10000:
                    revert with 0, 17
                mem[352] = 30
                mem[384] = 'SafeMath: subtraction overflow'
                if 0 > arg1 - (arg1 * _taxFee / 10000):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * _taxFee / 10000) < 0:
                    revert with 0, 17
                mem[64] = 480
                mem[416] = 30
                mem[448] = 'SafeMath: subtraction overflow'
                if arg1 * _marketingFee / 10000 > arg1 - (arg1 * _taxFee / 10000):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * _taxFee / 10000) < arg1 * _marketingFee / 10000:
                    revert with 0, 17
                idx = 0
                s = totalSupply
                t = stor12
                while idx < stor9.length:
                    mem[0] = stor9[idx]
                    mem[32] = 3
                    if stor3[stor9[idx]] > t:
                        _9269 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9269] = 26
                        mem[_9269 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _9353 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _9353 + 68] = mem[idx + _9269 + 32]
                                idx = idx + 32
                                continue 
                            mem[_9353 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _9353 + -mem[64] + 100
                        if not arg1:
                            if not arg1 * _taxFee / 10000:
                                if not arg1 * _marketingFee / 10000:
                                    return 0
                                if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                                    revert with 0, 17
                                if not arg1 * _marketingFee / 10000:
                                    revert with 0, 18
                                if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _10329 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10329] = 30
                                mem[_10329 + 32] = 'SafeMath: subtraction overflow'
                                _11122 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11122] = 30
                                mem[_11122 + 32] = 'SafeMath: subtraction overflow'
                                _12699 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12699] = 30
                                mem[_12699 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _marketingFee / 10000 * stor12 / totalSupply <= 0:
                                    if 0 < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _13152 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _13152 + 68] = mem[idx + _12699 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13152 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13152 + -mem[64] + 100
                            if arg1 * _taxFee / 10000 and stor12 / totalSupply > -1 / arg1 * _taxFee / 10000:
                                revert with 0, 17
                            if not arg1 * _taxFee / 10000:
                                revert with 0, 18
                            if arg1 * _taxFee / 10000 * stor12 / totalSupply / arg1 * _taxFee / 10000 != stor12 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _marketingFee / 10000:
                                _10328 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10328] = 30
                                mem[_10328 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                                    _10473 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _10473 + 68] = mem[idx + _10328 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_10473 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _10473 + -mem[64] + 100
                                if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                    revert with 0, 17
                                _11120 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11120] = 30
                                mem[_11120 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                    _11418 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _11418 + 68] = mem[idx + _11120 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_11418 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _11418 + -mem[64] + 100
                                if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                                    revert with 0, 17
                                _12697 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12697] = 30
                                mem[_12697 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                    if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _13151 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _13151 + 68] = mem[idx + _12697 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13151 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13151 + -mem[64] + 100
                            if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                                revert with 0, 17
                            if not arg1 * _marketingFee / 10000:
                                revert with 0, 18
                            if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _10831 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10831] = 30
                            mem[_10831 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                                _11119 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11119 + 68] = mem[idx + _10831 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11119 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11119 + -mem[64] + 100
                            if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                revert with 0, 17
                            _12231 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12231] = 30
                            mem[_12231 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                _12696 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _12696 + 68] = mem[idx + _12231 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12696 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12696 + -mem[64] + 100
                            if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                                revert with 0, 17
                            _14274 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14274] = 30
                            mem[_14274 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _marketingFee / 10000 * stor12 / totalSupply <= -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _14788 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _14788 + 68] = mem[idx + _14274 + 32]
                                idx = idx + 32
                                continue 
                            mem[_14788 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _14788 + -mem[64] + 100
                        if arg1 and stor12 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor12 / totalSupply / arg1 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _taxFee / 10000:
                            if not arg1 * _marketingFee / 10000:
                                _10327 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10327] = 30
                                mem[_10327 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor12 / totalSupply:
                                    _10472 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _10472 + 68] = mem[idx + _10327 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_10472 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _10472 + -mem[64] + 100
                                if arg1 * stor12 / totalSupply < 0:
                                    revert with 0, 17
                                _11117 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11117] = 30
                                mem[_11117 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor12 / totalSupply:
                                    _11417 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _11417 + 68] = mem[idx + _11117 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_11417 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _11417 + -mem[64] + 100
                                if arg1 * stor12 / totalSupply < 0:
                                    revert with 0, 17
                                _12694 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12694] = 30
                                mem[_12694 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= arg1 * stor12 / totalSupply:
                                    if arg1 * stor12 / totalSupply < 0:
                                        revert with 0, 17
                                    return (arg1 * stor12 / totalSupply)
                                _13150 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _13150 + 68] = mem[idx + _12694 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13150 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13150 + -mem[64] + 100
                            if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                                revert with 0, 17
                            if not arg1 * _marketingFee / 10000:
                                revert with 0, 18
                            if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _10830 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10830] = 30
                            mem[_10830 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor12 / totalSupply:
                                _11116 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11116 + 68] = mem[idx + _10830 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11116 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11116 + -mem[64] + 100
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 0, 17
                            _12229 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12229] = 30
                            mem[_12229 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor12 / totalSupply:
                                _12693 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _12693 + 68] = mem[idx + _12229 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12693 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12693 + -mem[64] + 100
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 0, 17
                            _14272 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14272] = 30
                            mem[_14272 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _marketingFee / 10000 * stor12 / totalSupply <= arg1 * stor12 / totalSupply:
                                if arg1 * stor12 / totalSupply < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                                    revert with 0, 17
                                return (arg1 * stor12 / totalSupply)
                            _14786 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _14786 + 68] = mem[idx + _14272 + 32]
                                idx = idx + 32
                                continue 
                            mem[_14786 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _14786 + -mem[64] + 100
                        if arg1 * _taxFee / 10000 and stor12 / totalSupply > -1 / arg1 * _taxFee / 10000:
                            revert with 0, 17
                        if not arg1 * _taxFee / 10000:
                            revert with 0, 18
                        if arg1 * _taxFee / 10000 * stor12 / totalSupply / arg1 * _taxFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _marketingFee / 10000:
                            _10829 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10829] = 30
                            mem[_10829 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                                _11115 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11115 + 68] = mem[idx + _10829 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11115 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11115 + -mem[64] + 100
                            if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                revert with 0, 17
                            _12227 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12227] = 30
                            mem[_12227 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                                _12692 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _12692 + 68] = mem[idx + _12227 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12692 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12692 + -mem[64] + 100
                            if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                                revert with 0, 17
                            _14270 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14270] = 30
                            mem[_14270 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                                if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor12 / totalSupply)
                            _14785 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _14785 + 68] = mem[idx + _14270 + 32]
                                idx = idx + 32
                                continue 
                            mem[_14785 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _14785 + -mem[64] + 100
                        if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                            revert with 0, 17
                        if not arg1 * _marketingFee / 10000:
                            revert with 0, 18
                        if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _11775 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11775] = 30
                        mem[_11775 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                            _12226 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12226 + 68] = mem[idx + _11775 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12226 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12226 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                            revert with 0, 17
                        _13672 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13672] = 30
                        mem[_13672 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                            _14269 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _14269 + 68] = mem[idx + _13672 + 32]
                                idx = idx + 32
                                continue 
                            mem[_14269 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _14269 + -mem[64] + 100
                        if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                            revert with 0, 17
                        _15880 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_15880] = 30
                        mem[_15880 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _marketingFee / 10000 * stor12 / totalSupply <= (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                            if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor12 / totalSupply)
                        _16348 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _16348 + 68] = mem[idx + _15880 + 32]
                            idx = idx + 32
                            continue 
                        mem[_16348 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _16348 + -mem[64] + 100
                    if idx >= stor9.length:
                        revert with 0, 50
                    mem[0] = stor9[idx]
                    mem[32] = 4
                    if stor4[stor9[idx]] <= s:
                        if idx >= stor9.length:
                            revert with 0, 50
                        mem[0] = stor9[idx]
                        mem[32] = 3
                        _9354 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9354] = 30
                        mem[_9354 + 32] = 'SafeMath: subtraction overflow'
                        if stor3[stor9[idx]] > t:
                            _9434 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _9434 + 68] = mem[idx + _9354 + 32]
                                idx = idx + 32
                                continue 
                            mem[_9434 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _9434 + -mem[64] + 100
                        if t < stor3[stor9[idx]]:
                            revert with 0, 17
                        if idx >= stor9.length:
                            revert with 0, 50
                        mem[0] = stor9[idx]
                        mem[32] = 4
                        _9787 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9787] = 30
                        mem[_9787 + 32] = 'SafeMath: subtraction overflow'
                        if stor4[stor9[idx]] <= s:
                            if s < stor4[stor9[idx]]:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s - stor4[stor9[idx]]
                            t = t - stor3[stor9[idx]]
                            continue 
                        _9835 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _9835 + 68] = mem[idx + _9787 + 32]
                            idx = idx + 32
                            continue 
                        mem[_9835 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _9835 + -mem[64] + 100
                    _9355 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9355] = 26
                    mem[_9355 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _9435 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _9435 + 68] = mem[idx + _9355 + 32]
                            idx = idx + 32
                            continue 
                        mem[_9435 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _9435 + -mem[64] + 100
                    if not arg1:
                        if not arg1 * _taxFee / 10000:
                            if not arg1 * _marketingFee / 10000:
                                return 0
                            if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                                revert with 0, 17
                            if not arg1 * _marketingFee / 10000:
                                revert with 0, 18
                            if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _10477 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10477] = 30
                            mem[_10477 + 32] = 'SafeMath: subtraction overflow'
                            _11427 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11427] = 30
                            mem[_11427 + 32] = 'SafeMath: subtraction overflow'
                            _13160 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13160] = 30
                            mem[_13160 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _marketingFee / 10000 * stor12 / totalSupply <= 0:
                                if 0 < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _13677 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13677 + 68] = mem[idx + _13160 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13677 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13677 + -mem[64] + 100
                        if arg1 * _taxFee / 10000 and stor12 / totalSupply > -1 / arg1 * _taxFee / 10000:
                            revert with 0, 17
                        if not arg1 * _taxFee / 10000:
                            revert with 0, 18
                        if arg1 * _taxFee / 10000 * stor12 / totalSupply / arg1 * _taxFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _marketingFee / 10000:
                            _10476 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10476] = 30
                            mem[_10476 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                                _10607 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _10607 + 68] = mem[idx + _10476 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_10607 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _10607 + -mem[64] + 100
                            if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                revert with 0, 17
                            _11425 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11425] = 30
                            mem[_11425 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                _11778 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11778 + 68] = mem[idx + _11425 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11778 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11778 + -mem[64] + 100
                            if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                                revert with 0, 17
                            _13158 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13158] = 30
                            mem[_13158 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                                    revert with 0, 17
                                else:
                                    return 0
                            _13676 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13676 + 68] = mem[idx + _13158 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13676 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13676 + -mem[64] + 100
                        if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                            revert with 0, 17
                        if not arg1 * _marketingFee / 10000:
                            revert with 0, 18
                        if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _11125 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11125] = 30
                        mem[_11125 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                            _11424 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11424 + 68] = mem[idx + _11125 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11424 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11424 + -mem[64] + 100
                        if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                            revert with 0, 17
                        _12705 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12705] = 30
                        mem[_12705 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                            _13157 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13157 + 68] = mem[idx + _12705 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13157 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13157 + -mem[64] + 100
                        if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                            revert with 0, 17
                        _14796 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14796] = 30
                        mem[_14796 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _marketingFee / 10000 * stor12 / totalSupply <= -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                            if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                                revert with 0, 17
                            else:
                                return 0
                        _15304 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _15304 + 68] = mem[idx + _14796 + 32]
                            idx = idx + 32
                            continue 
                        mem[_15304 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _15304 + -mem[64] + 100
                    if arg1 and stor12 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor12 / totalSupply / arg1 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _taxFee / 10000:
                        if not arg1 * _marketingFee / 10000:
                            _10475 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10475] = 30
                            mem[_10475 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor12 / totalSupply:
                                _10606 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _10606 + 68] = mem[idx + _10475 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_10606 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _10606 + -mem[64] + 100
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 0, 17
                            _11422 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11422] = 30
                            mem[_11422 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor12 / totalSupply:
                                _11777 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11777 + 68] = mem[idx + _11422 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11777 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11777 + -mem[64] + 100
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 0, 17
                            _13155 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13155] = 30
                            mem[_13155 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor12 / totalSupply:
                                if arg1 * stor12 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor12 / totalSupply)
                            _13675 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13675 + 68] = mem[idx + _13155 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13675 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13675 + -mem[64] + 100
                        if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                            revert with 0, 17
                        if not arg1 * _marketingFee / 10000:
                            revert with 0, 18
                        if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _11124 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11124] = 30
                        mem[_11124 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor12 / totalSupply:
                            _11421 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11421 + 68] = mem[idx + _11124 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11421 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11421 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 0, 17
                        _12703 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12703] = 30
                        mem[_12703 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor12 / totalSupply:
                            _13154 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13154 + 68] = mem[idx + _12703 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13154 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13154 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 0, 17
                        _14794 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14794] = 30
                        mem[_14794 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _marketingFee / 10000 * stor12 / totalSupply <= arg1 * stor12 / totalSupply:
                            if arg1 * stor12 / totalSupply < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor12 / totalSupply)
                        _15302 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _15302 + 68] = mem[idx + _14794 + 32]
                            idx = idx + 32
                            continue 
                        mem[_15302 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _15302 + -mem[64] + 100
                    if arg1 * _taxFee / 10000 and stor12 / totalSupply > -1 / arg1 * _taxFee / 10000:
                        revert with 0, 17
                    if not arg1 * _taxFee / 10000:
                        revert with 0, 18
                    if arg1 * _taxFee / 10000 * stor12 / totalSupply / arg1 * _taxFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _marketingFee / 10000:
                        _11123 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11123] = 30
                        mem[_11123 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                            _11420 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11420 + 68] = mem[idx + _11123 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11420 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11420 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                            revert with 0, 17
                        _12701 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12701] = 30
                        mem[_12701 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                            _13153 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13153 + 68] = mem[idx + _12701 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13153 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13153 + -mem[64] + 100
                        if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                            revert with 0, 17
                        _14792 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14792] = 30
                        mem[_14792 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                            if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                                revert with 0, 17
                            return (arg1 * stor12 / totalSupply)
                        _15301 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _15301 + 68] = mem[idx + _14792 + 32]
                            idx = idx + 32
                            continue 
                        mem[_15301 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _15301 + -mem[64] + 100
                    if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                        revert with 0, 17
                    if not arg1 * _marketingFee / 10000:
                        revert with 0, 18
                    if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _12233 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12233] = 30
                    mem[_12233 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                        _12700 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _12700 + 68] = mem[idx + _12233 + 32]
                            idx = idx + 32
                            continue 
                        mem[_12700 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _12700 + -mem[64] + 100
                    if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                        revert with 0, 17
                    _14276 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14276] = 30
                    mem[_14276 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                        _14791 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _14791 + 68] = mem[idx + _14276 + 32]
                            idx = idx + 32
                            continue 
                        mem[_14791 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14791 + -mem[64] + 100
                    if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                        revert with 0, 17
                    _16352 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_16352] = 30
                    mem[_16352 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _marketingFee / 10000 * stor12 / totalSupply <= (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                        if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                            revert with 0, 17
                        return (arg1 * stor12 / totalSupply)
                    _16690 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _16690 + 68] = mem[idx + _16352 + 32]
                        idx = idx + 32
                        continue 
                    mem[_16690 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _16690 + -mem[64] + 100
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if t >= stor12 / totalSupply:
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg1:
                        if not arg1 * _taxFee / 10000:
                            if arg1 * _marketingFee / 10000:
                                if arg1 * _marketingFee / 10000 and t / s > -1 / arg1 * _marketingFee / 10000:
                                    revert with 0, 17
                                if not arg1 * _marketingFee / 10000:
                                    revert with 0, 18
                                if arg1 * _marketingFee / 10000 * t / s / arg1 * _marketingFee / 10000 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _marketingFee / 10000 * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _marketingFee / 10000 * t / s:
                                    revert with 0, 17
                        else:
                            if arg1 * _taxFee / 10000 and t / s > -1 / arg1 * _taxFee / 10000:
                                revert with 0, 17
                            if not arg1 * _taxFee / 10000:
                                revert with 0, 18
                            if arg1 * _taxFee / 10000 * t / s / arg1 * _taxFee / 10000 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _marketingFee / 10000:
                                if arg1 * _taxFee / 10000 * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _taxFee / 10000 * t / s:
                                    revert with 0, 17
                                if 0 > -1 * arg1 * _taxFee / 10000 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _taxFee / 10000 * t / s < 0:
                                    revert with 0, 17
                                if 0 > -1 * arg1 * _taxFee / 10000 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _taxFee / 10000 * t / s < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * _marketingFee / 10000 and t / s > -1 / arg1 * _marketingFee / 10000:
                                    revert with 0, 17
                                if not arg1 * _marketingFee / 10000:
                                    revert with 0, 18
                                if arg1 * _marketingFee / 10000 * t / s / arg1 * _marketingFee / 10000 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _taxFee / 10000 * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _taxFee / 10000 * t / s:
                                    revert with 0, 17
                                if 0 > -1 * arg1 * _taxFee / 10000 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _taxFee / 10000 * t / s < 0:
                                    revert with 0, 17
                                if arg1 * _marketingFee / 10000 * t / s > -1 * arg1 * _taxFee / 10000 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _taxFee / 10000 * t / s < arg1 * _marketingFee / 10000 * t / s:
                                    revert with 0, 17
                        return 0
                    if arg1 and t / s > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _taxFee / 10000:
                        if not arg1 * _marketingFee / 10000:
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                        else:
                            if arg1 * _marketingFee / 10000 and t / s > -1 / arg1 * _marketingFee / 10000:
                                revert with 0, 17
                            if not arg1 * _marketingFee / 10000:
                                revert with 0, 18
                            if arg1 * _marketingFee / 10000 * t / s / arg1 * _marketingFee / 10000 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if arg1 * _marketingFee / 10000 * t / s > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < arg1 * _marketingFee / 10000 * t / s:
                                revert with 0, 17
                    else:
                        if arg1 * _taxFee / 10000 and t / s > -1 / arg1 * _taxFee / 10000:
                            revert with 0, 17
                        if not arg1 * _taxFee / 10000:
                            revert with 0, 18
                        if arg1 * _taxFee / 10000 * t / s / arg1 * _taxFee / 10000 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _marketingFee / 10000:
                            if arg1 * _taxFee / 10000 * t / s > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < arg1 * _taxFee / 10000 * t / s:
                                revert with 0, 17
                            if 0 > (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s) < 0:
                                revert with 0, 17
                            if 0 > (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s) < 0:
                                revert with 0, 17
                        else:
                            if arg1 * _marketingFee / 10000 and t / s > -1 / arg1 * _marketingFee / 10000:
                                revert with 0, 17
                            if not arg1 * _marketingFee / 10000:
                                revert with 0, 18
                            if arg1 * _marketingFee / 10000 * t / s / arg1 * _marketingFee / 10000 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * _taxFee / 10000 * t / s > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < arg1 * _taxFee / 10000 * t / s:
                                revert with 0, 17
                            if 0 > (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s) < 0:
                                revert with 0, 17
                            if arg1 * _marketingFee / 10000 * t / s > (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s) < arg1 * _marketingFee / 10000 * t / s:
                                revert with 0, 17
                    return (arg1 * t / s)
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if not arg1 * _taxFee / 10000:
                        if arg1 * _marketingFee / 10000:
                            if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                                revert with 0, 17
                            if not arg1 * _marketingFee / 10000:
                                revert with 0, 18
                            if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * _marketingFee / 10000 * stor12 / totalSupply > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                                revert with 0, 17
                    else:
                        if arg1 * _taxFee / 10000 and stor12 / totalSupply > -1 / arg1 * _taxFee / 10000:
                            revert with 0, 17
                        if not arg1 * _taxFee / 10000:
                            revert with 0, 18
                        if arg1 * _taxFee / 10000 * stor12 / totalSupply / arg1 * _taxFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _marketingFee / 10000:
                            if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                revert with 0, 17
                            if 0 > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                                revert with 0, 17
                            if 0 > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                                revert with 0, 17
                        else:
                            if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                                revert with 0, 17
                            if not arg1 * _marketingFee / 10000:
                                revert with 0, 18
                            if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                revert with 0, 17
                            if 0 > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                                revert with 0, 17
                            if arg1 * _marketingFee / 10000 * stor12 / totalSupply > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                                revert with 0, 17
                    return 0
                if arg1 and stor12 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor12 / totalSupply / arg1 != stor12 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _taxFee / 10000:
                    if not arg1 * _marketingFee / 10000:
                        if 0 > arg1 * stor12 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > arg1 * stor12 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > arg1 * stor12 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 0, 17
                    else:
                        if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                            revert with 0, 17
                        if not arg1 * _marketingFee / 10000:
                            revert with 0, 18
                        if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 > arg1 * stor12 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > arg1 * stor12 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 0, 17
                        if arg1 * _marketingFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor12 / totalSupply < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                            revert with 0, 17
                else:
                    if arg1 * _taxFee / 10000 and stor12 / totalSupply > -1 / arg1 * _taxFee / 10000:
                        revert with 0, 17
                    if not arg1 * _taxFee / 10000:
                        revert with 0, 18
                    if arg1 * _taxFee / 10000 * stor12 / totalSupply / arg1 * _taxFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _marketingFee / 10000:
                        if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                            revert with 0, 17
                        if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                            revert with 0, 17
                        if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                            revert with 0, 17
                    else:
                        if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                            revert with 0, 17
                        if not arg1 * _marketingFee / 10000:
                            revert with 0, 18
                        if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                            revert with 0, 17
                        if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                            revert with 0, 17
                        if arg1 * _marketingFee / 10000 * stor12 / totalSupply > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                            revert with 0, 17
        else:
            if arg1 and _liquidityFee > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * _liquidityFee / arg1 != _liquidityFee:
                revert with 0, 'SafeMath: multiplication overflow'
            mem[160] = 26
            mem[192] = 'SafeMath: division by zero'
            if not arg1:
                mem[224] = 26
                mem[256] = 'SafeMath: division by zero'
                mem[288] = 30
                mem[320] = 'SafeMath: subtraction overflow'
                if arg1 * _taxFee / 10000 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < arg1 * _taxFee / 10000:
                    revert with 0, 17
                mem[352] = 30
                mem[384] = 'SafeMath: subtraction overflow'
                if arg1 * _liquidityFee / 10000 > arg1 - (arg1 * _taxFee / 10000):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * _taxFee / 10000) < arg1 * _liquidityFee / 10000:
                    revert with 0, 17
                mem[64] = 480
                mem[416] = 30
                mem[448] = 'SafeMath: subtraction overflow'
                if 0 > arg1 - (arg1 * _taxFee / 10000) - (arg1 * _liquidityFee / 10000):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * _taxFee / 10000) - (arg1 * _liquidityFee / 10000) < 0:
                    revert with 0, 17
                idx = 0
                s = totalSupply
                t = stor12
                while idx < stor9.length:
                    mem[0] = stor9[idx]
                    mem[32] = 3
                    if stor3[stor9[idx]] > t:
                        _9268 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9268] = 26
                        mem[_9268 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _9350 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _9350 + 68] = mem[idx + _9268 + 32]
                                idx = idx + 32
                                continue 
                            mem[_9350 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _9350 + -mem[64] + 100
                        if not arg1:
                            if not arg1 * _taxFee / 10000:
                                if not arg1 * _liquidityFee / 10000:
                                    return 0
                                if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                                    revert with 0, 17
                                if not arg1 * _liquidityFee / 10000:
                                    revert with 0, 18
                                if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _10324 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10324] = 30
                                mem[_10324 + 32] = 'SafeMath: subtraction overflow'
                                _11104 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11104] = 30
                                mem[_11104 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > 0:
                                    _11402 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _11402 + 68] = mem[idx + _11104 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_11402 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _11402 + -mem[64] + 100
                                if 0 < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                    revert with 0, 17
                                _12675 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12675] = 30
                                mem[_12675 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                    if -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _13138 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _13138 + 68] = mem[idx + _12675 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13138 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13138 + -mem[64] + 100
                            if arg1 * _taxFee / 10000 and stor12 / totalSupply > -1 / arg1 * _taxFee / 10000:
                                revert with 0, 17
                            if not arg1 * _taxFee / 10000:
                                revert with 0, 18
                            if arg1 * _taxFee / 10000 * stor12 / totalSupply / arg1 * _taxFee / 10000 != stor12 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _liquidityFee / 10000:
                                _10323 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10323] = 30
                                mem[_10323 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                                    _10463 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _10463 + 68] = mem[idx + _10323 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_10463 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _10463 + -mem[64] + 100
                                if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                    revert with 0, 17
                                _11102 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11102] = 30
                                mem[_11102 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                    _11401 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _11401 + 68] = mem[idx + _11102 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_11401 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _11401 + -mem[64] + 100
                                if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                                    revert with 0, 17
                                _12673 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12673] = 30
                                mem[_12673 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                    if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _13137 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _13137 + 68] = mem[idx + _12673 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13137 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13137 + -mem[64] + 100
                            if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                                revert with 0, 17
                            if not arg1 * _liquidityFee / 10000:
                                revert with 0, 18
                            if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _10822 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10822] = 30
                            mem[_10822 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                                _11101 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11101 + 68] = mem[idx + _10822 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11101 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11101 + -mem[64] + 100
                            if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                revert with 0, 17
                            _12207 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12207] = 30
                            mem[_12207 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                _12672 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _12672 + 68] = mem[idx + _12207 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12672 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12672 + -mem[64] + 100
                            if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                revert with 0, 17
                            _14248 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14248] = 30
                            mem[_14248 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                                if (-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < 0:
                                    revert with 0, 17
                                else:
                                    return 0
                            _14769 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _14769 + 68] = mem[idx + _14248 + 32]
                                idx = idx + 32
                                continue 
                            mem[_14769 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _14769 + -mem[64] + 100
                        if arg1 and stor12 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor12 / totalSupply / arg1 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _taxFee / 10000:
                            if not arg1 * _liquidityFee / 10000:
                                _10321 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10321] = 30
                                mem[_10321 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor12 / totalSupply:
                                    _10462 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _10462 + 68] = mem[idx + _10321 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_10462 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _10462 + -mem[64] + 100
                                if arg1 * stor12 / totalSupply < 0:
                                    revert with 0, 17
                                _11099 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11099] = 30
                                mem[_11099 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor12 / totalSupply:
                                    _11400 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _11400 + 68] = mem[idx + _11099 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_11400 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _11400 + -mem[64] + 100
                                if arg1 * stor12 / totalSupply < 0:
                                    revert with 0, 17
                                _12670 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12670] = 30
                                mem[_12670 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= arg1 * stor12 / totalSupply:
                                    if arg1 * stor12 / totalSupply < 0:
                                        revert with 0, 17
                                    return (arg1 * stor12 / totalSupply)
                                _13136 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _13136 + 68] = mem[idx + _12670 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13136 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13136 + -mem[64] + 100
                            if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                                revert with 0, 17
                            if not arg1 * _liquidityFee / 10000:
                                revert with 0, 18
                            if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _10821 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10821] = 30
                            mem[_10821 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor12 / totalSupply:
                                _11098 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11098 + 68] = mem[idx + _10821 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11098 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11098 + -mem[64] + 100
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 0, 17
                            _12205 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12205] = 30
                            mem[_12205 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                                _12669 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _12669 + 68] = mem[idx + _12205 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12669 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12669 + -mem[64] + 100
                            if arg1 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                revert with 0, 17
                            _14246 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14246] = 30
                            mem[_14246 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                                if (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor12 / totalSupply)
                            _14767 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _14767 + 68] = mem[idx + _14246 + 32]
                                idx = idx + 32
                                continue 
                            mem[_14767 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _14767 + -mem[64] + 100
                        if arg1 * _taxFee / 10000 and stor12 / totalSupply > -1 / arg1 * _taxFee / 10000:
                            revert with 0, 17
                        if not arg1 * _taxFee / 10000:
                            revert with 0, 18
                        if arg1 * _taxFee / 10000 * stor12 / totalSupply / arg1 * _taxFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _liquidityFee / 10000:
                            _10820 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10820] = 30
                            mem[_10820 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                                _11097 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11097 + 68] = mem[idx + _10820 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11097 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11097 + -mem[64] + 100
                            if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                revert with 0, 17
                            _12203 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12203] = 30
                            mem[_12203 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                                _12668 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _12668 + 68] = mem[idx + _12203 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12668 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12668 + -mem[64] + 100
                            if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                                revert with 0, 17
                            _14244 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14244] = 30
                            mem[_14244 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                                if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor12 / totalSupply)
                            _14766 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _14766 + 68] = mem[idx + _14244 + 32]
                                idx = idx + 32
                                continue 
                            mem[_14766 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _14766 + -mem[64] + 100
                        if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                            revert with 0, 17
                        if not arg1 * _liquidityFee / 10000:
                            revert with 0, 18
                        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _11764 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11764] = 30
                        mem[_11764 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                            _12202 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12202 + 68] = mem[idx + _11764 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12202 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12202 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                            revert with 0, 17
                        _13652 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13652] = 30
                        mem[_13652 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                            _14243 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _14243 + 68] = mem[idx + _13652 + 32]
                                idx = idx + 32
                                continue 
                            mem[_14243 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _14243 + -mem[64] + 100
                        if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                            revert with 0, 17
                        _15861 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_15861] = 30
                        mem[_15861 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                            if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < 0:
                                revert with 0, 17
                            return (arg1 * stor12 / totalSupply)
                        _16330 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _16330 + 68] = mem[idx + _15861 + 32]
                            idx = idx + 32
                            continue 
                        mem[_16330 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _16330 + -mem[64] + 100
                    if idx >= stor9.length:
                        revert with 0, 50
                    mem[0] = stor9[idx]
                    mem[32] = 4
                    if stor4[stor9[idx]] <= s:
                        if idx >= stor9.length:
                            revert with 0, 50
                        mem[0] = stor9[idx]
                        mem[32] = 3
                        _9351 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9351] = 30
                        mem[_9351 + 32] = 'SafeMath: subtraction overflow'
                        if stor3[stor9[idx]] > t:
                            _9431 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _9431 + 68] = mem[idx + _9351 + 32]
                                idx = idx + 32
                                continue 
                            mem[_9431 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _9431 + -mem[64] + 100
                        if t < stor3[stor9[idx]]:
                            revert with 0, 17
                        if idx >= stor9.length:
                            revert with 0, 50
                        mem[0] = stor9[idx]
                        mem[32] = 4
                        _9784 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9784] = 30
                        mem[_9784 + 32] = 'SafeMath: subtraction overflow'
                        if stor4[stor9[idx]] <= s:
                            if s < stor4[stor9[idx]]:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s - stor4[stor9[idx]]
                            t = t - stor3[stor9[idx]]
                            continue 
                        _9832 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _9832 + 68] = mem[idx + _9784 + 32]
                            idx = idx + 32
                            continue 
                        mem[_9832 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _9832 + -mem[64] + 100
                    _9352 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9352] = 26
                    mem[_9352 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _9432 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _9432 + 68] = mem[idx + _9352 + 32]
                            idx = idx + 32
                            continue 
                        mem[_9432 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _9432 + -mem[64] + 100
                    if not arg1:
                        if not arg1 * _taxFee / 10000:
                            if not arg1 * _liquidityFee / 10000:
                                return 0
                            if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                                revert with 0, 17
                            if not arg1 * _liquidityFee / 10000:
                                revert with 0, 18
                            if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _10469 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10469] = 30
                            mem[_10469 + 32] = 'SafeMath: subtraction overflow'
                            _11411 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11411] = 30
                            mem[_11411 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > 0:
                                _11767 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11767 + 68] = mem[idx + _11411 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11767 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11767 + -mem[64] + 100
                            if 0 < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                revert with 0, 17
                            _13146 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13146] = 30
                            mem[_13146 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                if -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply < 0:
                                    revert with 0, 17
                                else:
                                    return 0
                            _13657 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13657 + 68] = mem[idx + _13146 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13657 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13657 + -mem[64] + 100
                        if arg1 * _taxFee / 10000 and stor12 / totalSupply > -1 / arg1 * _taxFee / 10000:
                            revert with 0, 17
                        if not arg1 * _taxFee / 10000:
                            revert with 0, 18
                        if arg1 * _taxFee / 10000 * stor12 / totalSupply / arg1 * _taxFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _liquidityFee / 10000:
                            _10468 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10468] = 30
                            mem[_10468 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                                _10600 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _10600 + 68] = mem[idx + _10468 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_10600 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _10600 + -mem[64] + 100
                            if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                revert with 0, 17
                            _11409 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11409] = 30
                            mem[_11409 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                _11766 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11766 + 68] = mem[idx + _11409 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11766 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11766 + -mem[64] + 100
                            if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                                revert with 0, 17
                            _13144 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13144] = 30
                            mem[_13144 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                                    revert with 0, 17
                                else:
                                    return 0
                            _13656 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13656 + 68] = mem[idx + _13144 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13656 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13656 + -mem[64] + 100
                        if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                            revert with 0, 17
                        if not arg1 * _liquidityFee / 10000:
                            revert with 0, 18
                        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _11108 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11108] = 30
                        mem[_11108 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                            _11408 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11408 + 68] = mem[idx + _11108 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11408 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11408 + -mem[64] + 100
                        if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                            revert with 0, 17
                        _12682 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12682] = 30
                        mem[_12682 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                            _13143 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13143 + 68] = mem[idx + _12682 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13143 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13143 + -mem[64] + 100
                        if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                            revert with 0, 17
                        _14777 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14777] = 30
                        mem[_14777 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                            if (-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < 0:
                                revert with 0, 17
                            else:
                                return 0
                        _15289 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _15289 + 68] = mem[idx + _14777 + 32]
                            idx = idx + 32
                            continue 
                        mem[_15289 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _15289 + -mem[64] + 100
                    if arg1 and stor12 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor12 / totalSupply / arg1 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _taxFee / 10000:
                        if not arg1 * _liquidityFee / 10000:
                            _10466 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_10466] = 30
                            mem[_10466 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor12 / totalSupply:
                                _10599 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _10599 + 68] = mem[idx + _10466 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_10599 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _10599 + -mem[64] + 100
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 0, 17
                            _11406 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11406] = 30
                            mem[_11406 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor12 / totalSupply:
                                _11765 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11765 + 68] = mem[idx + _11406 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11765 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11765 + -mem[64] + 100
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 0, 17
                            _13141 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13141] = 30
                            mem[_13141 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor12 / totalSupply:
                                if arg1 * stor12 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor12 / totalSupply)
                            _13655 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13655 + 68] = mem[idx + _13141 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13655 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13655 + -mem[64] + 100
                        if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                            revert with 0, 17
                        if not arg1 * _liquidityFee / 10000:
                            revert with 0, 18
                        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _11107 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11107] = 30
                        mem[_11107 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor12 / totalSupply:
                            _11405 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11405 + 68] = mem[idx + _11107 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11405 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11405 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 0, 17
                        _12680 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12680] = 30
                        mem[_12680 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                            _13140 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13140 + 68] = mem[idx + _12680 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13140 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13140 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                            revert with 0, 17
                        _14775 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14775] = 30
                        mem[_14775 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                            if (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < 0:
                                revert with 0, 17
                            return (arg1 * stor12 / totalSupply)
                        _15287 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _15287 + 68] = mem[idx + _14775 + 32]
                            idx = idx + 32
                            continue 
                        mem[_15287 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _15287 + -mem[64] + 100
                    if arg1 * _taxFee / 10000 and stor12 / totalSupply > -1 / arg1 * _taxFee / 10000:
                        revert with 0, 17
                    if not arg1 * _taxFee / 10000:
                        revert with 0, 18
                    if arg1 * _taxFee / 10000 * stor12 / totalSupply / arg1 * _taxFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _liquidityFee / 10000:
                        _11106 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11106] = 30
                        mem[_11106 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                            _11404 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11404 + 68] = mem[idx + _11106 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11404 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11404 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                            revert with 0, 17
                        _12678 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12678] = 30
                        mem[_12678 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                            _13139 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13139 + 68] = mem[idx + _12678 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13139 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13139 + -mem[64] + 100
                        if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                            revert with 0, 17
                        _14773 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14773] = 30
                        mem[_14773 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                            if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                                revert with 0, 17
                            return (arg1 * stor12 / totalSupply)
                        _15286 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _15286 + 68] = mem[idx + _14773 + 32]
                            idx = idx + 32
                            continue 
                        mem[_15286 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _15286 + -mem[64] + 100
                    if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                        revert with 0, 17
                    if not arg1 * _liquidityFee / 10000:
                        revert with 0, 18
                    if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _12209 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12209] = 30
                    mem[_12209 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                        _12677 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _12677 + 68] = mem[idx + _12209 + 32]
                            idx = idx + 32
                            continue 
                        mem[_12677 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _12677 + -mem[64] + 100
                    if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                        revert with 0, 17
                    _14250 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14250] = 30
                    mem[_14250 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                        _14772 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _14772 + 68] = mem[idx + _14250 + 32]
                            idx = idx + 32
                            continue 
                        mem[_14772 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14772 + -mem[64] + 100
                    if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                        revert with 0, 17
                    _16334 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_16334] = 30
                    mem[_16334 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                        if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < 0:
                            revert with 0, 17
                        return (arg1 * stor12 / totalSupply)
                    _16677 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _16677 + 68] = mem[idx + _16334 + 32]
                        idx = idx + 32
                        continue 
                    mem[_16677 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _16677 + -mem[64] + 100
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if t >= stor12 / totalSupply:
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg1:
                        if not arg1 * _taxFee / 10000:
                            if arg1 * _liquidityFee / 10000:
                                if arg1 * _liquidityFee / 10000 and t / s > -1 / arg1 * _liquidityFee / 10000:
                                    revert with 0, 17
                                if not arg1 * _liquidityFee / 10000:
                                    revert with 0, 18
                                if arg1 * _liquidityFee / 10000 * t / s / arg1 * _liquidityFee / 10000 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _liquidityFee / 10000 * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _liquidityFee / 10000 * t / s:
                                    revert with 0, 17
                                if 0 > -1 * arg1 * _liquidityFee / 10000 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _liquidityFee / 10000 * t / s < 0:
                                    revert with 0, 17
                        else:
                            if arg1 * _taxFee / 10000 and t / s > -1 / arg1 * _taxFee / 10000:
                                revert with 0, 17
                            if not arg1 * _taxFee / 10000:
                                revert with 0, 18
                            if arg1 * _taxFee / 10000 * t / s / arg1 * _taxFee / 10000 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _liquidityFee / 10000:
                                if arg1 * _taxFee / 10000 * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _taxFee / 10000 * t / s:
                                    revert with 0, 17
                                if 0 > -1 * arg1 * _taxFee / 10000 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _taxFee / 10000 * t / s < 0:
                                    revert with 0, 17
                                if 0 > -1 * arg1 * _taxFee / 10000 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _taxFee / 10000 * t / s < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * _liquidityFee / 10000 and t / s > -1 / arg1 * _liquidityFee / 10000:
                                    revert with 0, 17
                                if not arg1 * _liquidityFee / 10000:
                                    revert with 0, 18
                                if arg1 * _liquidityFee / 10000 * t / s / arg1 * _liquidityFee / 10000 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _taxFee / 10000 * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _taxFee / 10000 * t / s:
                                    revert with 0, 17
                                if arg1 * _liquidityFee / 10000 * t / s > -1 * arg1 * _taxFee / 10000 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _taxFee / 10000 * t / s < arg1 * _liquidityFee / 10000 * t / s:
                                    revert with 0, 17
                                if 0 > (-1 * arg1 * _taxFee / 10000 * t / s) - (arg1 * _liquidityFee / 10000 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (-1 * arg1 * _taxFee / 10000 * t / s) - (arg1 * _liquidityFee / 10000 * t / s) < 0:
                                    revert with 0, 17
                        return 0
                    if arg1 and t / s > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _taxFee / 10000:
                        if not arg1 * _liquidityFee / 10000:
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                        else:
                            if arg1 * _liquidityFee / 10000 and t / s > -1 / arg1 * _liquidityFee / 10000:
                                revert with 0, 17
                            if not arg1 * _liquidityFee / 10000:
                                revert with 0, 18
                            if arg1 * _liquidityFee / 10000 * t / s / arg1 * _liquidityFee / 10000 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if arg1 * _liquidityFee / 10000 * t / s > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < arg1 * _liquidityFee / 10000 * t / s:
                                revert with 0, 17
                            if 0 > (arg1 * t / s) - (arg1 * _liquidityFee / 10000 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (arg1 * _liquidityFee / 10000 * t / s) < 0:
                                revert with 0, 17
                    else:
                        if arg1 * _taxFee / 10000 and t / s > -1 / arg1 * _taxFee / 10000:
                            revert with 0, 17
                        if not arg1 * _taxFee / 10000:
                            revert with 0, 18
                        if arg1 * _taxFee / 10000 * t / s / arg1 * _taxFee / 10000 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _liquidityFee / 10000:
                            if arg1 * _taxFee / 10000 * t / s > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < arg1 * _taxFee / 10000 * t / s:
                                revert with 0, 17
                            if 0 > (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s) < 0:
                                revert with 0, 17
                            if 0 > (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s) < 0:
                                revert with 0, 17
                        else:
                            if arg1 * _liquidityFee / 10000 and t / s > -1 / arg1 * _liquidityFee / 10000:
                                revert with 0, 17
                            if not arg1 * _liquidityFee / 10000:
                                revert with 0, 18
                            if arg1 * _liquidityFee / 10000 * t / s / arg1 * _liquidityFee / 10000 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * _taxFee / 10000 * t / s > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < arg1 * _taxFee / 10000 * t / s:
                                revert with 0, 17
                            if arg1 * _liquidityFee / 10000 * t / s > (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s) < arg1 * _liquidityFee / 10000 * t / s:
                                revert with 0, 17
                            if 0 > (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s) - (arg1 * _liquidityFee / 10000 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s) - (arg1 * _liquidityFee / 10000 * t / s) < 0:
                                revert with 0, 17
                    return (arg1 * t / s)
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if not arg1 * _taxFee / 10000:
                        if arg1 * _liquidityFee / 10000:
                            if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                                revert with 0, 17
                            if not arg1 * _liquidityFee / 10000:
                                revert with 0, 18
                            if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                revert with 0, 17
                            if 0 > -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply < 0:
                                revert with 0, 17
                    else:
                        if arg1 * _taxFee / 10000 and stor12 / totalSupply > -1 / arg1 * _taxFee / 10000:
                            revert with 0, 17
                        if not arg1 * _taxFee / 10000:
                            revert with 0, 18
                        if arg1 * _taxFee / 10000 * stor12 / totalSupply / arg1 * _taxFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _liquidityFee / 10000:
                            if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                revert with 0, 17
                            if 0 > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                                revert with 0, 17
                            if 0 > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                                revert with 0, 17
                        else:
                            if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                                revert with 0, 17
                            if not arg1 * _liquidityFee / 10000:
                                revert with 0, 18
                            if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                revert with 0, 17
                            if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                revert with 0, 17
                            if 0 > (-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < 0:
                                revert with 0, 17
                    return 0
                if arg1 and stor12 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor12 / totalSupply / arg1 != stor12 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _taxFee / 10000:
                    if not arg1 * _liquidityFee / 10000:
                        if 0 > arg1 * stor12 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > arg1 * stor12 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > arg1 * stor12 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 0, 17
                    else:
                        if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                            revert with 0, 17
                        if not arg1 * _liquidityFee / 10000:
                            revert with 0, 18
                        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 > arg1 * stor12 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 0, 17
                        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                            revert with 0, 17
                        if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < 0:
                            revert with 0, 17
                else:
                    if arg1 * _taxFee / 10000 and stor12 / totalSupply > -1 / arg1 * _taxFee / 10000:
                        revert with 0, 17
                    if not arg1 * _taxFee / 10000:
                        revert with 0, 18
                    if arg1 * _taxFee / 10000 * stor12 / totalSupply / arg1 * _taxFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _liquidityFee / 10000:
                        if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                            revert with 0, 17
                        if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                            revert with 0, 17
                        if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                            revert with 0, 17
                    else:
                        if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                            revert with 0, 17
                        if not arg1 * _liquidityFee / 10000:
                            revert with 0, 18
                        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                            revert with 0, 17
                        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                            revert with 0, 17
                        if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < 0:
                            revert with 0, 17
            else:
                if arg1 and _marketingFee > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * _marketingFee / arg1 != _marketingFee:
                    revert with 0, 'SafeMath: multiplication overflow'
                mem[224] = 26
                mem[256] = 'SafeMath: division by zero'
                mem[288] = 30
                mem[320] = 'SafeMath: subtraction overflow'
                if arg1 * _taxFee / 10000 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < arg1 * _taxFee / 10000:
                    revert with 0, 17
                mem[352] = 30
                mem[384] = 'SafeMath: subtraction overflow'
                if arg1 * _liquidityFee / 10000 > arg1 - (arg1 * _taxFee / 10000):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * _taxFee / 10000) < arg1 * _liquidityFee / 10000:
                    revert with 0, 17
                mem[64] = 480
                mem[416] = 30
                mem[448] = 'SafeMath: subtraction overflow'
                if arg1 * _marketingFee / 10000 > arg1 - (arg1 * _taxFee / 10000) - (arg1 * _liquidityFee / 10000):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * _taxFee / 10000) - (arg1 * _liquidityFee / 10000) < arg1 * _marketingFee / 10000:
                    revert with 0, 17
                idx = 0
                s = totalSupply
                t = stor12
                while idx < stor9.length:
                    mem[0] = stor9[idx]
                    mem[32] = 3
                    if stor3[stor9[idx]] > t:
                        _9267 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9267] = 26
                        mem[_9267 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _9347 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _9347 + 68] = mem[idx + _9267 + 32]
                                idx = idx + 32
                                continue 
                            mem[_9347 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _9347 + -mem[64] + 100
                        if not arg1:
                            if not arg1 * _taxFee / 10000:
                                if not arg1 * _liquidityFee / 10000:
                                    if not arg1 * _marketingFee / 10000:
                                        return 0
                                    if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                                        revert with 0, 17
                                    if not arg1 * _marketingFee / 10000:
                                        revert with 0, 18
                                    if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _10314 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_10314] = 30
                                    mem[_10314 + 32] = 'SafeMath: subtraction overflow'
                                    _11083 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11083] = 30
                                    mem[_11083 + 32] = 'SafeMath: subtraction overflow'
                                    _12644 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12644] = 30
                                    mem[_12644 + 32] = 'SafeMath: subtraction overflow'
                                    if arg1 * _marketingFee / 10000 * stor12 / totalSupply <= 0:
                                        if 0 < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                                            revert with 0, 17
                                        else:
                                            return 0
                                    _13119 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _13119 + 68] = mem[idx + _12644 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_13119 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _13119 + -mem[64] + 100
                                if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                                    revert with 0, 17
                                if not arg1 * _liquidityFee / 10000:
                                    revert with 0, 18
                                if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not arg1 * _marketingFee / 10000:
                                    _10313 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_10313] = 30
                                    mem[_10313 + 32] = 'SafeMath: subtraction overflow'
                                    _11082 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11082] = 30
                                    mem[_11082 + 32] = 'SafeMath: subtraction overflow'
                                    if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > 0:
                                        _11387 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _11387 + 68] = mem[idx + _11082 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_11387 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _11387 + -mem[64] + 100
                                    if 0 < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                        revert with 0, 17
                                    _12642 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12642] = 30
                                    mem[_12642 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                        if -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply < 0:
                                            revert with 0, 17
                                        else:
                                            return 0
                                    _13118 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _13118 + 68] = mem[idx + _12642 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_13118 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _13118 + -mem[64] + 100
                                if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                                    revert with 0, 17
                                if not arg1 * _marketingFee / 10000:
                                    revert with 0, 18
                                if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _10805 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10805] = 30
                                mem[_10805 + 32] = 'SafeMath: subtraction overflow'
                                _12181 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12181] = 30
                                mem[_12181 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > 0:
                                    _12641 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _12641 + 68] = mem[idx + _12181 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_12641 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _12641 + -mem[64] + 100
                                if 0 < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                    revert with 0, 17
                                _14213 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14213] = 30
                                mem[_14213 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _marketingFee / 10000 * stor12 / totalSupply <= -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                    if -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _14741 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _14741 + 68] = mem[idx + _14213 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14741 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14741 + -mem[64] + 100
                            if arg1 * _taxFee / 10000 and stor12 / totalSupply > -1 / arg1 * _taxFee / 10000:
                                revert with 0, 17
                            if not arg1 * _taxFee / 10000:
                                revert with 0, 18
                            if arg1 * _taxFee / 10000 * stor12 / totalSupply / arg1 * _taxFee / 10000 != stor12 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _liquidityFee / 10000:
                                if not arg1 * _marketingFee / 10000:
                                    _10312 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_10312] = 30
                                    mem[_10312 + 32] = 'SafeMath: subtraction overflow'
                                    if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                                        _10452 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _10452 + 68] = mem[idx + _10312 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_10452 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _10452 + -mem[64] + 100
                                    if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                        revert with 0, 17
                                    _11080 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11080] = 30
                                    mem[_11080 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                        _11386 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _11386 + 68] = mem[idx + _11080 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_11386 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _11386 + -mem[64] + 100
                                    if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                                        revert with 0, 17
                                    _12639 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12639] = 30
                                    mem[_12639 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                        if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                                            revert with 0, 17
                                        else:
                                            return 0
                                    _13117 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _13117 + 68] = mem[idx + _12639 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_13117 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _13117 + -mem[64] + 100
                                if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                                    revert with 0, 17
                                if not arg1 * _marketingFee / 10000:
                                    revert with 0, 18
                                if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _10804 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10804] = 30
                                mem[_10804 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                                    _11079 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _11079 + 68] = mem[idx + _10804 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_11079 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _11079 + -mem[64] + 100
                                if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                    revert with 0, 17
                                _12179 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12179] = 30
                                mem[_12179 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                    _12638 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _12638 + 68] = mem[idx + _12179 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_12638 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _12638 + -mem[64] + 100
                                if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                                    revert with 0, 17
                                _14211 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14211] = 30
                                mem[_14211 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _marketingFee / 10000 * stor12 / totalSupply <= -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                    if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _14739 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _14739 + 68] = mem[idx + _14211 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14739 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14739 + -mem[64] + 100
                            if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                                revert with 0, 17
                            if not arg1 * _liquidityFee / 10000:
                                revert with 0, 18
                            if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _marketingFee / 10000:
                                _10803 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10803] = 30
                                mem[_10803 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                                    _11078 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _11078 + 68] = mem[idx + _10803 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_11078 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _11078 + -mem[64] + 100
                                if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                    revert with 0, 17
                                _12177 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12177] = 30
                                mem[_12177 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                    _12637 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _12637 + 68] = mem[idx + _12177 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_12637 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _12637 + -mem[64] + 100
                                if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                    revert with 0, 17
                                _14209 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14209] = 30
                                mem[_14209 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                                    if (-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _14738 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _14738 + 68] = mem[idx + _14209 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14738 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14738 + -mem[64] + 100
                            if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                                revert with 0, 17
                            if not arg1 * _marketingFee / 10000:
                                revert with 0, 18
                            if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _11748 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11748] = 30
                            mem[_11748 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                                _12176 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _12176 + 68] = mem[idx + _11748 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12176 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12176 + -mem[64] + 100
                            if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                revert with 0, 17
                            _13630 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13630] = 30
                            mem[_13630 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                _14208 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _14208 + 68] = mem[idx + _13630 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14208 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14208 + -mem[64] + 100
                            if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                revert with 0, 17
                            _15839 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15839] = 30
                            mem[_15839 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _marketingFee / 10000 * stor12 / totalSupply <= (-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                                if (-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _16305 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _16305 + 68] = mem[idx + _15839 + 32]
                                idx = idx + 32
                                continue 
                            mem[_16305 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _16305 + -mem[64] + 100
                        if arg1 and stor12 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor12 / totalSupply / arg1 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _taxFee / 10000:
                            if not arg1 * _liquidityFee / 10000:
                                if not arg1 * _marketingFee / 10000:
                                    _10310 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_10310] = 30
                                    mem[_10310 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg1 * stor12 / totalSupply:
                                        _10451 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _10451 + 68] = mem[idx + _10310 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_10451 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _10451 + -mem[64] + 100
                                    if arg1 * stor12 / totalSupply < 0:
                                        revert with 0, 17
                                    _11076 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_11076] = 30
                                    mem[_11076 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg1 * stor12 / totalSupply:
                                        _11384 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _11384 + 68] = mem[idx + _11076 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_11384 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _11384 + -mem[64] + 100
                                    if arg1 * stor12 / totalSupply < 0:
                                        revert with 0, 17
                                    _12635 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_12635] = 30
                                    mem[_12635 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= arg1 * stor12 / totalSupply:
                                        if arg1 * stor12 / totalSupply < 0:
                                            revert with 0, 17
                                        return (arg1 * stor12 / totalSupply)
                                    _13116 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _13116 + 68] = mem[idx + _12635 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_13116 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _13116 + -mem[64] + 100
                                if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                                    revert with 0, 17
                                if not arg1 * _marketingFee / 10000:
                                    revert with 0, 18
                                if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _10802 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10802] = 30
                                mem[_10802 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor12 / totalSupply:
                                    _11075 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _11075 + 68] = mem[idx + _10802 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_11075 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _11075 + -mem[64] + 100
                                if arg1 * stor12 / totalSupply < 0:
                                    revert with 0, 17
                                _12174 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12174] = 30
                                mem[_12174 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor12 / totalSupply:
                                    _12634 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _12634 + 68] = mem[idx + _12174 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_12634 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _12634 + -mem[64] + 100
                                if arg1 * stor12 / totalSupply < 0:
                                    revert with 0, 17
                                _14206 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14206] = 30
                                mem[_14206 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _marketingFee / 10000 * stor12 / totalSupply <= arg1 * stor12 / totalSupply:
                                    if arg1 * stor12 / totalSupply < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                                        revert with 0, 17
                                    return (arg1 * stor12 / totalSupply)
                                _14736 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _14736 + 68] = mem[idx + _14206 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14736 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14736 + -mem[64] + 100
                            if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                                revert with 0, 17
                            if not arg1 * _liquidityFee / 10000:
                                revert with 0, 18
                            if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _marketingFee / 10000:
                                _10801 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10801] = 30
                                mem[_10801 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor12 / totalSupply:
                                    _11074 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _11074 + 68] = mem[idx + _10801 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_11074 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _11074 + -mem[64] + 100
                                if arg1 * stor12 / totalSupply < 0:
                                    revert with 0, 17
                                _12172 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12172] = 30
                                mem[_12172 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                                    _12633 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _12633 + 68] = mem[idx + _12172 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_12633 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _12633 + -mem[64] + 100
                                if arg1 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                    revert with 0, 17
                                _14204 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14204] = 30
                                mem[_14204 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                                    if (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < 0:
                                        revert with 0, 17
                                    return (arg1 * stor12 / totalSupply)
                                _14735 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _14735 + 68] = mem[idx + _14204 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14735 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14735 + -mem[64] + 100
                            if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                                revert with 0, 17
                            if not arg1 * _marketingFee / 10000:
                                revert with 0, 18
                            if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _11747 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11747] = 30
                            mem[_11747 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor12 / totalSupply:
                                _12171 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _12171 + 68] = mem[idx + _11747 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12171 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12171 + -mem[64] + 100
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 0, 17
                            _13628 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13628] = 30
                            mem[_13628 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                                _14203 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _14203 + 68] = mem[idx + _13628 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14203 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14203 + -mem[64] + 100
                            if arg1 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                revert with 0, 17
                            _15837 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15837] = 30
                            mem[_15837 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _marketingFee / 10000 * stor12 / totalSupply <= (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                                if (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                                    revert with 0, 17
                                return (arg1 * stor12 / totalSupply)
                            _16302 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _16302 + 68] = mem[idx + _15837 + 32]
                                idx = idx + 32
                                continue 
                            mem[_16302 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _16302 + -mem[64] + 100
                        if arg1 * _taxFee / 10000 and stor12 / totalSupply > -1 / arg1 * _taxFee / 10000:
                            revert with 0, 17
                        if not arg1 * _taxFee / 10000:
                            revert with 0, 18
                        if arg1 * _taxFee / 10000 * stor12 / totalSupply / arg1 * _taxFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _liquidityFee / 10000:
                            if not arg1 * _marketingFee / 10000:
                                _10800 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10800] = 30
                                mem[_10800 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                                    _11073 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _11073 + 68] = mem[idx + _10800 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_11073 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _11073 + -mem[64] + 100
                                if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                    revert with 0, 17
                                _12169 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12169] = 30
                                mem[_12169 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                                    _12632 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _12632 + 68] = mem[idx + _12169 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_12632 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _12632 + -mem[64] + 100
                                if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                                    revert with 0, 17
                                _14201 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14201] = 30
                                mem[_14201 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                                    if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                                        revert with 0, 17
                                    return (arg1 * stor12 / totalSupply)
                                _14734 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _14734 + 68] = mem[idx + _14201 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14734 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14734 + -mem[64] + 100
                            if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                                revert with 0, 17
                            if not arg1 * _marketingFee / 10000:
                                revert with 0, 18
                            if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _11746 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11746] = 30
                            mem[_11746 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                                _12168 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _12168 + 68] = mem[idx + _11746 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12168 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12168 + -mem[64] + 100
                            if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                revert with 0, 17
                            _13626 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13626] = 30
                            mem[_13626 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                                _14200 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _14200 + 68] = mem[idx + _13626 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14200 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14200 + -mem[64] + 100
                            if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                                revert with 0, 17
                            _15835 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15835] = 30
                            mem[_15835 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _marketingFee / 10000 * stor12 / totalSupply <= (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                                if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                                    revert with 0, 17
                                return (arg1 * stor12 / totalSupply)
                            _16300 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _16300 + 68] = mem[idx + _15835 + 32]
                                idx = idx + 32
                                continue 
                            mem[_16300 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _16300 + -mem[64] + 100
                        if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                            revert with 0, 17
                        if not arg1 * _liquidityFee / 10000:
                            revert with 0, 18
                        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _marketingFee / 10000:
                            _11745 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11745] = 30
                            mem[_11745 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                                _12167 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _12167 + 68] = mem[idx + _11745 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12167 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12167 + -mem[64] + 100
                            if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                revert with 0, 17
                            _13624 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13624] = 30
                            mem[_13624 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                                _14199 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _14199 + 68] = mem[idx + _13624 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14199 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14199 + -mem[64] + 100
                            if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                revert with 0, 17
                            _15833 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15833] = 30
                            mem[_15833 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                                if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor12 / totalSupply)
                            _16299 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _16299 + 68] = mem[idx + _15833 + 32]
                                idx = idx + 32
                                continue 
                            mem[_16299 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _16299 + -mem[64] + 100
                        if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                            revert with 0, 17
                        if not arg1 * _marketingFee / 10000:
                            revert with 0, 18
                        if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _13115 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13115] = 30
                        mem[_13115 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                            _13623 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13623 + 68] = mem[idx + _13115 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13623 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13623 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                            revert with 0, 17
                        _15261 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_15261] = 30
                        mem[_15261 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                            _15832 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _15832 + 68] = mem[idx + _15261 + 32]
                                idx = idx + 32
                                continue 
                            mem[_15832 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _15832 + -mem[64] + 100
                        if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                            revert with 0, 17
                        _17043 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_17043] = 30
                        mem[_17043 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _marketingFee / 10000 * stor12 / totalSupply <= (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                            if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor12 / totalSupply)
                        _17297 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _17297 + 68] = mem[idx + _17043 + 32]
                            idx = idx + 32
                            continue 
                        mem[_17297 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _17297 + -mem[64] + 100
                    if idx >= stor9.length:
                        revert with 0, 50
                    mem[0] = stor9[idx]
                    mem[32] = 4
                    if stor4[stor9[idx]] <= s:
                        if idx >= stor9.length:
                            revert with 0, 50
                        mem[0] = stor9[idx]
                        mem[32] = 3
                        _9348 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9348] = 30
                        mem[_9348 + 32] = 'SafeMath: subtraction overflow'
                        if stor3[stor9[idx]] > t:
                            _9428 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _9428 + 68] = mem[idx + _9348 + 32]
                                idx = idx + 32
                                continue 
                            mem[_9428 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _9428 + -mem[64] + 100
                        if t < stor3[stor9[idx]]:
                            revert with 0, 17
                        if idx >= stor9.length:
                            revert with 0, 50
                        mem[0] = stor9[idx]
                        mem[32] = 4
                        _9781 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_9781] = 30
                        mem[_9781 + 32] = 'SafeMath: subtraction overflow'
                        if stor4[stor9[idx]] <= s:
                            if s < stor4[stor9[idx]]:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s - stor4[stor9[idx]]
                            t = t - stor3[stor9[idx]]
                            continue 
                        _9829 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _9829 + 68] = mem[idx + _9781 + 32]
                            idx = idx + 32
                            continue 
                        mem[_9829 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _9829 + -mem[64] + 100
                    _9349 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_9349] = 26
                    mem[_9349 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _9429 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _9429 + 68] = mem[idx + _9349 + 32]
                            idx = idx + 32
                            continue 
                        mem[_9429 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _9429 + -mem[64] + 100
                    if not arg1:
                        if not arg1 * _taxFee / 10000:
                            if not arg1 * _liquidityFee / 10000:
                                if not arg1 * _marketingFee / 10000:
                                    return 0
                                if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                                    revert with 0, 17
                                if not arg1 * _marketingFee / 10000:
                                    revert with 0, 18
                                if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _10459 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10459] = 30
                                mem[_10459 + 32] = 'SafeMath: subtraction overflow'
                                _11399 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11399] = 30
                                mem[_11399 + 32] = 'SafeMath: subtraction overflow'
                                _13133 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13133] = 30
                                mem[_13133 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _marketingFee / 10000 * stor12 / totalSupply <= 0:
                                    if 0 < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _13637 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _13637 + 68] = mem[idx + _13133 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13637 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13637 + -mem[64] + 100
                            if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                                revert with 0, 17
                            if not arg1 * _liquidityFee / 10000:
                                revert with 0, 18
                            if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _marketingFee / 10000:
                                _10458 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10458] = 30
                                mem[_10458 + 32] = 'SafeMath: subtraction overflow'
                                _11398 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11398] = 30
                                mem[_11398 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > 0:
                                    _11754 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _11754 + 68] = mem[idx + _11398 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_11754 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _11754 + -mem[64] + 100
                                if 0 < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                    revert with 0, 17
                                _13131 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13131] = 30
                                mem[_13131 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                    if -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _13636 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _13636 + 68] = mem[idx + _13131 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13636 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13636 + -mem[64] + 100
                            if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                                revert with 0, 17
                            if not arg1 * _marketingFee / 10000:
                                revert with 0, 18
                            if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _11090 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11090] = 30
                            mem[_11090 + 32] = 'SafeMath: subtraction overflow'
                            _12659 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12659] = 30
                            mem[_12659 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > 0:
                                _13130 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _13130 + 68] = mem[idx + _12659 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13130 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13130 + -mem[64] + 100
                            if 0 < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                revert with 0, 17
                            _14758 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14758] = 30
                            mem[_14758 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _marketingFee / 10000 * stor12 / totalSupply <= -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                if -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _15274 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _15274 + 68] = mem[idx + _14758 + 32]
                                idx = idx + 32
                                continue 
                            mem[_15274 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _15274 + -mem[64] + 100
                        if arg1 * _taxFee / 10000 and stor12 / totalSupply > -1 / arg1 * _taxFee / 10000:
                            revert with 0, 17
                        if not arg1 * _taxFee / 10000:
                            revert with 0, 18
                        if arg1 * _taxFee / 10000 * stor12 / totalSupply / arg1 * _taxFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _liquidityFee / 10000:
                            if not arg1 * _marketingFee / 10000:
                                _10457 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10457] = 30
                                mem[_10457 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                                    _10597 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _10597 + 68] = mem[idx + _10457 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_10597 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _10597 + -mem[64] + 100
                                if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                    revert with 0, 17
                                _11396 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11396] = 30
                                mem[_11396 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                    _11753 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _11753 + 68] = mem[idx + _11396 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_11753 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _11753 + -mem[64] + 100
                                if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                                    revert with 0, 17
                                _13128 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13128] = 30
                                mem[_13128 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                    if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _13635 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _13635 + 68] = mem[idx + _13128 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13635 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13635 + -mem[64] + 100
                            if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                                revert with 0, 17
                            if not arg1 * _marketingFee / 10000:
                                revert with 0, 18
                            if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _11089 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11089] = 30
                            mem[_11089 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                                _11395 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11395 + 68] = mem[idx + _11089 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11395 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11395 + -mem[64] + 100
                            if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                revert with 0, 17
                            _12657 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12657] = 30
                            mem[_12657 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                _13127 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _13127 + 68] = mem[idx + _12657 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13127 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13127 + -mem[64] + 100
                            if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                                revert with 0, 17
                            _14756 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14756] = 30
                            mem[_14756 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _marketingFee / 10000 * stor12 / totalSupply <= -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _15272 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _15272 + 68] = mem[idx + _14756 + 32]
                                idx = idx + 32
                                continue 
                            mem[_15272 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _15272 + -mem[64] + 100
                        if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                            revert with 0, 17
                        if not arg1 * _liquidityFee / 10000:
                            revert with 0, 18
                        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _marketingFee / 10000:
                            _11088 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11088] = 30
                            mem[_11088 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                                _11394 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11394 + 68] = mem[idx + _11088 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11394 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11394 + -mem[64] + 100
                            if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                revert with 0, 17
                            _12655 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12655] = 30
                            mem[_12655 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                _13126 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _13126 + 68] = mem[idx + _12655 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13126 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13126 + -mem[64] + 100
                            if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                revert with 0, 17
                            _14754 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14754] = 30
                            mem[_14754 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                                if (-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < 0:
                                    revert with 0, 17
                                else:
                                    return 0
                            _15271 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _15271 + 68] = mem[idx + _14754 + 32]
                                idx = idx + 32
                                continue 
                            mem[_15271 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _15271 + -mem[64] + 100
                        if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                            revert with 0, 17
                        if not arg1 * _marketingFee / 10000:
                            revert with 0, 18
                        if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _12185 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12185] = 30
                        mem[_12185 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                            _12654 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12654 + 68] = mem[idx + _12185 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12654 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12654 + -mem[64] + 100
                        if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                            revert with 0, 17
                        _14222 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14222] = 30
                        mem[_14222 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                            _14753 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _14753 + 68] = mem[idx + _14222 + 32]
                                idx = idx + 32
                                continue 
                            mem[_14753 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _14753 + -mem[64] + 100
                        if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                            revert with 0, 17
                        _16316 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_16316] = 30
                        mem[_16316 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _marketingFee / 10000 * stor12 / totalSupply <= (-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                            if (-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                                revert with 0, 17
                            else:
                                return 0
                        _16664 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _16664 + 68] = mem[idx + _16316 + 32]
                            idx = idx + 32
                            continue 
                        mem[_16664 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _16664 + -mem[64] + 100
                    if arg1 and stor12 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor12 / totalSupply / arg1 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _taxFee / 10000:
                        if not arg1 * _liquidityFee / 10000:
                            if not arg1 * _marketingFee / 10000:
                                _10455 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_10455] = 30
                                mem[_10455 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor12 / totalSupply:
                                    _10596 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _10596 + 68] = mem[idx + _10455 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_10596 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _10596 + -mem[64] + 100
                                if arg1 * stor12 / totalSupply < 0:
                                    revert with 0, 17
                                _11392 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11392] = 30
                                mem[_11392 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor12 / totalSupply:
                                    _11751 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _11751 + 68] = mem[idx + _11392 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_11751 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _11751 + -mem[64] + 100
                                if arg1 * stor12 / totalSupply < 0:
                                    revert with 0, 17
                                _13124 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13124] = 30
                                mem[_13124 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= arg1 * stor12 / totalSupply:
                                    if arg1 * stor12 / totalSupply < 0:
                                        revert with 0, 17
                                    return (arg1 * stor12 / totalSupply)
                                _13634 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _13634 + 68] = mem[idx + _13124 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13634 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13634 + -mem[64] + 100
                            if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                                revert with 0, 17
                            if not arg1 * _marketingFee / 10000:
                                revert with 0, 18
                            if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _11087 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11087] = 30
                            mem[_11087 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor12 / totalSupply:
                                _11391 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11391 + 68] = mem[idx + _11087 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11391 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11391 + -mem[64] + 100
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 0, 17
                            _12652 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12652] = 30
                            mem[_12652 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor12 / totalSupply:
                                _13123 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _13123 + 68] = mem[idx + _12652 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13123 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13123 + -mem[64] + 100
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 0, 17
                            _14751 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14751] = 30
                            mem[_14751 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _marketingFee / 10000 * stor12 / totalSupply <= arg1 * stor12 / totalSupply:
                                if arg1 * stor12 / totalSupply < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                                    revert with 0, 17
                                return (arg1 * stor12 / totalSupply)
                            _15269 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _15269 + 68] = mem[idx + _14751 + 32]
                                idx = idx + 32
                                continue 
                            mem[_15269 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _15269 + -mem[64] + 100
                        if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                            revert with 0, 17
                        if not arg1 * _liquidityFee / 10000:
                            revert with 0, 18
                        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _marketingFee / 10000:
                            _11086 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11086] = 30
                            mem[_11086 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor12 / totalSupply:
                                _11390 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11390 + 68] = mem[idx + _11086 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11390 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11390 + -mem[64] + 100
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 0, 17
                            _12650 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12650] = 30
                            mem[_12650 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                                _13122 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _13122 + 68] = mem[idx + _12650 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13122 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13122 + -mem[64] + 100
                            if arg1 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                revert with 0, 17
                            _14749 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14749] = 30
                            mem[_14749 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                                if (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor12 / totalSupply)
                            _15268 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _15268 + 68] = mem[idx + _14749 + 32]
                                idx = idx + 32
                                continue 
                            mem[_15268 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _15268 + -mem[64] + 100
                        if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                            revert with 0, 17
                        if not arg1 * _marketingFee / 10000:
                            revert with 0, 18
                        if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _12184 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12184] = 30
                        mem[_12184 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor12 / totalSupply:
                            _12649 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12649 + 68] = mem[idx + _12184 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12649 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12649 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < 0:
                            revert with 0, 17
                        _14220 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14220] = 30
                        mem[_14220 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                            _14748 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _14748 + 68] = mem[idx + _14220 + 32]
                                idx = idx + 32
                                continue 
                            mem[_14748 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _14748 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                            revert with 0, 17
                        _16314 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_16314] = 30
                        mem[_16314 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _marketingFee / 10000 * stor12 / totalSupply <= (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                            if (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor12 / totalSupply)
                        _16661 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _16661 + 68] = mem[idx + _16314 + 32]
                            idx = idx + 32
                            continue 
                        mem[_16661 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _16661 + -mem[64] + 100
                    if arg1 * _taxFee / 10000 and stor12 / totalSupply > -1 / arg1 * _taxFee / 10000:
                        revert with 0, 17
                    if not arg1 * _taxFee / 10000:
                        revert with 0, 18
                    if arg1 * _taxFee / 10000 * stor12 / totalSupply / arg1 * _taxFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _liquidityFee / 10000:
                        if not arg1 * _marketingFee / 10000:
                            _11085 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11085] = 30
                            mem[_11085 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                                _11389 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11389 + 68] = mem[idx + _11085 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11389 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11389 + -mem[64] + 100
                            if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                revert with 0, 17
                            _12647 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12647] = 30
                            mem[_12647 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                                _13121 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _13121 + 68] = mem[idx + _12647 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13121 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13121 + -mem[64] + 100
                            if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                                revert with 0, 17
                            _14746 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14746] = 30
                            mem[_14746 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                                if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor12 / totalSupply)
                            _15267 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _15267 + 68] = mem[idx + _14746 + 32]
                                idx = idx + 32
                                continue 
                            mem[_15267 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _15267 + -mem[64] + 100
                        if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                            revert with 0, 17
                        if not arg1 * _marketingFee / 10000:
                            revert with 0, 18
                        if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _12183 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12183] = 30
                        mem[_12183 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                            _12646 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12646 + 68] = mem[idx + _12183 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12646 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12646 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                            revert with 0, 17
                        _14218 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14218] = 30
                        mem[_14218 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                            _14745 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _14745 + 68] = mem[idx + _14218 + 32]
                                idx = idx + 32
                                continue 
                            mem[_14745 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _14745 + -mem[64] + 100
                        if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                            revert with 0, 17
                        _16312 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_16312] = 30
                        mem[_16312 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _marketingFee / 10000 * stor12 / totalSupply <= (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                            if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor12 / totalSupply)
                        _16659 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _16659 + 68] = mem[idx + _16312 + 32]
                            idx = idx + 32
                            continue 
                        mem[_16659 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _16659 + -mem[64] + 100
                    if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                        revert with 0, 17
                    if not arg1 * _liquidityFee / 10000:
                        revert with 0, 18
                    if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _marketingFee / 10000:
                        _12182 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12182] = 30
                        mem[_12182 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                            _12645 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12645 + 68] = mem[idx + _12182 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12645 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12645 + -mem[64] + 100
                        if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                            revert with 0, 17
                        _14216 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14216] = 30
                        mem[_14216 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                            _14744 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _14744 + 68] = mem[idx + _14216 + 32]
                                idx = idx + 32
                                continue 
                            mem[_14744 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _14744 + -mem[64] + 100
                        if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                            revert with 0, 17
                        _16310 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_16310] = 30
                        mem[_16310 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                            if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < 0:
                                revert with 0, 17
                            return (arg1 * stor12 / totalSupply)
                        _16658 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _16658 + 68] = mem[idx + _16310 + 32]
                            idx = idx + 32
                            continue 
                        mem[_16658 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _16658 + -mem[64] + 100
                    if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                        revert with 0, 17
                    if not arg1 * _marketingFee / 10000:
                        revert with 0, 18
                    if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _13633 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_13633] = 30
                    mem[_13633 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                        _14215 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _14215 + 68] = mem[idx + _13633 + 32]
                            idx = idx + 32
                            continue 
                        mem[_14215 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _14215 + -mem[64] + 100
                    if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                        revert with 0, 17
                    _15841 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_15841] = 30
                    mem[_15841 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                        _16309 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _16309 + 68] = mem[idx + _15841 + 32]
                            idx = idx + 32
                            continue 
                        mem[_16309 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _16309 + -mem[64] + 100
                    if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                        revert with 0, 17
                    _17302 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_17302] = 30
                    mem[_17302 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * _marketingFee / 10000 * stor12 / totalSupply <= (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                        if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                            revert with 0, 17
                        return (arg1 * stor12 / totalSupply)
                    _17452 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _17452 + 68] = mem[idx + _17302 + 32]
                        idx = idx + 32
                        continue 
                    mem[_17452 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _17452 + -mem[64] + 100
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if t >= stor12 / totalSupply:
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg1:
                        if not arg1 * _taxFee / 10000:
                            if not arg1 * _liquidityFee / 10000:
                                if arg1 * _marketingFee / 10000:
                                    if arg1 * _marketingFee / 10000 and t / s > -1 / arg1 * _marketingFee / 10000:
                                        revert with 0, 17
                                    if not arg1 * _marketingFee / 10000:
                                        revert with 0, 18
                                    if arg1 * _marketingFee / 10000 * t / s / arg1 * _marketingFee / 10000 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if arg1 * _marketingFee / 10000 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _marketingFee / 10000 * t / s:
                                        revert with 0, 17
                            else:
                                if arg1 * _liquidityFee / 10000 and t / s > -1 / arg1 * _liquidityFee / 10000:
                                    revert with 0, 17
                                if not arg1 * _liquidityFee / 10000:
                                    revert with 0, 18
                                if arg1 * _liquidityFee / 10000 * t / s / arg1 * _liquidityFee / 10000 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not arg1 * _marketingFee / 10000:
                                    if arg1 * _liquidityFee / 10000 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _liquidityFee / 10000 * t / s:
                                        revert with 0, 17
                                    if 0 > -1 * arg1 * _liquidityFee / 10000 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _liquidityFee / 10000 * t / s < 0:
                                        revert with 0, 17
                                else:
                                    if arg1 * _marketingFee / 10000 and t / s > -1 / arg1 * _marketingFee / 10000:
                                        revert with 0, 17
                                    if not arg1 * _marketingFee / 10000:
                                        revert with 0, 18
                                    if arg1 * _marketingFee / 10000 * t / s / arg1 * _marketingFee / 10000 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if arg1 * _liquidityFee / 10000 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _liquidityFee / 10000 * t / s:
                                        revert with 0, 17
                                    if arg1 * _marketingFee / 10000 * t / s > -1 * arg1 * _liquidityFee / 10000 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _liquidityFee / 10000 * t / s < arg1 * _marketingFee / 10000 * t / s:
                                        revert with 0, 17
                        else:
                            if arg1 * _taxFee / 10000 and t / s > -1 / arg1 * _taxFee / 10000:
                                revert with 0, 17
                            if not arg1 * _taxFee / 10000:
                                revert with 0, 18
                            if arg1 * _taxFee / 10000 * t / s / arg1 * _taxFee / 10000 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _liquidityFee / 10000:
                                if not arg1 * _marketingFee / 10000:
                                    if arg1 * _taxFee / 10000 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _taxFee / 10000 * t / s:
                                        revert with 0, 17
                                    if 0 > -1 * arg1 * _taxFee / 10000 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _taxFee / 10000 * t / s < 0:
                                        revert with 0, 17
                                    if 0 > -1 * arg1 * _taxFee / 10000 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _taxFee / 10000 * t / s < 0:
                                        revert with 0, 17
                                else:
                                    if arg1 * _marketingFee / 10000 and t / s > -1 / arg1 * _marketingFee / 10000:
                                        revert with 0, 17
                                    if not arg1 * _marketingFee / 10000:
                                        revert with 0, 18
                                    if arg1 * _marketingFee / 10000 * t / s / arg1 * _marketingFee / 10000 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if arg1 * _taxFee / 10000 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _taxFee / 10000 * t / s:
                                        revert with 0, 17
                                    if 0 > -1 * arg1 * _taxFee / 10000 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _taxFee / 10000 * t / s < 0:
                                        revert with 0, 17
                                    if arg1 * _marketingFee / 10000 * t / s > -1 * arg1 * _taxFee / 10000 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _taxFee / 10000 * t / s < arg1 * _marketingFee / 10000 * t / s:
                                        revert with 0, 17
                            else:
                                if arg1 * _liquidityFee / 10000 and t / s > -1 / arg1 * _liquidityFee / 10000:
                                    revert with 0, 17
                                if not arg1 * _liquidityFee / 10000:
                                    revert with 0, 18
                                if arg1 * _liquidityFee / 10000 * t / s / arg1 * _liquidityFee / 10000 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not arg1 * _marketingFee / 10000:
                                    if arg1 * _taxFee / 10000 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _taxFee / 10000 * t / s:
                                        revert with 0, 17
                                    if arg1 * _liquidityFee / 10000 * t / s > -1 * arg1 * _taxFee / 10000 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _taxFee / 10000 * t / s < arg1 * _liquidityFee / 10000 * t / s:
                                        revert with 0, 17
                                    if 0 > (-1 * arg1 * _taxFee / 10000 * t / s) - (arg1 * _liquidityFee / 10000 * t / s):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if (-1 * arg1 * _taxFee / 10000 * t / s) - (arg1 * _liquidityFee / 10000 * t / s) < 0:
                                        revert with 0, 17
                                else:
                                    if arg1 * _marketingFee / 10000 and t / s > -1 / arg1 * _marketingFee / 10000:
                                        revert with 0, 17
                                    if not arg1 * _marketingFee / 10000:
                                        revert with 0, 18
                                    if arg1 * _marketingFee / 10000 * t / s / arg1 * _marketingFee / 10000 != t / s:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if arg1 * _taxFee / 10000 * t / s > 0:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if 0 < arg1 * _taxFee / 10000 * t / s:
                                        revert with 0, 17
                                    if arg1 * _liquidityFee / 10000 * t / s > -1 * arg1 * _taxFee / 10000 * t / s:
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if -1 * arg1 * _taxFee / 10000 * t / s < arg1 * _liquidityFee / 10000 * t / s:
                                        revert with 0, 17
                                    if arg1 * _marketingFee / 10000 * t / s > (-1 * arg1 * _taxFee / 10000 * t / s) - (arg1 * _liquidityFee / 10000 * t / s):
                                        revert with 0, 'SafeMath: subtraction overflow', 0
                                    if (-1 * arg1 * _taxFee / 10000 * t / s) - (arg1 * _liquidityFee / 10000 * t / s) < arg1 * _marketingFee / 10000 * t / s:
                                        revert with 0, 17
                        return 0
                    if arg1 and t / s > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _taxFee / 10000:
                        if not arg1 * _liquidityFee / 10000:
                            if not arg1 * _marketingFee / 10000:
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * _marketingFee / 10000 and t / s > -1 / arg1 * _marketingFee / 10000:
                                    revert with 0, 17
                                if not arg1 * _marketingFee / 10000:
                                    revert with 0, 18
                                if arg1 * _marketingFee / 10000 * t / s / arg1 * _marketingFee / 10000 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if arg1 * _marketingFee / 10000 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _marketingFee / 10000 * t / s:
                                    revert with 0, 17
                        else:
                            if arg1 * _liquidityFee / 10000 and t / s > -1 / arg1 * _liquidityFee / 10000:
                                revert with 0, 17
                            if not arg1 * _liquidityFee / 10000:
                                revert with 0, 18
                            if arg1 * _liquidityFee / 10000 * t / s / arg1 * _liquidityFee / 10000 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _marketingFee / 10000:
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if arg1 * _liquidityFee / 10000 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _liquidityFee / 10000 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (arg1 * _liquidityFee / 10000 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _liquidityFee / 10000 * t / s) < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * _marketingFee / 10000 and t / s > -1 / arg1 * _marketingFee / 10000:
                                    revert with 0, 17
                                if not arg1 * _marketingFee / 10000:
                                    revert with 0, 18
                                if arg1 * _marketingFee / 10000 * t / s / arg1 * _marketingFee / 10000 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if 0 > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < 0:
                                    revert with 0, 17
                                if arg1 * _liquidityFee / 10000 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _liquidityFee / 10000 * t / s:
                                    revert with 0, 17
                                if arg1 * _marketingFee / 10000 * t / s > (arg1 * t / s) - (arg1 * _liquidityFee / 10000 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _liquidityFee / 10000 * t / s) < arg1 * _marketingFee / 10000 * t / s:
                                    revert with 0, 17
                    else:
                        if arg1 * _taxFee / 10000 and t / s > -1 / arg1 * _taxFee / 10000:
                            revert with 0, 17
                        if not arg1 * _taxFee / 10000:
                            revert with 0, 18
                        if arg1 * _taxFee / 10000 * t / s / arg1 * _taxFee / 10000 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _liquidityFee / 10000:
                            if not arg1 * _marketingFee / 10000:
                                if arg1 * _taxFee / 10000 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _taxFee / 10000 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s) < 0:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s) < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * _marketingFee / 10000 and t / s > -1 / arg1 * _marketingFee / 10000:
                                    revert with 0, 17
                                if not arg1 * _marketingFee / 10000:
                                    revert with 0, 18
                                if arg1 * _marketingFee / 10000 * t / s / arg1 * _marketingFee / 10000 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _taxFee / 10000 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _taxFee / 10000 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s) < 0:
                                    revert with 0, 17
                                if arg1 * _marketingFee / 10000 * t / s > (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s) < arg1 * _marketingFee / 10000 * t / s:
                                    revert with 0, 17
                        else:
                            if arg1 * _liquidityFee / 10000 and t / s > -1 / arg1 * _liquidityFee / 10000:
                                revert with 0, 17
                            if not arg1 * _liquidityFee / 10000:
                                revert with 0, 18
                            if arg1 * _liquidityFee / 10000 * t / s / arg1 * _liquidityFee / 10000 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _marketingFee / 10000:
                                if arg1 * _taxFee / 10000 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _taxFee / 10000 * t / s:
                                    revert with 0, 17
                                if arg1 * _liquidityFee / 10000 * t / s > (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s) < arg1 * _liquidityFee / 10000 * t / s:
                                    revert with 0, 17
                                if 0 > (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s) - (arg1 * _liquidityFee / 10000 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s) - (arg1 * _liquidityFee / 10000 * t / s) < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * _marketingFee / 10000 and t / s > -1 / arg1 * _marketingFee / 10000:
                                    revert with 0, 17
                                if not arg1 * _marketingFee / 10000:
                                    revert with 0, 18
                                if arg1 * _marketingFee / 10000 * t / s / arg1 * _marketingFee / 10000 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _taxFee / 10000 * t / s > arg1 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if arg1 * t / s < arg1 * _taxFee / 10000 * t / s:
                                    revert with 0, 17
                                if arg1 * _liquidityFee / 10000 * t / s > (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s) < arg1 * _liquidityFee / 10000 * t / s:
                                    revert with 0, 17
                                if arg1 * _marketingFee / 10000 * t / s > (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s) - (arg1 * _liquidityFee / 10000 * t / s):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (arg1 * t / s) - (arg1 * _taxFee / 10000 * t / s) - (arg1 * _liquidityFee / 10000 * t / s) < arg1 * _marketingFee / 10000 * t / s:
                                    revert with 0, 17
                    return (arg1 * t / s)
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if not arg1 * _taxFee / 10000:
                        if not arg1 * _liquidityFee / 10000:
                            if arg1 * _marketingFee / 10000:
                                if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                                    revert with 0, 17
                                if not arg1 * _marketingFee / 10000:
                                    revert with 0, 18
                                if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _marketingFee / 10000 * stor12 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                                    revert with 0, 17
                        else:
                            if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                                revert with 0, 17
                            if not arg1 * _liquidityFee / 10000:
                                revert with 0, 18
                            if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _marketingFee / 10000:
                                if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                    revert with 0, 17
                                if 0 > -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                                    revert with 0, 17
                                if not arg1 * _marketingFee / 10000:
                                    revert with 0, 18
                                if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                    revert with 0, 17
                                if arg1 * _marketingFee / 10000 * stor12 / totalSupply > -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _liquidityFee / 10000 * stor12 / totalSupply < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                                    revert with 0, 17
                    else:
                        if arg1 * _taxFee / 10000 and stor12 / totalSupply > -1 / arg1 * _taxFee / 10000:
                            revert with 0, 17
                        if not arg1 * _taxFee / 10000:
                            revert with 0, 18
                        if arg1 * _taxFee / 10000 * stor12 / totalSupply / arg1 * _taxFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _liquidityFee / 10000:
                            if not arg1 * _marketingFee / 10000:
                                if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                    revert with 0, 17
                                if 0 > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                                    revert with 0, 17
                                if 0 > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                                    revert with 0, 17
                                if not arg1 * _marketingFee / 10000:
                                    revert with 0, 18
                                if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                    revert with 0, 17
                                if 0 > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < 0:
                                    revert with 0, 17
                                if arg1 * _marketingFee / 10000 * stor12 / totalSupply > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                                    revert with 0, 17
                        else:
                            if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                                revert with 0, 17
                            if not arg1 * _liquidityFee / 10000:
                                revert with 0, 18
                            if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * _marketingFee / 10000:
                                if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                    revert with 0, 17
                                if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                    revert with 0, 17
                                if 0 > (-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                                    revert with 0, 17
                                if not arg1 * _marketingFee / 10000:
                                    revert with 0, 18
                                if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * _taxFee / 10000 * stor12 / totalSupply > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                    revert with 0, 17
                                if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * _taxFee / 10000 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                    revert with 0, 17
                                if arg1 * _marketingFee / 10000 * stor12 / totalSupply > (-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if (-1 * arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                                    revert with 0, 17
                    return 0
                if arg1 and stor12 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor12 / totalSupply / arg1 != stor12 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * _taxFee / 10000:
                    if not arg1 * _liquidityFee / 10000:
                        if not arg1 * _marketingFee / 10000:
                            if 0 > arg1 * stor12 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 0, 17
                            if 0 > arg1 * stor12 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 0, 17
                            if 0 > arg1 * stor12 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 0, 17
                        else:
                            if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                                revert with 0, 17
                            if not arg1 * _marketingFee / 10000:
                                revert with 0, 18
                            if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 > arg1 * stor12 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 0, 17
                            if 0 > arg1 * stor12 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 0, 17
                            if arg1 * _marketingFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor12 / totalSupply < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                                revert with 0, 17
                    else:
                        if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                            revert with 0, 17
                        if not arg1 * _liquidityFee / 10000:
                            revert with 0, 18
                        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _marketingFee / 10000:
                            if 0 > arg1 * stor12 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 0, 17
                            if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < 0:
                                revert with 0, 17
                        else:
                            if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                                revert with 0, 17
                            if not arg1 * _marketingFee / 10000:
                                revert with 0, 18
                            if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 > arg1 * stor12 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor12 / totalSupply < 0:
                                revert with 0, 17
                            if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor12 / totalSupply < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                revert with 0, 17
                            if arg1 * _marketingFee / 10000 * stor12 / totalSupply > (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                                revert with 0, 17
                else:
                    if arg1 * _taxFee / 10000 and stor12 / totalSupply > -1 / arg1 * _taxFee / 10000:
                        revert with 0, 17
                    if not arg1 * _taxFee / 10000:
                        revert with 0, 18
                    if arg1 * _taxFee / 10000 * stor12 / totalSupply / arg1 * _taxFee / 10000 != stor12 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * _liquidityFee / 10000:
                        if not arg1 * _marketingFee / 10000:
                            if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                                revert with 0, 17
                            if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                                revert with 0, 17
                        else:
                            if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                                revert with 0, 17
                            if not arg1 * _marketingFee / 10000:
                                revert with 0, 18
                            if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < 0:
                                revert with 0, 17
                            if arg1 * _marketingFee / 10000 * stor12 / totalSupply > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                                revert with 0, 17
                    else:
                        if arg1 * _liquidityFee / 10000 and stor12 / totalSupply > -1 / arg1 * _liquidityFee / 10000:
                            revert with 0, 17
                        if not arg1 * _liquidityFee / 10000:
                            revert with 0, 18
                        if arg1 * _liquidityFee / 10000 * stor12 / totalSupply / arg1 * _liquidityFee / 10000 != stor12 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * _marketingFee / 10000:
                            if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                revert with 0, 17
                            if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                revert with 0, 17
                            if 0 > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < 0:
                                revert with 0, 17
                        else:
                            if arg1 * _marketingFee / 10000 and stor12 / totalSupply > -1 / arg1 * _marketingFee / 10000:
                                revert with 0, 17
                            if not arg1 * _marketingFee / 10000:
                                revert with 0, 18
                            if arg1 * _marketingFee / 10000 * stor12 / totalSupply / arg1 * _marketingFee / 10000 != stor12 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * _taxFee / 10000 * stor12 / totalSupply > arg1 * stor12 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * stor12 / totalSupply < arg1 * _taxFee / 10000 * stor12 / totalSupply:
                                revert with 0, 17
                            if arg1 * _liquidityFee / 10000 * stor12 / totalSupply > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) < arg1 * _liquidityFee / 10000 * stor12 / totalSupply:
                                revert with 0, 17
                            if arg1 * _marketingFee / 10000 * stor12 / totalSupply > (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * stor12 / totalSupply) - (arg1 * _taxFee / 10000 * stor12 / totalSupply) - (arg1 * _liquidityFee / 10000 * stor12 / totalSupply) < arg1 * _marketingFee / 10000 * stor12 / totalSupply:
                                revert with 0, 17
    return (arg1 * stor12 / totalSupply)
}



}

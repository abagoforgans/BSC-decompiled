contract main {




// =====================  Runtime code  =====================


#
#  - add(uint256 arg1, address arg2, bool arg3)
#  - deposit(uint256 arg1, uint256 arg2)
#
const BONUS_MULTIPLIER = 1


address owner;
address sub_64d46cecAddress;
uint256 devFundDivRate;
address devaddr;
uint256 bonusEndBlock;
uint256 sub_a3eef5b2;
array of struct poolInfo;
mapping of struct userInfo;
uint256 totalAllocPoint;
uint256 startBlock;
uint256 endBlock;

function poolLength() payable {
    return poolInfo.length
}

function endBlock() payable {
    return endBlock
}

function poolInfo(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 < poolInfo.length
    return poolInfo[arg1].field_0, poolInfo[arg1].field_256, poolInfo[arg1].field_512, poolInfo[arg1].field_768
}

function totalAllocPoint() payable {
    return totalAllocPoint
}

function bonusEndBlock() payable {
    return bonusEndBlock
}

function startBlock() payable {
    return startBlock
}

function devFundDivRate() payable {
    return devFundDivRate
}

function sub_64d46cec(?) payable {
    return sub_64d46cecAddress
}

function owner() payable {
    return owner
}

function userInfo(uint256 arg1, address arg2) payable {
    require calldata.size - 4 >= 64
    return userInfo[arg1][arg2].field_0, userInfo[arg1][arg2].field_256
}

function sub_a3eef5b2(?) payable {
    return sub_a3eef5b2
}

function devaddr() payable {
    return devaddr
}

function _fallback() payable {
    revert
}

function dev(address arg1) payable {
    require calldata.size - 4 >= 32
    if devaddr != msg.sender:
        revert with 0, 'dev: wut?'
    devaddr = arg1
}

function renounceOwnership() payable {
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    emit OwnershipTransferred(owner, 0);
    owner = 0
}

function setBonusEndBlock(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    bonusEndBlock = arg1
}

function sub_e080c6c5(?) payable {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if arg1 <= 0:
        revert with 0, '!yftPerBlock-0'
    sub_a3eef5b2 = arg1
}

function setDevFundDivRate(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if arg1 <= 0:
        revert with 0, '!devFundDivRate-0'
    devFundDivRate = arg1
}

function transferOwnership(address arg1) payable {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    32,
                    38,
                    0xfe4f776e61626c653a206e6577206f776e657220697320746865207a65726f20616464726573,
                    mem[202 len 26]
    emit OwnershipTransferred(owner, arg1);
    owner = arg1
}

function emergencyWithdraw(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 < poolInfo.length
    if ext_code.hash(poolInfo[arg1].field_0) == 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470:
        revert with 0, 'Address: call to non-contract'
    if not ext_code.hash(poolInfo[arg1].field_0):
        revert with 0, 'Address: call to non-contract'
    mem[260 len 64] = unknown_0xa9059cbb(?????), msg.sender, userInfo[arg1][address(msg.sender)].field_32
    call poolInfo[arg1].field_0 with:
       funct uint32(msg.sender)
         gas gas_remaining wei
        args userInfo[arg1][address(msg.sender)].field_0, mem[324 len 4]
    if not return_data.size:
        if not ext_call.success:
            revert with unknown_0xa9059cbb(?????), msg.sender, userInfo[arg1][address(msg.sender)].field_0
        if not unknown_0xa9059cbb(?????), Mask(224, 32, msg.sender) >> 32:
            revert with 0, 32, 42, 0x775361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565, mem[370 len 22]
    else:
        mem[292 len return_data.size] = ext_call.return_data[0 len return_data.size]
        if not ext_call.success:
            if return_data.size > 0:
                revert with ext_call.return_data[0 len return_data.size]
            revert with 0, 'SafeERC20: low-level call failed'
        if return_data.size > 0:
            require return_data.size >= 32
            if not mem[292]:
                revert with 0, 
                            32,
                            42,
                            0x775361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                            mem[ceil32(return_data.size) + 371 len 22]
    emit EmergencyWithdraw(userInfo[arg1][address(msg.sender)].field_0, msg.sender, arg1);
    userInfo[arg1][address(msg.sender)].field_0 = 0
    userInfo[arg1][address(msg.sender)].field_256 = 0
}

function getMultiplier(uint256 arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    if arg1 <= endBlock:
        if arg2 <= endBlock:
            if arg2 <= bonusEndBlock:
                if arg1 > arg2:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not arg2 - arg1:
                    return 0
                require arg2 - arg1
                if arg2 - arg1 / arg2 - arg1 != 1:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                return (arg2 - arg1)
            if arg1 >= bonusEndBlock:
                if arg1 > arg2:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (arg2 - arg1)
            if bonusEndBlock > arg2:
                revert with 0, 'SafeMath: subtraction overflow'
            if arg1 > bonusEndBlock:
                revert with 0, 'SafeMath: subtraction overflow'
            if not bonusEndBlock - arg1:
                if arg2 - bonusEndBlock < 0:
                    revert with 0, 'SafeMath: addition overflow'
                return (arg2 - bonusEndBlock)
            require bonusEndBlock - arg1
            if bonusEndBlock - arg1 / bonusEndBlock - arg1 != 1:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
            if arg2 < bonusEndBlock:
                revert with 0, 'SafeMath: addition overflow'
            return (-arg1 + arg2)
        if endBlock <= bonusEndBlock:
            if arg1 > endBlock:
                revert with 0, 'SafeMath: subtraction overflow'
            if not endBlock - arg1:
                return 0
            require endBlock - arg1
            if endBlock - arg1 / endBlock - arg1 != 1:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
            return (endBlock - arg1)
        if arg1 >= bonusEndBlock:
            if arg1 > endBlock:
                revert with 0, 'SafeMath: subtraction overflow'
            return (endBlock - arg1)
        if bonusEndBlock > endBlock:
            revert with 0, 'SafeMath: subtraction overflow'
        if arg1 > bonusEndBlock:
            revert with 0, 'SafeMath: subtraction overflow'
        if not bonusEndBlock - arg1:
            if endBlock - bonusEndBlock < 0:
                revert with 0, 'SafeMath: addition overflow'
            return (endBlock - bonusEndBlock)
        require bonusEndBlock - arg1
        if bonusEndBlock - arg1 / bonusEndBlock - arg1 != 1:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
        if endBlock < bonusEndBlock:
            revert with 0, 'SafeMath: addition overflow'
        return (-arg1 + endBlock)
    if arg2 <= endBlock:
        if arg2 <= bonusEndBlock:
            if endBlock > arg2:
                revert with 0, 'SafeMath: subtraction overflow'
            if not arg2 - endBlock:
                return 0
            require arg2 - endBlock
            if arg2 - endBlock / arg2 - endBlock != 1:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
            return (arg2 - endBlock)
        if endBlock >= bonusEndBlock:
            if endBlock > arg2:
                revert with 0, 'SafeMath: subtraction overflow'
            return (arg2 - endBlock)
        if bonusEndBlock > arg2:
            revert with 0, 'SafeMath: subtraction overflow'
        if endBlock > bonusEndBlock:
            revert with 0, 'SafeMath: subtraction overflow'
        if not bonusEndBlock - endBlock:
            if arg2 - bonusEndBlock < 0:
                revert with 0, 'SafeMath: addition overflow'
            return (arg2 - bonusEndBlock)
        require bonusEndBlock - endBlock
        if bonusEndBlock - endBlock / bonusEndBlock - endBlock != 1:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
        if arg2 < bonusEndBlock:
            revert with 0, 'SafeMath: addition overflow'
        return (-endBlock + arg2)
    if endBlock <= bonusEndBlock:
        if endBlock > endBlock:
            revert with 0, 'SafeMath: subtraction overflow'
    else:
        if endBlock >= bonusEndBlock:
            if endBlock > endBlock:
                revert with 0, 'SafeMath: subtraction overflow'
        else:
            if bonusEndBlock > endBlock:
                revert with 0, 'SafeMath: subtraction overflow'
            if endBlock > bonusEndBlock:
                revert with 0, 'SafeMath: subtraction overflow'
            if not bonusEndBlock - endBlock:
                if endBlock - bonusEndBlock < 0:
                    revert with 0, 'SafeMath: addition overflow'
                return (endBlock - bonusEndBlock)
            require bonusEndBlock - endBlock
            if bonusEndBlock - endBlock / bonusEndBlock - endBlock != 1:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
            if 0 < bonusEndBlock - endBlock:
                revert with 0, 'SafeMath: addition overflow'
    return 0
}

function updatePool(uint256 arg1) payable {
    require calldata.size - 4 >= 32
    require arg1 < poolInfo.length
    if block.number > poolInfo[arg1].field_512:
        require ext_code.size(poolInfo[arg1].field_0)
        staticcall poolInfo[arg1].field_0.0x70a08231 with:
                gas gas_remaining wei
               args this.address
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if ext_call.return_data[0]:
            if poolInfo[arg1].field_512 <= endBlock:
                if block.number <= endBlock:
                    if block.number <= bonusEndBlock:
                        if poolInfo[arg1].field_512 > block.number:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not block.number - poolInfo[arg1].field_512:
                            if totalAllocPoint <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require totalAllocPoint
                            if devFundDivRate <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require devFundDivRate
                            require ext_code.size(sub_64d46cecAddress)
                            call sub_64d46cecAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args devaddr, 0 / totalAllocPoint / devFundDivRate
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(sub_64d46cecAddress)
                            call sub_64d46cecAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args address(this.address), 0 / totalAllocPoint
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if not 0 / totalAllocPoint:
                                if ext_call.return_data[0] <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require ext_call.return_data[0]
                                if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                            else:
                                require 0 / totalAllocPoint
                                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                if ext_call.return_data[0] <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require ext_call.return_data[0]
                                if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                        else:
                            require block.number - poolInfo[arg1].field_512
                            if block.number - poolInfo[arg1].field_512 / block.number - poolInfo[arg1].field_512 != 1:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                            if not block.number - poolInfo[arg1].field_512:
                                if totalAllocPoint <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require totalAllocPoint
                                if devFundDivRate <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require devFundDivRate
                                require ext_code.size(sub_64d46cecAddress)
                                call sub_64d46cecAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args devaddr, 0 / totalAllocPoint / devFundDivRate
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(sub_64d46cecAddress)
                                call sub_64d46cecAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args address(this.address), 0 / totalAllocPoint
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if not 0 / totalAllocPoint:
                                    if ext_call.return_data[0] <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require ext_call.return_data[0]
                                    if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                else:
                                    require 0 / totalAllocPoint
                                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                    if ext_call.return_data[0] <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require ext_call.return_data[0]
                                    if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                            else:
                                require block.number - poolInfo[arg1].field_512
                                if (block.number * sub_a3eef5b2) - (poolInfo[arg1].field_512 * sub_a3eef5b2) / block.number - poolInfo[arg1].field_512 != sub_a3eef5b2:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                                if not (block.number * sub_a3eef5b2) - (poolInfo[arg1].field_512 * sub_a3eef5b2):
                                    if totalAllocPoint <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require totalAllocPoint
                                    if devFundDivRate <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require devFundDivRate
                                    require ext_code.size(sub_64d46cecAddress)
                                    call sub_64d46cecAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args devaddr, 0 / totalAllocPoint / devFundDivRate
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(sub_64d46cecAddress)
                                    call sub_64d46cecAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args address(this.address), 0 / totalAllocPoint
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not 0 / totalAllocPoint:
                                        if ext_call.return_data[0] <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require ext_call.return_data[0]
                                        if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                    else:
                                        require 0 / totalAllocPoint
                                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                        if ext_call.return_data[0] <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require ext_call.return_data[0]
                                        if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                else:
                                    require (block.number * sub_a3eef5b2) - (poolInfo[arg1].field_512 * sub_a3eef5b2)
                                    if (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / (block.number * sub_a3eef5b2) - (poolInfo[arg1].field_512 * sub_a3eef5b2) != poolInfo[arg1].field_256:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                                    if totalAllocPoint <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require totalAllocPoint
                                    if devFundDivRate <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require devFundDivRate
                                    require ext_code.size(sub_64d46cecAddress)
                                    call sub_64d46cecAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args devaddr, (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / devFundDivRate
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(sub_64d46cecAddress)
                                    call sub_64d46cecAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args address(this.address), (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint:
                                        if ext_call.return_data[0] <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require ext_call.return_data[0]
                                        if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                    else:
                                        require (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint
                                        if 10^12 * (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                        if ext_call.return_data[0] <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require ext_call.return_data[0]
                                        if poolInfo[arg1].field_768 + (10^12 * (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 10^12 * (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]
                    else:
                        if poolInfo[arg1].field_512 >= bonusEndBlock:
                            if poolInfo[arg1].field_512 > block.number:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if not block.number - poolInfo[arg1].field_512:
                                if totalAllocPoint <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require totalAllocPoint
                                if devFundDivRate <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require devFundDivRate
                                require ext_code.size(sub_64d46cecAddress)
                                call sub_64d46cecAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args devaddr, 0 / totalAllocPoint / devFundDivRate
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(sub_64d46cecAddress)
                                call sub_64d46cecAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args address(this.address), 0 / totalAllocPoint
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if not 0 / totalAllocPoint:
                                    if ext_call.return_data[0] <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require ext_call.return_data[0]
                                    if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                else:
                                    require 0 / totalAllocPoint
                                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                    if ext_call.return_data[0] <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require ext_call.return_data[0]
                                    if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                            else:
                                require block.number - poolInfo[arg1].field_512
                                if (block.number * sub_a3eef5b2) - (poolInfo[arg1].field_512 * sub_a3eef5b2) / block.number - poolInfo[arg1].field_512 != sub_a3eef5b2:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                                if not (block.number * sub_a3eef5b2) - (poolInfo[arg1].field_512 * sub_a3eef5b2):
                                    if totalAllocPoint <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require totalAllocPoint
                                    if devFundDivRate <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require devFundDivRate
                                    require ext_code.size(sub_64d46cecAddress)
                                    call sub_64d46cecAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args devaddr, 0 / totalAllocPoint / devFundDivRate
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(sub_64d46cecAddress)
                                    call sub_64d46cecAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args address(this.address), 0 / totalAllocPoint
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not 0 / totalAllocPoint:
                                        if ext_call.return_data[0] <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require ext_call.return_data[0]
                                        if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                    else:
                                        require 0 / totalAllocPoint
                                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                        if ext_call.return_data[0] <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require ext_call.return_data[0]
                                        if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                else:
                                    require (block.number * sub_a3eef5b2) - (poolInfo[arg1].field_512 * sub_a3eef5b2)
                                    if (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / (block.number * sub_a3eef5b2) - (poolInfo[arg1].field_512 * sub_a3eef5b2) != poolInfo[arg1].field_256:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                                    if totalAllocPoint <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require totalAllocPoint
                                    if devFundDivRate <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require devFundDivRate
                                    require ext_code.size(sub_64d46cecAddress)
                                    call sub_64d46cecAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args devaddr, (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / devFundDivRate
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(sub_64d46cecAddress)
                                    call sub_64d46cecAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args address(this.address), (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint:
                                        if ext_call.return_data[0] <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require ext_call.return_data[0]
                                        if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                    else:
                                        require (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint
                                        if 10^12 * (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                        if ext_call.return_data[0] <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require ext_call.return_data[0]
                                        if poolInfo[arg1].field_768 + (10^12 * (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 10^12 * (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]
                        else:
                            if bonusEndBlock > block.number:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if poolInfo[arg1].field_512 > bonusEndBlock:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if not bonusEndBlock - poolInfo[arg1].field_512:
                                if block.number - bonusEndBlock < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not block.number - bonusEndBlock:
                                    if totalAllocPoint <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require totalAllocPoint
                                    if devFundDivRate <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require devFundDivRate
                                    require ext_code.size(sub_64d46cecAddress)
                                    call sub_64d46cecAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args devaddr, 0 / totalAllocPoint / devFundDivRate
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(sub_64d46cecAddress)
                                    call sub_64d46cecAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args address(this.address), 0 / totalAllocPoint
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not 0 / totalAllocPoint:
                                        if ext_call.return_data[0] <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require ext_call.return_data[0]
                                        if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                    else:
                                        require 0 / totalAllocPoint
                                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                        if ext_call.return_data[0] <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require ext_call.return_data[0]
                                        if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                else:
                                    require block.number - bonusEndBlock
                                    if (block.number * sub_a3eef5b2) - (bonusEndBlock * sub_a3eef5b2) / block.number - bonusEndBlock != sub_a3eef5b2:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                                    if not (block.number * sub_a3eef5b2) - (bonusEndBlock * sub_a3eef5b2):
                                        if totalAllocPoint <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalAllocPoint
                                        if devFundDivRate <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require devFundDivRate
                                        require ext_code.size(sub_64d46cecAddress)
                                        call sub_64d46cecAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args devaddr, 0 / totalAllocPoint / devFundDivRate
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require ext_code.size(sub_64d46cecAddress)
                                        call sub_64d46cecAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args address(this.address), 0 / totalAllocPoint
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not 0 / totalAllocPoint:
                                            if ext_call.return_data[0] <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require ext_call.return_data[0]
                                            if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                        else:
                                            require 0 / totalAllocPoint
                                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                            if ext_call.return_data[0] <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require ext_call.return_data[0]
                                            if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                    else:
                                        require (block.number * sub_a3eef5b2) - (bonusEndBlock * sub_a3eef5b2)
                                        if (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / (block.number * sub_a3eef5b2) - (bonusEndBlock * sub_a3eef5b2) != poolInfo[arg1].field_256:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                                        if totalAllocPoint <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalAllocPoint
                                        if devFundDivRate <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require devFundDivRate
                                        require ext_code.size(sub_64d46cecAddress)
                                        call sub_64d46cecAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args devaddr, (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / devFundDivRate
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require ext_code.size(sub_64d46cecAddress)
                                        call sub_64d46cecAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args address(this.address), (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint:
                                            if ext_call.return_data[0] <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require ext_call.return_data[0]
                                            if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                        else:
                                            require (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint
                                            if 10^12 * (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                            if ext_call.return_data[0] <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require ext_call.return_data[0]
                                            if poolInfo[arg1].field_768 + (10^12 * (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 10^12 * (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]
                            else:
                                require bonusEndBlock - poolInfo[arg1].field_512
                                if bonusEndBlock - poolInfo[arg1].field_512 / bonusEndBlock - poolInfo[arg1].field_512 != 1:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                                if block.number < bonusEndBlock:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not -poolInfo[arg1].field_512 + block.number:
                                    if totalAllocPoint <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require totalAllocPoint
                                    if devFundDivRate <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require devFundDivRate
                                    require ext_code.size(sub_64d46cecAddress)
                                    call sub_64d46cecAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args devaddr, 0 / totalAllocPoint / devFundDivRate
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(sub_64d46cecAddress)
                                    call sub_64d46cecAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args address(this.address), 0 / totalAllocPoint
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not 0 / totalAllocPoint:
                                        if ext_call.return_data[0] <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require ext_call.return_data[0]
                                        if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                    else:
                                        require 0 / totalAllocPoint
                                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                        if ext_call.return_data[0] <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require ext_call.return_data[0]
                                        if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                else:
                                    require -poolInfo[arg1].field_512 + block.number
                                    if (-1 * poolInfo[arg1].field_512 * sub_a3eef5b2) + (block.number * sub_a3eef5b2) / -poolInfo[arg1].field_512 + block.number != sub_a3eef5b2:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                                    if not (-1 * poolInfo[arg1].field_512 * sub_a3eef5b2) + (block.number * sub_a3eef5b2):
                                        if totalAllocPoint <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalAllocPoint
                                        if devFundDivRate <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require devFundDivRate
                                        require ext_code.size(sub_64d46cecAddress)
                                        call sub_64d46cecAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args devaddr, 0 / totalAllocPoint / devFundDivRate
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require ext_code.size(sub_64d46cecAddress)
                                        call sub_64d46cecAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args address(this.address), 0 / totalAllocPoint
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not 0 / totalAllocPoint:
                                            if ext_call.return_data[0] <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require ext_call.return_data[0]
                                            if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                        else:
                                            require 0 / totalAllocPoint
                                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                            if ext_call.return_data[0] <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require ext_call.return_data[0]
                                            if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                    else:
                                        require (-1 * poolInfo[arg1].field_512 * sub_a3eef5b2) + (block.number * sub_a3eef5b2)
                                        if (-1 * poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) + (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) / (-1 * poolInfo[arg1].field_512 * sub_a3eef5b2) + (block.number * sub_a3eef5b2) != poolInfo[arg1].field_256:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                                        if totalAllocPoint <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalAllocPoint
                                        if devFundDivRate <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require devFundDivRate
                                        require ext_code.size(sub_64d46cecAddress)
                                        call sub_64d46cecAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args devaddr, (-1 * poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) + (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / devFundDivRate
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require ext_code.size(sub_64d46cecAddress)
                                        call sub_64d46cecAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args address(this.address), (-1 * poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) + (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not (-1 * poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) + (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint:
                                            if ext_call.return_data[0] <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require ext_call.return_data[0]
                                            if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                        else:
                                            require (-1 * poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) + (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint
                                            if 10^12 * (-1 * poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) + (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / (-1 * poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) + (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                            if ext_call.return_data[0] <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require ext_call.return_data[0]
                                            if poolInfo[arg1].field_768 + (10^12 * (-1 * poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) + (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 10^12 * (-1 * poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) + (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]
                else:
                    if endBlock <= bonusEndBlock:
                        if poolInfo[arg1].field_512 > endBlock:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not endBlock - poolInfo[arg1].field_512:
                            if totalAllocPoint <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require totalAllocPoint
                            if devFundDivRate <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require devFundDivRate
                            require ext_code.size(sub_64d46cecAddress)
                            call sub_64d46cecAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args devaddr, 0 / totalAllocPoint / devFundDivRate
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(sub_64d46cecAddress)
                            call sub_64d46cecAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args address(this.address), 0 / totalAllocPoint
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if not 0 / totalAllocPoint:
                                if ext_call.return_data[0] <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require ext_call.return_data[0]
                                if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                            else:
                                require 0 / totalAllocPoint
                                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                if ext_call.return_data[0] <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require ext_call.return_data[0]
                                if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                        else:
                            require endBlock - poolInfo[arg1].field_512
                            if endBlock - poolInfo[arg1].field_512 / endBlock - poolInfo[arg1].field_512 != 1:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                            if not endBlock - poolInfo[arg1].field_512:
                                if totalAllocPoint <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require totalAllocPoint
                                if devFundDivRate <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require devFundDivRate
                                require ext_code.size(sub_64d46cecAddress)
                                call sub_64d46cecAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args devaddr, 0 / totalAllocPoint / devFundDivRate
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(sub_64d46cecAddress)
                                call sub_64d46cecAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args address(this.address), 0 / totalAllocPoint
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if not 0 / totalAllocPoint:
                                    if ext_call.return_data[0] <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require ext_call.return_data[0]
                                    if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                else:
                                    require 0 / totalAllocPoint
                                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                    if ext_call.return_data[0] <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require ext_call.return_data[0]
                                    if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                            else:
                                require endBlock - poolInfo[arg1].field_512
                                if (endBlock * sub_a3eef5b2) - (poolInfo[arg1].field_512 * sub_a3eef5b2) / endBlock - poolInfo[arg1].field_512 != sub_a3eef5b2:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                                if not (endBlock * sub_a3eef5b2) - (poolInfo[arg1].field_512 * sub_a3eef5b2):
                                    if totalAllocPoint <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require totalAllocPoint
                                    if devFundDivRate <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require devFundDivRate
                                    require ext_code.size(sub_64d46cecAddress)
                                    call sub_64d46cecAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args devaddr, 0 / totalAllocPoint / devFundDivRate
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(sub_64d46cecAddress)
                                    call sub_64d46cecAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args address(this.address), 0 / totalAllocPoint
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not 0 / totalAllocPoint:
                                        if ext_call.return_data[0] <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require ext_call.return_data[0]
                                        if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                    else:
                                        require 0 / totalAllocPoint
                                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                        if ext_call.return_data[0] <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require ext_call.return_data[0]
                                        if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                else:
                                    require (endBlock * sub_a3eef5b2) - (poolInfo[arg1].field_512 * sub_a3eef5b2)
                                    if (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / (endBlock * sub_a3eef5b2) - (poolInfo[arg1].field_512 * sub_a3eef5b2) != poolInfo[arg1].field_256:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                                    if totalAllocPoint <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require totalAllocPoint
                                    if devFundDivRate <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require devFundDivRate
                                    require ext_code.size(sub_64d46cecAddress)
                                    call sub_64d46cecAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args devaddr, (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / devFundDivRate
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(sub_64d46cecAddress)
                                    call sub_64d46cecAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args address(this.address), (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint:
                                        if ext_call.return_data[0] <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require ext_call.return_data[0]
                                        if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                    else:
                                        require (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint
                                        if 10^12 * (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                        if ext_call.return_data[0] <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require ext_call.return_data[0]
                                        if poolInfo[arg1].field_768 + (10^12 * (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 10^12 * (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]
                    else:
                        if poolInfo[arg1].field_512 >= bonusEndBlock:
                            if poolInfo[arg1].field_512 > endBlock:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if not endBlock - poolInfo[arg1].field_512:
                                if totalAllocPoint <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require totalAllocPoint
                                if devFundDivRate <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require devFundDivRate
                                require ext_code.size(sub_64d46cecAddress)
                                call sub_64d46cecAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args devaddr, 0 / totalAllocPoint / devFundDivRate
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(sub_64d46cecAddress)
                                call sub_64d46cecAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args address(this.address), 0 / totalAllocPoint
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if not 0 / totalAllocPoint:
                                    if ext_call.return_data[0] <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require ext_call.return_data[0]
                                    if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                else:
                                    require 0 / totalAllocPoint
                                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                    if ext_call.return_data[0] <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require ext_call.return_data[0]
                                    if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                            else:
                                require endBlock - poolInfo[arg1].field_512
                                if (endBlock * sub_a3eef5b2) - (poolInfo[arg1].field_512 * sub_a3eef5b2) / endBlock - poolInfo[arg1].field_512 != sub_a3eef5b2:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                                if not (endBlock * sub_a3eef5b2) - (poolInfo[arg1].field_512 * sub_a3eef5b2):
                                    if totalAllocPoint <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require totalAllocPoint
                                    if devFundDivRate <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require devFundDivRate
                                    require ext_code.size(sub_64d46cecAddress)
                                    call sub_64d46cecAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args devaddr, 0 / totalAllocPoint / devFundDivRate
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(sub_64d46cecAddress)
                                    call sub_64d46cecAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args address(this.address), 0 / totalAllocPoint
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not 0 / totalAllocPoint:
                                        if ext_call.return_data[0] <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require ext_call.return_data[0]
                                        if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                    else:
                                        require 0 / totalAllocPoint
                                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                        if ext_call.return_data[0] <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require ext_call.return_data[0]
                                        if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                else:
                                    require (endBlock * sub_a3eef5b2) - (poolInfo[arg1].field_512 * sub_a3eef5b2)
                                    if (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / (endBlock * sub_a3eef5b2) - (poolInfo[arg1].field_512 * sub_a3eef5b2) != poolInfo[arg1].field_256:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                                    if totalAllocPoint <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require totalAllocPoint
                                    if devFundDivRate <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require devFundDivRate
                                    require ext_code.size(sub_64d46cecAddress)
                                    call sub_64d46cecAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args devaddr, (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / devFundDivRate
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(sub_64d46cecAddress)
                                    call sub_64d46cecAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args address(this.address), (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint:
                                        if ext_call.return_data[0] <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require ext_call.return_data[0]
                                        if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                    else:
                                        require (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint
                                        if 10^12 * (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                        if ext_call.return_data[0] <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require ext_call.return_data[0]
                                        if poolInfo[arg1].field_768 + (10^12 * (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 10^12 * (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]
                        else:
                            if bonusEndBlock > endBlock:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if poolInfo[arg1].field_512 > bonusEndBlock:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if not bonusEndBlock - poolInfo[arg1].field_512:
                                if endBlock - bonusEndBlock < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not endBlock - bonusEndBlock:
                                    if totalAllocPoint <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require totalAllocPoint
                                    if devFundDivRate <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require devFundDivRate
                                    require ext_code.size(sub_64d46cecAddress)
                                    call sub_64d46cecAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args devaddr, 0 / totalAllocPoint / devFundDivRate
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(sub_64d46cecAddress)
                                    call sub_64d46cecAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args address(this.address), 0 / totalAllocPoint
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not 0 / totalAllocPoint:
                                        if ext_call.return_data[0] <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require ext_call.return_data[0]
                                        if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                    else:
                                        require 0 / totalAllocPoint
                                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                        if ext_call.return_data[0] <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require ext_call.return_data[0]
                                        if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                else:
                                    require endBlock - bonusEndBlock
                                    if (endBlock * sub_a3eef5b2) - (bonusEndBlock * sub_a3eef5b2) / endBlock - bonusEndBlock != sub_a3eef5b2:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                                    if not (endBlock * sub_a3eef5b2) - (bonusEndBlock * sub_a3eef5b2):
                                        if totalAllocPoint <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalAllocPoint
                                        if devFundDivRate <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require devFundDivRate
                                        require ext_code.size(sub_64d46cecAddress)
                                        call sub_64d46cecAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args devaddr, 0 / totalAllocPoint / devFundDivRate
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require ext_code.size(sub_64d46cecAddress)
                                        call sub_64d46cecAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args address(this.address), 0 / totalAllocPoint
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not 0 / totalAllocPoint:
                                            if ext_call.return_data[0] <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require ext_call.return_data[0]
                                            if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                        else:
                                            require 0 / totalAllocPoint
                                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                            if ext_call.return_data[0] <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require ext_call.return_data[0]
                                            if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                    else:
                                        require (endBlock * sub_a3eef5b2) - (bonusEndBlock * sub_a3eef5b2)
                                        if (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / (endBlock * sub_a3eef5b2) - (bonusEndBlock * sub_a3eef5b2) != poolInfo[arg1].field_256:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                                        if totalAllocPoint <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalAllocPoint
                                        if devFundDivRate <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require devFundDivRate
                                        require ext_code.size(sub_64d46cecAddress)
                                        call sub_64d46cecAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args devaddr, (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / devFundDivRate
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require ext_code.size(sub_64d46cecAddress)
                                        call sub_64d46cecAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args address(this.address), (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint:
                                            if ext_call.return_data[0] <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require ext_call.return_data[0]
                                            if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                        else:
                                            require (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint
                                            if 10^12 * (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                            if ext_call.return_data[0] <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require ext_call.return_data[0]
                                            if poolInfo[arg1].field_768 + (10^12 * (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 10^12 * (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]
                            else:
                                require bonusEndBlock - poolInfo[arg1].field_512
                                if bonusEndBlock - poolInfo[arg1].field_512 / bonusEndBlock - poolInfo[arg1].field_512 != 1:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                                if endBlock < bonusEndBlock:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not -poolInfo[arg1].field_512 + endBlock:
                                    if totalAllocPoint <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require totalAllocPoint
                                    if devFundDivRate <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require devFundDivRate
                                    require ext_code.size(sub_64d46cecAddress)
                                    call sub_64d46cecAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args devaddr, 0 / totalAllocPoint / devFundDivRate
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(sub_64d46cecAddress)
                                    call sub_64d46cecAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args address(this.address), 0 / totalAllocPoint
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not 0 / totalAllocPoint:
                                        if ext_call.return_data[0] <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require ext_call.return_data[0]
                                        if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                    else:
                                        require 0 / totalAllocPoint
                                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                        if ext_call.return_data[0] <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require ext_call.return_data[0]
                                        if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                else:
                                    require -poolInfo[arg1].field_512 + endBlock
                                    if (-1 * poolInfo[arg1].field_512 * sub_a3eef5b2) + (endBlock * sub_a3eef5b2) / -poolInfo[arg1].field_512 + endBlock != sub_a3eef5b2:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                                    if not (-1 * poolInfo[arg1].field_512 * sub_a3eef5b2) + (endBlock * sub_a3eef5b2):
                                        if totalAllocPoint <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalAllocPoint
                                        if devFundDivRate <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require devFundDivRate
                                        require ext_code.size(sub_64d46cecAddress)
                                        call sub_64d46cecAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args devaddr, 0 / totalAllocPoint / devFundDivRate
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require ext_code.size(sub_64d46cecAddress)
                                        call sub_64d46cecAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args address(this.address), 0 / totalAllocPoint
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not 0 / totalAllocPoint:
                                            if ext_call.return_data[0] <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require ext_call.return_data[0]
                                            if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                        else:
                                            require 0 / totalAllocPoint
                                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                            if ext_call.return_data[0] <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require ext_call.return_data[0]
                                            if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                    else:
                                        require (-1 * poolInfo[arg1].field_512 * sub_a3eef5b2) + (endBlock * sub_a3eef5b2)
                                        if (-1 * poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) + (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / (-1 * poolInfo[arg1].field_512 * sub_a3eef5b2) + (endBlock * sub_a3eef5b2) != poolInfo[arg1].field_256:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                                        if totalAllocPoint <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalAllocPoint
                                        if devFundDivRate <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require devFundDivRate
                                        require ext_code.size(sub_64d46cecAddress)
                                        call sub_64d46cecAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args devaddr, (-1 * poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) + (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / devFundDivRate
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require ext_code.size(sub_64d46cecAddress)
                                        call sub_64d46cecAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args address(this.address), (-1 * poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) + (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not (-1 * poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) + (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint:
                                            if ext_call.return_data[0] <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require ext_call.return_data[0]
                                            if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                        else:
                                            require (-1 * poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) + (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint
                                            if 10^12 * (-1 * poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) + (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / (-1 * poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) + (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                            if ext_call.return_data[0] <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require ext_call.return_data[0]
                                            if poolInfo[arg1].field_768 + (10^12 * (-1 * poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) + (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 10^12 * (-1 * poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) + (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]
            else:
                if block.number > endBlock:
                    if endBlock <= bonusEndBlock:
                        if endBlock > endBlock:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if totalAllocPoint <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require totalAllocPoint
                        if devFundDivRate <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require devFundDivRate
                        require ext_code.size(sub_64d46cecAddress)
                        call sub_64d46cecAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args devaddr, 0 / totalAllocPoint / devFundDivRate
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require ext_code.size(sub_64d46cecAddress)
                        call sub_64d46cecAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args address(this.address), 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not 0 / totalAllocPoint:
                            if ext_call.return_data[0] <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require ext_call.return_data[0]
                            if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                        else:
                            require 0 / totalAllocPoint
                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                            if ext_call.return_data[0] <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require ext_call.return_data[0]
                            if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                    else:
                        if endBlock >= bonusEndBlock:
                            if endBlock > endBlock:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if totalAllocPoint <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require totalAllocPoint
                            if devFundDivRate <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require devFundDivRate
                            require ext_code.size(sub_64d46cecAddress)
                            call sub_64d46cecAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args devaddr, 0 / totalAllocPoint / devFundDivRate
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(sub_64d46cecAddress)
                            call sub_64d46cecAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args address(this.address), 0 / totalAllocPoint
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if not 0 / totalAllocPoint:
                                if ext_call.return_data[0] <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require ext_call.return_data[0]
                                if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                            else:
                                require 0 / totalAllocPoint
                                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                if ext_call.return_data[0] <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require ext_call.return_data[0]
                                if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                        else:
                            if bonusEndBlock > endBlock:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if endBlock > bonusEndBlock:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if bonusEndBlock - endBlock:
                                require bonusEndBlock - endBlock
                                if bonusEndBlock - endBlock / bonusEndBlock - endBlock != 1:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                                if 0 < bonusEndBlock - endBlock:
                                    revert with 0, 'SafeMath: addition overflow'
                                if totalAllocPoint <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require totalAllocPoint
                                if devFundDivRate <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require devFundDivRate
                                require ext_code.size(sub_64d46cecAddress)
                                call sub_64d46cecAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args devaddr, 0 / totalAllocPoint / devFundDivRate
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(sub_64d46cecAddress)
                                call sub_64d46cecAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args address(this.address), 0 / totalAllocPoint
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if not 0 / totalAllocPoint:
                                    if ext_call.return_data[0] <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require ext_call.return_data[0]
                                    if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                else:
                                    require 0 / totalAllocPoint
                                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                    if ext_call.return_data[0] <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require ext_call.return_data[0]
                                    if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                            else:
                                if endBlock - bonusEndBlock < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not endBlock - bonusEndBlock:
                                    if totalAllocPoint <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require totalAllocPoint
                                    if devFundDivRate <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require devFundDivRate
                                    require ext_code.size(sub_64d46cecAddress)
                                    call sub_64d46cecAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args devaddr, 0 / totalAllocPoint / devFundDivRate
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(sub_64d46cecAddress)
                                    call sub_64d46cecAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args address(this.address), 0 / totalAllocPoint
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not 0 / totalAllocPoint:
                                        if ext_call.return_data[0] <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require ext_call.return_data[0]
                                        if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                    else:
                                        require 0 / totalAllocPoint
                                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                        if ext_call.return_data[0] <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require ext_call.return_data[0]
                                        if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                else:
                                    require endBlock - bonusEndBlock
                                    if (endBlock * sub_a3eef5b2) - (bonusEndBlock * sub_a3eef5b2) / endBlock - bonusEndBlock != sub_a3eef5b2:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                                    if not (endBlock * sub_a3eef5b2) - (bonusEndBlock * sub_a3eef5b2):
                                        if totalAllocPoint <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalAllocPoint
                                        if devFundDivRate <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require devFundDivRate
                                        require ext_code.size(sub_64d46cecAddress)
                                        call sub_64d46cecAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args devaddr, 0 / totalAllocPoint / devFundDivRate
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require ext_code.size(sub_64d46cecAddress)
                                        call sub_64d46cecAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args address(this.address), 0 / totalAllocPoint
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not 0 / totalAllocPoint:
                                            if ext_call.return_data[0] <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require ext_call.return_data[0]
                                            if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                        else:
                                            require 0 / totalAllocPoint
                                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                            if ext_call.return_data[0] <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require ext_call.return_data[0]
                                            if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                    else:
                                        require (endBlock * sub_a3eef5b2) - (bonusEndBlock * sub_a3eef5b2)
                                        if (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / (endBlock * sub_a3eef5b2) - (bonusEndBlock * sub_a3eef5b2) != poolInfo[arg1].field_256:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                                        if totalAllocPoint <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalAllocPoint
                                        if devFundDivRate <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require devFundDivRate
                                        require ext_code.size(sub_64d46cecAddress)
                                        call sub_64d46cecAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args devaddr, (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / devFundDivRate
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require ext_code.size(sub_64d46cecAddress)
                                        call sub_64d46cecAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args address(this.address), (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint:
                                            if ext_call.return_data[0] <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require ext_call.return_data[0]
                                            if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                        else:
                                            require (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint
                                            if 10^12 * (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                            if ext_call.return_data[0] <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require ext_call.return_data[0]
                                            if poolInfo[arg1].field_768 + (10^12 * (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 10^12 * (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]
                else:
                    if block.number <= bonusEndBlock:
                        if endBlock > block.number:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not block.number - endBlock:
                            if totalAllocPoint <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require totalAllocPoint
                            if devFundDivRate <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require devFundDivRate
                            require ext_code.size(sub_64d46cecAddress)
                            call sub_64d46cecAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args devaddr, 0 / totalAllocPoint / devFundDivRate
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(sub_64d46cecAddress)
                            call sub_64d46cecAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args address(this.address), 0 / totalAllocPoint
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if not 0 / totalAllocPoint:
                                if ext_call.return_data[0] <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require ext_call.return_data[0]
                                if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                            else:
                                require 0 / totalAllocPoint
                                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                if ext_call.return_data[0] <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require ext_call.return_data[0]
                                if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                        else:
                            require block.number - endBlock
                            if block.number - endBlock / block.number - endBlock != 1:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                            if not block.number - endBlock:
                                if totalAllocPoint <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require totalAllocPoint
                                if devFundDivRate <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require devFundDivRate
                                require ext_code.size(sub_64d46cecAddress)
                                call sub_64d46cecAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args devaddr, 0 / totalAllocPoint / devFundDivRate
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(sub_64d46cecAddress)
                                call sub_64d46cecAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args address(this.address), 0 / totalAllocPoint
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if not 0 / totalAllocPoint:
                                    if ext_call.return_data[0] <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require ext_call.return_data[0]
                                    if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                else:
                                    require 0 / totalAllocPoint
                                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                    if ext_call.return_data[0] <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require ext_call.return_data[0]
                                    if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                            else:
                                require block.number - endBlock
                                if (block.number * sub_a3eef5b2) - (endBlock * sub_a3eef5b2) / block.number - endBlock != sub_a3eef5b2:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                                if not (block.number * sub_a3eef5b2) - (endBlock * sub_a3eef5b2):
                                    if totalAllocPoint <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require totalAllocPoint
                                    if devFundDivRate <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require devFundDivRate
                                    require ext_code.size(sub_64d46cecAddress)
                                    call sub_64d46cecAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args devaddr, 0 / totalAllocPoint / devFundDivRate
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(sub_64d46cecAddress)
                                    call sub_64d46cecAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args address(this.address), 0 / totalAllocPoint
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not 0 / totalAllocPoint:
                                        if ext_call.return_data[0] <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require ext_call.return_data[0]
                                        if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                    else:
                                        require 0 / totalAllocPoint
                                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                        if ext_call.return_data[0] <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require ext_call.return_data[0]
                                        if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                else:
                                    require (block.number * sub_a3eef5b2) - (endBlock * sub_a3eef5b2)
                                    if (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / (block.number * sub_a3eef5b2) - (endBlock * sub_a3eef5b2) != poolInfo[arg1].field_256:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                                    if totalAllocPoint <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require totalAllocPoint
                                    if devFundDivRate <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require devFundDivRate
                                    require ext_code.size(sub_64d46cecAddress)
                                    call sub_64d46cecAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args devaddr, (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / devFundDivRate
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(sub_64d46cecAddress)
                                    call sub_64d46cecAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args address(this.address), (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint:
                                        if ext_call.return_data[0] <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require ext_call.return_data[0]
                                        if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                    else:
                                        require (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint
                                        if 10^12 * (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                        if ext_call.return_data[0] <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require ext_call.return_data[0]
                                        if poolInfo[arg1].field_768 + (10^12 * (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 10^12 * (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]
                    else:
                        if endBlock >= bonusEndBlock:
                            if endBlock > block.number:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if not block.number - endBlock:
                                if totalAllocPoint <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require totalAllocPoint
                                if devFundDivRate <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require devFundDivRate
                                require ext_code.size(sub_64d46cecAddress)
                                call sub_64d46cecAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args devaddr, 0 / totalAllocPoint / devFundDivRate
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(sub_64d46cecAddress)
                                call sub_64d46cecAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args address(this.address), 0 / totalAllocPoint
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if not 0 / totalAllocPoint:
                                    if ext_call.return_data[0] <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require ext_call.return_data[0]
                                    if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                else:
                                    require 0 / totalAllocPoint
                                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                    if ext_call.return_data[0] <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require ext_call.return_data[0]
                                    if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                            else:
                                require block.number - endBlock
                                if (block.number * sub_a3eef5b2) - (endBlock * sub_a3eef5b2) / block.number - endBlock != sub_a3eef5b2:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                                if not (block.number * sub_a3eef5b2) - (endBlock * sub_a3eef5b2):
                                    if totalAllocPoint <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require totalAllocPoint
                                    if devFundDivRate <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require devFundDivRate
                                    require ext_code.size(sub_64d46cecAddress)
                                    call sub_64d46cecAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args devaddr, 0 / totalAllocPoint / devFundDivRate
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(sub_64d46cecAddress)
                                    call sub_64d46cecAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args address(this.address), 0 / totalAllocPoint
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not 0 / totalAllocPoint:
                                        if ext_call.return_data[0] <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require ext_call.return_data[0]
                                        if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                    else:
                                        require 0 / totalAllocPoint
                                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                        if ext_call.return_data[0] <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require ext_call.return_data[0]
                                        if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                else:
                                    require (block.number * sub_a3eef5b2) - (endBlock * sub_a3eef5b2)
                                    if (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / (block.number * sub_a3eef5b2) - (endBlock * sub_a3eef5b2) != poolInfo[arg1].field_256:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                                    if totalAllocPoint <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require totalAllocPoint
                                    if devFundDivRate <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require devFundDivRate
                                    require ext_code.size(sub_64d46cecAddress)
                                    call sub_64d46cecAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args devaddr, (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / devFundDivRate
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(sub_64d46cecAddress)
                                    call sub_64d46cecAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args address(this.address), (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint:
                                        if ext_call.return_data[0] <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require ext_call.return_data[0]
                                        if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                    else:
                                        require (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint
                                        if 10^12 * (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                        if ext_call.return_data[0] <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require ext_call.return_data[0]
                                        if poolInfo[arg1].field_768 + (10^12 * (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 10^12 * (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]
                        else:
                            if bonusEndBlock > block.number:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if endBlock > bonusEndBlock:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if not bonusEndBlock - endBlock:
                                if block.number - bonusEndBlock < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not block.number - bonusEndBlock:
                                    if totalAllocPoint <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require totalAllocPoint
                                    if devFundDivRate <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require devFundDivRate
                                    require ext_code.size(sub_64d46cecAddress)
                                    call sub_64d46cecAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args devaddr, 0 / totalAllocPoint / devFundDivRate
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(sub_64d46cecAddress)
                                    call sub_64d46cecAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args address(this.address), 0 / totalAllocPoint
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not 0 / totalAllocPoint:
                                        if ext_call.return_data[0] <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require ext_call.return_data[0]
                                        if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                    else:
                                        require 0 / totalAllocPoint
                                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                        if ext_call.return_data[0] <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require ext_call.return_data[0]
                                        if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                else:
                                    require block.number - bonusEndBlock
                                    if (block.number * sub_a3eef5b2) - (bonusEndBlock * sub_a3eef5b2) / block.number - bonusEndBlock != sub_a3eef5b2:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                                    if not (block.number * sub_a3eef5b2) - (bonusEndBlock * sub_a3eef5b2):
                                        if totalAllocPoint <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalAllocPoint
                                        if devFundDivRate <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require devFundDivRate
                                        require ext_code.size(sub_64d46cecAddress)
                                        call sub_64d46cecAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args devaddr, 0 / totalAllocPoint / devFundDivRate
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require ext_code.size(sub_64d46cecAddress)
                                        call sub_64d46cecAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args address(this.address), 0 / totalAllocPoint
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not 0 / totalAllocPoint:
                                            if ext_call.return_data[0] <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require ext_call.return_data[0]
                                            if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                        else:
                                            require 0 / totalAllocPoint
                                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                            if ext_call.return_data[0] <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require ext_call.return_data[0]
                                            if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                    else:
                                        require (block.number * sub_a3eef5b2) - (bonusEndBlock * sub_a3eef5b2)
                                        if (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / (block.number * sub_a3eef5b2) - (bonusEndBlock * sub_a3eef5b2) != poolInfo[arg1].field_256:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                                        if totalAllocPoint <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalAllocPoint
                                        if devFundDivRate <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require devFundDivRate
                                        require ext_code.size(sub_64d46cecAddress)
                                        call sub_64d46cecAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args devaddr, (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / devFundDivRate
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require ext_code.size(sub_64d46cecAddress)
                                        call sub_64d46cecAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args address(this.address), (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint:
                                            if ext_call.return_data[0] <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require ext_call.return_data[0]
                                            if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                        else:
                                            require (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint
                                            if 10^12 * (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                            if ext_call.return_data[0] <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require ext_call.return_data[0]
                                            if poolInfo[arg1].field_768 + (10^12 * (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 10^12 * (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]
                            else:
                                require bonusEndBlock - endBlock
                                if bonusEndBlock - endBlock / bonusEndBlock - endBlock != 1:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                                if block.number < bonusEndBlock:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not -endBlock + block.number:
                                    if totalAllocPoint <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require totalAllocPoint
                                    if devFundDivRate <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require devFundDivRate
                                    require ext_code.size(sub_64d46cecAddress)
                                    call sub_64d46cecAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args devaddr, 0 / totalAllocPoint / devFundDivRate
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(sub_64d46cecAddress)
                                    call sub_64d46cecAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args address(this.address), 0 / totalAllocPoint
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not 0 / totalAllocPoint:
                                        if ext_call.return_data[0] <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require ext_call.return_data[0]
                                        if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                    else:
                                        require 0 / totalAllocPoint
                                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                        if ext_call.return_data[0] <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require ext_call.return_data[0]
                                        if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                else:
                                    require -endBlock + block.number
                                    if (-1 * endBlock * sub_a3eef5b2) + (block.number * sub_a3eef5b2) / -endBlock + block.number != sub_a3eef5b2:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                                    if not (-1 * endBlock * sub_a3eef5b2) + (block.number * sub_a3eef5b2):
                                        if totalAllocPoint <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalAllocPoint
                                        if devFundDivRate <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require devFundDivRate
                                        require ext_code.size(sub_64d46cecAddress)
                                        call sub_64d46cecAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args devaddr, 0 / totalAllocPoint / devFundDivRate
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require ext_code.size(sub_64d46cecAddress)
                                        call sub_64d46cecAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args address(this.address), 0 / totalAllocPoint
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not 0 / totalAllocPoint:
                                            if ext_call.return_data[0] <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require ext_call.return_data[0]
                                            if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                        else:
                                            require 0 / totalAllocPoint
                                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                            if ext_call.return_data[0] <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require ext_call.return_data[0]
                                            if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                    else:
                                        require (-1 * endBlock * sub_a3eef5b2) + (block.number * sub_a3eef5b2)
                                        if (-1 * endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) + (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) / (-1 * endBlock * sub_a3eef5b2) + (block.number * sub_a3eef5b2) != poolInfo[arg1].field_256:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                                        if totalAllocPoint <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalAllocPoint
                                        if devFundDivRate <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require devFundDivRate
                                        require ext_code.size(sub_64d46cecAddress)
                                        call sub_64d46cecAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args devaddr, (-1 * endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) + (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / devFundDivRate
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require ext_code.size(sub_64d46cecAddress)
                                        call sub_64d46cecAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args address(this.address), (-1 * endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) + (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not (-1 * endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) + (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint:
                                            if ext_call.return_data[0] <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require ext_call.return_data[0]
                                            if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                        else:
                                            require (-1 * endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) + (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint
                                            if 10^12 * (-1 * endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) + (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / (-1 * endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) + (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                            if ext_call.return_data[0] <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require ext_call.return_data[0]
                                            if poolInfo[arg1].field_768 + (10^12 * (-1 * endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) + (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 10^12 * (-1 * endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) + (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]
        poolInfo[arg1].field_512 = block.number
}

function sub_68f35a80(?) payable {
    require calldata.size - 4 >= 64
    require arg1 < poolInfo.length
    require ext_code.size(poolInfo[arg1].field_0)
    staticcall poolInfo[arg1].field_0.0x70a08231 with:
            gas gas_remaining wei
           args this.address
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    if block.number <= poolInfo[arg1].field_512:
        if not userInfo[arg1][address(arg2)].field_0:
            if userInfo[arg1][address(arg2)].field_256 > 0:
                revert with 0, 'SafeMath: subtraction overflow'
            return -userInfo[arg1][address(arg2)].field_256
        require userInfo[arg1][address(arg2)].field_0
        if userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        33,
                        0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[197 len 31]
        if userInfo[arg1][address(arg2)].field_256 > userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / 10^12:
            revert with 0, 'SafeMath: subtraction overflow'
        return ((userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(arg2)].field_256)
    if not ext_call.return_data[0]:
        if not userInfo[arg1][address(arg2)].field_0:
            if userInfo[arg1][address(arg2)].field_256 > 0:
                revert with 0, 'SafeMath: subtraction overflow'
            return -userInfo[arg1][address(arg2)].field_256
        require userInfo[arg1][address(arg2)].field_0
        if userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                        32,
                        33,
                        0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                        mem[197 len 31]
        if userInfo[arg1][address(arg2)].field_256 > userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / 10^12:
            revert with 0, 'SafeMath: subtraction overflow'
        return ((userInfo[arg1][address(arg2)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(arg2)].field_256)
    if poolInfo[arg1].field_512 <= endBlock:
        if block.number <= endBlock:
            if block.number <= bonusEndBlock:
                if poolInfo[arg1].field_512 > block.number:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not block.number - poolInfo[arg1].field_512:
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not 0 / totalAllocPoint:
                        if ext_call.return_data[0] <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require ext_call.return_data[0]
                        if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256
                        require userInfo[arg1][address(arg2)].field_0
                        if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]):
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                    require 0 / totalAllocPoint
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                    if ext_call.return_data[0] <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require ext_call.return_data[0]
                    if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256
                    require userInfo[arg1][address(arg2)].field_0
                    if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]):
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                require block.number - poolInfo[arg1].field_512
                if block.number - poolInfo[arg1].field_512 / block.number - poolInfo[arg1].field_512 != 1:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                if not block.number - poolInfo[arg1].field_512:
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not 0 / totalAllocPoint:
                        if ext_call.return_data[0] <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require ext_call.return_data[0]
                        if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256
                        require userInfo[arg1][address(arg2)].field_0
                        if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]):
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                    require 0 / totalAllocPoint
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                    if ext_call.return_data[0] <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require ext_call.return_data[0]
                    if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256
                    require userInfo[arg1][address(arg2)].field_0
                    if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]):
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                require block.number - poolInfo[arg1].field_512
                if (block.number * sub_a3eef5b2) - (poolInfo[arg1].field_512 * sub_a3eef5b2) / block.number - poolInfo[arg1].field_512 != sub_a3eef5b2:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                if not (block.number * sub_a3eef5b2) - (poolInfo[arg1].field_512 * sub_a3eef5b2):
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not 0 / totalAllocPoint:
                        if ext_call.return_data[0] <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require ext_call.return_data[0]
                        if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256
                        require userInfo[arg1][address(arg2)].field_0
                        if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]):
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                    require 0 / totalAllocPoint
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                    if ext_call.return_data[0] <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require ext_call.return_data[0]
                    if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256
                    require userInfo[arg1][address(arg2)].field_0
                    if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]):
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                require (block.number * sub_a3eef5b2) - (poolInfo[arg1].field_512 * sub_a3eef5b2)
                if (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / (block.number * sub_a3eef5b2) - (poolInfo[arg1].field_512 * sub_a3eef5b2) != poolInfo[arg1].field_256:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint:
                    if ext_call.return_data[0] <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require ext_call.return_data[0]
                    if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256
                    require userInfo[arg1][address(arg2)].field_0
                    if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]):
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                require (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint
                if 10^12 * (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                if ext_call.return_data[0] <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require ext_call.return_data[0]
                if poolInfo[arg1].field_768 + (10^12 * (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                require userInfo[arg1][address(arg2)].field_0
                if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (10^12 * (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]):
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            if poolInfo[arg1].field_512 >= bonusEndBlock:
                if poolInfo[arg1].field_512 > block.number:
                    revert with 0, 'SafeMath: subtraction overflow'
                if not block.number - poolInfo[arg1].field_512:
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not 0 / totalAllocPoint:
                        if ext_call.return_data[0] <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require ext_call.return_data[0]
                        if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256
                        require userInfo[arg1][address(arg2)].field_0
                        if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]):
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                    require 0 / totalAllocPoint
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                    if ext_call.return_data[0] <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require ext_call.return_data[0]
                    if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256
                    require userInfo[arg1][address(arg2)].field_0
                    if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]):
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                require block.number - poolInfo[arg1].field_512
                if (block.number * sub_a3eef5b2) - (poolInfo[arg1].field_512 * sub_a3eef5b2) / block.number - poolInfo[arg1].field_512 != sub_a3eef5b2:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                if not (block.number * sub_a3eef5b2) - (poolInfo[arg1].field_512 * sub_a3eef5b2):
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not 0 / totalAllocPoint:
                        if ext_call.return_data[0] <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require ext_call.return_data[0]
                        if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256
                        require userInfo[arg1][address(arg2)].field_0
                        if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]):
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                    require 0 / totalAllocPoint
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                    if ext_call.return_data[0] <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require ext_call.return_data[0]
                    if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256
                    require userInfo[arg1][address(arg2)].field_0
                    if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]):
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                require (block.number * sub_a3eef5b2) - (poolInfo[arg1].field_512 * sub_a3eef5b2)
                if (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / (block.number * sub_a3eef5b2) - (poolInfo[arg1].field_512 * sub_a3eef5b2) != poolInfo[arg1].field_256:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint:
                    if ext_call.return_data[0] <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require ext_call.return_data[0]
                    if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256
                    require userInfo[arg1][address(arg2)].field_0
                    if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]):
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                require (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint
                if 10^12 * (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                if ext_call.return_data[0] <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require ext_call.return_data[0]
                if poolInfo[arg1].field_768 + (10^12 * (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                require userInfo[arg1][address(arg2)].field_0
                if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (10^12 * (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]):
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            if bonusEndBlock > block.number:
                revert with 0, 'SafeMath: subtraction overflow'
            if poolInfo[arg1].field_512 > bonusEndBlock:
                revert with 0, 'SafeMath: subtraction overflow'
            if not bonusEndBlock - poolInfo[arg1].field_512:
                if block.number - bonusEndBlock < 0:
                    revert with 0, 'SafeMath: addition overflow'
                if not block.number - bonusEndBlock:
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not 0 / totalAllocPoint:
                        if ext_call.return_data[0] <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require ext_call.return_data[0]
                        if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256
                        require userInfo[arg1][address(arg2)].field_0
                        if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]):
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                    require 0 / totalAllocPoint
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                    if ext_call.return_data[0] <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require ext_call.return_data[0]
                    if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256
                    require userInfo[arg1][address(arg2)].field_0
                    if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]):
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                require block.number - bonusEndBlock
                if (block.number * sub_a3eef5b2) - (bonusEndBlock * sub_a3eef5b2) / block.number - bonusEndBlock != sub_a3eef5b2:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                if not (block.number * sub_a3eef5b2) - (bonusEndBlock * sub_a3eef5b2):
                    if totalAllocPoint <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require totalAllocPoint
                    if not 0 / totalAllocPoint:
                        if ext_call.return_data[0] <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require ext_call.return_data[0]
                        if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        if not userInfo[arg1][address(arg2)].field_0:
                            if userInfo[arg1][address(arg2)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            return -userInfo[arg1][address(arg2)].field_256
                        require userInfo[arg1][address(arg2)].field_0
                        if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]):
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                        if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                    require 0 / totalAllocPoint
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                    if ext_call.return_data[0] <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require ext_call.return_data[0]
                    if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256
                    require userInfo[arg1][address(arg2)].field_0
                    if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]):
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                require (block.number * sub_a3eef5b2) - (bonusEndBlock * sub_a3eef5b2)
                if (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / (block.number * sub_a3eef5b2) - (bonusEndBlock * sub_a3eef5b2) != poolInfo[arg1].field_256:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint:
                    if ext_call.return_data[0] <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require ext_call.return_data[0]
                    if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256
                    require userInfo[arg1][address(arg2)].field_0
                    if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]):
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                require (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint
                if 10^12 * (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                if ext_call.return_data[0] <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require ext_call.return_data[0]
                if poolInfo[arg1].field_768 + (10^12 * (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                require userInfo[arg1][address(arg2)].field_0
                if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (10^12 * (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]):
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            require bonusEndBlock - poolInfo[arg1].field_512
            if bonusEndBlock - poolInfo[arg1].field_512 / bonusEndBlock - poolInfo[arg1].field_512 != 1:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
            if block.number < bonusEndBlock:
                revert with 0, 'SafeMath: addition overflow'
            if not -poolInfo[arg1].field_512 + block.number:
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not 0 / totalAllocPoint:
                    if ext_call.return_data[0] <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require ext_call.return_data[0]
                    if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256
                    require userInfo[arg1][address(arg2)].field_0
                    if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]):
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                require 0 / totalAllocPoint
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                if ext_call.return_data[0] <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require ext_call.return_data[0]
                if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                require userInfo[arg1][address(arg2)].field_0
                if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]):
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            require -poolInfo[arg1].field_512 + block.number
            if (-1 * poolInfo[arg1].field_512 * sub_a3eef5b2) + (block.number * sub_a3eef5b2) / -poolInfo[arg1].field_512 + block.number != sub_a3eef5b2:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
            if not (-1 * poolInfo[arg1].field_512 * sub_a3eef5b2) + (block.number * sub_a3eef5b2):
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not 0 / totalAllocPoint:
                    if ext_call.return_data[0] <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require ext_call.return_data[0]
                    if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256
                    require userInfo[arg1][address(arg2)].field_0
                    if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]):
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                require 0 / totalAllocPoint
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                if ext_call.return_data[0] <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require ext_call.return_data[0]
                if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                require userInfo[arg1][address(arg2)].field_0
                if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]):
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            require (-1 * poolInfo[arg1].field_512 * sub_a3eef5b2) + (block.number * sub_a3eef5b2)
            if (-1 * poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) + (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) / (-1 * poolInfo[arg1].field_512 * sub_a3eef5b2) + (block.number * sub_a3eef5b2) != poolInfo[arg1].field_256:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
            if totalAllocPoint <= 0:
                revert with 0, 'SafeMath: division by zero'
            require totalAllocPoint
            if not (-1 * poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) + (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint:
                if ext_call.return_data[0] <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require ext_call.return_data[0]
                if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                require userInfo[arg1][address(arg2)].field_0
                if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]):
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            require (-1 * poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) + (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint
            if 10^12 * (-1 * poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) + (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / (-1 * poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) + (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
            if ext_call.return_data[0] <= 0:
                revert with 0, 'SafeMath: division by zero'
            require ext_call.return_data[0]
            if poolInfo[arg1].field_768 + (10^12 * (-1 * poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) + (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256
            require userInfo[arg1][address(arg2)].field_0
            if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (-1 * poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) + (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (10^12 * (-1 * poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) + (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]):
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (-1 * poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) + (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (-1 * poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) + (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
        if endBlock <= bonusEndBlock:
            if poolInfo[arg1].field_512 > endBlock:
                revert with 0, 'SafeMath: subtraction overflow'
            if not endBlock - poolInfo[arg1].field_512:
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not 0 / totalAllocPoint:
                    if ext_call.return_data[0] <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require ext_call.return_data[0]
                    if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256
                    require userInfo[arg1][address(arg2)].field_0
                    if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]):
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                require 0 / totalAllocPoint
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                if ext_call.return_data[0] <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require ext_call.return_data[0]
                if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                require userInfo[arg1][address(arg2)].field_0
                if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]):
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            require endBlock - poolInfo[arg1].field_512
            if endBlock - poolInfo[arg1].field_512 / endBlock - poolInfo[arg1].field_512 != 1:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
            if not endBlock - poolInfo[arg1].field_512:
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not 0 / totalAllocPoint:
                    if ext_call.return_data[0] <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require ext_call.return_data[0]
                    if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256
                    require userInfo[arg1][address(arg2)].field_0
                    if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]):
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                require 0 / totalAllocPoint
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                if ext_call.return_data[0] <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require ext_call.return_data[0]
                if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                require userInfo[arg1][address(arg2)].field_0
                if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]):
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            require endBlock - poolInfo[arg1].field_512
            if (endBlock * sub_a3eef5b2) - (poolInfo[arg1].field_512 * sub_a3eef5b2) / endBlock - poolInfo[arg1].field_512 != sub_a3eef5b2:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
            if not (endBlock * sub_a3eef5b2) - (poolInfo[arg1].field_512 * sub_a3eef5b2):
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not 0 / totalAllocPoint:
                    if ext_call.return_data[0] <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require ext_call.return_data[0]
                    if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256
                    require userInfo[arg1][address(arg2)].field_0
                    if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]):
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                require 0 / totalAllocPoint
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                if ext_call.return_data[0] <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require ext_call.return_data[0]
                if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                require userInfo[arg1][address(arg2)].field_0
                if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]):
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            require (endBlock * sub_a3eef5b2) - (poolInfo[arg1].field_512 * sub_a3eef5b2)
            if (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / (endBlock * sub_a3eef5b2) - (poolInfo[arg1].field_512 * sub_a3eef5b2) != poolInfo[arg1].field_256:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
            if totalAllocPoint <= 0:
                revert with 0, 'SafeMath: division by zero'
            require totalAllocPoint
            if not (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint:
                if ext_call.return_data[0] <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require ext_call.return_data[0]
                if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                require userInfo[arg1][address(arg2)].field_0
                if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]):
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            require (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint
            if 10^12 * (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
            if ext_call.return_data[0] <= 0:
                revert with 0, 'SafeMath: division by zero'
            require ext_call.return_data[0]
            if poolInfo[arg1].field_768 + (10^12 * (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256
            require userInfo[arg1][address(arg2)].field_0
            if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (10^12 * (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]):
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
        if poolInfo[arg1].field_512 >= bonusEndBlock:
            if poolInfo[arg1].field_512 > endBlock:
                revert with 0, 'SafeMath: subtraction overflow'
            if not endBlock - poolInfo[arg1].field_512:
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not 0 / totalAllocPoint:
                    if ext_call.return_data[0] <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require ext_call.return_data[0]
                    if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256
                    require userInfo[arg1][address(arg2)].field_0
                    if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]):
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                require 0 / totalAllocPoint
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                if ext_call.return_data[0] <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require ext_call.return_data[0]
                if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                require userInfo[arg1][address(arg2)].field_0
                if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]):
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            require endBlock - poolInfo[arg1].field_512
            if (endBlock * sub_a3eef5b2) - (poolInfo[arg1].field_512 * sub_a3eef5b2) / endBlock - poolInfo[arg1].field_512 != sub_a3eef5b2:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
            if not (endBlock * sub_a3eef5b2) - (poolInfo[arg1].field_512 * sub_a3eef5b2):
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not 0 / totalAllocPoint:
                    if ext_call.return_data[0] <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require ext_call.return_data[0]
                    if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256
                    require userInfo[arg1][address(arg2)].field_0
                    if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]):
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                require 0 / totalAllocPoint
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                if ext_call.return_data[0] <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require ext_call.return_data[0]
                if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                require userInfo[arg1][address(arg2)].field_0
                if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]):
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            require (endBlock * sub_a3eef5b2) - (poolInfo[arg1].field_512 * sub_a3eef5b2)
            if (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / (endBlock * sub_a3eef5b2) - (poolInfo[arg1].field_512 * sub_a3eef5b2) != poolInfo[arg1].field_256:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
            if totalAllocPoint <= 0:
                revert with 0, 'SafeMath: division by zero'
            require totalAllocPoint
            if not (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint:
                if ext_call.return_data[0] <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require ext_call.return_data[0]
                if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                require userInfo[arg1][address(arg2)].field_0
                if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]):
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            require (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint
            if 10^12 * (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
            if ext_call.return_data[0] <= 0:
                revert with 0, 'SafeMath: division by zero'
            require ext_call.return_data[0]
            if poolInfo[arg1].field_768 + (10^12 * (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256
            require userInfo[arg1][address(arg2)].field_0
            if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (10^12 * (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]):
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
        if bonusEndBlock > endBlock:
            revert with 0, 'SafeMath: subtraction overflow'
        if poolInfo[arg1].field_512 > bonusEndBlock:
            revert with 0, 'SafeMath: subtraction overflow'
        if not bonusEndBlock - poolInfo[arg1].field_512:
            if endBlock - bonusEndBlock < 0:
                revert with 0, 'SafeMath: addition overflow'
            if not endBlock - bonusEndBlock:
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not 0 / totalAllocPoint:
                    if ext_call.return_data[0] <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require ext_call.return_data[0]
                    if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256
                    require userInfo[arg1][address(arg2)].field_0
                    if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]):
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                require 0 / totalAllocPoint
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                if ext_call.return_data[0] <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require ext_call.return_data[0]
                if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                require userInfo[arg1][address(arg2)].field_0
                if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]):
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            require endBlock - bonusEndBlock
            if (endBlock * sub_a3eef5b2) - (bonusEndBlock * sub_a3eef5b2) / endBlock - bonusEndBlock != sub_a3eef5b2:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
            if not (endBlock * sub_a3eef5b2) - (bonusEndBlock * sub_a3eef5b2):
                if totalAllocPoint <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require totalAllocPoint
                if not 0 / totalAllocPoint:
                    if ext_call.return_data[0] <= 0:
                        revert with 0, 'SafeMath: division by zero'
                    require ext_call.return_data[0]
                    if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    if not userInfo[arg1][address(arg2)].field_0:
                        if userInfo[arg1][address(arg2)].field_256 > 0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        return -userInfo[arg1][address(arg2)].field_256
                    require userInfo[arg1][address(arg2)].field_0
                    if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]):
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                    if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
                require 0 / totalAllocPoint
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                if ext_call.return_data[0] <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require ext_call.return_data[0]
                if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                require userInfo[arg1][address(arg2)].field_0
                if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]):
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            require (endBlock * sub_a3eef5b2) - (bonusEndBlock * sub_a3eef5b2)
            if (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / (endBlock * sub_a3eef5b2) - (bonusEndBlock * sub_a3eef5b2) != poolInfo[arg1].field_256:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
            if totalAllocPoint <= 0:
                revert with 0, 'SafeMath: division by zero'
            require totalAllocPoint
            if not (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint:
                if ext_call.return_data[0] <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require ext_call.return_data[0]
                if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                require userInfo[arg1][address(arg2)].field_0
                if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]):
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            require (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint
            if 10^12 * (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
            if ext_call.return_data[0] <= 0:
                revert with 0, 'SafeMath: division by zero'
            require ext_call.return_data[0]
            if poolInfo[arg1].field_768 + (10^12 * (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256
            require userInfo[arg1][address(arg2)].field_0
            if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (10^12 * (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]):
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
        require bonusEndBlock - poolInfo[arg1].field_512
        if bonusEndBlock - poolInfo[arg1].field_512 / bonusEndBlock - poolInfo[arg1].field_512 != 1:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
        if endBlock < bonusEndBlock:
            revert with 0, 'SafeMath: addition overflow'
        if not -poolInfo[arg1].field_512 + endBlock:
            if totalAllocPoint <= 0:
                revert with 0, 'SafeMath: division by zero'
            require totalAllocPoint
            if not 0 / totalAllocPoint:
                if ext_call.return_data[0] <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require ext_call.return_data[0]
                if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                require userInfo[arg1][address(arg2)].field_0
                if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]):
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            require 0 / totalAllocPoint
            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
            if ext_call.return_data[0] <= 0:
                revert with 0, 'SafeMath: division by zero'
            require ext_call.return_data[0]
            if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256
            require userInfo[arg1][address(arg2)].field_0
            if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]):
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
        require -poolInfo[arg1].field_512 + endBlock
        if (-1 * poolInfo[arg1].field_512 * sub_a3eef5b2) + (endBlock * sub_a3eef5b2) / -poolInfo[arg1].field_512 + endBlock != sub_a3eef5b2:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
        if not (-1 * poolInfo[arg1].field_512 * sub_a3eef5b2) + (endBlock * sub_a3eef5b2):
            if totalAllocPoint <= 0:
                revert with 0, 'SafeMath: division by zero'
            require totalAllocPoint
            if not 0 / totalAllocPoint:
                if ext_call.return_data[0] <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require ext_call.return_data[0]
                if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                require userInfo[arg1][address(arg2)].field_0
                if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]):
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            require 0 / totalAllocPoint
            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
            if ext_call.return_data[0] <= 0:
                revert with 0, 'SafeMath: division by zero'
            require ext_call.return_data[0]
            if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256
            require userInfo[arg1][address(arg2)].field_0
            if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]):
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
        require (-1 * poolInfo[arg1].field_512 * sub_a3eef5b2) + (endBlock * sub_a3eef5b2)
        if (-1 * poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) + (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / (-1 * poolInfo[arg1].field_512 * sub_a3eef5b2) + (endBlock * sub_a3eef5b2) != poolInfo[arg1].field_256:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
        if totalAllocPoint <= 0:
            revert with 0, 'SafeMath: division by zero'
        require totalAllocPoint
        if not (-1 * poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) + (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint:
            if ext_call.return_data[0] <= 0:
                revert with 0, 'SafeMath: division by zero'
            require ext_call.return_data[0]
            if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256
            require userInfo[arg1][address(arg2)].field_0
            if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]):
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
        require (-1 * poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) + (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint
        if 10^12 * (-1 * poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) + (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / (-1 * poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) + (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
        if ext_call.return_data[0] <= 0:
            revert with 0, 'SafeMath: division by zero'
        require ext_call.return_data[0]
        if poolInfo[arg1].field_768 + (10^12 * (-1 * poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) + (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
            revert with 0, 'SafeMath: addition overflow'
        if not userInfo[arg1][address(arg2)].field_0:
            if userInfo[arg1][address(arg2)].field_256 > 0:
                revert with 0, 'SafeMath: subtraction overflow'
            return -userInfo[arg1][address(arg2)].field_256
        require userInfo[arg1][address(arg2)].field_0
        if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (-1 * poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) + (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (10^12 * (-1 * poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) + (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]):
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
        if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (-1 * poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) + (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
            revert with 0, 'SafeMath: subtraction overflow'
        return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (-1 * poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) + (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
    if block.number > endBlock:
        if endBlock <= bonusEndBlock:
            if endBlock > endBlock:
                revert with 0, 'SafeMath: subtraction overflow'
            if totalAllocPoint <= 0:
                revert with 0, 'SafeMath: division by zero'
            require totalAllocPoint
            if not 0 / totalAllocPoint:
                if ext_call.return_data[0] <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require ext_call.return_data[0]
                if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                require userInfo[arg1][address(arg2)].field_0
                if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]):
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            require 0 / totalAllocPoint
            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
            if ext_call.return_data[0] <= 0:
                revert with 0, 'SafeMath: division by zero'
            require ext_call.return_data[0]
            if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256
            require userInfo[arg1][address(arg2)].field_0
            if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]):
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
        if endBlock >= bonusEndBlock:
            if endBlock > endBlock:
                revert with 0, 'SafeMath: subtraction overflow'
            if totalAllocPoint <= 0:
                revert with 0, 'SafeMath: division by zero'
            require totalAllocPoint
            if not 0 / totalAllocPoint:
                if ext_call.return_data[0] <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require ext_call.return_data[0]
                if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                require userInfo[arg1][address(arg2)].field_0
                if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]):
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            require 0 / totalAllocPoint
            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
            if ext_call.return_data[0] <= 0:
                revert with 0, 'SafeMath: division by zero'
            require ext_call.return_data[0]
            if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256
            require userInfo[arg1][address(arg2)].field_0
            if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]):
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
        if bonusEndBlock > endBlock:
            revert with 0, 'SafeMath: subtraction overflow'
        if endBlock > bonusEndBlock:
            revert with 0, 'SafeMath: subtraction overflow'
        if bonusEndBlock - endBlock:
            require bonusEndBlock - endBlock
            if bonusEndBlock - endBlock / bonusEndBlock - endBlock != 1:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
            if 0 < bonusEndBlock - endBlock:
                revert with 0, 'SafeMath: addition overflow'
            if totalAllocPoint <= 0:
                revert with 0, 'SafeMath: division by zero'
            require totalAllocPoint
            if not 0 / totalAllocPoint:
                if ext_call.return_data[0] <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require ext_call.return_data[0]
                if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                require userInfo[arg1][address(arg2)].field_0
                if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]):
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            require 0 / totalAllocPoint
            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
            if ext_call.return_data[0] <= 0:
                revert with 0, 'SafeMath: division by zero'
            require ext_call.return_data[0]
            if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256
            require userInfo[arg1][address(arg2)].field_0
            if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]):
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
        if endBlock - bonusEndBlock < 0:
            revert with 0, 'SafeMath: addition overflow'
        if not endBlock - bonusEndBlock:
            if totalAllocPoint <= 0:
                revert with 0, 'SafeMath: division by zero'
            require totalAllocPoint
            if not 0 / totalAllocPoint:
                if ext_call.return_data[0] <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require ext_call.return_data[0]
                if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                require userInfo[arg1][address(arg2)].field_0
                if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]):
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            require 0 / totalAllocPoint
            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
            if ext_call.return_data[0] <= 0:
                revert with 0, 'SafeMath: division by zero'
            require ext_call.return_data[0]
            if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256
            require userInfo[arg1][address(arg2)].field_0
            if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]):
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
        require endBlock - bonusEndBlock
        if (endBlock * sub_a3eef5b2) - (bonusEndBlock * sub_a3eef5b2) / endBlock - bonusEndBlock != sub_a3eef5b2:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
        if not (endBlock * sub_a3eef5b2) - (bonusEndBlock * sub_a3eef5b2):
            if totalAllocPoint <= 0:
                revert with 0, 'SafeMath: division by zero'
            require totalAllocPoint
            if not 0 / totalAllocPoint:
                if ext_call.return_data[0] <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require ext_call.return_data[0]
                if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                require userInfo[arg1][address(arg2)].field_0
                if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]):
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            require 0 / totalAllocPoint
            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
            if ext_call.return_data[0] <= 0:
                revert with 0, 'SafeMath: division by zero'
            require ext_call.return_data[0]
            if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256
            require userInfo[arg1][address(arg2)].field_0
            if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]):
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
        require (endBlock * sub_a3eef5b2) - (bonusEndBlock * sub_a3eef5b2)
        if (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / (endBlock * sub_a3eef5b2) - (bonusEndBlock * sub_a3eef5b2) != poolInfo[arg1].field_256:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
        if totalAllocPoint <= 0:
            revert with 0, 'SafeMath: division by zero'
        require totalAllocPoint
        if not (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint:
            if ext_call.return_data[0] <= 0:
                revert with 0, 'SafeMath: division by zero'
            require ext_call.return_data[0]
            if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256
            require userInfo[arg1][address(arg2)].field_0
            if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]):
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
        require (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint
        if 10^12 * (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
        if ext_call.return_data[0] <= 0:
            revert with 0, 'SafeMath: division by zero'
        require ext_call.return_data[0]
        if poolInfo[arg1].field_768 + (10^12 * (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
            revert with 0, 'SafeMath: addition overflow'
        if not userInfo[arg1][address(arg2)].field_0:
            if userInfo[arg1][address(arg2)].field_256 > 0:
                revert with 0, 'SafeMath: subtraction overflow'
            return -userInfo[arg1][address(arg2)].field_256
        require userInfo[arg1][address(arg2)].field_0
        if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (10^12 * (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]):
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
        if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
            revert with 0, 'SafeMath: subtraction overflow'
        return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
    if block.number <= bonusEndBlock:
        if endBlock > block.number:
            revert with 0, 'SafeMath: subtraction overflow'
        if not block.number - endBlock:
            if totalAllocPoint <= 0:
                revert with 0, 'SafeMath: division by zero'
            require totalAllocPoint
            if not 0 / totalAllocPoint:
                if ext_call.return_data[0] <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require ext_call.return_data[0]
                if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                require userInfo[arg1][address(arg2)].field_0
                if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]):
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            require 0 / totalAllocPoint
            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
            if ext_call.return_data[0] <= 0:
                revert with 0, 'SafeMath: division by zero'
            require ext_call.return_data[0]
            if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256
            require userInfo[arg1][address(arg2)].field_0
            if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]):
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
        require block.number - endBlock
        if block.number - endBlock / block.number - endBlock != 1:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
        if not block.number - endBlock:
            if totalAllocPoint <= 0:
                revert with 0, 'SafeMath: division by zero'
            require totalAllocPoint
            if not 0 / totalAllocPoint:
                if ext_call.return_data[0] <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require ext_call.return_data[0]
                if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                require userInfo[arg1][address(arg2)].field_0
                if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]):
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            require 0 / totalAllocPoint
            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
            if ext_call.return_data[0] <= 0:
                revert with 0, 'SafeMath: division by zero'
            require ext_call.return_data[0]
            if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256
            require userInfo[arg1][address(arg2)].field_0
            if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]):
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
        require block.number - endBlock
        if (block.number * sub_a3eef5b2) - (endBlock * sub_a3eef5b2) / block.number - endBlock != sub_a3eef5b2:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
        if not (block.number * sub_a3eef5b2) - (endBlock * sub_a3eef5b2):
            if totalAllocPoint <= 0:
                revert with 0, 'SafeMath: division by zero'
            require totalAllocPoint
            if not 0 / totalAllocPoint:
                if ext_call.return_data[0] <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require ext_call.return_data[0]
                if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                require userInfo[arg1][address(arg2)].field_0
                if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]):
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            require 0 / totalAllocPoint
            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
            if ext_call.return_data[0] <= 0:
                revert with 0, 'SafeMath: division by zero'
            require ext_call.return_data[0]
            if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256
            require userInfo[arg1][address(arg2)].field_0
            if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]):
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
        require (block.number * sub_a3eef5b2) - (endBlock * sub_a3eef5b2)
        if (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / (block.number * sub_a3eef5b2) - (endBlock * sub_a3eef5b2) != poolInfo[arg1].field_256:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
        if totalAllocPoint <= 0:
            revert with 0, 'SafeMath: division by zero'
        require totalAllocPoint
        if not (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint:
            if ext_call.return_data[0] <= 0:
                revert with 0, 'SafeMath: division by zero'
            require ext_call.return_data[0]
            if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256
            require userInfo[arg1][address(arg2)].field_0
            if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]):
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
        require (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint
        if 10^12 * (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
        if ext_call.return_data[0] <= 0:
            revert with 0, 'SafeMath: division by zero'
        require ext_call.return_data[0]
        if poolInfo[arg1].field_768 + (10^12 * (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
            revert with 0, 'SafeMath: addition overflow'
        if not userInfo[arg1][address(arg2)].field_0:
            if userInfo[arg1][address(arg2)].field_256 > 0:
                revert with 0, 'SafeMath: subtraction overflow'
            return -userInfo[arg1][address(arg2)].field_256
        require userInfo[arg1][address(arg2)].field_0
        if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (10^12 * (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]):
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
        if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
            revert with 0, 'SafeMath: subtraction overflow'
        return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
    if endBlock >= bonusEndBlock:
        if endBlock > block.number:
            revert with 0, 'SafeMath: subtraction overflow'
        if not block.number - endBlock:
            if totalAllocPoint <= 0:
                revert with 0, 'SafeMath: division by zero'
            require totalAllocPoint
            if not 0 / totalAllocPoint:
                if ext_call.return_data[0] <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require ext_call.return_data[0]
                if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                require userInfo[arg1][address(arg2)].field_0
                if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]):
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            require 0 / totalAllocPoint
            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
            if ext_call.return_data[0] <= 0:
                revert with 0, 'SafeMath: division by zero'
            require ext_call.return_data[0]
            if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256
            require userInfo[arg1][address(arg2)].field_0
            if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]):
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
        require block.number - endBlock
        if (block.number * sub_a3eef5b2) - (endBlock * sub_a3eef5b2) / block.number - endBlock != sub_a3eef5b2:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
        if not (block.number * sub_a3eef5b2) - (endBlock * sub_a3eef5b2):
            if totalAllocPoint <= 0:
                revert with 0, 'SafeMath: division by zero'
            require totalAllocPoint
            if not 0 / totalAllocPoint:
                if ext_call.return_data[0] <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require ext_call.return_data[0]
                if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                require userInfo[arg1][address(arg2)].field_0
                if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]):
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            require 0 / totalAllocPoint
            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
            if ext_call.return_data[0] <= 0:
                revert with 0, 'SafeMath: division by zero'
            require ext_call.return_data[0]
            if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256
            require userInfo[arg1][address(arg2)].field_0
            if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]):
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
        require (block.number * sub_a3eef5b2) - (endBlock * sub_a3eef5b2)
        if (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / (block.number * sub_a3eef5b2) - (endBlock * sub_a3eef5b2) != poolInfo[arg1].field_256:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
        if totalAllocPoint <= 0:
            revert with 0, 'SafeMath: division by zero'
        require totalAllocPoint
        if not (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint:
            if ext_call.return_data[0] <= 0:
                revert with 0, 'SafeMath: division by zero'
            require ext_call.return_data[0]
            if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256
            require userInfo[arg1][address(arg2)].field_0
            if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]):
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
        require (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint
        if 10^12 * (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
        if ext_call.return_data[0] <= 0:
            revert with 0, 'SafeMath: division by zero'
        require ext_call.return_data[0]
        if poolInfo[arg1].field_768 + (10^12 * (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
            revert with 0, 'SafeMath: addition overflow'
        if not userInfo[arg1][address(arg2)].field_0:
            if userInfo[arg1][address(arg2)].field_256 > 0:
                revert with 0, 'SafeMath: subtraction overflow'
            return -userInfo[arg1][address(arg2)].field_256
        require userInfo[arg1][address(arg2)].field_0
        if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (10^12 * (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]):
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
        if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
            revert with 0, 'SafeMath: subtraction overflow'
        return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
    if bonusEndBlock > block.number:
        revert with 0, 'SafeMath: subtraction overflow'
    if endBlock > bonusEndBlock:
        revert with 0, 'SafeMath: subtraction overflow'
    if not bonusEndBlock - endBlock:
        if block.number - bonusEndBlock < 0:
            revert with 0, 'SafeMath: addition overflow'
        if not block.number - bonusEndBlock:
            if totalAllocPoint <= 0:
                revert with 0, 'SafeMath: division by zero'
            require totalAllocPoint
            if not 0 / totalAllocPoint:
                if ext_call.return_data[0] <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require ext_call.return_data[0]
                if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                require userInfo[arg1][address(arg2)].field_0
                if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]):
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            require 0 / totalAllocPoint
            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
            if ext_call.return_data[0] <= 0:
                revert with 0, 'SafeMath: division by zero'
            require ext_call.return_data[0]
            if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256
            require userInfo[arg1][address(arg2)].field_0
            if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]):
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
        require block.number - bonusEndBlock
        if (block.number * sub_a3eef5b2) - (bonusEndBlock * sub_a3eef5b2) / block.number - bonusEndBlock != sub_a3eef5b2:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
        if not (block.number * sub_a3eef5b2) - (bonusEndBlock * sub_a3eef5b2):
            if totalAllocPoint <= 0:
                revert with 0, 'SafeMath: division by zero'
            require totalAllocPoint
            if not 0 / totalAllocPoint:
                if ext_call.return_data[0] <= 0:
                    revert with 0, 'SafeMath: division by zero'
                require ext_call.return_data[0]
                if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                if not userInfo[arg1][address(arg2)].field_0:
                    if userInfo[arg1][address(arg2)].field_256 > 0:
                        revert with 0, 'SafeMath: subtraction overflow'
                    return -userInfo[arg1][address(arg2)].field_256
                require userInfo[arg1][address(arg2)].field_0
                if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]):
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
            require 0 / totalAllocPoint
            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
            if ext_call.return_data[0] <= 0:
                revert with 0, 'SafeMath: division by zero'
            require ext_call.return_data[0]
            if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256
            require userInfo[arg1][address(arg2)].field_0
            if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]):
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
        require (block.number * sub_a3eef5b2) - (bonusEndBlock * sub_a3eef5b2)
        if (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / (block.number * sub_a3eef5b2) - (bonusEndBlock * sub_a3eef5b2) != poolInfo[arg1].field_256:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
        if totalAllocPoint <= 0:
            revert with 0, 'SafeMath: division by zero'
        require totalAllocPoint
        if not (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint:
            if ext_call.return_data[0] <= 0:
                revert with 0, 'SafeMath: division by zero'
            require ext_call.return_data[0]
            if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256
            require userInfo[arg1][address(arg2)].field_0
            if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]):
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
        require (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint
        if 10^12 * (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
        if ext_call.return_data[0] <= 0:
            revert with 0, 'SafeMath: division by zero'
        require ext_call.return_data[0]
        if poolInfo[arg1].field_768 + (10^12 * (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
            revert with 0, 'SafeMath: addition overflow'
        if not userInfo[arg1][address(arg2)].field_0:
            if userInfo[arg1][address(arg2)].field_256 > 0:
                revert with 0, 'SafeMath: subtraction overflow'
            return -userInfo[arg1][address(arg2)].field_256
        require userInfo[arg1][address(arg2)].field_0
        if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (10^12 * (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]):
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
        if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
            revert with 0, 'SafeMath: subtraction overflow'
        return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
    require bonusEndBlock - endBlock
    if bonusEndBlock - endBlock / bonusEndBlock - endBlock != 1:
        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
    if block.number < bonusEndBlock:
        revert with 0, 'SafeMath: addition overflow'
    if not -endBlock + block.number:
        if totalAllocPoint <= 0:
            revert with 0, 'SafeMath: division by zero'
        require totalAllocPoint
        if not 0 / totalAllocPoint:
            if ext_call.return_data[0] <= 0:
                revert with 0, 'SafeMath: division by zero'
            require ext_call.return_data[0]
            if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256
            require userInfo[arg1][address(arg2)].field_0
            if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]):
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
        require 0 / totalAllocPoint
        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
        if ext_call.return_data[0] <= 0:
            revert with 0, 'SafeMath: division by zero'
        require ext_call.return_data[0]
        if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
            revert with 0, 'SafeMath: addition overflow'
        if not userInfo[arg1][address(arg2)].field_0:
            if userInfo[arg1][address(arg2)].field_256 > 0:
                revert with 0, 'SafeMath: subtraction overflow'
            return -userInfo[arg1][address(arg2)].field_256
        require userInfo[arg1][address(arg2)].field_0
        if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]):
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
        if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
            revert with 0, 'SafeMath: subtraction overflow'
        return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
    require -endBlock + block.number
    if (-1 * endBlock * sub_a3eef5b2) + (block.number * sub_a3eef5b2) / -endBlock + block.number != sub_a3eef5b2:
        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
    if not (-1 * endBlock * sub_a3eef5b2) + (block.number * sub_a3eef5b2):
        if totalAllocPoint <= 0:
            revert with 0, 'SafeMath: division by zero'
        require totalAllocPoint
        if not 0 / totalAllocPoint:
            if ext_call.return_data[0] <= 0:
                revert with 0, 'SafeMath: division by zero'
            require ext_call.return_data[0]
            if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                revert with 0, 'SafeMath: addition overflow'
            if not userInfo[arg1][address(arg2)].field_0:
                if userInfo[arg1][address(arg2)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                return -userInfo[arg1][address(arg2)].field_256
            require userInfo[arg1][address(arg2)].field_0
            if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]):
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
            if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
        require 0 / totalAllocPoint
        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
        if ext_call.return_data[0] <= 0:
            revert with 0, 'SafeMath: division by zero'
        require ext_call.return_data[0]
        if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
            revert with 0, 'SafeMath: addition overflow'
        if not userInfo[arg1][address(arg2)].field_0:
            if userInfo[arg1][address(arg2)].field_256 > 0:
                revert with 0, 'SafeMath: subtraction overflow'
            return -userInfo[arg1][address(arg2)].field_256
        require userInfo[arg1][address(arg2)].field_0
        if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]):
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
        if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
            revert with 0, 'SafeMath: subtraction overflow'
        return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
    require (-1 * endBlock * sub_a3eef5b2) + (block.number * sub_a3eef5b2)
    if (-1 * endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) + (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) / (-1 * endBlock * sub_a3eef5b2) + (block.number * sub_a3eef5b2) != poolInfo[arg1].field_256:
        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
    if totalAllocPoint <= 0:
        revert with 0, 'SafeMath: division by zero'
    require totalAllocPoint
    if not (-1 * endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) + (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint:
        if ext_call.return_data[0] <= 0:
            revert with 0, 'SafeMath: division by zero'
        require ext_call.return_data[0]
        if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
            revert with 0, 'SafeMath: addition overflow'
        if not userInfo[arg1][address(arg2)].field_0:
            if userInfo[arg1][address(arg2)].field_256 > 0:
                revert with 0, 'SafeMath: subtraction overflow'
            return -userInfo[arg1][address(arg2)].field_256
        require userInfo[arg1][address(arg2)].field_0
        if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]):
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
        if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
            revert with 0, 'SafeMath: subtraction overflow'
        return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (0 / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
    require (-1 * endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) + (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint
    if 10^12 * (-1 * endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) + (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / (-1 * endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) + (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
    if ext_call.return_data[0] <= 0:
        revert with 0, 'SafeMath: division by zero'
    require ext_call.return_data[0]
    if poolInfo[arg1].field_768 + (10^12 * (-1 * endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) + (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
        revert with 0, 'SafeMath: addition overflow'
    if not userInfo[arg1][address(arg2)].field_0:
        if userInfo[arg1][address(arg2)].field_256 > 0:
            revert with 0, 'SafeMath: subtraction overflow'
        return -userInfo[arg1][address(arg2)].field_256
    require userInfo[arg1][address(arg2)].field_0
    if (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (-1 * endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) + (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / userInfo[arg1][address(arg2)].field_0 != poolInfo[arg1].field_768 + (10^12 * (-1 * endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) + (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]):
        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
    if userInfo[arg1][address(arg2)].field_256 > (poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (-1 * endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) + (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12:
        revert with 0, 'SafeMath: subtraction overflow'
    return (((poolInfo[arg1].field_768 * userInfo[arg1][address(arg2)].field_0) + (10^12 * (-1 * endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) + (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0] * userInfo[arg1][address(arg2)].field_0) / 10^12) - userInfo[arg1][address(arg2)].field_256)
}

function withdraw(uint256 arg1, uint256 arg2) payable {
    require calldata.size - 4 >= 64
    require arg1 < poolInfo.length
    if userInfo[arg1][address(msg.sender)].field_0 < arg2:
        revert with 0, 'withdraw: not good'
    require arg1 < poolInfo.length
    if block.number <= poolInfo[arg1].field_512:
        if not userInfo[arg1][address(msg.sender)].field_0:
            if userInfo[arg1][address(msg.sender)].field_256 > 0:
                revert with 0, 'SafeMath: subtraction overflow'
            require ext_code.size(sub_64d46cecAddress)
            staticcall sub_64d46cecAddress.0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(sub_64d46cecAddress)
            if -userInfo[arg1][address(msg.sender)].field_256 <= ext_call.return_data[0]:
                call sub_64d46cecAddress.0xa9059cbb with:
                     gas gas_remaining wei
                    args msg.sender, -userInfo[arg1][address(msg.sender)].field_256
            else:
                call sub_64d46cecAddress.0xa9059cbb with:
                     gas gas_remaining wei
                    args msg.sender, ext_call.return_data[0]
        else:
            require userInfo[arg1][address(msg.sender)].field_0
            if userInfo[arg1][address(msg.sender)].field_0 * poolInfo[arg1].field_768 / userInfo[arg1][address(msg.sender)].field_0 != poolInfo[arg1].field_768:
                revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                            32,
                            33,
                            0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                            mem[197 len 31]
            if userInfo[arg1][address(msg.sender)].field_256 > userInfo[arg1][address(msg.sender)].field_0 * poolInfo[arg1].field_768 / 10^12:
                revert with 0, 'SafeMath: subtraction overflow'
            require ext_code.size(sub_64d46cecAddress)
            staticcall sub_64d46cecAddress.0x70a08231 with:
                    gas gas_remaining wei
                   args this.address
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_code.size(sub_64d46cecAddress)
            if (userInfo[arg1][address(msg.sender)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(msg.sender)].field_256 <= ext_call.return_data[0]:
                call sub_64d46cecAddress.0xa9059cbb with:
                     gas gas_remaining wei
                    args msg.sender, (userInfo[arg1][address(msg.sender)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(msg.sender)].field_256
            else:
                call sub_64d46cecAddress.0xa9059cbb with:
                     gas gas_remaining wei
                    args msg.sender, ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if arg2 > userInfo[arg1][address(msg.sender)].field_0:
            revert with 0, 'SafeMath: subtraction overflow'
        userInfo[arg1][address(msg.sender)].field_0 -= arg2
        if not userInfo[arg1][address(msg.sender)].field_0:
            userInfo[arg1][address(msg.sender)].field_256 = 0
        else:
            require userInfo[arg1][address(msg.sender)].field_0
            if userInfo[arg1][address(msg.sender)].field_0 * poolInfo[arg1].field_768 / userInfo[arg1][address(msg.sender)].field_0 != poolInfo[arg1].field_768:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
            userInfo[arg1][address(msg.sender)].field_256 = userInfo[arg1][address(msg.sender)].field_0 * poolInfo[arg1].field_768 / 10^12
        if ext_code.hash(poolInfo[arg1].field_0) == 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470:
            revert with 0, 'Address: call to non-contract'
        if not ext_code.hash(poolInfo[arg1].field_0):
            revert with 0, 'Address: call to non-contract'
        mem[516 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
        call poolInfo[arg1].field_0 with:
           funct uint32(msg.sender)
             gas gas_remaining wei
            args Mask(224, 32, arg2) << 224, mem[580 len 4]
        if not return_data.size:
            require not ext_call.success
            revert with 'SafeMath: division by zero'
        mem[548 len return_data.size] = ext_call.return_data[0 len return_data.size]
        if not ext_call.success:
            if return_data.size > 0:
                revert with ext_call.return_data[0 len return_data.size]
            revert with 0, 'SafeERC20: low-level call failed'
        if return_data.size > 0:
            require return_data.size >= 32
            if not mem[548]:
                revert with 0, 
                            32,
                            42,
                            0x775361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                            mem[ceil32(return_data.size) + 627 len 22]
    else:
        require ext_code.size(poolInfo[arg1].field_0)
        staticcall poolInfo[arg1].field_0.0x70a08231 with:
                gas gas_remaining wei
               args this.address
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if not ext_call.return_data[0]:
            poolInfo[arg1].field_512 = block.number
            if not userInfo[arg1][address(msg.sender)].field_0:
                if userInfo[arg1][address(msg.sender)].field_256 > 0:
                    revert with 0, 'SafeMath: subtraction overflow'
                require ext_code.size(sub_64d46cecAddress)
                staticcall sub_64d46cecAddress.0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_code.size(sub_64d46cecAddress)
                if -userInfo[arg1][address(msg.sender)].field_256 <= ext_call.return_data[0]:
                    call sub_64d46cecAddress.0xa9059cbb with:
                         gas gas_remaining wei
                        args msg.sender, -userInfo[arg1][address(msg.sender)].field_256
                else:
                    call sub_64d46cecAddress.0xa9059cbb with:
                         gas gas_remaining wei
                        args msg.sender, ext_call.return_data[0]
            else:
                require userInfo[arg1][address(msg.sender)].field_0
                if userInfo[arg1][address(msg.sender)].field_0 * poolInfo[arg1].field_768 / userInfo[arg1][address(msg.sender)].field_0 != poolInfo[arg1].field_768:
                    revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                                32,
                                33,
                                0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f,
                                mem[197 len 31]
                if userInfo[arg1][address(msg.sender)].field_256 > userInfo[arg1][address(msg.sender)].field_0 * poolInfo[arg1].field_768 / 10^12:
                    revert with 0, 'SafeMath: subtraction overflow'
                require ext_code.size(sub_64d46cecAddress)
                staticcall sub_64d46cecAddress.0x70a08231 with:
                        gas gas_remaining wei
                       args this.address
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_code.size(sub_64d46cecAddress)
                if (userInfo[arg1][address(msg.sender)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(msg.sender)].field_256 <= ext_call.return_data[0]:
                    call sub_64d46cecAddress.0xa9059cbb with:
                         gas gas_remaining wei
                        args msg.sender, (userInfo[arg1][address(msg.sender)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(msg.sender)].field_256
                else:
                    call sub_64d46cecAddress.0xa9059cbb with:
                         gas gas_remaining wei
                        args msg.sender, ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if arg2 > userInfo[arg1][address(msg.sender)].field_0:
                revert with 0, 'SafeMath: subtraction overflow'
            userInfo[arg1][address(msg.sender)].field_0 -= arg2
            if not userInfo[arg1][address(msg.sender)].field_0:
                userInfo[arg1][address(msg.sender)].field_256 = 0
            else:
                require userInfo[arg1][address(msg.sender)].field_0
                if userInfo[arg1][address(msg.sender)].field_0 * poolInfo[arg1].field_768 / userInfo[arg1][address(msg.sender)].field_0 != poolInfo[arg1].field_768:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                userInfo[arg1][address(msg.sender)].field_256 = userInfo[arg1][address(msg.sender)].field_0 * poolInfo[arg1].field_768 / 10^12
            if ext_code.hash(poolInfo[arg1].field_0) == 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470:
                revert with 0, 'Address: call to non-contract'
            if not ext_code.hash(poolInfo[arg1].field_0):
                revert with 0, 'Address: call to non-contract'
            mem[516 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
            call poolInfo[arg1].field_0 with:
               funct uint32(msg.sender)
                 gas gas_remaining wei
                args Mask(224, 32, arg2) << 224, mem[580 len 4]
            if not return_data.size:
                require not ext_call.success
                revert with 'SafeMath: division by zero'
            mem[548 len return_data.size] = ext_call.return_data[0 len return_data.size]
            if not ext_call.success:
                if return_data.size > 0:
                    revert with ext_call.return_data[0 len return_data.size]
                revert with 0, 'SafeERC20: low-level call failed'
            if return_data.size > 0:
                require return_data.size >= 32
                if not mem[548]:
                    revert with 0, 
                                32,
                                42,
                                0x775361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                mem[ceil32(return_data.size) + 627 len 22]
        else:
            if poolInfo[arg1].field_512 <= endBlock:
                if block.number <= endBlock:
                    if block.number <= bonusEndBlock:
                        if poolInfo[arg1].field_512 > block.number:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not block.number - poolInfo[arg1].field_512:
                            if totalAllocPoint <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require totalAllocPoint
                            if devFundDivRate <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require devFundDivRate
                            require ext_code.size(sub_64d46cecAddress)
                            call sub_64d46cecAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args devaddr, 0 / totalAllocPoint / devFundDivRate
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(sub_64d46cecAddress)
                            call sub_64d46cecAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args address(this.address), 0 / totalAllocPoint
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if not 0 / totalAllocPoint:
                                if ext_call.return_data[0] <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require ext_call.return_data[0]
                                if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                            else:
                                require 0 / totalAllocPoint
                                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                if ext_call.return_data[0] <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require ext_call.return_data[0]
                                if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                        else:
                            require block.number - poolInfo[arg1].field_512
                            if block.number - poolInfo[arg1].field_512 / block.number - poolInfo[arg1].field_512 != 1:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                            if not block.number - poolInfo[arg1].field_512:
                                if totalAllocPoint <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require totalAllocPoint
                                if devFundDivRate <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require devFundDivRate
                                require ext_code.size(sub_64d46cecAddress)
                                call sub_64d46cecAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args devaddr, 0 / totalAllocPoint / devFundDivRate
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(sub_64d46cecAddress)
                                call sub_64d46cecAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args address(this.address), 0 / totalAllocPoint
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if not 0 / totalAllocPoint:
                                    if ext_call.return_data[0] <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require ext_call.return_data[0]
                                    if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                else:
                                    require 0 / totalAllocPoint
                                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                    if ext_call.return_data[0] <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require ext_call.return_data[0]
                                    if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                            else:
                                require block.number - poolInfo[arg1].field_512
                                if (block.number * sub_a3eef5b2) - (poolInfo[arg1].field_512 * sub_a3eef5b2) / block.number - poolInfo[arg1].field_512 != sub_a3eef5b2:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                                if not (block.number * sub_a3eef5b2) - (poolInfo[arg1].field_512 * sub_a3eef5b2):
                                    if totalAllocPoint <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require totalAllocPoint
                                    if devFundDivRate <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require devFundDivRate
                                    require ext_code.size(sub_64d46cecAddress)
                                    call sub_64d46cecAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args devaddr, 0 / totalAllocPoint / devFundDivRate
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(sub_64d46cecAddress)
                                    call sub_64d46cecAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args address(this.address), 0 / totalAllocPoint
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not 0 / totalAllocPoint:
                                        if ext_call.return_data[0] <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require ext_call.return_data[0]
                                        if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                    else:
                                        require 0 / totalAllocPoint
                                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                        if ext_call.return_data[0] <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require ext_call.return_data[0]
                                        if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                else:
                                    require (block.number * sub_a3eef5b2) - (poolInfo[arg1].field_512 * sub_a3eef5b2)
                                    if (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / (block.number * sub_a3eef5b2) - (poolInfo[arg1].field_512 * sub_a3eef5b2) != poolInfo[arg1].field_256:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                                    if totalAllocPoint <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require totalAllocPoint
                                    if devFundDivRate <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require devFundDivRate
                                    require ext_code.size(sub_64d46cecAddress)
                                    call sub_64d46cecAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args devaddr, (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / devFundDivRate
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(sub_64d46cecAddress)
                                    call sub_64d46cecAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args address(this.address), (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint:
                                        if ext_call.return_data[0] <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require ext_call.return_data[0]
                                        if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                    else:
                                        require (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint
                                        if 10^12 * (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                        if ext_call.return_data[0] <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require ext_call.return_data[0]
                                        if poolInfo[arg1].field_768 + (10^12 * (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 10^12 * (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[arg1].field_512 = block.number
                        if not userInfo[arg1][address(msg.sender)].field_0:
                            if userInfo[arg1][address(msg.sender)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            require ext_code.size(sub_64d46cecAddress)
                            staticcall sub_64d46cecAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_code.size(sub_64d46cecAddress)
                            if -userInfo[arg1][address(msg.sender)].field_256 <= ext_call.return_data[0]:
                                call sub_64d46cecAddress.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, -userInfo[arg1][address(msg.sender)].field_256
                            else:
                                call sub_64d46cecAddress.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, ext_call.return_data[0]
                        else:
                            require userInfo[arg1][address(msg.sender)].field_0
                            if userInfo[arg1][address(msg.sender)].field_0 * poolInfo[arg1].field_768 / userInfo[arg1][address(msg.sender)].field_0 != poolInfo[arg1].field_768:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                            if userInfo[arg1][address(msg.sender)].field_256 > userInfo[arg1][address(msg.sender)].field_0 * poolInfo[arg1].field_768 / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            require ext_code.size(sub_64d46cecAddress)
                            staticcall sub_64d46cecAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_code.size(sub_64d46cecAddress)
                            if (userInfo[arg1][address(msg.sender)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(msg.sender)].field_256 <= ext_call.return_data[0]:
                                call sub_64d46cecAddress.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, (userInfo[arg1][address(msg.sender)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(msg.sender)].field_256
                            else:
                                call sub_64d46cecAddress.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if arg2 > userInfo[arg1][address(msg.sender)].field_0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        userInfo[arg1][address(msg.sender)].field_0 -= arg2
                        if not userInfo[arg1][address(msg.sender)].field_0:
                            userInfo[arg1][address(msg.sender)].field_256 = 0
                        else:
                            require userInfo[arg1][address(msg.sender)].field_0
                            if userInfo[arg1][address(msg.sender)].field_0 * poolInfo[arg1].field_768 / userInfo[arg1][address(msg.sender)].field_0 != poolInfo[arg1].field_768:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[645 len 31]
                            userInfo[arg1][address(msg.sender)].field_256 = userInfo[arg1][address(msg.sender)].field_0 * poolInfo[arg1].field_768 / 10^12
                        if ext_code.hash(poolInfo[arg1].field_0) == 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470:
                            revert with 0, 'Address: call to non-contract'
                        if not ext_code.hash(poolInfo[arg1].field_0):
                            revert with 0, 'Address: call to non-contract'
                        mem[772 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                        call poolInfo[arg1].field_0 with:
                           funct uint32(msg.sender)
                             gas gas_remaining wei
                            args Mask(224, 32, arg2) << 224, mem[836 len 4]
                        if not return_data.size:
                            require not ext_call.success
                            revert with 'SafeMath: subtraction overflow'
                        mem[804 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size > 0:
                                revert with ext_call.return_data[0 len return_data.size]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if return_data.size > 0:
                            require return_data.size >= 32
                            if not mem[804]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x775361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[ceil32(return_data.size) + 883 len 22]
                    else:
                        if poolInfo[arg1].field_512 >= bonusEndBlock:
                            if poolInfo[arg1].field_512 > block.number:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if not block.number - poolInfo[arg1].field_512:
                                if totalAllocPoint <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require totalAllocPoint
                                if devFundDivRate <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require devFundDivRate
                                require ext_code.size(sub_64d46cecAddress)
                                call sub_64d46cecAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args devaddr, 0 / totalAllocPoint / devFundDivRate
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(sub_64d46cecAddress)
                                call sub_64d46cecAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args address(this.address), 0 / totalAllocPoint
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if not 0 / totalAllocPoint:
                                    if ext_call.return_data[0] <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require ext_call.return_data[0]
                                    if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                else:
                                    require 0 / totalAllocPoint
                                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                    if ext_call.return_data[0] <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require ext_call.return_data[0]
                                    if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                            else:
                                require block.number - poolInfo[arg1].field_512
                                if (block.number * sub_a3eef5b2) - (poolInfo[arg1].field_512 * sub_a3eef5b2) / block.number - poolInfo[arg1].field_512 != sub_a3eef5b2:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                                if not (block.number * sub_a3eef5b2) - (poolInfo[arg1].field_512 * sub_a3eef5b2):
                                    if totalAllocPoint <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require totalAllocPoint
                                    if devFundDivRate <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require devFundDivRate
                                    require ext_code.size(sub_64d46cecAddress)
                                    call sub_64d46cecAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args devaddr, 0 / totalAllocPoint / devFundDivRate
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(sub_64d46cecAddress)
                                    call sub_64d46cecAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args address(this.address), 0 / totalAllocPoint
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not 0 / totalAllocPoint:
                                        if ext_call.return_data[0] <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require ext_call.return_data[0]
                                        if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                    else:
                                        require 0 / totalAllocPoint
                                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                        if ext_call.return_data[0] <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require ext_call.return_data[0]
                                        if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                else:
                                    require (block.number * sub_a3eef5b2) - (poolInfo[arg1].field_512 * sub_a3eef5b2)
                                    if (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / (block.number * sub_a3eef5b2) - (poolInfo[arg1].field_512 * sub_a3eef5b2) != poolInfo[arg1].field_256:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                                    if totalAllocPoint <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require totalAllocPoint
                                    if devFundDivRate <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require devFundDivRate
                                    require ext_code.size(sub_64d46cecAddress)
                                    call sub_64d46cecAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args devaddr, (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / devFundDivRate
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(sub_64d46cecAddress)
                                    call sub_64d46cecAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args address(this.address), (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint:
                                        if ext_call.return_data[0] <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require ext_call.return_data[0]
                                        if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                    else:
                                        require (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint
                                        if 10^12 * (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                        if ext_call.return_data[0] <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require ext_call.return_data[0]
                                        if poolInfo[arg1].field_768 + (10^12 * (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 10^12 * (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[arg1].field_512 = block.number
                            if not userInfo[arg1][address(msg.sender)].field_0:
                                if userInfo[arg1][address(msg.sender)].field_256 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                require ext_code.size(sub_64d46cecAddress)
                                staticcall sub_64d46cecAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sub_64d46cecAddress)
                                if -userInfo[arg1][address(msg.sender)].field_256 <= ext_call.return_data[0]:
                                    call sub_64d46cecAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, -userInfo[arg1][address(msg.sender)].field_256
                                else:
                                    call sub_64d46cecAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, ext_call.return_data[0]
                            else:
                                require userInfo[arg1][address(msg.sender)].field_0
                                if userInfo[arg1][address(msg.sender)].field_0 * poolInfo[arg1].field_768 / userInfo[arg1][address(msg.sender)].field_0 != poolInfo[arg1].field_768:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                if userInfo[arg1][address(msg.sender)].field_256 > userInfo[arg1][address(msg.sender)].field_0 * poolInfo[arg1].field_768 / 10^12:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                require ext_code.size(sub_64d46cecAddress)
                                staticcall sub_64d46cecAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sub_64d46cecAddress)
                                if (userInfo[arg1][address(msg.sender)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(msg.sender)].field_256 <= ext_call.return_data[0]:
                                    call sub_64d46cecAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, (userInfo[arg1][address(msg.sender)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(msg.sender)].field_256
                                else:
                                    call sub_64d46cecAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if arg2 > userInfo[arg1][address(msg.sender)].field_0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            userInfo[arg1][address(msg.sender)].field_0 -= arg2
                            if not userInfo[arg1][address(msg.sender)].field_0:
                                userInfo[arg1][address(msg.sender)].field_256 = 0
                            else:
                                require userInfo[arg1][address(msg.sender)].field_0
                                if userInfo[arg1][address(msg.sender)].field_0 * poolInfo[arg1].field_768 / userInfo[arg1][address(msg.sender)].field_0 != poolInfo[arg1].field_768:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[645 len 31]
                                userInfo[arg1][address(msg.sender)].field_256 = userInfo[arg1][address(msg.sender)].field_0 * poolInfo[arg1].field_768 / 10^12
                            if ext_code.hash(poolInfo[arg1].field_0) == 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470:
                                revert with 0, 'Address: call to non-contract'
                            if not ext_code.hash(poolInfo[arg1].field_0):
                                revert with 0, 'Address: call to non-contract'
                            mem[772 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                            call poolInfo[arg1].field_0 with:
                               funct uint32(msg.sender)
                                 gas gas_remaining wei
                                args Mask(224, 32, arg2) << 224, mem[836 len 4]
                            if not return_data.size:
                                require not ext_call.success
                                revert with 'SafeMath: subtraction overflow'
                            mem[804 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                if return_data.size > 0:
                                    revert with ext_call.return_data[0 len return_data.size]
                                revert with 0, 'SafeERC20: low-level call failed'
                            if return_data.size > 0:
                                require return_data.size >= 32
                                if not mem[804]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x775361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[ceil32(return_data.size) + 883 len 22]
                        else:
                            if bonusEndBlock > block.number:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if poolInfo[arg1].field_512 > bonusEndBlock:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if not bonusEndBlock - poolInfo[arg1].field_512:
                                if block.number - bonusEndBlock < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not block.number - bonusEndBlock:
                                    if totalAllocPoint <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require totalAllocPoint
                                    if devFundDivRate <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require devFundDivRate
                                    require ext_code.size(sub_64d46cecAddress)
                                    call sub_64d46cecAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args devaddr, 0 / totalAllocPoint / devFundDivRate
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(sub_64d46cecAddress)
                                    call sub_64d46cecAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args address(this.address), 0 / totalAllocPoint
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not 0 / totalAllocPoint:
                                        if ext_call.return_data[0] <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require ext_call.return_data[0]
                                        if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                    else:
                                        require 0 / totalAllocPoint
                                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                        if ext_call.return_data[0] <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require ext_call.return_data[0]
                                        if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                else:
                                    require block.number - bonusEndBlock
                                    if (block.number * sub_a3eef5b2) - (bonusEndBlock * sub_a3eef5b2) / block.number - bonusEndBlock != sub_a3eef5b2:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                                    if not (block.number * sub_a3eef5b2) - (bonusEndBlock * sub_a3eef5b2):
                                        if totalAllocPoint <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalAllocPoint
                                        if devFundDivRate <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require devFundDivRate
                                        require ext_code.size(sub_64d46cecAddress)
                                        call sub_64d46cecAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args devaddr, 0 / totalAllocPoint / devFundDivRate
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require ext_code.size(sub_64d46cecAddress)
                                        call sub_64d46cecAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args address(this.address), 0 / totalAllocPoint
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not 0 / totalAllocPoint:
                                            if ext_call.return_data[0] <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require ext_call.return_data[0]
                                            if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                        else:
                                            require 0 / totalAllocPoint
                                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                            if ext_call.return_data[0] <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require ext_call.return_data[0]
                                            if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                    else:
                                        require (block.number * sub_a3eef5b2) - (bonusEndBlock * sub_a3eef5b2)
                                        if (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / (block.number * sub_a3eef5b2) - (bonusEndBlock * sub_a3eef5b2) != poolInfo[arg1].field_256:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                                        if totalAllocPoint <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalAllocPoint
                                        if devFundDivRate <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require devFundDivRate
                                        require ext_code.size(sub_64d46cecAddress)
                                        call sub_64d46cecAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args devaddr, (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / devFundDivRate
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require ext_code.size(sub_64d46cecAddress)
                                        call sub_64d46cecAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args address(this.address), (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint:
                                            if ext_call.return_data[0] <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require ext_call.return_data[0]
                                            if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                        else:
                                            require (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint
                                            if 10^12 * (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                            if ext_call.return_data[0] <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require ext_call.return_data[0]
                                            if poolInfo[arg1].field_768 + (10^12 * (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 10^12 * (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]
                            else:
                                require bonusEndBlock - poolInfo[arg1].field_512
                                if bonusEndBlock - poolInfo[arg1].field_512 / bonusEndBlock - poolInfo[arg1].field_512 != 1:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                                if block.number < bonusEndBlock:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not -poolInfo[arg1].field_512 + block.number:
                                    if totalAllocPoint <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require totalAllocPoint
                                    if devFundDivRate <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require devFundDivRate
                                    require ext_code.size(sub_64d46cecAddress)
                                    call sub_64d46cecAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args devaddr, 0 / totalAllocPoint / devFundDivRate
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(sub_64d46cecAddress)
                                    call sub_64d46cecAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args address(this.address), 0 / totalAllocPoint
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not 0 / totalAllocPoint:
                                        if ext_call.return_data[0] <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require ext_call.return_data[0]
                                        if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                    else:
                                        require 0 / totalAllocPoint
                                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                        if ext_call.return_data[0] <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require ext_call.return_data[0]
                                        if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                else:
                                    require -poolInfo[arg1].field_512 + block.number
                                    if (-1 * poolInfo[arg1].field_512 * sub_a3eef5b2) + (block.number * sub_a3eef5b2) / -poolInfo[arg1].field_512 + block.number != sub_a3eef5b2:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                                    if not (-1 * poolInfo[arg1].field_512 * sub_a3eef5b2) + (block.number * sub_a3eef5b2):
                                        if totalAllocPoint <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalAllocPoint
                                        if devFundDivRate <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require devFundDivRate
                                        require ext_code.size(sub_64d46cecAddress)
                                        call sub_64d46cecAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args devaddr, 0 / totalAllocPoint / devFundDivRate
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require ext_code.size(sub_64d46cecAddress)
                                        call sub_64d46cecAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args address(this.address), 0 / totalAllocPoint
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not 0 / totalAllocPoint:
                                            if ext_call.return_data[0] <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require ext_call.return_data[0]
                                            if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                        else:
                                            require 0 / totalAllocPoint
                                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                            if ext_call.return_data[0] <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require ext_call.return_data[0]
                                            if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                    else:
                                        require (-1 * poolInfo[arg1].field_512 * sub_a3eef5b2) + (block.number * sub_a3eef5b2)
                                        if (-1 * poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) + (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) / (-1 * poolInfo[arg1].field_512 * sub_a3eef5b2) + (block.number * sub_a3eef5b2) != poolInfo[arg1].field_256:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                                        if totalAllocPoint <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalAllocPoint
                                        if devFundDivRate <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require devFundDivRate
                                        require ext_code.size(sub_64d46cecAddress)
                                        call sub_64d46cecAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args devaddr, (-1 * poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) + (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / devFundDivRate
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require ext_code.size(sub_64d46cecAddress)
                                        call sub_64d46cecAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args address(this.address), (-1 * poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) + (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not (-1 * poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) + (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint:
                                            if ext_call.return_data[0] <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require ext_call.return_data[0]
                                            if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                        else:
                                            require (-1 * poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) + (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint
                                            if 10^12 * (-1 * poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) + (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / (-1 * poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) + (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                            if ext_call.return_data[0] <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require ext_call.return_data[0]
                                            if poolInfo[arg1].field_768 + (10^12 * (-1 * poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) + (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 10^12 * (-1 * poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) + (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[arg1].field_512 = block.number
                            if not userInfo[arg1][address(msg.sender)].field_0:
                                if userInfo[arg1][address(msg.sender)].field_256 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                require ext_code.size(sub_64d46cecAddress)
                                staticcall sub_64d46cecAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sub_64d46cecAddress)
                                if -userInfo[arg1][address(msg.sender)].field_256 <= ext_call.return_data[0]:
                                    call sub_64d46cecAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, -userInfo[arg1][address(msg.sender)].field_256
                                else:
                                    call sub_64d46cecAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, ext_call.return_data[0]
                            else:
                                require userInfo[arg1][address(msg.sender)].field_0
                                if userInfo[arg1][address(msg.sender)].field_0 * poolInfo[arg1].field_768 / userInfo[arg1][address(msg.sender)].field_0 != poolInfo[arg1].field_768:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                                if userInfo[arg1][address(msg.sender)].field_256 > userInfo[arg1][address(msg.sender)].field_0 * poolInfo[arg1].field_768 / 10^12:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                require ext_code.size(sub_64d46cecAddress)
                                staticcall sub_64d46cecAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sub_64d46cecAddress)
                                if (userInfo[arg1][address(msg.sender)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(msg.sender)].field_256 <= ext_call.return_data[0]:
                                    call sub_64d46cecAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, (userInfo[arg1][address(msg.sender)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(msg.sender)].field_256
                                else:
                                    call sub_64d46cecAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if arg2 > userInfo[arg1][address(msg.sender)].field_0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            userInfo[arg1][address(msg.sender)].field_0 -= arg2
                            if not userInfo[arg1][address(msg.sender)].field_0:
                                userInfo[arg1][address(msg.sender)].field_256 = 0
                            else:
                                require userInfo[arg1][address(msg.sender)].field_0
                                if userInfo[arg1][address(msg.sender)].field_0 * poolInfo[arg1].field_768 / userInfo[arg1][address(msg.sender)].field_0 != poolInfo[arg1].field_768:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[709 len 31]
                                userInfo[arg1][address(msg.sender)].field_256 = userInfo[arg1][address(msg.sender)].field_0 * poolInfo[arg1].field_768 / 10^12
                            if ext_code.hash(poolInfo[arg1].field_0) == 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470:
                                revert with 0, 'Address: call to non-contract'
                            if not ext_code.hash(poolInfo[arg1].field_0):
                                revert with 0, 'Address: call to non-contract'
                            mem[836 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                            call poolInfo[arg1].field_0 with:
                               funct uint32(msg.sender)
                                 gas gas_remaining wei
                                args Mask(224, 32, arg2) << 224, mem[900 len 4]
                            if not return_data.size:
                                require not ext_call.success
                                revert with 'SafeMath: subtraction overflow'
                            mem[868 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                if return_data.size > 0:
                                    revert with ext_call.return_data[0 len return_data.size]
                                revert with 0, 'SafeERC20: low-level call failed'
                            if return_data.size > 0:
                                require return_data.size >= 32
                                if not mem[868]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x775361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[ceil32(return_data.size) + 947 len 22]
                else:
                    if endBlock <= bonusEndBlock:
                        if poolInfo[arg1].field_512 > endBlock:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not endBlock - poolInfo[arg1].field_512:
                            if totalAllocPoint <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require totalAllocPoint
                            if devFundDivRate <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require devFundDivRate
                            require ext_code.size(sub_64d46cecAddress)
                            call sub_64d46cecAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args devaddr, 0 / totalAllocPoint / devFundDivRate
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(sub_64d46cecAddress)
                            call sub_64d46cecAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args address(this.address), 0 / totalAllocPoint
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if not 0 / totalAllocPoint:
                                if ext_call.return_data[0] <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require ext_call.return_data[0]
                                if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                            else:
                                require 0 / totalAllocPoint
                                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                if ext_call.return_data[0] <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require ext_call.return_data[0]
                                if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                        else:
                            require endBlock - poolInfo[arg1].field_512
                            if endBlock - poolInfo[arg1].field_512 / endBlock - poolInfo[arg1].field_512 != 1:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                            if not endBlock - poolInfo[arg1].field_512:
                                if totalAllocPoint <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require totalAllocPoint
                                if devFundDivRate <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require devFundDivRate
                                require ext_code.size(sub_64d46cecAddress)
                                call sub_64d46cecAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args devaddr, 0 / totalAllocPoint / devFundDivRate
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(sub_64d46cecAddress)
                                call sub_64d46cecAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args address(this.address), 0 / totalAllocPoint
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if not 0 / totalAllocPoint:
                                    if ext_call.return_data[0] <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require ext_call.return_data[0]
                                    if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                else:
                                    require 0 / totalAllocPoint
                                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                    if ext_call.return_data[0] <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require ext_call.return_data[0]
                                    if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                            else:
                                require endBlock - poolInfo[arg1].field_512
                                if (endBlock * sub_a3eef5b2) - (poolInfo[arg1].field_512 * sub_a3eef5b2) / endBlock - poolInfo[arg1].field_512 != sub_a3eef5b2:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                                if not (endBlock * sub_a3eef5b2) - (poolInfo[arg1].field_512 * sub_a3eef5b2):
                                    if totalAllocPoint <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require totalAllocPoint
                                    if devFundDivRate <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require devFundDivRate
                                    require ext_code.size(sub_64d46cecAddress)
                                    call sub_64d46cecAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args devaddr, 0 / totalAllocPoint / devFundDivRate
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(sub_64d46cecAddress)
                                    call sub_64d46cecAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args address(this.address), 0 / totalAllocPoint
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not 0 / totalAllocPoint:
                                        if ext_call.return_data[0] <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require ext_call.return_data[0]
                                        if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                    else:
                                        require 0 / totalAllocPoint
                                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                        if ext_call.return_data[0] <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require ext_call.return_data[0]
                                        if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                else:
                                    require (endBlock * sub_a3eef5b2) - (poolInfo[arg1].field_512 * sub_a3eef5b2)
                                    if (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / (endBlock * sub_a3eef5b2) - (poolInfo[arg1].field_512 * sub_a3eef5b2) != poolInfo[arg1].field_256:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                                    if totalAllocPoint <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require totalAllocPoint
                                    if devFundDivRate <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require devFundDivRate
                                    require ext_code.size(sub_64d46cecAddress)
                                    call sub_64d46cecAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args devaddr, (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / devFundDivRate
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(sub_64d46cecAddress)
                                    call sub_64d46cecAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args address(this.address), (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint:
                                        if ext_call.return_data[0] <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require ext_call.return_data[0]
                                        if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                    else:
                                        require (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint
                                        if 10^12 * (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                        if ext_call.return_data[0] <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require ext_call.return_data[0]
                                        if poolInfo[arg1].field_768 + (10^12 * (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 10^12 * (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[arg1].field_512 = block.number
                        if not userInfo[arg1][address(msg.sender)].field_0:
                            if userInfo[arg1][address(msg.sender)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            require ext_code.size(sub_64d46cecAddress)
                            staticcall sub_64d46cecAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_code.size(sub_64d46cecAddress)
                            if -userInfo[arg1][address(msg.sender)].field_256 <= ext_call.return_data[0]:
                                call sub_64d46cecAddress.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, -userInfo[arg1][address(msg.sender)].field_256
                            else:
                                call sub_64d46cecAddress.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, ext_call.return_data[0]
                        else:
                            require userInfo[arg1][address(msg.sender)].field_0
                            if userInfo[arg1][address(msg.sender)].field_0 * poolInfo[arg1].field_768 / userInfo[arg1][address(msg.sender)].field_0 != poolInfo[arg1].field_768:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                            if userInfo[arg1][address(msg.sender)].field_256 > userInfo[arg1][address(msg.sender)].field_0 * poolInfo[arg1].field_768 / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            require ext_code.size(sub_64d46cecAddress)
                            staticcall sub_64d46cecAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_code.size(sub_64d46cecAddress)
                            if (userInfo[arg1][address(msg.sender)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(msg.sender)].field_256 <= ext_call.return_data[0]:
                                call sub_64d46cecAddress.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, (userInfo[arg1][address(msg.sender)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(msg.sender)].field_256
                            else:
                                call sub_64d46cecAddress.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if arg2 > userInfo[arg1][address(msg.sender)].field_0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        userInfo[arg1][address(msg.sender)].field_0 -= arg2
                        if not userInfo[arg1][address(msg.sender)].field_0:
                            userInfo[arg1][address(msg.sender)].field_256 = 0
                        else:
                            require userInfo[arg1][address(msg.sender)].field_0
                            if userInfo[arg1][address(msg.sender)].field_0 * poolInfo[arg1].field_768 / userInfo[arg1][address(msg.sender)].field_0 != poolInfo[arg1].field_768:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[645 len 31]
                            userInfo[arg1][address(msg.sender)].field_256 = userInfo[arg1][address(msg.sender)].field_0 * poolInfo[arg1].field_768 / 10^12
                        if ext_code.hash(poolInfo[arg1].field_0) == 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470:
                            revert with 0, 'Address: call to non-contract'
                        if not ext_code.hash(poolInfo[arg1].field_0):
                            revert with 0, 'Address: call to non-contract'
                        mem[772 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                        call poolInfo[arg1].field_0 with:
                           funct uint32(msg.sender)
                             gas gas_remaining wei
                            args Mask(224, 32, arg2) << 224, mem[836 len 4]
                        if not return_data.size:
                            require not ext_call.success
                            revert with 'SafeMath: subtraction overflow'
                        mem[804 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size > 0:
                                revert with ext_call.return_data[0 len return_data.size]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if return_data.size > 0:
                            require return_data.size >= 32
                            if not mem[804]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x775361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[ceil32(return_data.size) + 883 len 22]
                    else:
                        if poolInfo[arg1].field_512 >= bonusEndBlock:
                            if poolInfo[arg1].field_512 > endBlock:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if not endBlock - poolInfo[arg1].field_512:
                                if totalAllocPoint <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require totalAllocPoint
                                if devFundDivRate <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require devFundDivRate
                                require ext_code.size(sub_64d46cecAddress)
                                call sub_64d46cecAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args devaddr, 0 / totalAllocPoint / devFundDivRate
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(sub_64d46cecAddress)
                                call sub_64d46cecAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args address(this.address), 0 / totalAllocPoint
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if not 0 / totalAllocPoint:
                                    if ext_call.return_data[0] <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require ext_call.return_data[0]
                                    if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                else:
                                    require 0 / totalAllocPoint
                                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                    if ext_call.return_data[0] <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require ext_call.return_data[0]
                                    if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                            else:
                                require endBlock - poolInfo[arg1].field_512
                                if (endBlock * sub_a3eef5b2) - (poolInfo[arg1].field_512 * sub_a3eef5b2) / endBlock - poolInfo[arg1].field_512 != sub_a3eef5b2:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                                if not (endBlock * sub_a3eef5b2) - (poolInfo[arg1].field_512 * sub_a3eef5b2):
                                    if totalAllocPoint <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require totalAllocPoint
                                    if devFundDivRate <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require devFundDivRate
                                    require ext_code.size(sub_64d46cecAddress)
                                    call sub_64d46cecAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args devaddr, 0 / totalAllocPoint / devFundDivRate
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(sub_64d46cecAddress)
                                    call sub_64d46cecAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args address(this.address), 0 / totalAllocPoint
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not 0 / totalAllocPoint:
                                        if ext_call.return_data[0] <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require ext_call.return_data[0]
                                        if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                    else:
                                        require 0 / totalAllocPoint
                                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                        if ext_call.return_data[0] <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require ext_call.return_data[0]
                                        if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                else:
                                    require (endBlock * sub_a3eef5b2) - (poolInfo[arg1].field_512 * sub_a3eef5b2)
                                    if (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / (endBlock * sub_a3eef5b2) - (poolInfo[arg1].field_512 * sub_a3eef5b2) != poolInfo[arg1].field_256:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                                    if totalAllocPoint <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require totalAllocPoint
                                    if devFundDivRate <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require devFundDivRate
                                    require ext_code.size(sub_64d46cecAddress)
                                    call sub_64d46cecAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args devaddr, (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / devFundDivRate
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(sub_64d46cecAddress)
                                    call sub_64d46cecAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args address(this.address), (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint:
                                        if ext_call.return_data[0] <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require ext_call.return_data[0]
                                        if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                    else:
                                        require (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint
                                        if 10^12 * (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                        if ext_call.return_data[0] <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require ext_call.return_data[0]
                                        if poolInfo[arg1].field_768 + (10^12 * (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 10^12 * (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[arg1].field_512 = block.number
                            if not userInfo[arg1][address(msg.sender)].field_0:
                                if userInfo[arg1][address(msg.sender)].field_256 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                require ext_code.size(sub_64d46cecAddress)
                                staticcall sub_64d46cecAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sub_64d46cecAddress)
                                if -userInfo[arg1][address(msg.sender)].field_256 <= ext_call.return_data[0]:
                                    call sub_64d46cecAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, -userInfo[arg1][address(msg.sender)].field_256
                                else:
                                    call sub_64d46cecAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, ext_call.return_data[0]
                            else:
                                require userInfo[arg1][address(msg.sender)].field_0
                                if userInfo[arg1][address(msg.sender)].field_0 * poolInfo[arg1].field_768 / userInfo[arg1][address(msg.sender)].field_0 != poolInfo[arg1].field_768:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                if userInfo[arg1][address(msg.sender)].field_256 > userInfo[arg1][address(msg.sender)].field_0 * poolInfo[arg1].field_768 / 10^12:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                require ext_code.size(sub_64d46cecAddress)
                                staticcall sub_64d46cecAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sub_64d46cecAddress)
                                if (userInfo[arg1][address(msg.sender)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(msg.sender)].field_256 <= ext_call.return_data[0]:
                                    call sub_64d46cecAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, (userInfo[arg1][address(msg.sender)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(msg.sender)].field_256
                                else:
                                    call sub_64d46cecAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if arg2 > userInfo[arg1][address(msg.sender)].field_0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            userInfo[arg1][address(msg.sender)].field_0 -= arg2
                            if not userInfo[arg1][address(msg.sender)].field_0:
                                userInfo[arg1][address(msg.sender)].field_256 = 0
                            else:
                                require userInfo[arg1][address(msg.sender)].field_0
                                if userInfo[arg1][address(msg.sender)].field_0 * poolInfo[arg1].field_768 / userInfo[arg1][address(msg.sender)].field_0 != poolInfo[arg1].field_768:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[645 len 31]
                                userInfo[arg1][address(msg.sender)].field_256 = userInfo[arg1][address(msg.sender)].field_0 * poolInfo[arg1].field_768 / 10^12
                            if ext_code.hash(poolInfo[arg1].field_0) == 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470:
                                revert with 0, 'Address: call to non-contract'
                            if not ext_code.hash(poolInfo[arg1].field_0):
                                revert with 0, 'Address: call to non-contract'
                            mem[772 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                            call poolInfo[arg1].field_0 with:
                               funct uint32(msg.sender)
                                 gas gas_remaining wei
                                args Mask(224, 32, arg2) << 224, mem[836 len 4]
                            if not return_data.size:
                                require not ext_call.success
                                revert with 'SafeMath: subtraction overflow'
                            mem[804 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                if return_data.size > 0:
                                    revert with ext_call.return_data[0 len return_data.size]
                                revert with 0, 'SafeERC20: low-level call failed'
                            if return_data.size > 0:
                                require return_data.size >= 32
                                if not mem[804]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x775361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[ceil32(return_data.size) + 883 len 22]
                        else:
                            if bonusEndBlock > endBlock:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if poolInfo[arg1].field_512 > bonusEndBlock:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if not bonusEndBlock - poolInfo[arg1].field_512:
                                if endBlock - bonusEndBlock < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not endBlock - bonusEndBlock:
                                    if totalAllocPoint <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require totalAllocPoint
                                    if devFundDivRate <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require devFundDivRate
                                    require ext_code.size(sub_64d46cecAddress)
                                    call sub_64d46cecAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args devaddr, 0 / totalAllocPoint / devFundDivRate
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(sub_64d46cecAddress)
                                    call sub_64d46cecAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args address(this.address), 0 / totalAllocPoint
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not 0 / totalAllocPoint:
                                        if ext_call.return_data[0] <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require ext_call.return_data[0]
                                        if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                    else:
                                        require 0 / totalAllocPoint
                                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                        if ext_call.return_data[0] <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require ext_call.return_data[0]
                                        if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                else:
                                    require endBlock - bonusEndBlock
                                    if (endBlock * sub_a3eef5b2) - (bonusEndBlock * sub_a3eef5b2) / endBlock - bonusEndBlock != sub_a3eef5b2:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                                    if not (endBlock * sub_a3eef5b2) - (bonusEndBlock * sub_a3eef5b2):
                                        if totalAllocPoint <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalAllocPoint
                                        if devFundDivRate <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require devFundDivRate
                                        require ext_code.size(sub_64d46cecAddress)
                                        call sub_64d46cecAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args devaddr, 0 / totalAllocPoint / devFundDivRate
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require ext_code.size(sub_64d46cecAddress)
                                        call sub_64d46cecAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args address(this.address), 0 / totalAllocPoint
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not 0 / totalAllocPoint:
                                            if ext_call.return_data[0] <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require ext_call.return_data[0]
                                            if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                        else:
                                            require 0 / totalAllocPoint
                                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                            if ext_call.return_data[0] <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require ext_call.return_data[0]
                                            if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                    else:
                                        require (endBlock * sub_a3eef5b2) - (bonusEndBlock * sub_a3eef5b2)
                                        if (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / (endBlock * sub_a3eef5b2) - (bonusEndBlock * sub_a3eef5b2) != poolInfo[arg1].field_256:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                                        if totalAllocPoint <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalAllocPoint
                                        if devFundDivRate <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require devFundDivRate
                                        require ext_code.size(sub_64d46cecAddress)
                                        call sub_64d46cecAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args devaddr, (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / devFundDivRate
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require ext_code.size(sub_64d46cecAddress)
                                        call sub_64d46cecAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args address(this.address), (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint:
                                            if ext_call.return_data[0] <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require ext_call.return_data[0]
                                            if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                        else:
                                            require (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint
                                            if 10^12 * (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                            if ext_call.return_data[0] <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require ext_call.return_data[0]
                                            if poolInfo[arg1].field_768 + (10^12 * (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 10^12 * (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]
                            else:
                                require bonusEndBlock - poolInfo[arg1].field_512
                                if bonusEndBlock - poolInfo[arg1].field_512 / bonusEndBlock - poolInfo[arg1].field_512 != 1:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                                if endBlock < bonusEndBlock:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not -poolInfo[arg1].field_512 + endBlock:
                                    if totalAllocPoint <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require totalAllocPoint
                                    if devFundDivRate <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require devFundDivRate
                                    require ext_code.size(sub_64d46cecAddress)
                                    call sub_64d46cecAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args devaddr, 0 / totalAllocPoint / devFundDivRate
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(sub_64d46cecAddress)
                                    call sub_64d46cecAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args address(this.address), 0 / totalAllocPoint
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not 0 / totalAllocPoint:
                                        if ext_call.return_data[0] <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require ext_call.return_data[0]
                                        if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                    else:
                                        require 0 / totalAllocPoint
                                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                        if ext_call.return_data[0] <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require ext_call.return_data[0]
                                        if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                else:
                                    require -poolInfo[arg1].field_512 + endBlock
                                    if (-1 * poolInfo[arg1].field_512 * sub_a3eef5b2) + (endBlock * sub_a3eef5b2) / -poolInfo[arg1].field_512 + endBlock != sub_a3eef5b2:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                                    if not (-1 * poolInfo[arg1].field_512 * sub_a3eef5b2) + (endBlock * sub_a3eef5b2):
                                        if totalAllocPoint <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalAllocPoint
                                        if devFundDivRate <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require devFundDivRate
                                        require ext_code.size(sub_64d46cecAddress)
                                        call sub_64d46cecAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args devaddr, 0 / totalAllocPoint / devFundDivRate
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require ext_code.size(sub_64d46cecAddress)
                                        call sub_64d46cecAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args address(this.address), 0 / totalAllocPoint
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not 0 / totalAllocPoint:
                                            if ext_call.return_data[0] <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require ext_call.return_data[0]
                                            if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                        else:
                                            require 0 / totalAllocPoint
                                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                            if ext_call.return_data[0] <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require ext_call.return_data[0]
                                            if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                    else:
                                        require (-1 * poolInfo[arg1].field_512 * sub_a3eef5b2) + (endBlock * sub_a3eef5b2)
                                        if (-1 * poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) + (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / (-1 * poolInfo[arg1].field_512 * sub_a3eef5b2) + (endBlock * sub_a3eef5b2) != poolInfo[arg1].field_256:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                                        if totalAllocPoint <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalAllocPoint
                                        if devFundDivRate <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require devFundDivRate
                                        require ext_code.size(sub_64d46cecAddress)
                                        call sub_64d46cecAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args devaddr, (-1 * poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) + (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / devFundDivRate
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require ext_code.size(sub_64d46cecAddress)
                                        call sub_64d46cecAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args address(this.address), (-1 * poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) + (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not (-1 * poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) + (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint:
                                            if ext_call.return_data[0] <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require ext_call.return_data[0]
                                            if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                        else:
                                            require (-1 * poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) + (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint
                                            if 10^12 * (-1 * poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) + (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / (-1 * poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) + (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                            if ext_call.return_data[0] <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require ext_call.return_data[0]
                                            if poolInfo[arg1].field_768 + (10^12 * (-1 * poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) + (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 10^12 * (-1 * poolInfo[arg1].field_512 * sub_a3eef5b2 * poolInfo[arg1].field_256) + (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[arg1].field_512 = block.number
                            if not userInfo[arg1][address(msg.sender)].field_0:
                                if userInfo[arg1][address(msg.sender)].field_256 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                require ext_code.size(sub_64d46cecAddress)
                                staticcall sub_64d46cecAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sub_64d46cecAddress)
                                if -userInfo[arg1][address(msg.sender)].field_256 <= ext_call.return_data[0]:
                                    call sub_64d46cecAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, -userInfo[arg1][address(msg.sender)].field_256
                                else:
                                    call sub_64d46cecAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, ext_call.return_data[0]
                            else:
                                require userInfo[arg1][address(msg.sender)].field_0
                                if userInfo[arg1][address(msg.sender)].field_0 * poolInfo[arg1].field_768 / userInfo[arg1][address(msg.sender)].field_0 != poolInfo[arg1].field_768:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                                if userInfo[arg1][address(msg.sender)].field_256 > userInfo[arg1][address(msg.sender)].field_0 * poolInfo[arg1].field_768 / 10^12:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                require ext_code.size(sub_64d46cecAddress)
                                staticcall sub_64d46cecAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sub_64d46cecAddress)
                                if (userInfo[arg1][address(msg.sender)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(msg.sender)].field_256 <= ext_call.return_data[0]:
                                    call sub_64d46cecAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, (userInfo[arg1][address(msg.sender)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(msg.sender)].field_256
                                else:
                                    call sub_64d46cecAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if arg2 > userInfo[arg1][address(msg.sender)].field_0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            userInfo[arg1][address(msg.sender)].field_0 -= arg2
                            if not userInfo[arg1][address(msg.sender)].field_0:
                                userInfo[arg1][address(msg.sender)].field_256 = 0
                            else:
                                require userInfo[arg1][address(msg.sender)].field_0
                                if userInfo[arg1][address(msg.sender)].field_0 * poolInfo[arg1].field_768 / userInfo[arg1][address(msg.sender)].field_0 != poolInfo[arg1].field_768:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[709 len 31]
                                userInfo[arg1][address(msg.sender)].field_256 = userInfo[arg1][address(msg.sender)].field_0 * poolInfo[arg1].field_768 / 10^12
                            if ext_code.hash(poolInfo[arg1].field_0) == 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470:
                                revert with 0, 'Address: call to non-contract'
                            if not ext_code.hash(poolInfo[arg1].field_0):
                                revert with 0, 'Address: call to non-contract'
                            mem[836 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                            call poolInfo[arg1].field_0 with:
                               funct uint32(msg.sender)
                                 gas gas_remaining wei
                                args Mask(224, 32, arg2) << 224, mem[900 len 4]
                            if not return_data.size:
                                require not ext_call.success
                                revert with 'SafeMath: subtraction overflow'
                            mem[868 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                if return_data.size > 0:
                                    revert with ext_call.return_data[0 len return_data.size]
                                revert with 0, 'SafeERC20: low-level call failed'
                            if return_data.size > 0:
                                require return_data.size >= 32
                                if not mem[868]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x775361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[ceil32(return_data.size) + 947 len 22]
            else:
                if block.number > endBlock:
                    if endBlock <= bonusEndBlock:
                        if endBlock > endBlock:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if totalAllocPoint <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require totalAllocPoint
                        if devFundDivRate <= 0:
                            revert with 0, 'SafeMath: division by zero'
                        require devFundDivRate
                        require ext_code.size(sub_64d46cecAddress)
                        call sub_64d46cecAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args devaddr, 0 / totalAllocPoint / devFundDivRate
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require ext_code.size(sub_64d46cecAddress)
                        call sub_64d46cecAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args address(this.address), 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not 0 / totalAllocPoint:
                            if ext_call.return_data[0] <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require ext_call.return_data[0]
                            if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                        else:
                            require 0 / totalAllocPoint
                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                            if ext_call.return_data[0] <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require ext_call.return_data[0]
                            if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[arg1].field_512 = block.number
                        if not userInfo[arg1][address(msg.sender)].field_0:
                            if userInfo[arg1][address(msg.sender)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            require ext_code.size(sub_64d46cecAddress)
                            staticcall sub_64d46cecAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_code.size(sub_64d46cecAddress)
                            if -userInfo[arg1][address(msg.sender)].field_256 <= ext_call.return_data[0]:
                                call sub_64d46cecAddress.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, -userInfo[arg1][address(msg.sender)].field_256
                            else:
                                call sub_64d46cecAddress.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, ext_call.return_data[0]
                        else:
                            require userInfo[arg1][address(msg.sender)].field_0
                            if userInfo[arg1][address(msg.sender)].field_0 * poolInfo[arg1].field_768 / userInfo[arg1][address(msg.sender)].field_0 != poolInfo[arg1].field_768:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                            if userInfo[arg1][address(msg.sender)].field_256 > userInfo[arg1][address(msg.sender)].field_0 * poolInfo[arg1].field_768 / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            require ext_code.size(sub_64d46cecAddress)
                            staticcall sub_64d46cecAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_code.size(sub_64d46cecAddress)
                            if (userInfo[arg1][address(msg.sender)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(msg.sender)].field_256 <= ext_call.return_data[0]:
                                call sub_64d46cecAddress.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, (userInfo[arg1][address(msg.sender)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(msg.sender)].field_256
                            else:
                                call sub_64d46cecAddress.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if arg2 > userInfo[arg1][address(msg.sender)].field_0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        userInfo[arg1][address(msg.sender)].field_0 -= arg2
                        if not userInfo[arg1][address(msg.sender)].field_0:
                            userInfo[arg1][address(msg.sender)].field_256 = 0
                        else:
                            require userInfo[arg1][address(msg.sender)].field_0
                            if userInfo[arg1][address(msg.sender)].field_0 * poolInfo[arg1].field_768 / userInfo[arg1][address(msg.sender)].field_0 != poolInfo[arg1].field_768:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[645 len 31]
                            userInfo[arg1][address(msg.sender)].field_256 = userInfo[arg1][address(msg.sender)].field_0 * poolInfo[arg1].field_768 / 10^12
                        if ext_code.hash(poolInfo[arg1].field_0) == 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470:
                            revert with 0, 'Address: call to non-contract'
                        if not ext_code.hash(poolInfo[arg1].field_0):
                            revert with 0, 'Address: call to non-contract'
                        mem[772 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                        call poolInfo[arg1].field_0 with:
                           funct uint32(msg.sender)
                             gas gas_remaining wei
                            args Mask(224, 32, arg2) << 224, mem[836 len 4]
                        if not return_data.size:
                            require not ext_call.success
                            revert with 'SafeMath: subtraction overflow'
                        mem[804 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size > 0:
                                revert with ext_call.return_data[0 len return_data.size]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if return_data.size > 0:
                            require return_data.size >= 32
                            if not mem[804]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x775361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[ceil32(return_data.size) + 883 len 22]
                    else:
                        if endBlock >= bonusEndBlock:
                            if endBlock > endBlock:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if totalAllocPoint <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require totalAllocPoint
                            if devFundDivRate <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require devFundDivRate
                            require ext_code.size(sub_64d46cecAddress)
                            call sub_64d46cecAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args devaddr, 0 / totalAllocPoint / devFundDivRate
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(sub_64d46cecAddress)
                            call sub_64d46cecAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args address(this.address), 0 / totalAllocPoint
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if not 0 / totalAllocPoint:
                                if ext_call.return_data[0] <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require ext_call.return_data[0]
                                if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                            else:
                                require 0 / totalAllocPoint
                                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                if ext_call.return_data[0] <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require ext_call.return_data[0]
                                if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[arg1].field_512 = block.number
                            if not userInfo[arg1][address(msg.sender)].field_0:
                                if userInfo[arg1][address(msg.sender)].field_256 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                require ext_code.size(sub_64d46cecAddress)
                                staticcall sub_64d46cecAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sub_64d46cecAddress)
                                if -userInfo[arg1][address(msg.sender)].field_256 <= ext_call.return_data[0]:
                                    call sub_64d46cecAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, -userInfo[arg1][address(msg.sender)].field_256
                                else:
                                    call sub_64d46cecAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, ext_call.return_data[0]
                            else:
                                require userInfo[arg1][address(msg.sender)].field_0
                                if userInfo[arg1][address(msg.sender)].field_0 * poolInfo[arg1].field_768 / userInfo[arg1][address(msg.sender)].field_0 != poolInfo[arg1].field_768:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                if userInfo[arg1][address(msg.sender)].field_256 > userInfo[arg1][address(msg.sender)].field_0 * poolInfo[arg1].field_768 / 10^12:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                require ext_code.size(sub_64d46cecAddress)
                                staticcall sub_64d46cecAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sub_64d46cecAddress)
                                if (userInfo[arg1][address(msg.sender)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(msg.sender)].field_256 <= ext_call.return_data[0]:
                                    call sub_64d46cecAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, (userInfo[arg1][address(msg.sender)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(msg.sender)].field_256
                                else:
                                    call sub_64d46cecAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if arg2 > userInfo[arg1][address(msg.sender)].field_0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            userInfo[arg1][address(msg.sender)].field_0 -= arg2
                            if not userInfo[arg1][address(msg.sender)].field_0:
                                userInfo[arg1][address(msg.sender)].field_256 = 0
                            else:
                                require userInfo[arg1][address(msg.sender)].field_0
                                if userInfo[arg1][address(msg.sender)].field_0 * poolInfo[arg1].field_768 / userInfo[arg1][address(msg.sender)].field_0 != poolInfo[arg1].field_768:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[645 len 31]
                                userInfo[arg1][address(msg.sender)].field_256 = userInfo[arg1][address(msg.sender)].field_0 * poolInfo[arg1].field_768 / 10^12
                            if ext_code.hash(poolInfo[arg1].field_0) == 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470:
                                revert with 0, 'Address: call to non-contract'
                            if not ext_code.hash(poolInfo[arg1].field_0):
                                revert with 0, 'Address: call to non-contract'
                            mem[772 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                            call poolInfo[arg1].field_0 with:
                               funct uint32(msg.sender)
                                 gas gas_remaining wei
                                args Mask(224, 32, arg2) << 224, mem[836 len 4]
                            if not return_data.size:
                                require not ext_call.success
                                revert with 'SafeMath: subtraction overflow'
                            mem[804 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                if return_data.size > 0:
                                    revert with ext_call.return_data[0 len return_data.size]
                                revert with 0, 'SafeERC20: low-level call failed'
                            if return_data.size > 0:
                                require return_data.size >= 32
                                if not mem[804]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x775361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[ceil32(return_data.size) + 883 len 22]
                        else:
                            if bonusEndBlock > endBlock:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if endBlock > bonusEndBlock:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if bonusEndBlock - endBlock:
                                require bonusEndBlock - endBlock
                                if bonusEndBlock - endBlock / bonusEndBlock - endBlock != 1:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                                if 0 < bonusEndBlock - endBlock:
                                    revert with 0, 'SafeMath: addition overflow'
                                if totalAllocPoint <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require totalAllocPoint
                                if devFundDivRate <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require devFundDivRate
                                require ext_code.size(sub_64d46cecAddress)
                                call sub_64d46cecAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args devaddr, 0 / totalAllocPoint / devFundDivRate
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(sub_64d46cecAddress)
                                call sub_64d46cecAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args address(this.address), 0 / totalAllocPoint
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if not 0 / totalAllocPoint:
                                    if ext_call.return_data[0] <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require ext_call.return_data[0]
                                    if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                else:
                                    require 0 / totalAllocPoint
                                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                    if ext_call.return_data[0] <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require ext_call.return_data[0]
                                    if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                            else:
                                if endBlock - bonusEndBlock < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not endBlock - bonusEndBlock:
                                    if totalAllocPoint <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require totalAllocPoint
                                    if devFundDivRate <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require devFundDivRate
                                    require ext_code.size(sub_64d46cecAddress)
                                    call sub_64d46cecAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args devaddr, 0 / totalAllocPoint / devFundDivRate
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(sub_64d46cecAddress)
                                    call sub_64d46cecAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args address(this.address), 0 / totalAllocPoint
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not 0 / totalAllocPoint:
                                        if ext_call.return_data[0] <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require ext_call.return_data[0]
                                        if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                    else:
                                        require 0 / totalAllocPoint
                                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                        if ext_call.return_data[0] <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require ext_call.return_data[0]
                                        if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                else:
                                    require endBlock - bonusEndBlock
                                    if (endBlock * sub_a3eef5b2) - (bonusEndBlock * sub_a3eef5b2) / endBlock - bonusEndBlock != sub_a3eef5b2:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                                    if not (endBlock * sub_a3eef5b2) - (bonusEndBlock * sub_a3eef5b2):
                                        if totalAllocPoint <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalAllocPoint
                                        if devFundDivRate <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require devFundDivRate
                                        require ext_code.size(sub_64d46cecAddress)
                                        call sub_64d46cecAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args devaddr, 0 / totalAllocPoint / devFundDivRate
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require ext_code.size(sub_64d46cecAddress)
                                        call sub_64d46cecAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args address(this.address), 0 / totalAllocPoint
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not 0 / totalAllocPoint:
                                            if ext_call.return_data[0] <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require ext_call.return_data[0]
                                            if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                        else:
                                            require 0 / totalAllocPoint
                                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                            if ext_call.return_data[0] <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require ext_call.return_data[0]
                                            if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                    else:
                                        require (endBlock * sub_a3eef5b2) - (bonusEndBlock * sub_a3eef5b2)
                                        if (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / (endBlock * sub_a3eef5b2) - (bonusEndBlock * sub_a3eef5b2) != poolInfo[arg1].field_256:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                                        if totalAllocPoint <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalAllocPoint
                                        if devFundDivRate <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require devFundDivRate
                                        require ext_code.size(sub_64d46cecAddress)
                                        call sub_64d46cecAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args devaddr, (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / devFundDivRate
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require ext_code.size(sub_64d46cecAddress)
                                        call sub_64d46cecAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args address(this.address), (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint:
                                            if ext_call.return_data[0] <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require ext_call.return_data[0]
                                            if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                        else:
                                            require (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint
                                            if 10^12 * (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                            if ext_call.return_data[0] <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require ext_call.return_data[0]
                                            if poolInfo[arg1].field_768 + (10^12 * (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 10^12 * (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[arg1].field_512 = block.number
                            if not userInfo[arg1][address(msg.sender)].field_0:
                                if userInfo[arg1][address(msg.sender)].field_256 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                require ext_code.size(sub_64d46cecAddress)
                                staticcall sub_64d46cecAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sub_64d46cecAddress)
                                if -userInfo[arg1][address(msg.sender)].field_256 <= ext_call.return_data[0]:
                                    call sub_64d46cecAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, -userInfo[arg1][address(msg.sender)].field_256
                                else:
                                    call sub_64d46cecAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, ext_call.return_data[0]
                            else:
                                require userInfo[arg1][address(msg.sender)].field_0
                                if userInfo[arg1][address(msg.sender)].field_0 * poolInfo[arg1].field_768 / userInfo[arg1][address(msg.sender)].field_0 != poolInfo[arg1].field_768:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                                if userInfo[arg1][address(msg.sender)].field_256 > userInfo[arg1][address(msg.sender)].field_0 * poolInfo[arg1].field_768 / 10^12:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                require ext_code.size(sub_64d46cecAddress)
                                staticcall sub_64d46cecAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sub_64d46cecAddress)
                                if (userInfo[arg1][address(msg.sender)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(msg.sender)].field_256 <= ext_call.return_data[0]:
                                    call sub_64d46cecAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, (userInfo[arg1][address(msg.sender)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(msg.sender)].field_256
                                else:
                                    call sub_64d46cecAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if arg2 > userInfo[arg1][address(msg.sender)].field_0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            userInfo[arg1][address(msg.sender)].field_0 -= arg2
                            if not userInfo[arg1][address(msg.sender)].field_0:
                                userInfo[arg1][address(msg.sender)].field_256 = 0
                            else:
                                require userInfo[arg1][address(msg.sender)].field_0
                                if userInfo[arg1][address(msg.sender)].field_0 * poolInfo[arg1].field_768 / userInfo[arg1][address(msg.sender)].field_0 != poolInfo[arg1].field_768:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[709 len 31]
                                userInfo[arg1][address(msg.sender)].field_256 = userInfo[arg1][address(msg.sender)].field_0 * poolInfo[arg1].field_768 / 10^12
                            if ext_code.hash(poolInfo[arg1].field_0) == 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470:
                                revert with 0, 'Address: call to non-contract'
                            if not ext_code.hash(poolInfo[arg1].field_0):
                                revert with 0, 'Address: call to non-contract'
                            mem[836 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                            call poolInfo[arg1].field_0 with:
                               funct uint32(msg.sender)
                                 gas gas_remaining wei
                                args Mask(224, 32, arg2) << 224, mem[900 len 4]
                            if not return_data.size:
                                require not ext_call.success
                                revert with 'SafeMath: subtraction overflow'
                            mem[868 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                if return_data.size > 0:
                                    revert with ext_call.return_data[0 len return_data.size]
                                revert with 0, 'SafeERC20: low-level call failed'
                            if return_data.size > 0:
                                require return_data.size >= 32
                                if not mem[868]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x775361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[ceil32(return_data.size) + 947 len 22]
                else:
                    if block.number <= bonusEndBlock:
                        if endBlock > block.number:
                            revert with 0, 'SafeMath: subtraction overflow'
                        if not block.number - endBlock:
                            if totalAllocPoint <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require totalAllocPoint
                            if devFundDivRate <= 0:
                                revert with 0, 'SafeMath: division by zero'
                            require devFundDivRate
                            require ext_code.size(sub_64d46cecAddress)
                            call sub_64d46cecAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args devaddr, 0 / totalAllocPoint / devFundDivRate
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require ext_code.size(sub_64d46cecAddress)
                            call sub_64d46cecAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args address(this.address), 0 / totalAllocPoint
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if not 0 / totalAllocPoint:
                                if ext_call.return_data[0] <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require ext_call.return_data[0]
                                if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                            else:
                                require 0 / totalAllocPoint
                                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                if ext_call.return_data[0] <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require ext_call.return_data[0]
                                if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                        else:
                            require block.number - endBlock
                            if block.number - endBlock / block.number - endBlock != 1:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                            if not block.number - endBlock:
                                if totalAllocPoint <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require totalAllocPoint
                                if devFundDivRate <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require devFundDivRate
                                require ext_code.size(sub_64d46cecAddress)
                                call sub_64d46cecAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args devaddr, 0 / totalAllocPoint / devFundDivRate
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(sub_64d46cecAddress)
                                call sub_64d46cecAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args address(this.address), 0 / totalAllocPoint
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if not 0 / totalAllocPoint:
                                    if ext_call.return_data[0] <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require ext_call.return_data[0]
                                    if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                else:
                                    require 0 / totalAllocPoint
                                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                    if ext_call.return_data[0] <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require ext_call.return_data[0]
                                    if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                            else:
                                require block.number - endBlock
                                if (block.number * sub_a3eef5b2) - (endBlock * sub_a3eef5b2) / block.number - endBlock != sub_a3eef5b2:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                                if not (block.number * sub_a3eef5b2) - (endBlock * sub_a3eef5b2):
                                    if totalAllocPoint <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require totalAllocPoint
                                    if devFundDivRate <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require devFundDivRate
                                    require ext_code.size(sub_64d46cecAddress)
                                    call sub_64d46cecAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args devaddr, 0 / totalAllocPoint / devFundDivRate
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(sub_64d46cecAddress)
                                    call sub_64d46cecAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args address(this.address), 0 / totalAllocPoint
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not 0 / totalAllocPoint:
                                        if ext_call.return_data[0] <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require ext_call.return_data[0]
                                        if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                    else:
                                        require 0 / totalAllocPoint
                                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                        if ext_call.return_data[0] <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require ext_call.return_data[0]
                                        if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                else:
                                    require (block.number * sub_a3eef5b2) - (endBlock * sub_a3eef5b2)
                                    if (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / (block.number * sub_a3eef5b2) - (endBlock * sub_a3eef5b2) != poolInfo[arg1].field_256:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                                    if totalAllocPoint <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require totalAllocPoint
                                    if devFundDivRate <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require devFundDivRate
                                    require ext_code.size(sub_64d46cecAddress)
                                    call sub_64d46cecAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args devaddr, (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / devFundDivRate
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(sub_64d46cecAddress)
                                    call sub_64d46cecAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args address(this.address), (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint:
                                        if ext_call.return_data[0] <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require ext_call.return_data[0]
                                        if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                    else:
                                        require (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint
                                        if 10^12 * (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                        if ext_call.return_data[0] <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require ext_call.return_data[0]
                                        if poolInfo[arg1].field_768 + (10^12 * (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 10^12 * (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[arg1].field_512 = block.number
                        if not userInfo[arg1][address(msg.sender)].field_0:
                            if userInfo[arg1][address(msg.sender)].field_256 > 0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            require ext_code.size(sub_64d46cecAddress)
                            staticcall sub_64d46cecAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_code.size(sub_64d46cecAddress)
                            if -userInfo[arg1][address(msg.sender)].field_256 <= ext_call.return_data[0]:
                                call sub_64d46cecAddress.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, -userInfo[arg1][address(msg.sender)].field_256
                            else:
                                call sub_64d46cecAddress.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, ext_call.return_data[0]
                        else:
                            require userInfo[arg1][address(msg.sender)].field_0
                            if userInfo[arg1][address(msg.sender)].field_0 * poolInfo[arg1].field_768 / userInfo[arg1][address(msg.sender)].field_0 != poolInfo[arg1].field_768:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                            if userInfo[arg1][address(msg.sender)].field_256 > userInfo[arg1][address(msg.sender)].field_0 * poolInfo[arg1].field_768 / 10^12:
                                revert with 0, 'SafeMath: subtraction overflow'
                            require ext_code.size(sub_64d46cecAddress)
                            staticcall sub_64d46cecAddress.0x70a08231 with:
                                    gas gas_remaining wei
                                   args this.address
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            require ext_code.size(sub_64d46cecAddress)
                            if (userInfo[arg1][address(msg.sender)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(msg.sender)].field_256 <= ext_call.return_data[0]:
                                call sub_64d46cecAddress.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, (userInfo[arg1][address(msg.sender)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(msg.sender)].field_256
                            else:
                                call sub_64d46cecAddress.0xa9059cbb with:
                                     gas gas_remaining wei
                                    args msg.sender, ext_call.return_data[0]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 32
                        if arg2 > userInfo[arg1][address(msg.sender)].field_0:
                            revert with 0, 'SafeMath: subtraction overflow'
                        userInfo[arg1][address(msg.sender)].field_0 -= arg2
                        if not userInfo[arg1][address(msg.sender)].field_0:
                            userInfo[arg1][address(msg.sender)].field_256 = 0
                        else:
                            require userInfo[arg1][address(msg.sender)].field_0
                            if userInfo[arg1][address(msg.sender)].field_0 * poolInfo[arg1].field_768 / userInfo[arg1][address(msg.sender)].field_0 != poolInfo[arg1].field_768:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[645 len 31]
                            userInfo[arg1][address(msg.sender)].field_256 = userInfo[arg1][address(msg.sender)].field_0 * poolInfo[arg1].field_768 / 10^12
                        if ext_code.hash(poolInfo[arg1].field_0) == 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470:
                            revert with 0, 'Address: call to non-contract'
                        if not ext_code.hash(poolInfo[arg1].field_0):
                            revert with 0, 'Address: call to non-contract'
                        mem[772 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                        call poolInfo[arg1].field_0 with:
                           funct uint32(msg.sender)
                             gas gas_remaining wei
                            args Mask(224, 32, arg2) << 224, mem[836 len 4]
                        if not return_data.size:
                            require not ext_call.success
                            revert with 'SafeMath: subtraction overflow'
                        mem[804 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        if not ext_call.success:
                            if return_data.size > 0:
                                revert with ext_call.return_data[0 len return_data.size]
                            revert with 0, 'SafeERC20: low-level call failed'
                        if return_data.size > 0:
                            require return_data.size >= 32
                            if not mem[804]:
                                revert with 0, 
                                            32,
                                            42,
                                            0x775361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                            mem[ceil32(return_data.size) + 883 len 22]
                    else:
                        if endBlock >= bonusEndBlock:
                            if endBlock > block.number:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if not block.number - endBlock:
                                if totalAllocPoint <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require totalAllocPoint
                                if devFundDivRate <= 0:
                                    revert with 0, 'SafeMath: division by zero'
                                require devFundDivRate
                                require ext_code.size(sub_64d46cecAddress)
                                call sub_64d46cecAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args devaddr, 0 / totalAllocPoint / devFundDivRate
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require ext_code.size(sub_64d46cecAddress)
                                call sub_64d46cecAddress.0x40c10f19 with:
                                     gas gas_remaining wei
                                    args address(this.address), 0 / totalAllocPoint
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                if not 0 / totalAllocPoint:
                                    if ext_call.return_data[0] <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require ext_call.return_data[0]
                                    if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                else:
                                    require 0 / totalAllocPoint
                                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                    if ext_call.return_data[0] <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require ext_call.return_data[0]
                                    if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                            else:
                                require block.number - endBlock
                                if (block.number * sub_a3eef5b2) - (endBlock * sub_a3eef5b2) / block.number - endBlock != sub_a3eef5b2:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                                if not (block.number * sub_a3eef5b2) - (endBlock * sub_a3eef5b2):
                                    if totalAllocPoint <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require totalAllocPoint
                                    if devFundDivRate <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require devFundDivRate
                                    require ext_code.size(sub_64d46cecAddress)
                                    call sub_64d46cecAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args devaddr, 0 / totalAllocPoint / devFundDivRate
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(sub_64d46cecAddress)
                                    call sub_64d46cecAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args address(this.address), 0 / totalAllocPoint
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not 0 / totalAllocPoint:
                                        if ext_call.return_data[0] <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require ext_call.return_data[0]
                                        if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                    else:
                                        require 0 / totalAllocPoint
                                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                        if ext_call.return_data[0] <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require ext_call.return_data[0]
                                        if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                else:
                                    require (block.number * sub_a3eef5b2) - (endBlock * sub_a3eef5b2)
                                    if (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / (block.number * sub_a3eef5b2) - (endBlock * sub_a3eef5b2) != poolInfo[arg1].field_256:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[261 len 31]
                                    if totalAllocPoint <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require totalAllocPoint
                                    if devFundDivRate <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require devFundDivRate
                                    require ext_code.size(sub_64d46cecAddress)
                                    call sub_64d46cecAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args devaddr, (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / devFundDivRate
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(sub_64d46cecAddress)
                                    call sub_64d46cecAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args address(this.address), (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint:
                                        if ext_call.return_data[0] <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require ext_call.return_data[0]
                                        if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                    else:
                                        require (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint
                                        if 10^12 * (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[389 len 31]
                                        if ext_call.return_data[0] <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require ext_call.return_data[0]
                                        if poolInfo[arg1].field_768 + (10^12 * (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 10^12 * (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[arg1].field_512 = block.number
                            if not userInfo[arg1][address(msg.sender)].field_0:
                                if userInfo[arg1][address(msg.sender)].field_256 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                require ext_code.size(sub_64d46cecAddress)
                                staticcall sub_64d46cecAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sub_64d46cecAddress)
                                if -userInfo[arg1][address(msg.sender)].field_256 <= ext_call.return_data[0]:
                                    call sub_64d46cecAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, -userInfo[arg1][address(msg.sender)].field_256
                                else:
                                    call sub_64d46cecAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, ext_call.return_data[0]
                            else:
                                require userInfo[arg1][address(msg.sender)].field_0
                                if userInfo[arg1][address(msg.sender)].field_0 * poolInfo[arg1].field_768 / userInfo[arg1][address(msg.sender)].field_0 != poolInfo[arg1].field_768:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                if userInfo[arg1][address(msg.sender)].field_256 > userInfo[arg1][address(msg.sender)].field_0 * poolInfo[arg1].field_768 / 10^12:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                require ext_code.size(sub_64d46cecAddress)
                                staticcall sub_64d46cecAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sub_64d46cecAddress)
                                if (userInfo[arg1][address(msg.sender)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(msg.sender)].field_256 <= ext_call.return_data[0]:
                                    call sub_64d46cecAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, (userInfo[arg1][address(msg.sender)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(msg.sender)].field_256
                                else:
                                    call sub_64d46cecAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if arg2 > userInfo[arg1][address(msg.sender)].field_0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            userInfo[arg1][address(msg.sender)].field_0 -= arg2
                            if not userInfo[arg1][address(msg.sender)].field_0:
                                userInfo[arg1][address(msg.sender)].field_256 = 0
                            else:
                                require userInfo[arg1][address(msg.sender)].field_0
                                if userInfo[arg1][address(msg.sender)].field_0 * poolInfo[arg1].field_768 / userInfo[arg1][address(msg.sender)].field_0 != poolInfo[arg1].field_768:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[645 len 31]
                                userInfo[arg1][address(msg.sender)].field_256 = userInfo[arg1][address(msg.sender)].field_0 * poolInfo[arg1].field_768 / 10^12
                            if ext_code.hash(poolInfo[arg1].field_0) == 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470:
                                revert with 0, 'Address: call to non-contract'
                            if not ext_code.hash(poolInfo[arg1].field_0):
                                revert with 0, 'Address: call to non-contract'
                            mem[772 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                            call poolInfo[arg1].field_0 with:
                               funct uint32(msg.sender)
                                 gas gas_remaining wei
                                args Mask(224, 32, arg2) << 224, mem[836 len 4]
                            if not return_data.size:
                                require not ext_call.success
                                revert with 'SafeMath: subtraction overflow'
                            mem[804 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                if return_data.size > 0:
                                    revert with ext_call.return_data[0 len return_data.size]
                                revert with 0, 'SafeERC20: low-level call failed'
                            if return_data.size > 0:
                                require return_data.size >= 32
                                if not mem[804]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x775361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[ceil32(return_data.size) + 883 len 22]
                        else:
                            if bonusEndBlock > block.number:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if endBlock > bonusEndBlock:
                                revert with 0, 'SafeMath: subtraction overflow'
                            if not bonusEndBlock - endBlock:
                                if block.number - bonusEndBlock < 0:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not block.number - bonusEndBlock:
                                    if totalAllocPoint <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require totalAllocPoint
                                    if devFundDivRate <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require devFundDivRate
                                    require ext_code.size(sub_64d46cecAddress)
                                    call sub_64d46cecAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args devaddr, 0 / totalAllocPoint / devFundDivRate
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(sub_64d46cecAddress)
                                    call sub_64d46cecAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args address(this.address), 0 / totalAllocPoint
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not 0 / totalAllocPoint:
                                        if ext_call.return_data[0] <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require ext_call.return_data[0]
                                        if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                    else:
                                        require 0 / totalAllocPoint
                                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                        if ext_call.return_data[0] <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require ext_call.return_data[0]
                                        if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                else:
                                    require block.number - bonusEndBlock
                                    if (block.number * sub_a3eef5b2) - (bonusEndBlock * sub_a3eef5b2) / block.number - bonusEndBlock != sub_a3eef5b2:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                                    if not (block.number * sub_a3eef5b2) - (bonusEndBlock * sub_a3eef5b2):
                                        if totalAllocPoint <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalAllocPoint
                                        if devFundDivRate <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require devFundDivRate
                                        require ext_code.size(sub_64d46cecAddress)
                                        call sub_64d46cecAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args devaddr, 0 / totalAllocPoint / devFundDivRate
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require ext_code.size(sub_64d46cecAddress)
                                        call sub_64d46cecAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args address(this.address), 0 / totalAllocPoint
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not 0 / totalAllocPoint:
                                            if ext_call.return_data[0] <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require ext_call.return_data[0]
                                            if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                        else:
                                            require 0 / totalAllocPoint
                                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                            if ext_call.return_data[0] <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require ext_call.return_data[0]
                                            if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                    else:
                                        require (block.number * sub_a3eef5b2) - (bonusEndBlock * sub_a3eef5b2)
                                        if (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / (block.number * sub_a3eef5b2) - (bonusEndBlock * sub_a3eef5b2) != poolInfo[arg1].field_256:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                                        if totalAllocPoint <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalAllocPoint
                                        if devFundDivRate <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require devFundDivRate
                                        require ext_code.size(sub_64d46cecAddress)
                                        call sub_64d46cecAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args devaddr, (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / devFundDivRate
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require ext_code.size(sub_64d46cecAddress)
                                        call sub_64d46cecAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args address(this.address), (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint:
                                            if ext_call.return_data[0] <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require ext_call.return_data[0]
                                            if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                        else:
                                            require (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint
                                            if 10^12 * (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                            if ext_call.return_data[0] <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require ext_call.return_data[0]
                                            if poolInfo[arg1].field_768 + (10^12 * (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 10^12 * (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]
                            else:
                                require bonusEndBlock - endBlock
                                if bonusEndBlock - endBlock / bonusEndBlock - endBlock != 1:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                                if block.number < bonusEndBlock:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not -endBlock + block.number:
                                    if totalAllocPoint <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require totalAllocPoint
                                    if devFundDivRate <= 0:
                                        revert with 0, 'SafeMath: division by zero'
                                    require devFundDivRate
                                    require ext_code.size(sub_64d46cecAddress)
                                    call sub_64d46cecAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args devaddr, 0 / totalAllocPoint / devFundDivRate
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    require ext_code.size(sub_64d46cecAddress)
                                    call sub_64d46cecAddress.0x40c10f19 with:
                                         gas gas_remaining wei
                                        args address(this.address), 0 / totalAllocPoint
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    if not 0 / totalAllocPoint:
                                        if ext_call.return_data[0] <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require ext_call.return_data[0]
                                        if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                    else:
                                        require 0 / totalAllocPoint
                                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                        if ext_call.return_data[0] <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require ext_call.return_data[0]
                                        if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                            revert with 0, 'SafeMath: addition overflow'
                                        poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                else:
                                    require -endBlock + block.number
                                    if (-1 * endBlock * sub_a3eef5b2) + (block.number * sub_a3eef5b2) / -endBlock + block.number != sub_a3eef5b2:
                                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                                    if not (-1 * endBlock * sub_a3eef5b2) + (block.number * sub_a3eef5b2):
                                        if totalAllocPoint <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalAllocPoint
                                        if devFundDivRate <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require devFundDivRate
                                        require ext_code.size(sub_64d46cecAddress)
                                        call sub_64d46cecAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args devaddr, 0 / totalAllocPoint / devFundDivRate
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require ext_code.size(sub_64d46cecAddress)
                                        call sub_64d46cecAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args address(this.address), 0 / totalAllocPoint
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not 0 / totalAllocPoint:
                                            if ext_call.return_data[0] <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require ext_call.return_data[0]
                                            if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                        else:
                                            require 0 / totalAllocPoint
                                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                            if ext_call.return_data[0] <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require ext_call.return_data[0]
                                            if poolInfo[arg1].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                    else:
                                        require (-1 * endBlock * sub_a3eef5b2) + (block.number * sub_a3eef5b2)
                                        if (-1 * endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) + (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) / (-1 * endBlock * sub_a3eef5b2) + (block.number * sub_a3eef5b2) != poolInfo[arg1].field_256:
                                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[325 len 31]
                                        if totalAllocPoint <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require totalAllocPoint
                                        if devFundDivRate <= 0:
                                            revert with 0, 'SafeMath: division by zero'
                                        require devFundDivRate
                                        require ext_code.size(sub_64d46cecAddress)
                                        call sub_64d46cecAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args devaddr, (-1 * endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) + (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / devFundDivRate
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require ext_code.size(sub_64d46cecAddress)
                                        call sub_64d46cecAddress.0x40c10f19 with:
                                             gas gas_remaining wei
                                            args address(this.address), (-1 * endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) + (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        if not (-1 * endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) + (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint:
                                            if ext_call.return_data[0] <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require ext_call.return_data[0]
                                            if poolInfo[arg1].field_768 + (0 / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 0 / ext_call.return_data[0]
                                        else:
                                            require (-1 * endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) + (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint
                                            if 10^12 * (-1 * endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) + (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / (-1 * endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) + (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint != 10^12:
                                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[453 len 31]
                                            if ext_call.return_data[0] <= 0:
                                                revert with 0, 'SafeMath: division by zero'
                                            require ext_call.return_data[0]
                                            if poolInfo[arg1].field_768 + (10^12 * (-1 * endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) + (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]) < poolInfo[arg1].field_768:
                                                revert with 0, 'SafeMath: addition overflow'
                                            poolInfo[arg1].field_768 += 10^12 * (-1 * endBlock * sub_a3eef5b2 * poolInfo[arg1].field_256) + (block.number * sub_a3eef5b2 * poolInfo[arg1].field_256) / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[arg1].field_512 = block.number
                            if not userInfo[arg1][address(msg.sender)].field_0:
                                if userInfo[arg1][address(msg.sender)].field_256 > 0:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                require ext_code.size(sub_64d46cecAddress)
                                staticcall sub_64d46cecAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sub_64d46cecAddress)
                                if -userInfo[arg1][address(msg.sender)].field_256 <= ext_call.return_data[0]:
                                    call sub_64d46cecAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, -userInfo[arg1][address(msg.sender)].field_256
                                else:
                                    call sub_64d46cecAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, ext_call.return_data[0]
                            else:
                                require userInfo[arg1][address(msg.sender)].field_0
                                if userInfo[arg1][address(msg.sender)].field_0 * poolInfo[arg1].field_768 / userInfo[arg1][address(msg.sender)].field_0 != poolInfo[arg1].field_768:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[517 len 31]
                                if userInfo[arg1][address(msg.sender)].field_256 > userInfo[arg1][address(msg.sender)].field_0 * poolInfo[arg1].field_768 / 10^12:
                                    revert with 0, 'SafeMath: subtraction overflow'
                                require ext_code.size(sub_64d46cecAddress)
                                staticcall sub_64d46cecAddress.0x70a08231 with:
                                        gas gas_remaining wei
                                       args this.address
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 32
                                require ext_code.size(sub_64d46cecAddress)
                                if (userInfo[arg1][address(msg.sender)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(msg.sender)].field_256 <= ext_call.return_data[0]:
                                    call sub_64d46cecAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, (userInfo[arg1][address(msg.sender)].field_0 * poolInfo[arg1].field_768 / 10^12) - userInfo[arg1][address(msg.sender)].field_256
                                else:
                                    call sub_64d46cecAddress.0xa9059cbb with:
                                         gas gas_remaining wei
                                        args msg.sender, ext_call.return_data[0]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            require return_data.size >= 32
                            if arg2 > userInfo[arg1][address(msg.sender)].field_0:
                                revert with 0, 'SafeMath: subtraction overflow'
                            userInfo[arg1][address(msg.sender)].field_0 -= arg2
                            if not userInfo[arg1][address(msg.sender)].field_0:
                                userInfo[arg1][address(msg.sender)].field_256 = 0
                            else:
                                require userInfo[arg1][address(msg.sender)].field_0
                                if userInfo[arg1][address(msg.sender)].field_0 * poolInfo[arg1].field_768 / userInfo[arg1][address(msg.sender)].field_0 != poolInfo[arg1].field_768:
                                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[709 len 31]
                                userInfo[arg1][address(msg.sender)].field_256 = userInfo[arg1][address(msg.sender)].field_0 * poolInfo[arg1].field_768 / 10^12
                            if ext_code.hash(poolInfo[arg1].field_0) == 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470:
                                revert with 0, 'Address: call to non-contract'
                            if not ext_code.hash(poolInfo[arg1].field_0):
                                revert with 0, 'Address: call to non-contract'
                            mem[836 len 64] = unknown_0xa9059cbb(?????), msg.sender, Mask(224, 32, arg2) >> 32
                            call poolInfo[arg1].field_0 with:
                               funct uint32(msg.sender)
                                 gas gas_remaining wei
                                args Mask(224, 32, arg2) << 224, mem[900 len 4]
                            if not return_data.size:
                                require not ext_call.success
                                revert with 'SafeMath: subtraction overflow'
                            mem[868 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            if not ext_call.success:
                                if return_data.size > 0:
                                    revert with ext_call.return_data[0 len return_data.size]
                                revert with 0, 'SafeERC20: low-level call failed'
                            if return_data.size > 0:
                                require return_data.size >= 32
                                if not mem[868]:
                                    revert with 0, 
                                                32,
                                                42,
                                                0x775361666545524332303a204552433230206f7065726174696f6e20646964206e6f7420737563636565,
                                                mem[ceil32(return_data.size) + 947 len 22]
    emit Withdraw(arg2, msg.sender, arg1);
}

function massUpdatePools() payable {
    mem[64] = 96
    idx = 0
    while idx < poolInfo.length:
        mem[0] = 6
        if block.number <= poolInfo[idx].field_512:
            idx = idx + 1
            continue 
        mem[mem[64] + 4] = this.address
        require ext_code.size(poolInfo[idx].field_0)
        staticcall poolInfo[idx].field_0.0x70a08231 with:
                gas gas_remaining wei
               args address(this.address)
        mem[mem[64]] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        if not ext_call.return_data[0]:
            poolInfo[idx].field_512 = block.number
            idx = idx + 1
            continue 
        if poolInfo[idx].field_512 <= endBlock:
            if block.number <= endBlock:
                if block.number <= bonusEndBlock:
                    _2111 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2111] = 30
                    mem[_2111 + 32] = 'SafeMath: subtraction overflow'
                    if poolInfo[idx].field_512 > block.number:
                        _2116 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_2116 + idx + 68] = mem[_2111 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2116 + 68] = mem[_2116 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _2116 + -mem[64] + 100
                    if not block.number - poolInfo[idx].field_512:
                        _2289 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2289] = 26
                        mem[_2289 + 32] = 'SafeMath: division by zero'
                        if totalAllocPoint <= 0:
                            _2317 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2317 + idx + 68] = mem[_2289 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2317 + 68] = mem[_2317 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _2317 + -mem[64] + 100
                        require totalAllocPoint
                        _2419 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2419] = 26
                        mem[_2419 + 32] = 'SafeMath: division by zero'
                        if devFundDivRate <= 0:
                            _2485 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2485 + idx + 68] = mem[_2419 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2485 + 68] = mem[_2485 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _2485 + -mem[64] + 100
                        require devFundDivRate
                        require ext_code.size(sub_64d46cecAddress)
                        call sub_64d46cecAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args devaddr, 0 / totalAllocPoint / devFundDivRate
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sub_64d46cecAddress)
                        call sub_64d46cecAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args address(this.address), 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not 0 / totalAllocPoint:
                            _3001 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3001] = 26
                            mem[_3001 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0] > 0:
                                require ext_call.return_data[0]
                                if poolInfo[idx].field_768 + (0 / ext_call.return_data[0]) < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _3115 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3115 + idx + 68] = mem[_3001 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3115 + 68] = mem[_3115 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _3115 + -mem[64] + 100
                        require 0 / totalAllocPoint
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _3114 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3114] = 26
                        mem[_3114 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0] > 0:
                            require ext_call.return_data[0]
                            if poolInfo[idx].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _3253 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3253 + idx + 68] = mem[_3114 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3253 + 68] = mem[_3253 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _3253 + -mem[64] + 100
                    require block.number - poolInfo[idx].field_512
                    if block.number - poolInfo[idx].field_512 / block.number - poolInfo[idx].field_512 != 1:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if not block.number - poolInfo[idx].field_512:
                        _2316 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2316] = 26
                        mem[_2316 + 32] = 'SafeMath: division by zero'
                        if totalAllocPoint <= 0:
                            _2357 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2357 + idx + 68] = mem[_2316 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2357 + 68] = mem[_2357 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _2357 + -mem[64] + 100
                        require totalAllocPoint
                        _2483 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2483] = 26
                        mem[_2483 + 32] = 'SafeMath: division by zero'
                        if devFundDivRate <= 0:
                            _2552 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2552 + idx + 68] = mem[_2483 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2552 + 68] = mem[_2552 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _2552 + -mem[64] + 100
                        require devFundDivRate
                        require ext_code.size(sub_64d46cecAddress)
                        call sub_64d46cecAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args devaddr, 0 / totalAllocPoint / devFundDivRate
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sub_64d46cecAddress)
                        call sub_64d46cecAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args address(this.address), 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not 0 / totalAllocPoint:
                            _3113 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3113] = 26
                            mem[_3113 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0] > 0:
                                require ext_call.return_data[0]
                                if poolInfo[idx].field_768 + (0 / ext_call.return_data[0]) < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _3250 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3250 + idx + 68] = mem[_3113 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3250 + 68] = mem[_3250 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _3250 + -mem[64] + 100
                        require 0 / totalAllocPoint
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _3249 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3249] = 26
                        mem[_3249 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0] > 0:
                            require ext_call.return_data[0]
                            if poolInfo[idx].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _3405 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3405 + idx + 68] = mem[_3249 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3405 + 68] = mem[_3405 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _3405 + -mem[64] + 100
                    require block.number - poolInfo[idx].field_512
                    if (block.number * sub_a3eef5b2) - (poolInfo[idx].field_512 * sub_a3eef5b2) / block.number - poolInfo[idx].field_512 != sub_a3eef5b2:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if not (block.number * sub_a3eef5b2) - (poolInfo[idx].field_512 * sub_a3eef5b2):
                        _2356 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2356] = 26
                        mem[_2356 + 32] = 'SafeMath: division by zero'
                        if totalAllocPoint <= 0:
                            _2415 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2415 + idx + 68] = mem[_2356 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2415 + 68] = mem[_2415 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _2415 + -mem[64] + 100
                        require totalAllocPoint
                        _2550 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2550] = 26
                        mem[_2550 + 32] = 'SafeMath: division by zero'
                        if devFundDivRate <= 0:
                            _2634 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2634 + idx + 68] = mem[_2550 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2634 + 68] = mem[_2634 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _2634 + -mem[64] + 100
                        require devFundDivRate
                        require ext_code.size(sub_64d46cecAddress)
                        call sub_64d46cecAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args devaddr, 0 / totalAllocPoint / devFundDivRate
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sub_64d46cecAddress)
                        call sub_64d46cecAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args address(this.address), 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not 0 / totalAllocPoint:
                            _3248 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3248] = 26
                            mem[_3248 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0] > 0:
                                require ext_call.return_data[0]
                                if poolInfo[idx].field_768 + (0 / ext_call.return_data[0]) < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _3402 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3402 + idx + 68] = mem[_3248 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3402 + 68] = mem[_3402 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _3402 + -mem[64] + 100
                        require 0 / totalAllocPoint
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _3401 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3401] = 26
                        mem[_3401 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0] > 0:
                            require ext_call.return_data[0]
                            if poolInfo[idx].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _3537 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3537 + idx + 68] = mem[_3401 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3537 + 68] = mem[_3537 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _3537 + -mem[64] + 100
                    require (block.number * sub_a3eef5b2) - (poolInfo[idx].field_512 * sub_a3eef5b2)
                    if (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) / (block.number * sub_a3eef5b2) - (poolInfo[idx].field_512 * sub_a3eef5b2) != poolInfo[idx].field_256:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _2414 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2414] = 26
                    mem[_2414 + 32] = 'SafeMath: division by zero'
                    if totalAllocPoint <= 0:
                        _2479 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2479 + idx + 68] = mem[_2414 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2479 + 68] = mem[_2479 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _2479 + -mem[64] + 100
                    require totalAllocPoint
                    _2632 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2632] = 26
                    mem[_2632 + 32] = 'SafeMath: division by zero'
                    if devFundDivRate <= 0:
                        _2729 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2729 + idx + 68] = mem[_2632 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2729 + 68] = mem[_2729 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _2729 + -mem[64] + 100
                    require devFundDivRate
                    require ext_code.size(sub_64d46cecAddress)
                    call sub_64d46cecAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args devaddr, (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint
                    require ext_code.size(sub_64d46cecAddress)
                    call sub_64d46cecAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args address(this.address), (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint:
                        _3400 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3400] = 26
                        mem[_3400 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0] > 0:
                            require ext_call.return_data[0]
                            if poolInfo[idx].field_768 + (0 / ext_call.return_data[0]) < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _3534 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3534 + idx + 68] = mem[_3400 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3534 + 68] = mem[_3534 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _3534 + -mem[64] + 100
                    require (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint
                    if 10^12 * (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint / (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _3533 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3533] = 26
                    mem[_3533 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0] > 0:
                        require ext_call.return_data[0]
                        if poolInfo[idx].field_768 + (10^12 * (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^12 * (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _3632 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3632 + idx + 68] = mem[_3533 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3632 + 68] = mem[_3632 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _3632 + -mem[64] + 100
                if poolInfo[idx].field_512 >= bonusEndBlock:
                    _2113 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2113] = 30
                    mem[_2113 + 32] = 'SafeMath: subtraction overflow'
                    if poolInfo[idx].field_512 > block.number:
                        _2127 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_2127 + idx + 68] = mem[_2113 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2127 + 68] = mem[_2127 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _2127 + -mem[64] + 100
                    if not block.number - poolInfo[idx].field_512:
                        _2259 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2259] = 26
                        mem[_2259 + 32] = 'SafeMath: division by zero'
                        if totalAllocPoint <= 0:
                            _2279 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2279 + idx + 68] = mem[_2259 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2279 + 68] = mem[_2279 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _2279 + -mem[64] + 100
                        require totalAllocPoint
                        _2335 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2335] = 26
                        mem[_2335 + 32] = 'SafeMath: division by zero'
                        if devFundDivRate <= 0:
                            _2385 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2385 + idx + 68] = mem[_2335 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2385 + 68] = mem[_2385 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _2385 + -mem[64] + 100
                        require devFundDivRate
                        require ext_code.size(sub_64d46cecAddress)
                        call sub_64d46cecAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args devaddr, 0 / totalAllocPoint / devFundDivRate
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sub_64d46cecAddress)
                        call sub_64d46cecAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args address(this.address), 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not 0 / totalAllocPoint:
                            _2868 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2868] = 26
                            mem[_2868 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0] > 0:
                                require ext_call.return_data[0]
                                if poolInfo[idx].field_768 + (0 / ext_call.return_data[0]) < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _2963 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2963 + idx + 68] = mem[_2868 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2963 + 68] = mem[_2963 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _2963 + -mem[64] + 100
                        require 0 / totalAllocPoint
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _2962 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2962] = 26
                        mem[_2962 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0] > 0:
                            require ext_call.return_data[0]
                            if poolInfo[idx].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _3062 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3062 + idx + 68] = mem[_2962 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3062 + 68] = mem[_3062 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _3062 + -mem[64] + 100
                    require block.number - poolInfo[idx].field_512
                    if (block.number * sub_a3eef5b2) - (poolInfo[idx].field_512 * sub_a3eef5b2) / block.number - poolInfo[idx].field_512 != sub_a3eef5b2:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if not (block.number * sub_a3eef5b2) - (poolInfo[idx].field_512 * sub_a3eef5b2):
                        _2278 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2278] = 26
                        mem[_2278 + 32] = 'SafeMath: division by zero'
                        if totalAllocPoint <= 0:
                            _2303 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2303 + idx + 68] = mem[_2278 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2303 + 68] = mem[_2303 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _2303 + -mem[64] + 100
                        require totalAllocPoint
                        _2383 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2383] = 26
                        mem[_2383 + 32] = 'SafeMath: division by zero'
                        if devFundDivRate <= 0:
                            _2442 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2442 + idx + 68] = mem[_2383 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2442 + 68] = mem[_2442 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _2442 + -mem[64] + 100
                        require devFundDivRate
                        require ext_code.size(sub_64d46cecAddress)
                        call sub_64d46cecAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args devaddr, 0 / totalAllocPoint / devFundDivRate
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sub_64d46cecAddress)
                        call sub_64d46cecAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args address(this.address), 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not 0 / totalAllocPoint:
                            _2961 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2961] = 26
                            mem[_2961 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0] > 0:
                                require ext_call.return_data[0]
                                if poolInfo[idx].field_768 + (0 / ext_call.return_data[0]) < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _3059 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3059 + idx + 68] = mem[_2961 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3059 + 68] = mem[_3059 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _3059 + -mem[64] + 100
                        require 0 / totalAllocPoint
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _3058 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3058] = 26
                        mem[_3058 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0] > 0:
                            require ext_call.return_data[0]
                            if poolInfo[idx].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _3178 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3178 + idx + 68] = mem[_3058 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3178 + 68] = mem[_3178 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _3178 + -mem[64] + 100
                    require (block.number * sub_a3eef5b2) - (poolInfo[idx].field_512 * sub_a3eef5b2)
                    if (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) / (block.number * sub_a3eef5b2) - (poolInfo[idx].field_512 * sub_a3eef5b2) != poolInfo[idx].field_256:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _2302 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2302] = 26
                    mem[_2302 + 32] = 'SafeMath: division by zero'
                    if totalAllocPoint <= 0:
                        _2331 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2331 + idx + 68] = mem[_2302 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2331 + 68] = mem[_2331 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _2331 + -mem[64] + 100
                    require totalAllocPoint
                    _2440 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2440] = 26
                    mem[_2440 + 32] = 'SafeMath: division by zero'
                    if devFundDivRate <= 0:
                        _2507 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2507 + idx + 68] = mem[_2440 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2507 + 68] = mem[_2507 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _2507 + -mem[64] + 100
                    require devFundDivRate
                    require ext_code.size(sub_64d46cecAddress)
                    call sub_64d46cecAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args devaddr, (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint
                    require ext_code.size(sub_64d46cecAddress)
                    call sub_64d46cecAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args address(this.address), (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint:
                        _3057 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3057] = 26
                        mem[_3057 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0] > 0:
                            require ext_call.return_data[0]
                            if poolInfo[idx].field_768 + (0 / ext_call.return_data[0]) < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _3175 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3175 + idx + 68] = mem[_3057 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3175 + 68] = mem[_3175 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _3175 + -mem[64] + 100
                    require (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint
                    if 10^12 * (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint / (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _3174 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3174] = 26
                    mem[_3174 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0] > 0:
                        require ext_call.return_data[0]
                        if poolInfo[idx].field_768 + (10^12 * (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^12 * (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _3314 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3314 + idx + 68] = mem[_3174 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3314 + 68] = mem[_3314 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _3314 + -mem[64] + 100
                _2112 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2112] = 30
                mem[_2112 + 32] = 'SafeMath: subtraction overflow'
                if bonusEndBlock > block.number:
                    _2124 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_2124 + idx + 68] = mem[_2112 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2124 + 68] = mem[_2124 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _2124 + -mem[64] + 100
                _2166 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2166] = 30
                mem[_2166 + 32] = 'SafeMath: subtraction overflow'
                if poolInfo[idx].field_512 > bonusEndBlock:
                    _2199 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_2199 + idx + 68] = mem[_2166 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2199 + 68] = mem[_2199 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _2199 + -mem[64] + 100
                if not bonusEndBlock - poolInfo[idx].field_512:
                    if block.number - bonusEndBlock < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    if not block.number - bonusEndBlock:
                        _2506 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2506] = 26
                        mem[_2506 + 32] = 'SafeMath: division by zero'
                        if totalAllocPoint <= 0:
                            _2581 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2581 + idx + 68] = mem[_2506 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2581 + 68] = mem[_2581 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _2581 + -mem[64] + 100
                        require totalAllocPoint
                        _2776 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2776] = 26
                        mem[_2776 + 32] = 'SafeMath: division by zero'
                        if devFundDivRate <= 0:
                            _2865 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2865 + idx + 68] = mem[_2776 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2865 + 68] = mem[_2865 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _2865 + -mem[64] + 100
                        require devFundDivRate
                        require ext_code.size(sub_64d46cecAddress)
                        call sub_64d46cecAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args devaddr, 0 / totalAllocPoint / devFundDivRate
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sub_64d46cecAddress)
                        call sub_64d46cecAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args address(this.address), 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not 0 / totalAllocPoint:
                            _3570 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3570] = 26
                            mem[_3570 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0] > 0:
                                require ext_call.return_data[0]
                                if poolInfo[idx].field_768 + (0 / ext_call.return_data[0]) < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _3665 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3665 + idx + 68] = mem[_3570 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3665 + 68] = mem[_3665 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _3665 + -mem[64] + 100
                        require 0 / totalAllocPoint
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _3664 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3664] = 26
                        mem[_3664 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0] > 0:
                            require ext_call.return_data[0]
                            if poolInfo[idx].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _3754 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3754 + idx + 68] = mem[_3664 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3754 + 68] = mem[_3754 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _3754 + -mem[64] + 100
                    require block.number - bonusEndBlock
                    if (block.number * sub_a3eef5b2) - (bonusEndBlock * sub_a3eef5b2) / block.number - bonusEndBlock != sub_a3eef5b2:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if not (block.number * sub_a3eef5b2) - (bonusEndBlock * sub_a3eef5b2):
                        _2580 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2580] = 26
                        mem[_2580 + 32] = 'SafeMath: division by zero'
                        if totalAllocPoint <= 0:
                            _2675 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2675 + idx + 68] = mem[_2580 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2675 + 68] = mem[_2675 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _2675 + -mem[64] + 100
                        require totalAllocPoint
                        _2863 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2863] = 26
                        mem[_2863 + 32] = 'SafeMath: division by zero'
                        if devFundDivRate <= 0:
                            _2957 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2957 + idx + 68] = mem[_2863 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2957 + 68] = mem[_2957 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _2957 + -mem[64] + 100
                        require devFundDivRate
                        require ext_code.size(sub_64d46cecAddress)
                        call sub_64d46cecAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args devaddr, 0 / totalAllocPoint / devFundDivRate
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sub_64d46cecAddress)
                        call sub_64d46cecAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args address(this.address), 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not 0 / totalAllocPoint:
                            _3663 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3663] = 26
                            mem[_3663 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0] > 0:
                                require ext_call.return_data[0]
                                if poolInfo[idx].field_768 + (0 / ext_call.return_data[0]) < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _3751 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3751 + idx + 68] = mem[_3663 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3751 + 68] = mem[_3751 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _3751 + -mem[64] + 100
                        require 0 / totalAllocPoint
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _3750 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3750] = 26
                        mem[_3750 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0] > 0:
                            require ext_call.return_data[0]
                            if poolInfo[idx].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _3844 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3844 + idx + 68] = mem[_3750 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3844 + 68] = mem[_3844 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _3844 + -mem[64] + 100
                    require (block.number * sub_a3eef5b2) - (bonusEndBlock * sub_a3eef5b2)
                    if (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / (block.number * sub_a3eef5b2) - (bonusEndBlock * sub_a3eef5b2) != poolInfo[idx].field_256:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _2674 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2674] = 26
                    mem[_2674 + 32] = 'SafeMath: division by zero'
                    if totalAllocPoint <= 0:
                        _2772 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2772 + idx + 68] = mem[_2674 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2772 + 68] = mem[_2772 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _2772 + -mem[64] + 100
                    require totalAllocPoint
                    _2955 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2955] = 26
                    mem[_2955 + 32] = 'SafeMath: division by zero'
                    if devFundDivRate <= 0:
                        _3052 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3052 + idx + 68] = mem[_2955 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3052 + 68] = mem[_3052 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _3052 + -mem[64] + 100
                    require devFundDivRate
                    require ext_code.size(sub_64d46cecAddress)
                    call sub_64d46cecAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args devaddr, (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint
                    require ext_code.size(sub_64d46cecAddress)
                    call sub_64d46cecAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args address(this.address), (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint:
                        _3749 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3749] = 26
                        mem[_3749 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0] > 0:
                            require ext_call.return_data[0]
                            if poolInfo[idx].field_768 + (0 / ext_call.return_data[0]) < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _3841 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3841 + idx + 68] = mem[_3749 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3841 + 68] = mem[_3841 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _3841 + -mem[64] + 100
                    require (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint
                    if 10^12 * (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint / (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _3840 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3840] = 26
                    mem[_3840 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0] > 0:
                        require ext_call.return_data[0]
                        if poolInfo[idx].field_768 + (10^12 * (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^12 * (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _3937 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3937 + idx + 68] = mem[_3840 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3937 + 68] = mem[_3937 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _3937 + -mem[64] + 100
                require bonusEndBlock - poolInfo[idx].field_512
                if bonusEndBlock - poolInfo[idx].field_512 / bonusEndBlock - poolInfo[idx].field_512 != 1:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if block.number < bonusEndBlock:
                    revert with 0, 'SafeMath: addition overflow'
                if not -poolInfo[idx].field_512 + block.number:
                    _2579 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2579] = 26
                    mem[_2579 + 32] = 'SafeMath: division by zero'
                    if totalAllocPoint <= 0:
                        _2671 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2671 + idx + 68] = mem[_2579 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2671 + 68] = mem[_2671 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _2671 + -mem[64] + 100
                    require totalAllocPoint
                    _2860 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2860] = 26
                    mem[_2860 + 32] = 'SafeMath: division by zero'
                    if devFundDivRate <= 0:
                        _2952 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2952 + idx + 68] = mem[_2860 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2952 + 68] = mem[_2952 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _2952 + -mem[64] + 100
                    require devFundDivRate
                    require ext_code.size(sub_64d46cecAddress)
                    call sub_64d46cecAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args devaddr, 0 / totalAllocPoint / devFundDivRate
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sub_64d46cecAddress)
                    call sub_64d46cecAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args address(this.address), 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not 0 / totalAllocPoint:
                        _3662 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3662] = 26
                        mem[_3662 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0] > 0:
                            require ext_call.return_data[0]
                            if poolInfo[idx].field_768 + (0 / ext_call.return_data[0]) < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _3746 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3746 + idx + 68] = mem[_3662 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3746 + 68] = mem[_3746 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _3746 + -mem[64] + 100
                    require 0 / totalAllocPoint
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _3745 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3745] = 26
                    mem[_3745 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0] > 0:
                        require ext_call.return_data[0]
                        if poolInfo[idx].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _3836 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3836 + idx + 68] = mem[_3745 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3836 + 68] = mem[_3836 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _3836 + -mem[64] + 100
                require -poolInfo[idx].field_512 + block.number
                if (-1 * poolInfo[idx].field_512 * sub_a3eef5b2) + (block.number * sub_a3eef5b2) / -poolInfo[idx].field_512 + block.number != sub_a3eef5b2:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if not (-1 * poolInfo[idx].field_512 * sub_a3eef5b2) + (block.number * sub_a3eef5b2):
                    _2670 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2670] = 26
                    mem[_2670 + 32] = 'SafeMath: division by zero'
                    if totalAllocPoint <= 0:
                        _2768 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2768 + idx + 68] = mem[_2670 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2768 + 68] = mem[_2768 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _2768 + -mem[64] + 100
                    require totalAllocPoint
                    _2950 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2950] = 26
                    mem[_2950 + 32] = 'SafeMath: division by zero'
                    if devFundDivRate <= 0:
                        _3048 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3048 + idx + 68] = mem[_2950 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3048 + 68] = mem[_3048 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _3048 + -mem[64] + 100
                    require devFundDivRate
                    require ext_code.size(sub_64d46cecAddress)
                    call sub_64d46cecAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args devaddr, 0 / totalAllocPoint / devFundDivRate
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sub_64d46cecAddress)
                    call sub_64d46cecAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args address(this.address), 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not 0 / totalAllocPoint:
                        _3744 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3744] = 26
                        mem[_3744 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0] > 0:
                            require ext_call.return_data[0]
                            if poolInfo[idx].field_768 + (0 / ext_call.return_data[0]) < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _3833 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3833 + idx + 68] = mem[_3744 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3833 + 68] = mem[_3833 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _3833 + -mem[64] + 100
                    require 0 / totalAllocPoint
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _3832 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3832] = 26
                    mem[_3832 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0] > 0:
                        require ext_call.return_data[0]
                        if poolInfo[idx].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _3931 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3931 + idx + 68] = mem[_3832 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3931 + 68] = mem[_3931 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _3931 + -mem[64] + 100
                require (-1 * poolInfo[idx].field_512 * sub_a3eef5b2) + (block.number * sub_a3eef5b2)
                if (-1 * poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) + (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) / (-1 * poolInfo[idx].field_512 * sub_a3eef5b2) + (block.number * sub_a3eef5b2) != poolInfo[idx].field_256:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _2767 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2767] = 26
                mem[_2767 + 32] = 'SafeMath: division by zero'
                if totalAllocPoint <= 0:
                    _2856 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2856 + idx + 68] = mem[_2767 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2856 + 68] = mem[_2856 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _2856 + -mem[64] + 100
                require totalAllocPoint
                _3046 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3046] = 26
                mem[_3046 + 32] = 'SafeMath: division by zero'
                if devFundDivRate <= 0:
                    _3167 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3167 + idx + 68] = mem[_3046 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3167 + 68] = mem[_3167 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _3167 + -mem[64] + 100
                require devFundDivRate
                require ext_code.size(sub_64d46cecAddress)
                call sub_64d46cecAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args devaddr, (-1 * poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) + (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = (-1 * poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) + (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint
                require ext_code.size(sub_64d46cecAddress)
                call sub_64d46cecAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args address(this.address), (-1 * poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) + (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if not (-1 * poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) + (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint:
                    _3831 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3831] = 26
                    mem[_3831 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0] > 0:
                        require ext_call.return_data[0]
                        if poolInfo[idx].field_768 + (0 / ext_call.return_data[0]) < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _3928 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3928 + idx + 68] = mem[_3831 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3928 + 68] = mem[_3928 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _3928 + -mem[64] + 100
                require (-1 * poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) + (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint
                if 10^12 * (-1 * poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) + (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint / (-1 * poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) + (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _3927 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3927] = 26
                mem[_3927 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0] > 0:
                    require ext_call.return_data[0]
                    if poolInfo[idx].field_768 + (10^12 * (-1 * poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) + (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^12 * (-1 * poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) + (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _4030 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_4030 + idx + 68] = mem[_3927 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_4030 + 68] = mem[_4030 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _4030 + -mem[64] + 100
            if endBlock <= bonusEndBlock:
                _2114 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2114] = 30
                mem[_2114 + 32] = 'SafeMath: subtraction overflow'
                if poolInfo[idx].field_512 > endBlock:
                    _2130 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_2130 + idx + 68] = mem[_2114 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2130 + 68] = mem[_2130 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _2130 + -mem[64] + 100
                if not endBlock - poolInfo[idx].field_512:
                    _2307 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2307] = 26
                    mem[_2307 + 32] = 'SafeMath: division by zero'
                    if totalAllocPoint <= 0:
                        _2342 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2342 + idx + 68] = mem[_2307 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2342 + 68] = mem[_2342 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _2342 + -mem[64] + 100
                    require totalAllocPoint
                    _2457 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2457] = 26
                    mem[_2457 + 32] = 'SafeMath: division by zero'
                    if devFundDivRate <= 0:
                        _2524 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2524 + idx + 68] = mem[_2457 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2524 + 68] = mem[_2524 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _2524 + -mem[64] + 100
                    require devFundDivRate
                    require ext_code.size(sub_64d46cecAddress)
                    call sub_64d46cecAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args devaddr, 0 / totalAllocPoint / devFundDivRate
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sub_64d46cecAddress)
                    call sub_64d46cecAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args address(this.address), 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not 0 / totalAllocPoint:
                        _3076 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3076] = 26
                        mem[_3076 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0] > 0:
                            require ext_call.return_data[0]
                            if poolInfo[idx].field_768 + (0 / ext_call.return_data[0]) < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _3200 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3200 + idx + 68] = mem[_3076 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3200 + 68] = mem[_3200 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _3200 + -mem[64] + 100
                    require 0 / totalAllocPoint
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _3199 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3199] = 26
                    mem[_3199 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0] > 0:
                        require ext_call.return_data[0]
                        if poolInfo[idx].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _3348 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3348 + idx + 68] = mem[_3199 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3348 + 68] = mem[_3348 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _3348 + -mem[64] + 100
                require endBlock - poolInfo[idx].field_512
                if endBlock - poolInfo[idx].field_512 / endBlock - poolInfo[idx].field_512 != 1:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if not endBlock - poolInfo[idx].field_512:
                    _2341 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2341] = 26
                    mem[_2341 + 32] = 'SafeMath: division by zero'
                    if totalAllocPoint <= 0:
                        _2395 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2395 + idx + 68] = mem[_2341 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2395 + 68] = mem[_2395 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _2395 + -mem[64] + 100
                    require totalAllocPoint
                    _2522 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2522] = 26
                    mem[_2522 + 32] = 'SafeMath: division by zero'
                    if devFundDivRate <= 0:
                        _2603 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2603 + idx + 68] = mem[_2522 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2603 + 68] = mem[_2603 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _2603 + -mem[64] + 100
                    require devFundDivRate
                    require ext_code.size(sub_64d46cecAddress)
                    call sub_64d46cecAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args devaddr, 0 / totalAllocPoint / devFundDivRate
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sub_64d46cecAddress)
                    call sub_64d46cecAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args address(this.address), 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not 0 / totalAllocPoint:
                        _3198 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3198] = 26
                        mem[_3198 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0] > 0:
                            require ext_call.return_data[0]
                            if poolInfo[idx].field_768 + (0 / ext_call.return_data[0]) < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _3345 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3345 + idx + 68] = mem[_3198 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3345 + 68] = mem[_3345 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _3345 + -mem[64] + 100
                    require 0 / totalAllocPoint
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _3344 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3344] = 26
                    mem[_3344 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0] > 0:
                        require ext_call.return_data[0]
                        if poolInfo[idx].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _3486 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3486 + idx + 68] = mem[_3344 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3486 + 68] = mem[_3486 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _3486 + -mem[64] + 100
                require endBlock - poolInfo[idx].field_512
                if (endBlock * sub_a3eef5b2) - (poolInfo[idx].field_512 * sub_a3eef5b2) / endBlock - poolInfo[idx].field_512 != sub_a3eef5b2:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if not (endBlock * sub_a3eef5b2) - (poolInfo[idx].field_512 * sub_a3eef5b2):
                    _2394 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2394] = 26
                    mem[_2394 + 32] = 'SafeMath: division by zero'
                    if totalAllocPoint <= 0:
                        _2453 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2453 + idx + 68] = mem[_2394 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2453 + 68] = mem[_2453 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _2453 + -mem[64] + 100
                    require totalAllocPoint
                    _2601 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2601] = 26
                    mem[_2601 + 32] = 'SafeMath: division by zero'
                    if devFundDivRate <= 0:
                        _2696 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2696 + idx + 68] = mem[_2601 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2696 + 68] = mem[_2696 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _2696 + -mem[64] + 100
                    require devFundDivRate
                    require ext_code.size(sub_64d46cecAddress)
                    call sub_64d46cecAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args devaddr, 0 / totalAllocPoint / devFundDivRate
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sub_64d46cecAddress)
                    call sub_64d46cecAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args address(this.address), 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not 0 / totalAllocPoint:
                        _3343 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3343] = 26
                        mem[_3343 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0] > 0:
                            require ext_call.return_data[0]
                            if poolInfo[idx].field_768 + (0 / ext_call.return_data[0]) < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _3483 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3483 + idx + 68] = mem[_3343 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3483 + 68] = mem[_3483 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _3483 + -mem[64] + 100
                    require 0 / totalAllocPoint
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _3482 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3482] = 26
                    mem[_3482 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0] > 0:
                        require ext_call.return_data[0]
                        if poolInfo[idx].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _3594 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3594 + idx + 68] = mem[_3482 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3594 + 68] = mem[_3594 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _3594 + -mem[64] + 100
                require (endBlock * sub_a3eef5b2) - (poolInfo[idx].field_512 * sub_a3eef5b2)
                if (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) / (endBlock * sub_a3eef5b2) - (poolInfo[idx].field_512 * sub_a3eef5b2) != poolInfo[idx].field_256:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _2452 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2452] = 26
                mem[_2452 + 32] = 'SafeMath: division by zero'
                if totalAllocPoint <= 0:
                    _2518 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2518 + idx + 68] = mem[_2452 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2518 + 68] = mem[_2518 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _2518 + -mem[64] + 100
                require totalAllocPoint
                _2694 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2694] = 26
                mem[_2694 + 32] = 'SafeMath: division by zero'
                if devFundDivRate <= 0:
                    _2788 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2788 + idx + 68] = mem[_2694 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2788 + 68] = mem[_2788 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _2788 + -mem[64] + 100
                require devFundDivRate
                require ext_code.size(sub_64d46cecAddress)
                call sub_64d46cecAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args devaddr, (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint
                require ext_code.size(sub_64d46cecAddress)
                call sub_64d46cecAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args address(this.address), (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if not (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint:
                    _3481 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3481] = 26
                    mem[_3481 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0] > 0:
                        require ext_call.return_data[0]
                        if poolInfo[idx].field_768 + (0 / ext_call.return_data[0]) < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _3591 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3591 + idx + 68] = mem[_3481 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3591 + 68] = mem[_3591 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _3591 + -mem[64] + 100
                require (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint
                if 10^12 * (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint / (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _3590 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3590] = 26
                mem[_3590 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0] > 0:
                    require ext_call.return_data[0]
                    if poolInfo[idx].field_768 + (10^12 * (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^12 * (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _3682 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_3682 + idx + 68] = mem[_3590 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_3682 + 68] = mem[_3682 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _3682 + -mem[64] + 100
            if poolInfo[idx].field_512 >= bonusEndBlock:
                _2120 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2120] = 30
                mem[_2120 + 32] = 'SafeMath: subtraction overflow'
                if poolInfo[idx].field_512 > endBlock:
                    _2142 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_2142 + idx + 68] = mem[_2120 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2142 + 68] = mem[_2142 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _2142 + -mem[64] + 100
                if not endBlock - poolInfo[idx].field_512:
                    _2268 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2268] = 26
                    mem[_2268 + 32] = 'SafeMath: division by zero'
                    if totalAllocPoint <= 0:
                        _2293 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2293 + idx + 68] = mem[_2268 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2293 + 68] = mem[_2293 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _2293 + -mem[64] + 100
                    require totalAllocPoint
                    _2365 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2365] = 26
                    mem[_2365 + 32] = 'SafeMath: division by zero'
                    if devFundDivRate <= 0:
                        _2424 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2424 + idx + 68] = mem[_2365 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2424 + 68] = mem[_2424 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _2424 + -mem[64] + 100
                    require devFundDivRate
                    require ext_code.size(sub_64d46cecAddress)
                    call sub_64d46cecAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args devaddr, 0 / totalAllocPoint / devFundDivRate
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sub_64d46cecAddress)
                    call sub_64d46cecAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args address(this.address), 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not 0 / totalAllocPoint:
                        _2917 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2917] = 26
                        mem[_2917 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0] > 0:
                            require ext_call.return_data[0]
                            if poolInfo[idx].field_768 + (0 / ext_call.return_data[0]) < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _3016 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3016 + idx + 68] = mem[_2917 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3016 + 68] = mem[_3016 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _3016 + -mem[64] + 100
                    require 0 / totalAllocPoint
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _3015 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3015] = 26
                    mem[_3015 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0] > 0:
                        require ext_call.return_data[0]
                        if poolInfo[idx].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _3134 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3134 + idx + 68] = mem[_3015 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3134 + 68] = mem[_3134 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _3134 + -mem[64] + 100
                require endBlock - poolInfo[idx].field_512
                if (endBlock * sub_a3eef5b2) - (poolInfo[idx].field_512 * sub_a3eef5b2) / endBlock - poolInfo[idx].field_512 != sub_a3eef5b2:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if not (endBlock * sub_a3eef5b2) - (poolInfo[idx].field_512 * sub_a3eef5b2):
                    _2292 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2292] = 26
                    mem[_2292 + 32] = 'SafeMath: division by zero'
                    if totalAllocPoint <= 0:
                        _2321 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2321 + idx + 68] = mem[_2292 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2321 + 68] = mem[_2321 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _2321 + -mem[64] + 100
                    require totalAllocPoint
                    _2422 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2422] = 26
                    mem[_2422 + 32] = 'SafeMath: division by zero'
                    if devFundDivRate <= 0:
                        _2490 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2490 + idx + 68] = mem[_2422 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2490 + 68] = mem[_2490 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _2490 + -mem[64] + 100
                    require devFundDivRate
                    require ext_code.size(sub_64d46cecAddress)
                    call sub_64d46cecAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args devaddr, 0 / totalAllocPoint / devFundDivRate
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sub_64d46cecAddress)
                    call sub_64d46cecAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args address(this.address), 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not 0 / totalAllocPoint:
                        _3014 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3014] = 26
                        mem[_3014 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0] > 0:
                            require ext_call.return_data[0]
                            if poolInfo[idx].field_768 + (0 / ext_call.return_data[0]) < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _3131 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3131 + idx + 68] = mem[_3014 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3131 + 68] = mem[_3131 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _3131 + -mem[64] + 100
                    require 0 / totalAllocPoint
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _3130 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3130] = 26
                    mem[_3130 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0] > 0:
                        require ext_call.return_data[0]
                        if poolInfo[idx].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _3268 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3268 + idx + 68] = mem[_3130 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3268 + 68] = mem[_3268 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _3268 + -mem[64] + 100
                require (endBlock * sub_a3eef5b2) - (poolInfo[idx].field_512 * sub_a3eef5b2)
                if (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) / (endBlock * sub_a3eef5b2) - (poolInfo[idx].field_512 * sub_a3eef5b2) != poolInfo[idx].field_256:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _2320 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2320] = 26
                mem[_2320 + 32] = 'SafeMath: division by zero'
                if totalAllocPoint <= 0:
                    _2361 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2361 + idx + 68] = mem[_2320 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2361 + 68] = mem[_2361 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _2361 + -mem[64] + 100
                require totalAllocPoint
                _2488 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2488] = 26
                mem[_2488 + 32] = 'SafeMath: division by zero'
                if devFundDivRate <= 0:
                    _2557 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2557 + idx + 68] = mem[_2488 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2557 + 68] = mem[_2557 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _2557 + -mem[64] + 100
                require devFundDivRate
                require ext_code.size(sub_64d46cecAddress)
                call sub_64d46cecAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args devaddr, (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint
                require ext_code.size(sub_64d46cecAddress)
                call sub_64d46cecAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args address(this.address), (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if not (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint:
                    _3129 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3129] = 26
                    mem[_3129 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0] > 0:
                        require ext_call.return_data[0]
                        if poolInfo[idx].field_768 + (0 / ext_call.return_data[0]) < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _3265 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3265 + idx + 68] = mem[_3129 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3265 + 68] = mem[_3265 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _3265 + -mem[64] + 100
                require (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint
                if 10^12 * (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint / (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _3264 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3264] = 26
                mem[_3264 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0] > 0:
                    require ext_call.return_data[0]
                    if poolInfo[idx].field_768 + (10^12 * (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^12 * (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _3414 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_3414 + idx + 68] = mem[_3264 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_3414 + 68] = mem[_3414 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _3414 + -mem[64] + 100
            _2119 = mem[64]
            mem[64] = mem[64] + 64
            mem[_2119] = 30
            mem[_2119 + 32] = 'SafeMath: subtraction overflow'
            if bonusEndBlock > endBlock:
                _2139 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_2139 + idx + 68] = mem[_2119 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_2139 + 68] = mem[_2139 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _2139 + -mem[64] + 100
            _2183 = mem[64]
            mem[64] = mem[64] + 64
            mem[_2183] = 30
            mem[_2183 + 32] = 'SafeMath: subtraction overflow'
            if poolInfo[idx].field_512 > bonusEndBlock:
                _2214 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_2214 + idx + 68] = mem[_2183 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_2214 + 68] = mem[_2214 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _2214 + -mem[64] + 100
            if not bonusEndBlock - poolInfo[idx].field_512:
                if endBlock - bonusEndBlock < 0:
                    revert with 0, 'SafeMath: addition overflow'
                if not endBlock - bonusEndBlock:
                    _2556 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2556] = 26
                    mem[_2556 + 32] = 'SafeMath: division by zero'
                    if totalAllocPoint <= 0:
                        _2641 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2641 + idx + 68] = mem[_2556 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2641 + 68] = mem[_2641 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _2641 + -mem[64] + 100
                    require totalAllocPoint
                    _2829 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2829] = 26
                    mem[_2829 + 32] = 'SafeMath: division by zero'
                    if devFundDivRate <= 0:
                        _2914 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2914 + idx + 68] = mem[_2829 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2914 + 68] = mem[_2914 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _2914 + -mem[64] + 100
                    require devFundDivRate
                    require ext_code.size(sub_64d46cecAddress)
                    call sub_64d46cecAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args devaddr, 0 / totalAllocPoint / devFundDivRate
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sub_64d46cecAddress)
                    call sub_64d46cecAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args address(this.address), 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not 0 / totalAllocPoint:
                        _3639 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3639] = 26
                        mem[_3639 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0] > 0:
                            require ext_call.return_data[0]
                            if poolInfo[idx].field_768 + (0 / ext_call.return_data[0]) < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _3715 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3715 + idx + 68] = mem[_3639 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3715 + 68] = mem[_3715 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _3715 + -mem[64] + 100
                    require 0 / totalAllocPoint
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _3714 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3714] = 26
                    mem[_3714 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0] > 0:
                        require ext_call.return_data[0]
                        if poolInfo[idx].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _3799 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3799 + idx + 68] = mem[_3714 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3799 + 68] = mem[_3799 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _3799 + -mem[64] + 100
                require endBlock - bonusEndBlock
                if (endBlock * sub_a3eef5b2) - (bonusEndBlock * sub_a3eef5b2) / endBlock - bonusEndBlock != sub_a3eef5b2:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if not (endBlock * sub_a3eef5b2) - (bonusEndBlock * sub_a3eef5b2):
                    _2640 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2640] = 26
                    mem[_2640 + 32] = 'SafeMath: division by zero'
                    if totalAllocPoint <= 0:
                        _2739 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2739 + idx + 68] = mem[_2640 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2739 + 68] = mem[_2739 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _2739 + -mem[64] + 100
                    require totalAllocPoint
                    _2912 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2912] = 26
                    mem[_2912 + 32] = 'SafeMath: division by zero'
                    if devFundDivRate <= 0:
                        _3010 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3010 + idx + 68] = mem[_2912 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3010 + 68] = mem[_3010 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _3010 + -mem[64] + 100
                    require devFundDivRate
                    require ext_code.size(sub_64d46cecAddress)
                    call sub_64d46cecAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args devaddr, 0 / totalAllocPoint / devFundDivRate
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sub_64d46cecAddress)
                    call sub_64d46cecAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args address(this.address), 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not 0 / totalAllocPoint:
                        _3713 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3713] = 26
                        mem[_3713 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0] > 0:
                            require ext_call.return_data[0]
                            if poolInfo[idx].field_768 + (0 / ext_call.return_data[0]) < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _3796 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3796 + idx + 68] = mem[_3713 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3796 + 68] = mem[_3796 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _3796 + -mem[64] + 100
                    require 0 / totalAllocPoint
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _3795 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3795] = 26
                    mem[_3795 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0] > 0:
                        require ext_call.return_data[0]
                        if poolInfo[idx].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _3896 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3896 + idx + 68] = mem[_3795 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3896 + 68] = mem[_3896 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _3896 + -mem[64] + 100
                require (endBlock * sub_a3eef5b2) - (bonusEndBlock * sub_a3eef5b2)
                if (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / (endBlock * sub_a3eef5b2) - (bonusEndBlock * sub_a3eef5b2) != poolInfo[idx].field_256:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _2738 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2738] = 26
                mem[_2738 + 32] = 'SafeMath: division by zero'
                if totalAllocPoint <= 0:
                    _2825 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2825 + idx + 68] = mem[_2738 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2825 + 68] = mem[_2825 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _2825 + -mem[64] + 100
                require totalAllocPoint
                _3008 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3008] = 26
                mem[_3008 + 32] = 'SafeMath: division by zero'
                if devFundDivRate <= 0:
                    _3124 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3124 + idx + 68] = mem[_3008 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3124 + 68] = mem[_3124 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _3124 + -mem[64] + 100
                require devFundDivRate
                require ext_code.size(sub_64d46cecAddress)
                call sub_64d46cecAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args devaddr, (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint
                require ext_code.size(sub_64d46cecAddress)
                call sub_64d46cecAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args address(this.address), (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if not (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint:
                    _3794 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3794] = 26
                    mem[_3794 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0] > 0:
                        require ext_call.return_data[0]
                        if poolInfo[idx].field_768 + (0 / ext_call.return_data[0]) < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _3893 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3893 + idx + 68] = mem[_3794 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3893 + 68] = mem[_3893 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _3893 + -mem[64] + 100
                require (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint
                if 10^12 * (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint / (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _3892 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3892] = 26
                mem[_3892 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0] > 0:
                    require ext_call.return_data[0]
                    if poolInfo[idx].field_768 + (10^12 * (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^12 * (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _3998 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_3998 + idx + 68] = mem[_3892 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_3998 + 68] = mem[_3998 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _3998 + -mem[64] + 100
            require bonusEndBlock - poolInfo[idx].field_512
            if bonusEndBlock - poolInfo[idx].field_512 / bonusEndBlock - poolInfo[idx].field_512 != 1:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            if endBlock < bonusEndBlock:
                revert with 0, 'SafeMath: addition overflow'
            if not -poolInfo[idx].field_512 + endBlock:
                _2639 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2639] = 26
                mem[_2639 + 32] = 'SafeMath: division by zero'
                if totalAllocPoint <= 0:
                    _2735 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2735 + idx + 68] = mem[_2639 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2735 + 68] = mem[_2735 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _2735 + -mem[64] + 100
                require totalAllocPoint
                _2909 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2909] = 26
                mem[_2909 + 32] = 'SafeMath: division by zero'
                if devFundDivRate <= 0:
                    _3005 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3005 + idx + 68] = mem[_2909 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3005 + 68] = mem[_3005 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _3005 + -mem[64] + 100
                require devFundDivRate
                require ext_code.size(sub_64d46cecAddress)
                call sub_64d46cecAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args devaddr, 0 / totalAllocPoint / devFundDivRate
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = 0 / totalAllocPoint
                require ext_code.size(sub_64d46cecAddress)
                call sub_64d46cecAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args address(this.address), 0 / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if not 0 / totalAllocPoint:
                    _3712 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3712] = 26
                    mem[_3712 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0] > 0:
                        require ext_call.return_data[0]
                        if poolInfo[idx].field_768 + (0 / ext_call.return_data[0]) < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _3791 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3791 + idx + 68] = mem[_3712 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3791 + 68] = mem[_3791 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _3791 + -mem[64] + 100
                require 0 / totalAllocPoint
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _3790 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3790] = 26
                mem[_3790 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0] > 0:
                    require ext_call.return_data[0]
                    if poolInfo[idx].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _3888 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_3888 + idx + 68] = mem[_3790 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_3888 + 68] = mem[_3888 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _3888 + -mem[64] + 100
            require -poolInfo[idx].field_512 + endBlock
            if (-1 * poolInfo[idx].field_512 * sub_a3eef5b2) + (endBlock * sub_a3eef5b2) / -poolInfo[idx].field_512 + endBlock != sub_a3eef5b2:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            if not (-1 * poolInfo[idx].field_512 * sub_a3eef5b2) + (endBlock * sub_a3eef5b2):
                _2734 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2734] = 26
                mem[_2734 + 32] = 'SafeMath: division by zero'
                if totalAllocPoint <= 0:
                    _2821 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2821 + idx + 68] = mem[_2734 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2821 + 68] = mem[_2821 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _2821 + -mem[64] + 100
                require totalAllocPoint
                _3003 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3003] = 26
                mem[_3003 + 32] = 'SafeMath: division by zero'
                if devFundDivRate <= 0:
                    _3120 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3120 + idx + 68] = mem[_3003 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3120 + 68] = mem[_3120 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _3120 + -mem[64] + 100
                require devFundDivRate
                require ext_code.size(sub_64d46cecAddress)
                call sub_64d46cecAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args devaddr, 0 / totalAllocPoint / devFundDivRate
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = 0 / totalAllocPoint
                require ext_code.size(sub_64d46cecAddress)
                call sub_64d46cecAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args address(this.address), 0 / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if not 0 / totalAllocPoint:
                    _3789 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3789] = 26
                    mem[_3789 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0] > 0:
                        require ext_call.return_data[0]
                        if poolInfo[idx].field_768 + (0 / ext_call.return_data[0]) < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _3885 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3885 + idx + 68] = mem[_3789 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3885 + 68] = mem[_3885 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _3885 + -mem[64] + 100
                require 0 / totalAllocPoint
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _3884 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3884] = 26
                mem[_3884 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0] > 0:
                    require ext_call.return_data[0]
                    if poolInfo[idx].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _3992 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_3992 + idx + 68] = mem[_3884 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_3992 + 68] = mem[_3992 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _3992 + -mem[64] + 100
            require (-1 * poolInfo[idx].field_512 * sub_a3eef5b2) + (endBlock * sub_a3eef5b2)
            if (-1 * poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) + (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / (-1 * poolInfo[idx].field_512 * sub_a3eef5b2) + (endBlock * sub_a3eef5b2) != poolInfo[idx].field_256:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _2820 = mem[64]
            mem[64] = mem[64] + 64
            mem[_2820] = 26
            mem[_2820 + 32] = 'SafeMath: division by zero'
            if totalAllocPoint <= 0:
                _2905 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_2905 + idx + 68] = mem[_2820 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_2905 + 68] = mem[_2905 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _2905 + -mem[64] + 100
            require totalAllocPoint
            _3118 = mem[64]
            mem[64] = mem[64] + 64
            mem[_3118] = 26
            mem[_3118 + 32] = 'SafeMath: division by zero'
            if devFundDivRate <= 0:
                _3257 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_3257 + idx + 68] = mem[_3118 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_3257 + 68] = mem[_3257 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _3257 + -mem[64] + 100
            require devFundDivRate
            require ext_code.size(sub_64d46cecAddress)
            call sub_64d46cecAddress.0x40c10f19 with:
                 gas gas_remaining wei
                args devaddr, (-1 * poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) + (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = this.address
            mem[mem[64] + 36] = (-1 * poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) + (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint
            require ext_code.size(sub_64d46cecAddress)
            call sub_64d46cecAddress.0x40c10f19 with:
                 gas gas_remaining wei
                args address(this.address), (-1 * poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) + (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if not (-1 * poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) + (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint:
                _3883 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3883] = 26
                mem[_3883 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0] > 0:
                    require ext_call.return_data[0]
                    if poolInfo[idx].field_768 + (0 / ext_call.return_data[0]) < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _3989 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_3989 + idx + 68] = mem[_3883 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_3989 + 68] = mem[_3989 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _3989 + -mem[64] + 100
            require (-1 * poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) + (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint
            if 10^12 * (-1 * poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) + (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint / (-1 * poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) + (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _3988 = mem[64]
            mem[64] = mem[64] + 64
            mem[_3988] = 26
            mem[_3988 + 32] = 'SafeMath: division by zero'
            if ext_call.return_data[0] > 0:
                require ext_call.return_data[0]
                if poolInfo[idx].field_768 + (10^12 * (-1 * poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) + (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) < poolInfo[idx].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                poolInfo[idx].field_768 += 10^12 * (-1 * poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) + (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                poolInfo[idx].field_512 = block.number
                idx = idx + 1
                continue 
            _4091 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[_4091 + idx + 68] = mem[_3988 + idx + 32]
                idx = idx + 32
                continue 
            mem[_4091 + 68] = mem[_4091 + 74 len 26]
            revert with memory
              from mem[64]
               len _4091 + -mem[64] + 100
        if block.number > endBlock:
            if endBlock <= bonusEndBlock:
                _2123 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2123] = 30
                mem[_2123 + 32] = 'SafeMath: subtraction overflow'
                if endBlock > endBlock:
                    _2151 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_2151 + idx + 68] = mem[_2123 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2151 + 68] = mem[_2151 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _2151 + -mem[64] + 100
                _2330 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2330] = 26
                mem[_2330 + 32] = 'SafeMath: division by zero'
                if totalAllocPoint <= 0:
                    _2379 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2379 + idx + 68] = mem[_2330 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2379 + 68] = mem[_2379 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _2379 + -mem[64] + 100
                require totalAllocPoint
                _2504 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2504] = 26
                mem[_2504 + 32] = 'SafeMath: division by zero'
                if devFundDivRate <= 0:
                    _2576 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2576 + idx + 68] = mem[_2504 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2576 + 68] = mem[_2576 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _2576 + -mem[64] + 100
                require devFundDivRate
                require ext_code.size(sub_64d46cecAddress)
                call sub_64d46cecAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args devaddr, 0 / totalAllocPoint / devFundDivRate
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = 0 / totalAllocPoint
                require ext_code.size(sub_64d46cecAddress)
                call sub_64d46cecAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args address(this.address), 0 / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if not 0 / totalAllocPoint:
                    _3166 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3166] = 26
                    mem[_3166 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0] > 0:
                        require ext_call.return_data[0]
                        if poolInfo[idx].field_768 + (0 / ext_call.return_data[0]) < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _3308 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3308 + idx + 68] = mem[_3166 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3308 + 68] = mem[_3308 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _3308 + -mem[64] + 100
                require 0 / totalAllocPoint
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _3307 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3307] = 26
                mem[_3307 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0] > 0:
                    require ext_call.return_data[0]
                    if poolInfo[idx].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _3451 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_3451 + idx + 68] = mem[_3307 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_3451 + 68] = mem[_3451 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _3451 + -mem[64] + 100
            if endBlock >= bonusEndBlock:
                _2137 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2137] = 30
                mem[_2137 + 32] = 'SafeMath: subtraction overflow'
                if endBlock > endBlock:
                    _2163 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_2163 + idx + 68] = mem[_2137 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2163 + 68] = mem[_2163 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _2163 + -mem[64] + 100
                _2288 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2288] = 26
                mem[_2288 + 32] = 'SafeMath: division by zero'
                if totalAllocPoint <= 0:
                    _2311 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2311 + idx + 68] = mem[_2288 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2311 + 68] = mem[_2311 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _2311 + -mem[64] + 100
                require totalAllocPoint
                _2408 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2408] = 26
                mem[_2408 + 32] = 'SafeMath: division by zero'
                if devFundDivRate <= 0:
                    _2470 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2470 + idx + 68] = mem[_2408 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2470 + 68] = mem[_2470 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _2470 + -mem[64] + 100
                require devFundDivRate
                require ext_code.size(sub_64d46cecAddress)
                call sub_64d46cecAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args devaddr, 0 / totalAllocPoint / devFundDivRate
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = 0 / totalAllocPoint
                require ext_code.size(sub_64d46cecAddress)
                call sub_64d46cecAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args address(this.address), 0 / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if not 0 / totalAllocPoint:
                    _2992 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2992] = 26
                    mem[_2992 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0] > 0:
                        require ext_call.return_data[0]
                        if poolInfo[idx].field_768 + (0 / ext_call.return_data[0]) < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _3096 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3096 + idx + 68] = mem[_2992 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3096 + 68] = mem[_3096 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _3096 + -mem[64] + 100
                require 0 / totalAllocPoint
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _3095 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3095] = 26
                mem[_3095 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0] > 0:
                    require ext_call.return_data[0]
                    if poolInfo[idx].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _3226 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_3226 + idx + 68] = mem[_3095 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_3226 + 68] = mem[_3226 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _3226 + -mem[64] + 100
            _2136 = mem[64]
            mem[64] = mem[64] + 64
            mem[_2136] = 30
            mem[_2136 + 32] = 'SafeMath: subtraction overflow'
            if bonusEndBlock > endBlock:
                _2160 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_2160 + idx + 68] = mem[_2136 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_2160 + 68] = mem[_2160 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _2160 + -mem[64] + 100
            _2208 = mem[64]
            mem[64] = mem[64] + 64
            mem[_2208] = 30
            mem[_2208 + 32] = 'SafeMath: subtraction overflow'
            if endBlock > bonusEndBlock:
                _2227 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_2227 + idx + 68] = mem[_2208 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_2227 + 68] = mem[_2227 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _2227 + -mem[64] + 100
            if bonusEndBlock - endBlock:
                require bonusEndBlock - endBlock
                if bonusEndBlock - endBlock / bonusEndBlock - endBlock != 1:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if 0 < bonusEndBlock - endBlock:
                    revert with 0, 'SafeMath: addition overflow'
                _2716 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2716] = 26
                mem[_2716 + 32] = 'SafeMath: division by zero'
                if totalAllocPoint <= 0:
                    _2802 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2802 + idx + 68] = mem[_2716 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2802 + 68] = mem[_2802 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _2802 + -mem[64] + 100
                require totalAllocPoint
                _2984 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2984] = 26
                mem[_2984 + 32] = 'SafeMath: division by zero'
                if devFundDivRate <= 0:
                    _3086 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3086 + idx + 68] = mem[_2984 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3086 + 68] = mem[_3086 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _3086 + -mem[64] + 100
                require devFundDivRate
                require ext_code.size(sub_64d46cecAddress)
                call sub_64d46cecAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args devaddr, 0 / totalAllocPoint / devFundDivRate
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = 0 / totalAllocPoint
                require ext_code.size(sub_64d46cecAddress)
                call sub_64d46cecAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args address(this.address), 0 / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if not 0 / totalAllocPoint:
                    _3778 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3778] = 26
                    mem[_3778 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0] > 0:
                        require ext_call.return_data[0]
                        if poolInfo[idx].field_768 + (0 / ext_call.return_data[0]) < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _3863 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3863 + idx + 68] = mem[_3778 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3863 + 68] = mem[_3863 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _3863 + -mem[64] + 100
                require 0 / totalAllocPoint
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _3862 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3862] = 26
                mem[_3862 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0] > 0:
                    require ext_call.return_data[0]
                    if poolInfo[idx].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _3960 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_3960 + idx + 68] = mem[_3862 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_3960 + 68] = mem[_3960 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _3960 + -mem[64] + 100
            if endBlock - bonusEndBlock < 0:
                revert with 0, 'SafeMath: addition overflow'
            if not endBlock - bonusEndBlock:
                _2622 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2622] = 26
                mem[_2622 + 32] = 'SafeMath: division by zero'
                if totalAllocPoint <= 0:
                    _2718 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2718 + idx + 68] = mem[_2622 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2718 + 68] = mem[_2718 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _2718 + -mem[64] + 100
                require totalAllocPoint
                _2896 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2896] = 26
                mem[_2896 + 32] = 'SafeMath: division by zero'
                if devFundDivRate <= 0:
                    _2989 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2989 + idx + 68] = mem[_2896 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2989 + 68] = mem[_2989 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _2989 + -mem[64] + 100
                require devFundDivRate
                require ext_code.size(sub_64d46cecAddress)
                call sub_64d46cecAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args devaddr, 0 / totalAllocPoint / devFundDivRate
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = 0 / totalAllocPoint
                require ext_code.size(sub_64d46cecAddress)
                call sub_64d46cecAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args address(this.address), 0 / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if not 0 / totalAllocPoint:
                    _3702 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3702] = 26
                    mem[_3702 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0] > 0:
                        require ext_call.return_data[0]
                        if poolInfo[idx].field_768 + (0 / ext_call.return_data[0]) < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _3781 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3781 + idx + 68] = mem[_3702 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3781 + 68] = mem[_3781 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _3781 + -mem[64] + 100
                require 0 / totalAllocPoint
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _3780 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3780] = 26
                mem[_3780 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0] > 0:
                    require ext_call.return_data[0]
                    if poolInfo[idx].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _3871 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_3871 + idx + 68] = mem[_3780 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_3871 + 68] = mem[_3871 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _3871 + -mem[64] + 100
            require endBlock - bonusEndBlock
            if (endBlock * sub_a3eef5b2) - (bonusEndBlock * sub_a3eef5b2) / endBlock - bonusEndBlock != sub_a3eef5b2:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            if not (endBlock * sub_a3eef5b2) - (bonusEndBlock * sub_a3eef5b2):
                _2717 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2717] = 26
                mem[_2717 + 32] = 'SafeMath: division by zero'
                if totalAllocPoint <= 0:
                    _2806 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2806 + idx + 68] = mem[_2717 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2806 + 68] = mem[_2806 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _2806 + -mem[64] + 100
                require totalAllocPoint
                _2987 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2987] = 26
                mem[_2987 + 32] = 'SafeMath: division by zero'
                if devFundDivRate <= 0:
                    _3091 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3091 + idx + 68] = mem[_2987 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3091 + 68] = mem[_3091 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _3091 + -mem[64] + 100
                require devFundDivRate
                require ext_code.size(sub_64d46cecAddress)
                call sub_64d46cecAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args devaddr, 0 / totalAllocPoint / devFundDivRate
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = 0 / totalAllocPoint
                require ext_code.size(sub_64d46cecAddress)
                call sub_64d46cecAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args address(this.address), 0 / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if not 0 / totalAllocPoint:
                    _3779 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3779] = 26
                    mem[_3779 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0] > 0:
                        require ext_call.return_data[0]
                        if poolInfo[idx].field_768 + (0 / ext_call.return_data[0]) < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _3868 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3868 + idx + 68] = mem[_3779 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3868 + 68] = mem[_3868 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _3868 + -mem[64] + 100
                require 0 / totalAllocPoint
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _3867 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3867] = 26
                mem[_3867 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0] > 0:
                    require ext_call.return_data[0]
                    if poolInfo[idx].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _3968 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_3968 + idx + 68] = mem[_3867 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_3968 + 68] = mem[_3968 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _3968 + -mem[64] + 100
            require (endBlock * sub_a3eef5b2) - (bonusEndBlock * sub_a3eef5b2)
            if (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / (endBlock * sub_a3eef5b2) - (bonusEndBlock * sub_a3eef5b2) != poolInfo[idx].field_256:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _2805 = mem[64]
            mem[64] = mem[64] + 64
            mem[_2805] = 26
            mem[_2805 + 32] = 'SafeMath: division by zero'
            if totalAllocPoint <= 0:
                _2892 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_2892 + idx + 68] = mem[_2805 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_2892 + 68] = mem[_2892 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _2892 + -mem[64] + 100
            require totalAllocPoint
            _3089 = mem[64]
            mem[64] = mem[64] + 64
            mem[_3089] = 26
            mem[_3089 + 32] = 'SafeMath: division by zero'
            if devFundDivRate <= 0:
                _3221 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_3221 + idx + 68] = mem[_3089 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_3221 + 68] = mem[_3221 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _3221 + -mem[64] + 100
            require devFundDivRate
            require ext_code.size(sub_64d46cecAddress)
            call sub_64d46cecAddress.0x40c10f19 with:
                 gas gas_remaining wei
                args devaddr, (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = this.address
            mem[mem[64] + 36] = (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint
            require ext_code.size(sub_64d46cecAddress)
            call sub_64d46cecAddress.0x40c10f19 with:
                 gas gas_remaining wei
                args address(this.address), (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if not (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint:
                _3866 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3866] = 26
                mem[_3866 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0] > 0:
                    require ext_call.return_data[0]
                    if poolInfo[idx].field_768 + (0 / ext_call.return_data[0]) < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _3965 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_3965 + idx + 68] = mem[_3866 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_3965 + 68] = mem[_3965 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _3965 + -mem[64] + 100
            require (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint
            if 10^12 * (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint / (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _3964 = mem[64]
            mem[64] = mem[64] + 64
            mem[_3964] = 26
            mem[_3964 + 32] = 'SafeMath: division by zero'
            if ext_call.return_data[0] > 0:
                require ext_call.return_data[0]
                if poolInfo[idx].field_768 + (10^12 * (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) < poolInfo[idx].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                poolInfo[idx].field_768 += 10^12 * (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                poolInfo[idx].field_512 = block.number
                idx = idx + 1
                continue 
            _4070 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[_4070 + idx + 68] = mem[_3964 + idx + 32]
                idx = idx + 32
                continue 
            mem[_4070 + 68] = mem[_4070 + 74 len 26]
            revert with memory
              from mem[64]
               len _4070 + -mem[64] + 100
        if block.number <= bonusEndBlock:
            _2115 = mem[64]
            mem[64] = mem[64] + 64
            mem[_2115] = 30
            mem[_2115 + 32] = 'SafeMath: subtraction overflow'
            if endBlock > block.number:
                _2133 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_2133 + idx + 68] = mem[_2115 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_2133 + 68] = mem[_2133 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _2133 + -mem[64] + 100
            if not block.number - endBlock:
                _2308 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2308] = 26
                mem[_2308 + 32] = 'SafeMath: division by zero'
                if totalAllocPoint <= 0:
                    _2348 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2348 + idx + 68] = mem[_2308 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2348 + 68] = mem[_2348 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _2348 + -mem[64] + 100
                require totalAllocPoint
                _2468 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2468] = 26
                mem[_2468 + 32] = 'SafeMath: division by zero'
                if devFundDivRate <= 0:
                    _2537 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2537 + idx + 68] = mem[_2468 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2537 + 68] = mem[_2537 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _2537 + -mem[64] + 100
                require devFundDivRate
                require ext_code.size(sub_64d46cecAddress)
                call sub_64d46cecAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args devaddr, 0 / totalAllocPoint / devFundDivRate
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = 0 / totalAllocPoint
                require ext_code.size(sub_64d46cecAddress)
                call sub_64d46cecAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args address(this.address), 0 / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if not 0 / totalAllocPoint:
                    _3085 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3085] = 26
                    mem[_3085 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0] > 0:
                        require ext_call.return_data[0]
                        if poolInfo[idx].field_768 + (0 / ext_call.return_data[0]) < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _3217 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3217 + idx + 68] = mem[_3085 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3217 + 68] = mem[_3217 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _3217 + -mem[64] + 100
                require 0 / totalAllocPoint
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _3216 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3216] = 26
                mem[_3216 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0] > 0:
                    require ext_call.return_data[0]
                    if poolInfo[idx].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _3375 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_3375 + idx + 68] = mem[_3216 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_3375 + 68] = mem[_3375 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _3375 + -mem[64] + 100
            require block.number - endBlock
            if block.number - endBlock / block.number - endBlock != 1:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            if not block.number - endBlock:
                _2347 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2347] = 26
                mem[_2347 + 32] = 'SafeMath: division by zero'
                if totalAllocPoint <= 0:
                    _2404 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2404 + idx + 68] = mem[_2347 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2404 + 68] = mem[_2404 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _2404 + -mem[64] + 100
                require totalAllocPoint
                _2535 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2535] = 26
                mem[_2535 + 32] = 'SafeMath: division by zero'
                if devFundDivRate <= 0:
                    _2618 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2618 + idx + 68] = mem[_2535 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2618 + 68] = mem[_2618 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _2618 + -mem[64] + 100
                require devFundDivRate
                require ext_code.size(sub_64d46cecAddress)
                call sub_64d46cecAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args devaddr, 0 / totalAllocPoint / devFundDivRate
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = 0 / totalAllocPoint
                require ext_code.size(sub_64d46cecAddress)
                call sub_64d46cecAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args address(this.address), 0 / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if not 0 / totalAllocPoint:
                    _3215 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3215] = 26
                    mem[_3215 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0] > 0:
                        require ext_call.return_data[0]
                        if poolInfo[idx].field_768 + (0 / ext_call.return_data[0]) < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _3372 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3372 + idx + 68] = mem[_3215 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3372 + 68] = mem[_3372 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _3372 + -mem[64] + 100
                require 0 / totalAllocPoint
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _3371 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3371] = 26
                mem[_3371 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0] > 0:
                    require ext_call.return_data[0]
                    if poolInfo[idx].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _3513 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_3513 + idx + 68] = mem[_3371 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_3513 + 68] = mem[_3513 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _3513 + -mem[64] + 100
            require block.number - endBlock
            if (block.number * sub_a3eef5b2) - (endBlock * sub_a3eef5b2) / block.number - endBlock != sub_a3eef5b2:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            if not (block.number * sub_a3eef5b2) - (endBlock * sub_a3eef5b2):
                _2403 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2403] = 26
                mem[_2403 + 32] = 'SafeMath: division by zero'
                if totalAllocPoint <= 0:
                    _2464 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2464 + idx + 68] = mem[_2403 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2464 + 68] = mem[_2464 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _2464 + -mem[64] + 100
                require totalAllocPoint
                _2616 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2616] = 26
                mem[_2616 + 32] = 'SafeMath: division by zero'
                if devFundDivRate <= 0:
                    _2711 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2711 + idx + 68] = mem[_2616 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2711 + 68] = mem[_2711 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _2711 + -mem[64] + 100
                require devFundDivRate
                require ext_code.size(sub_64d46cecAddress)
                call sub_64d46cecAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args devaddr, 0 / totalAllocPoint / devFundDivRate
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = 0 / totalAllocPoint
                require ext_code.size(sub_64d46cecAddress)
                call sub_64d46cecAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args address(this.address), 0 / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if not 0 / totalAllocPoint:
                    _3370 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3370] = 26
                    mem[_3370 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0] > 0:
                        require ext_call.return_data[0]
                        if poolInfo[idx].field_768 + (0 / ext_call.return_data[0]) < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _3510 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3510 + idx + 68] = mem[_3370 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3510 + 68] = mem[_3510 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _3510 + -mem[64] + 100
                require 0 / totalAllocPoint
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _3509 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3509] = 26
                mem[_3509 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0] > 0:
                    require ext_call.return_data[0]
                    if poolInfo[idx].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _3615 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_3615 + idx + 68] = mem[_3509 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_3615 + 68] = mem[_3615 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _3615 + -mem[64] + 100
            require (block.number * sub_a3eef5b2) - (endBlock * sub_a3eef5b2)
            if (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / (block.number * sub_a3eef5b2) - (endBlock * sub_a3eef5b2) != poolInfo[idx].field_256:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _2463 = mem[64]
            mem[64] = mem[64] + 64
            mem[_2463] = 26
            mem[_2463 + 32] = 'SafeMath: division by zero'
            if totalAllocPoint <= 0:
                _2531 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_2531 + idx + 68] = mem[_2463 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_2531 + 68] = mem[_2531 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _2531 + -mem[64] + 100
            require totalAllocPoint
            _2709 = mem[64]
            mem[64] = mem[64] + 64
            mem[_2709] = 26
            mem[_2709 + 32] = 'SafeMath: division by zero'
            if devFundDivRate <= 0:
                _2797 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_2797 + idx + 68] = mem[_2709 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_2797 + 68] = mem[_2797 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _2797 + -mem[64] + 100
            require devFundDivRate
            require ext_code.size(sub_64d46cecAddress)
            call sub_64d46cecAddress.0x40c10f19 with:
                 gas gas_remaining wei
                args devaddr, (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = this.address
            mem[mem[64] + 36] = (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint
            require ext_code.size(sub_64d46cecAddress)
            call sub_64d46cecAddress.0x40c10f19 with:
                 gas gas_remaining wei
                args address(this.address), (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if not (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint:
                _3508 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3508] = 26
                mem[_3508 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0] > 0:
                    require ext_call.return_data[0]
                    if poolInfo[idx].field_768 + (0 / ext_call.return_data[0]) < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _3612 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_3612 + idx + 68] = mem[_3508 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_3612 + 68] = mem[_3612 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _3612 + -mem[64] + 100
            require (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint
            if 10^12 * (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint / (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _3611 = mem[64]
            mem[64] = mem[64] + 64
            mem[_3611] = 26
            mem[_3611 + 32] = 'SafeMath: division by zero'
            if ext_call.return_data[0] > 0:
                require ext_call.return_data[0]
                if poolInfo[idx].field_768 + (10^12 * (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) < poolInfo[idx].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                poolInfo[idx].field_768 += 10^12 * (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                poolInfo[idx].field_512 = block.number
                idx = idx + 1
                continue 
            _3695 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[_3695 + idx + 68] = mem[_3611 + idx + 32]
                idx = idx + 32
                continue 
            mem[_3695 + 68] = mem[_3695 + 74 len 26]
            revert with memory
              from mem[64]
               len _3695 + -mem[64] + 100
        if endBlock >= bonusEndBlock:
            _2122 = mem[64]
            mem[64] = mem[64] + 64
            mem[_2122] = 30
            mem[_2122 + 32] = 'SafeMath: subtraction overflow'
            if endBlock > block.number:
                _2148 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_2148 + idx + 68] = mem[_2122 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_2148 + 68] = mem[_2148 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _2148 + -mem[64] + 100
            if not block.number - endBlock:
                _2273 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2273] = 26
                mem[_2273 + 32] = 'SafeMath: division by zero'
                if totalAllocPoint <= 0:
                    _2299 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2299 + idx + 68] = mem[_2273 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2299 + 68] = mem[_2299 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _2299 + -mem[64] + 100
                require totalAllocPoint
                _2373 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2373] = 26
                mem[_2373 + 32] = 'SafeMath: division by zero'
                if devFundDivRate <= 0:
                    _2432 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2432 + idx + 68] = mem[_2373 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2432 + 68] = mem[_2432 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _2432 + -mem[64] + 100
                require devFundDivRate
                require ext_code.size(sub_64d46cecAddress)
                call sub_64d46cecAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args devaddr, 0 / totalAllocPoint / devFundDivRate
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = 0 / totalAllocPoint
                require ext_code.size(sub_64d46cecAddress)
                call sub_64d46cecAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args address(this.address), 0 / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if not 0 / totalAllocPoint:
                    _2936 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2936] = 26
                    mem[_2936 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0] > 0:
                        require ext_call.return_data[0]
                        if poolInfo[idx].field_768 + (0 / ext_call.return_data[0]) < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _3037 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3037 + idx + 68] = mem[_2936 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3037 + 68] = mem[_3037 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _3037 + -mem[64] + 100
                require 0 / totalAllocPoint
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _3036 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3036] = 26
                mem[_3036 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0] > 0:
                    require ext_call.return_data[0]
                    if poolInfo[idx].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _3156 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_3156 + idx + 68] = mem[_3036 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_3156 + 68] = mem[_3156 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _3156 + -mem[64] + 100
            require block.number - endBlock
            if (block.number * sub_a3eef5b2) - (endBlock * sub_a3eef5b2) / block.number - endBlock != sub_a3eef5b2:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            if not (block.number * sub_a3eef5b2) - (endBlock * sub_a3eef5b2):
                _2298 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2298] = 26
                mem[_2298 + 32] = 'SafeMath: division by zero'
                if totalAllocPoint <= 0:
                    _2326 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2326 + idx + 68] = mem[_2298 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2326 + 68] = mem[_2326 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _2326 + -mem[64] + 100
                require totalAllocPoint
                _2430 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2430] = 26
                mem[_2430 + 32] = 'SafeMath: division by zero'
                if devFundDivRate <= 0:
                    _2498 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2498 + idx + 68] = mem[_2430 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2498 + 68] = mem[_2498 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _2498 + -mem[64] + 100
                require devFundDivRate
                require ext_code.size(sub_64d46cecAddress)
                call sub_64d46cecAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args devaddr, 0 / totalAllocPoint / devFundDivRate
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = 0 / totalAllocPoint
                require ext_code.size(sub_64d46cecAddress)
                call sub_64d46cecAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args address(this.address), 0 / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if not 0 / totalAllocPoint:
                    _3035 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3035] = 26
                    mem[_3035 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0] > 0:
                        require ext_call.return_data[0]
                        if poolInfo[idx].field_768 + (0 / ext_call.return_data[0]) < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _3153 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3153 + idx + 68] = mem[_3035 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3153 + 68] = mem[_3153 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _3153 + -mem[64] + 100
                require 0 / totalAllocPoint
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _3152 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3152] = 26
                mem[_3152 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0] > 0:
                    require ext_call.return_data[0]
                    if poolInfo[idx].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _3287 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_3287 + idx + 68] = mem[_3152 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_3287 + 68] = mem[_3287 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _3287 + -mem[64] + 100
            require (block.number * sub_a3eef5b2) - (endBlock * sub_a3eef5b2)
            if (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / (block.number * sub_a3eef5b2) - (endBlock * sub_a3eef5b2) != poolInfo[idx].field_256:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _2325 = mem[64]
            mem[64] = mem[64] + 64
            mem[_2325] = 26
            mem[_2325 + 32] = 'SafeMath: division by zero'
            if totalAllocPoint <= 0:
                _2369 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_2369 + idx + 68] = mem[_2325 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_2369 + 68] = mem[_2369 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _2369 + -mem[64] + 100
            require totalAllocPoint
            _2496 = mem[64]
            mem[64] = mem[64] + 64
            mem[_2496] = 26
            mem[_2496 + 32] = 'SafeMath: division by zero'
            if devFundDivRate <= 0:
                _2565 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_2565 + idx + 68] = mem[_2496 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_2565 + 68] = mem[_2565 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _2565 + -mem[64] + 100
            require devFundDivRate
            require ext_code.size(sub_64d46cecAddress)
            call sub_64d46cecAddress.0x40c10f19 with:
                 gas gas_remaining wei
                args devaddr, (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = this.address
            mem[mem[64] + 36] = (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint
            require ext_code.size(sub_64d46cecAddress)
            call sub_64d46cecAddress.0x40c10f19 with:
                 gas gas_remaining wei
                args address(this.address), (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if not (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint:
                _3151 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3151] = 26
                mem[_3151 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0] > 0:
                    require ext_call.return_data[0]
                    if poolInfo[idx].field_768 + (0 / ext_call.return_data[0]) < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _3284 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_3284 + idx + 68] = mem[_3151 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_3284 + 68] = mem[_3284 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _3284 + -mem[64] + 100
            require (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint
            if 10^12 * (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint / (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _3283 = mem[64]
            mem[64] = mem[64] + 64
            mem[_3283] = 26
            mem[_3283 + 32] = 'SafeMath: division by zero'
            if ext_call.return_data[0] > 0:
                require ext_call.return_data[0]
                if poolInfo[idx].field_768 + (10^12 * (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) < poolInfo[idx].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                poolInfo[idx].field_768 += 10^12 * (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                poolInfo[idx].field_512 = block.number
                idx = idx + 1
                continue 
            _3428 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[_3428 + idx + 68] = mem[_3283 + idx + 32]
                idx = idx + 32
                continue 
            mem[_3428 + 68] = mem[_3428 + 74 len 26]
            revert with memory
              from mem[64]
               len _3428 + -mem[64] + 100
        _2121 = mem[64]
        mem[64] = mem[64] + 64
        mem[_2121] = 30
        mem[_2121 + 32] = 'SafeMath: subtraction overflow'
        if bonusEndBlock > block.number:
            _2145 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[_2145 + idx + 68] = mem[_2121 + idx + 32]
                idx = idx + 32
                continue 
            mem[_2145 + 68] = mem[_2145 + 70 len 30]
            revert with memory
              from mem[64]
               len _2145 + -mem[64] + 100
        _2189 = mem[64]
        mem[64] = mem[64] + 64
        mem[_2189] = 30
        mem[_2189 + 32] = 'SafeMath: subtraction overflow'
        if endBlock > bonusEndBlock:
            _2219 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[_2219 + idx + 68] = mem[_2189 + idx + 32]
                idx = idx + 32
                continue 
            mem[_2219 + 68] = mem[_2219 + 70 len 30]
            revert with memory
              from mem[64]
               len _2219 + -mem[64] + 100
        if not bonusEndBlock - endBlock:
            if block.number - bonusEndBlock < 0:
                revert with 0, 'SafeMath: addition overflow'
            if not block.number - bonusEndBlock:
                _2564 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2564] = 26
                mem[_2564 + 32] = 'SafeMath: division by zero'
                if totalAllocPoint <= 0:
                    _2654 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2654 + idx + 68] = mem[_2564 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2654 + 68] = mem[_2654 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _2654 + -mem[64] + 100
                require totalAllocPoint
                _2846 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2846] = 26
                mem[_2846 + 32] = 'SafeMath: division by zero'
                if devFundDivRate <= 0:
                    _2933 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2933 + idx + 68] = mem[_2846 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2933 + 68] = mem[_2933 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _2933 + -mem[64] + 100
                require devFundDivRate
                require ext_code.size(sub_64d46cecAddress)
                call sub_64d46cecAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args devaddr, 0 / totalAllocPoint / devFundDivRate
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = 0 / totalAllocPoint
                require ext_code.size(sub_64d46cecAddress)
                call sub_64d46cecAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args address(this.address), 0 / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if not 0 / totalAllocPoint:
                    _3649 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3649] = 26
                    mem[_3649 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0] > 0:
                        require ext_call.return_data[0]
                        if poolInfo[idx].field_768 + (0 / ext_call.return_data[0]) < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _3729 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3729 + idx + 68] = mem[_3649 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3729 + 68] = mem[_3729 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _3729 + -mem[64] + 100
                require 0 / totalAllocPoint
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _3728 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3728] = 26
                mem[_3728 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0] > 0:
                    require ext_call.return_data[0]
                    if poolInfo[idx].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _3819 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_3819 + idx + 68] = mem[_3728 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_3819 + 68] = mem[_3819 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _3819 + -mem[64] + 100
            require block.number - bonusEndBlock
            if (block.number * sub_a3eef5b2) - (bonusEndBlock * sub_a3eef5b2) / block.number - bonusEndBlock != sub_a3eef5b2:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            if not (block.number * sub_a3eef5b2) - (bonusEndBlock * sub_a3eef5b2):
                _2653 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2653] = 26
                mem[_2653 + 32] = 'SafeMath: division by zero'
                if totalAllocPoint <= 0:
                    _2755 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2755 + idx + 68] = mem[_2653 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2755 + 68] = mem[_2755 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _2755 + -mem[64] + 100
                require totalAllocPoint
                _2931 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2931] = 26
                mem[_2931 + 32] = 'SafeMath: division by zero'
                if devFundDivRate <= 0:
                    _3031 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3031 + idx + 68] = mem[_2931 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3031 + 68] = mem[_3031 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _3031 + -mem[64] + 100
                require devFundDivRate
                require ext_code.size(sub_64d46cecAddress)
                call sub_64d46cecAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args devaddr, 0 / totalAllocPoint / devFundDivRate
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = 0 / totalAllocPoint
                require ext_code.size(sub_64d46cecAddress)
                call sub_64d46cecAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args address(this.address), 0 / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if not 0 / totalAllocPoint:
                    _3727 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3727] = 26
                    mem[_3727 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0] > 0:
                        require ext_call.return_data[0]
                        if poolInfo[idx].field_768 + (0 / ext_call.return_data[0]) < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _3816 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3816 + idx + 68] = mem[_3727 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3816 + 68] = mem[_3816 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _3816 + -mem[64] + 100
                require 0 / totalAllocPoint
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _3815 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3815] = 26
                mem[_3815 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0] > 0:
                    require ext_call.return_data[0]
                    if poolInfo[idx].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _3917 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_3917 + idx + 68] = mem[_3815 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_3917 + 68] = mem[_3917 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _3917 + -mem[64] + 100
            require (block.number * sub_a3eef5b2) - (bonusEndBlock * sub_a3eef5b2)
            if (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / (block.number * sub_a3eef5b2) - (bonusEndBlock * sub_a3eef5b2) != poolInfo[idx].field_256:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _2754 = mem[64]
            mem[64] = mem[64] + 64
            mem[_2754] = 26
            mem[_2754 + 32] = 'SafeMath: division by zero'
            if totalAllocPoint <= 0:
                _2842 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_2842 + idx + 68] = mem[_2754 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_2842 + 68] = mem[_2842 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _2842 + -mem[64] + 100
            require totalAllocPoint
            _3029 = mem[64]
            mem[64] = mem[64] + 64
            mem[_3029] = 26
            mem[_3029 + 32] = 'SafeMath: division by zero'
            if devFundDivRate <= 0:
                _3146 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_3146 + idx + 68] = mem[_3029 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_3146 + 68] = mem[_3146 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _3146 + -mem[64] + 100
            require devFundDivRate
            require ext_code.size(sub_64d46cecAddress)
            call sub_64d46cecAddress.0x40c10f19 with:
                 gas gas_remaining wei
                args devaddr, (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = this.address
            mem[mem[64] + 36] = (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint
            require ext_code.size(sub_64d46cecAddress)
            call sub_64d46cecAddress.0x40c10f19 with:
                 gas gas_remaining wei
                args address(this.address), (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if not (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint:
                _3814 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3814] = 26
                mem[_3814 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0] > 0:
                    require ext_call.return_data[0]
                    if poolInfo[idx].field_768 + (0 / ext_call.return_data[0]) < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _3914 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_3914 + idx + 68] = mem[_3814 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_3914 + 68] = mem[_3914 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _3914 + -mem[64] + 100
            require (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint
            if 10^12 * (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint / (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _3913 = mem[64]
            mem[64] = mem[64] + 64
            mem[_3913] = 26
            mem[_3913 + 32] = 'SafeMath: division by zero'
            if ext_call.return_data[0] > 0:
                require ext_call.return_data[0]
                if poolInfo[idx].field_768 + (10^12 * (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) < poolInfo[idx].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                poolInfo[idx].field_768 += 10^12 * (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                poolInfo[idx].field_512 = block.number
                idx = idx + 1
                continue 
            _4015 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[_4015 + idx + 68] = mem[_3913 + idx + 32]
                idx = idx + 32
                continue 
            mem[_4015 + 68] = mem[_4015 + 74 len 26]
            revert with memory
              from mem[64]
               len _4015 + -mem[64] + 100
        require bonusEndBlock - endBlock
        if bonusEndBlock - endBlock / bonusEndBlock - endBlock != 1:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
        if block.number < bonusEndBlock:
            revert with 0, 'SafeMath: addition overflow'
        if not -endBlock + block.number:
            _2652 = mem[64]
            mem[64] = mem[64] + 64
            mem[_2652] = 26
            mem[_2652 + 32] = 'SafeMath: division by zero'
            if totalAllocPoint <= 0:
                _2751 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_2751 + idx + 68] = mem[_2652 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_2751 + 68] = mem[_2751 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _2751 + -mem[64] + 100
            require totalAllocPoint
            _2928 = mem[64]
            mem[64] = mem[64] + 64
            mem[_2928] = 26
            mem[_2928 + 32] = 'SafeMath: division by zero'
            if devFundDivRate <= 0:
                _3026 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_3026 + idx + 68] = mem[_2928 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_3026 + 68] = mem[_3026 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _3026 + -mem[64] + 100
            require devFundDivRate
            require ext_code.size(sub_64d46cecAddress)
            call sub_64d46cecAddress.0x40c10f19 with:
                 gas gas_remaining wei
                args devaddr, 0 / totalAllocPoint / devFundDivRate
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = this.address
            mem[mem[64] + 36] = 0 / totalAllocPoint
            require ext_code.size(sub_64d46cecAddress)
            call sub_64d46cecAddress.0x40c10f19 with:
                 gas gas_remaining wei
                args address(this.address), 0 / totalAllocPoint
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if not 0 / totalAllocPoint:
                _3726 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3726] = 26
                mem[_3726 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0] > 0:
                    require ext_call.return_data[0]
                    if poolInfo[idx].field_768 + (0 / ext_call.return_data[0]) < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _3811 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_3811 + idx + 68] = mem[_3726 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_3811 + 68] = mem[_3811 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _3811 + -mem[64] + 100
            require 0 / totalAllocPoint
            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _3810 = mem[64]
            mem[64] = mem[64] + 64
            mem[_3810] = 26
            mem[_3810 + 32] = 'SafeMath: division by zero'
            if ext_call.return_data[0] > 0:
                require ext_call.return_data[0]
                if poolInfo[idx].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[idx].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                poolInfo[idx].field_512 = block.number
                idx = idx + 1
                continue 
            _3909 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[_3909 + idx + 68] = mem[_3810 + idx + 32]
                idx = idx + 32
                continue 
            mem[_3909 + 68] = mem[_3909 + 74 len 26]
            revert with memory
              from mem[64]
               len _3909 + -mem[64] + 100
        require -endBlock + block.number
        if (-1 * endBlock * sub_a3eef5b2) + (block.number * sub_a3eef5b2) / -endBlock + block.number != sub_a3eef5b2:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
        if not (-1 * endBlock * sub_a3eef5b2) + (block.number * sub_a3eef5b2):
            _2750 = mem[64]
            mem[64] = mem[64] + 64
            mem[_2750] = 26
            mem[_2750 + 32] = 'SafeMath: division by zero'
            if totalAllocPoint <= 0:
                _2838 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_2838 + idx + 68] = mem[_2750 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_2838 + 68] = mem[_2838 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _2838 + -mem[64] + 100
            require totalAllocPoint
            _3024 = mem[64]
            mem[64] = mem[64] + 64
            mem[_3024] = 26
            mem[_3024 + 32] = 'SafeMath: division by zero'
            if devFundDivRate <= 0:
                _3142 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_3142 + idx + 68] = mem[_3024 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_3142 + 68] = mem[_3142 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _3142 + -mem[64] + 100
            require devFundDivRate
            require ext_code.size(sub_64d46cecAddress)
            call sub_64d46cecAddress.0x40c10f19 with:
                 gas gas_remaining wei
                args devaddr, 0 / totalAllocPoint / devFundDivRate
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = this.address
            mem[mem[64] + 36] = 0 / totalAllocPoint
            require ext_code.size(sub_64d46cecAddress)
            call sub_64d46cecAddress.0x40c10f19 with:
                 gas gas_remaining wei
                args address(this.address), 0 / totalAllocPoint
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if not 0 / totalAllocPoint:
                _3809 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3809] = 26
                mem[_3809 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0] > 0:
                    require ext_call.return_data[0]
                    if poolInfo[idx].field_768 + (0 / ext_call.return_data[0]) < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _3906 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_3906 + idx + 68] = mem[_3809 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_3906 + 68] = mem[_3906 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _3906 + -mem[64] + 100
            require 0 / totalAllocPoint
            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _3905 = mem[64]
            mem[64] = mem[64] + 64
            mem[_3905] = 26
            mem[_3905 + 32] = 'SafeMath: division by zero'
            if ext_call.return_data[0] > 0:
                require ext_call.return_data[0]
                if poolInfo[idx].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[idx].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                poolInfo[idx].field_512 = block.number
                idx = idx + 1
                continue 
            _4009 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[_4009 + idx + 68] = mem[_3905 + idx + 32]
                idx = idx + 32
                continue 
            mem[_4009 + 68] = mem[_4009 + 74 len 26]
            revert with memory
              from mem[64]
               len _4009 + -mem[64] + 100
        require (-1 * endBlock * sub_a3eef5b2) + (block.number * sub_a3eef5b2)
        if (-1 * endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) + (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) / (-1 * endBlock * sub_a3eef5b2) + (block.number * sub_a3eef5b2) != poolInfo[idx].field_256:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
        _2837 = mem[64]
        mem[64] = mem[64] + 64
        mem[_2837] = 26
        mem[_2837 + 32] = 'SafeMath: division by zero'
        if totalAllocPoint <= 0:
            _2924 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[_2924 + idx + 68] = mem[_2837 + idx + 32]
                idx = idx + 32
                continue 
            mem[_2924 + 68] = mem[_2924 + 74 len 26]
            revert with memory
              from mem[64]
               len _2924 + -mem[64] + 100
        require totalAllocPoint
        _3140 = mem[64]
        mem[64] = mem[64] + 64
        mem[_3140] = 26
        mem[_3140 + 32] = 'SafeMath: division by zero'
        if devFundDivRate <= 0:
            _3276 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[_3276 + idx + 68] = mem[_3140 + idx + 32]
                idx = idx + 32
                continue 
            mem[_3276 + 68] = mem[_3276 + 74 len 26]
            revert with memory
              from mem[64]
               len _3276 + -mem[64] + 100
        require devFundDivRate
        require ext_code.size(sub_64d46cecAddress)
        call sub_64d46cecAddress.0x40c10f19 with:
             gas gas_remaining wei
            args devaddr, (-1 * endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) + (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = this.address
        mem[mem[64] + 36] = (-1 * endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) + (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint
        require ext_code.size(sub_64d46cecAddress)
        call sub_64d46cecAddress.0x40c10f19 with:
             gas gas_remaining wei
            args address(this.address), (-1 * endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) + (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        if not (-1 * endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) + (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint:
            _3904 = mem[64]
            mem[64] = mem[64] + 64
            mem[_3904] = 26
            mem[_3904 + 32] = 'SafeMath: division by zero'
            if ext_call.return_data[0] > 0:
                require ext_call.return_data[0]
                if poolInfo[idx].field_768 + (0 / ext_call.return_data[0]) < poolInfo[idx].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                poolInfo[idx].field_512 = block.number
                idx = idx + 1
                continue 
            _4006 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[_4006 + idx + 68] = mem[_3904 + idx + 32]
                idx = idx + 32
                continue 
            mem[_4006 + 68] = mem[_4006 + 74 len 26]
            revert with memory
              from mem[64]
               len _4006 + -mem[64] + 100
        require (-1 * endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) + (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint
        if 10^12 * (-1 * endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) + (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint / (-1 * endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) + (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
        _4005 = mem[64]
        mem[64] = mem[64] + 64
        mem[_4005] = 26
        mem[_4005 + 32] = 'SafeMath: division by zero'
        if ext_call.return_data[0] > 0:
            require ext_call.return_data[0]
            if poolInfo[idx].field_768 + (10^12 * (-1 * endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) + (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) < poolInfo[idx].field_768:
                revert with 0, 'SafeMath: addition overflow'
            poolInfo[idx].field_768 += 10^12 * (-1 * endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) + (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
            poolInfo[idx].field_512 = block.number
            idx = idx + 1
            continue 
        _4101 = mem[64]
        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 32
        mem[mem[64] + 36] = 26
        idx = 0
        while idx < 26:
            mem[_4101 + idx + 68] = mem[_4005 + idx + 32]
            idx = idx + 32
            continue 
        mem[_4101 + 68] = mem[_4101 + 74 len 26]
        revert with memory
          from mem[64]
           len _4101 + -mem[64] + 100
}

function set(uint256 arg1, uint256 arg2, bool arg3) payable {
    mem[64] = 96
    require calldata.size - 4 >= 96
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if arg3:
        idx = 0
        while idx < poolInfo.length:
            mem[0] = 6
            if block.number <= poolInfo[idx].field_512:
                idx = idx + 1
                continue 
            mem[mem[64] + 4] = this.address
            require ext_code.size(poolInfo[idx].field_0)
            staticcall poolInfo[idx].field_0.0x70a08231 with:
                    gas gas_remaining wei
                   args address(this.address)
            mem[mem[64]] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            if not ext_call.return_data[0]:
                poolInfo[idx].field_512 = block.number
                idx = idx + 1
                continue 
            if poolInfo[idx].field_512 <= endBlock:
                if block.number <= endBlock:
                    if block.number <= bonusEndBlock:
                        _2153 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2153] = 30
                        mem[_2153 + 32] = 'SafeMath: subtraction overflow'
                        if poolInfo[idx].field_512 > block.number:
                            _2158 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_2158 + idx + 68] = mem[_2153 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2158 + 68] = mem[_2158 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _2158 + -mem[64] + 100
                        if not block.number - poolInfo[idx].field_512:
                            _2331 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2331] = 26
                            mem[_2331 + 32] = 'SafeMath: division by zero'
                            if totalAllocPoint <= 0:
                                _2359 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[_2359 + idx + 68] = mem[_2331 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2359 + 68] = mem[_2359 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _2359 + -mem[64] + 100
                            require totalAllocPoint
                            _2461 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2461] = 26
                            mem[_2461 + 32] = 'SafeMath: division by zero'
                            if devFundDivRate <= 0:
                                _2527 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[_2527 + idx + 68] = mem[_2461 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2527 + 68] = mem[_2527 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _2527 + -mem[64] + 100
                            require devFundDivRate
                            require ext_code.size(sub_64d46cecAddress)
                            call sub_64d46cecAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args devaddr, 0 / totalAllocPoint / devFundDivRate
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = this.address
                            mem[mem[64] + 36] = 0 / totalAllocPoint
                            require ext_code.size(sub_64d46cecAddress)
                            call sub_64d46cecAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args address(this.address), 0 / totalAllocPoint
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if not 0 / totalAllocPoint:
                                _3043 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3043] = 26
                                mem[_3043 + 32] = 'SafeMath: division by zero'
                                if ext_call.return_data[0] > 0:
                                    require ext_call.return_data[0]
                                    if poolInfo[idx].field_768 + (0 / ext_call.return_data[0]) < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                    poolInfo[idx].field_512 = block.number
                                    idx = idx + 1
                                    continue 
                                _3157 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[_3157 + idx + 68] = mem[_3043 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3157 + 68] = mem[_3157 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _3157 + -mem[64] + 100
                            require 0 / totalAllocPoint
                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _3156 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3156] = 26
                            mem[_3156 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0] > 0:
                                require ext_call.return_data[0]
                                if poolInfo[idx].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _3295 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3295 + idx + 68] = mem[_3156 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3295 + 68] = mem[_3295 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _3295 + -mem[64] + 100
                        require block.number - poolInfo[idx].field_512
                        if block.number - poolInfo[idx].field_512 / block.number - poolInfo[idx].field_512 != 1:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if not block.number - poolInfo[idx].field_512:
                            _2358 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2358] = 26
                            mem[_2358 + 32] = 'SafeMath: division by zero'
                            if totalAllocPoint <= 0:
                                _2399 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[_2399 + idx + 68] = mem[_2358 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2399 + 68] = mem[_2399 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _2399 + -mem[64] + 100
                            require totalAllocPoint
                            _2525 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2525] = 26
                            mem[_2525 + 32] = 'SafeMath: division by zero'
                            if devFundDivRate <= 0:
                                _2594 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[_2594 + idx + 68] = mem[_2525 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2594 + 68] = mem[_2594 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _2594 + -mem[64] + 100
                            require devFundDivRate
                            require ext_code.size(sub_64d46cecAddress)
                            call sub_64d46cecAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args devaddr, 0 / totalAllocPoint / devFundDivRate
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = this.address
                            mem[mem[64] + 36] = 0 / totalAllocPoint
                            require ext_code.size(sub_64d46cecAddress)
                            call sub_64d46cecAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args address(this.address), 0 / totalAllocPoint
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if not 0 / totalAllocPoint:
                                _3155 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3155] = 26
                                mem[_3155 + 32] = 'SafeMath: division by zero'
                                if ext_call.return_data[0] > 0:
                                    require ext_call.return_data[0]
                                    if poolInfo[idx].field_768 + (0 / ext_call.return_data[0]) < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                    poolInfo[idx].field_512 = block.number
                                    idx = idx + 1
                                    continue 
                                _3292 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[_3292 + idx + 68] = mem[_3155 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3292 + 68] = mem[_3292 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _3292 + -mem[64] + 100
                            require 0 / totalAllocPoint
                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _3291 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3291] = 26
                            mem[_3291 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0] > 0:
                                require ext_call.return_data[0]
                                if poolInfo[idx].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _3447 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3447 + idx + 68] = mem[_3291 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3447 + 68] = mem[_3447 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _3447 + -mem[64] + 100
                        require block.number - poolInfo[idx].field_512
                        if (block.number * sub_a3eef5b2) - (poolInfo[idx].field_512 * sub_a3eef5b2) / block.number - poolInfo[idx].field_512 != sub_a3eef5b2:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if not (block.number * sub_a3eef5b2) - (poolInfo[idx].field_512 * sub_a3eef5b2):
                            _2398 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2398] = 26
                            mem[_2398 + 32] = 'SafeMath: division by zero'
                            if totalAllocPoint <= 0:
                                _2457 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[_2457 + idx + 68] = mem[_2398 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2457 + 68] = mem[_2457 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _2457 + -mem[64] + 100
                            require totalAllocPoint
                            _2592 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2592] = 26
                            mem[_2592 + 32] = 'SafeMath: division by zero'
                            if devFundDivRate <= 0:
                                _2676 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[_2676 + idx + 68] = mem[_2592 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2676 + 68] = mem[_2676 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _2676 + -mem[64] + 100
                            require devFundDivRate
                            require ext_code.size(sub_64d46cecAddress)
                            call sub_64d46cecAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args devaddr, 0 / totalAllocPoint / devFundDivRate
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = this.address
                            mem[mem[64] + 36] = 0 / totalAllocPoint
                            require ext_code.size(sub_64d46cecAddress)
                            call sub_64d46cecAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args address(this.address), 0 / totalAllocPoint
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if not 0 / totalAllocPoint:
                                _3290 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3290] = 26
                                mem[_3290 + 32] = 'SafeMath: division by zero'
                                if ext_call.return_data[0] > 0:
                                    require ext_call.return_data[0]
                                    if poolInfo[idx].field_768 + (0 / ext_call.return_data[0]) < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                    poolInfo[idx].field_512 = block.number
                                    idx = idx + 1
                                    continue 
                                _3444 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[_3444 + idx + 68] = mem[_3290 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3444 + 68] = mem[_3444 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _3444 + -mem[64] + 100
                            require 0 / totalAllocPoint
                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _3443 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3443] = 26
                            mem[_3443 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0] > 0:
                                require ext_call.return_data[0]
                                if poolInfo[idx].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _3579 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3579 + idx + 68] = mem[_3443 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3579 + 68] = mem[_3579 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _3579 + -mem[64] + 100
                        require (block.number * sub_a3eef5b2) - (poolInfo[idx].field_512 * sub_a3eef5b2)
                        if (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) / (block.number * sub_a3eef5b2) - (poolInfo[idx].field_512 * sub_a3eef5b2) != poolInfo[idx].field_256:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _2456 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2456] = 26
                        mem[_2456 + 32] = 'SafeMath: division by zero'
                        if totalAllocPoint <= 0:
                            _2521 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2521 + idx + 68] = mem[_2456 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2521 + 68] = mem[_2521 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _2521 + -mem[64] + 100
                        require totalAllocPoint
                        _2674 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2674] = 26
                        mem[_2674 + 32] = 'SafeMath: division by zero'
                        if devFundDivRate <= 0:
                            _2771 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2771 + idx + 68] = mem[_2674 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2771 + 68] = mem[_2771 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _2771 + -mem[64] + 100
                        require devFundDivRate
                        require ext_code.size(sub_64d46cecAddress)
                        call sub_64d46cecAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args devaddr, (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint
                        require ext_code.size(sub_64d46cecAddress)
                        call sub_64d46cecAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args address(this.address), (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint:
                            _3442 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3442] = 26
                            mem[_3442 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0] > 0:
                                require ext_call.return_data[0]
                                if poolInfo[idx].field_768 + (0 / ext_call.return_data[0]) < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _3576 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3576 + idx + 68] = mem[_3442 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3576 + 68] = mem[_3576 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _3576 + -mem[64] + 100
                        require (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint
                        if 10^12 * (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint / (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _3575 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3575] = 26
                        mem[_3575 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0] > 0:
                            require ext_call.return_data[0]
                            if poolInfo[idx].field_768 + (10^12 * (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^12 * (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _3674 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3674 + idx + 68] = mem[_3575 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3674 + 68] = mem[_3674 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _3674 + -mem[64] + 100
                    if poolInfo[idx].field_512 >= bonusEndBlock:
                        _2155 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2155] = 30
                        mem[_2155 + 32] = 'SafeMath: subtraction overflow'
                        if poolInfo[idx].field_512 > block.number:
                            _2169 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[_2169 + idx + 68] = mem[_2155 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2169 + 68] = mem[_2169 + 70 len 30]
                            revert with memory
                              from mem[64]
                               len _2169 + -mem[64] + 100
                        if not block.number - poolInfo[idx].field_512:
                            _2301 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2301] = 26
                            mem[_2301 + 32] = 'SafeMath: division by zero'
                            if totalAllocPoint <= 0:
                                _2321 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[_2321 + idx + 68] = mem[_2301 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2321 + 68] = mem[_2321 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _2321 + -mem[64] + 100
                            require totalAllocPoint
                            _2377 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2377] = 26
                            mem[_2377 + 32] = 'SafeMath: division by zero'
                            if devFundDivRate <= 0:
                                _2427 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[_2427 + idx + 68] = mem[_2377 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2427 + 68] = mem[_2427 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _2427 + -mem[64] + 100
                            require devFundDivRate
                            require ext_code.size(sub_64d46cecAddress)
                            call sub_64d46cecAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args devaddr, 0 / totalAllocPoint / devFundDivRate
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = this.address
                            mem[mem[64] + 36] = 0 / totalAllocPoint
                            require ext_code.size(sub_64d46cecAddress)
                            call sub_64d46cecAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args address(this.address), 0 / totalAllocPoint
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if not 0 / totalAllocPoint:
                                _2910 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_2910] = 26
                                mem[_2910 + 32] = 'SafeMath: division by zero'
                                if ext_call.return_data[0] > 0:
                                    require ext_call.return_data[0]
                                    if poolInfo[idx].field_768 + (0 / ext_call.return_data[0]) < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                    poolInfo[idx].field_512 = block.number
                                    idx = idx + 1
                                    continue 
                                _3005 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[_3005 + idx + 68] = mem[_2910 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3005 + 68] = mem[_3005 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _3005 + -mem[64] + 100
                            require 0 / totalAllocPoint
                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _3004 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3004] = 26
                            mem[_3004 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0] > 0:
                                require ext_call.return_data[0]
                                if poolInfo[idx].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _3104 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3104 + idx + 68] = mem[_3004 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3104 + 68] = mem[_3104 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _3104 + -mem[64] + 100
                        require block.number - poolInfo[idx].field_512
                        if (block.number * sub_a3eef5b2) - (poolInfo[idx].field_512 * sub_a3eef5b2) / block.number - poolInfo[idx].field_512 != sub_a3eef5b2:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if not (block.number * sub_a3eef5b2) - (poolInfo[idx].field_512 * sub_a3eef5b2):
                            _2320 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2320] = 26
                            mem[_2320 + 32] = 'SafeMath: division by zero'
                            if totalAllocPoint <= 0:
                                _2345 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[_2345 + idx + 68] = mem[_2320 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2345 + 68] = mem[_2345 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _2345 + -mem[64] + 100
                            require totalAllocPoint
                            _2425 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2425] = 26
                            mem[_2425 + 32] = 'SafeMath: division by zero'
                            if devFundDivRate <= 0:
                                _2484 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[_2484 + idx + 68] = mem[_2425 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2484 + 68] = mem[_2484 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _2484 + -mem[64] + 100
                            require devFundDivRate
                            require ext_code.size(sub_64d46cecAddress)
                            call sub_64d46cecAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args devaddr, 0 / totalAllocPoint / devFundDivRate
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = this.address
                            mem[mem[64] + 36] = 0 / totalAllocPoint
                            require ext_code.size(sub_64d46cecAddress)
                            call sub_64d46cecAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args address(this.address), 0 / totalAllocPoint
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if not 0 / totalAllocPoint:
                                _3003 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3003] = 26
                                mem[_3003 + 32] = 'SafeMath: division by zero'
                                if ext_call.return_data[0] > 0:
                                    require ext_call.return_data[0]
                                    if poolInfo[idx].field_768 + (0 / ext_call.return_data[0]) < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                    poolInfo[idx].field_512 = block.number
                                    idx = idx + 1
                                    continue 
                                _3101 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[_3101 + idx + 68] = mem[_3003 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3101 + 68] = mem[_3101 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _3101 + -mem[64] + 100
                            require 0 / totalAllocPoint
                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _3100 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3100] = 26
                            mem[_3100 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0] > 0:
                                require ext_call.return_data[0]
                                if poolInfo[idx].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _3220 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3220 + idx + 68] = mem[_3100 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3220 + 68] = mem[_3220 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _3220 + -mem[64] + 100
                        require (block.number * sub_a3eef5b2) - (poolInfo[idx].field_512 * sub_a3eef5b2)
                        if (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) / (block.number * sub_a3eef5b2) - (poolInfo[idx].field_512 * sub_a3eef5b2) != poolInfo[idx].field_256:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _2344 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2344] = 26
                        mem[_2344 + 32] = 'SafeMath: division by zero'
                        if totalAllocPoint <= 0:
                            _2373 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2373 + idx + 68] = mem[_2344 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2373 + 68] = mem[_2373 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _2373 + -mem[64] + 100
                        require totalAllocPoint
                        _2482 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2482] = 26
                        mem[_2482 + 32] = 'SafeMath: division by zero'
                        if devFundDivRate <= 0:
                            _2549 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2549 + idx + 68] = mem[_2482 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2549 + 68] = mem[_2549 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _2549 + -mem[64] + 100
                        require devFundDivRate
                        require ext_code.size(sub_64d46cecAddress)
                        call sub_64d46cecAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args devaddr, (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint
                        require ext_code.size(sub_64d46cecAddress)
                        call sub_64d46cecAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args address(this.address), (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint:
                            _3099 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3099] = 26
                            mem[_3099 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0] > 0:
                                require ext_call.return_data[0]
                                if poolInfo[idx].field_768 + (0 / ext_call.return_data[0]) < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _3217 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3217 + idx + 68] = mem[_3099 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3217 + 68] = mem[_3217 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _3217 + -mem[64] + 100
                        require (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint
                        if 10^12 * (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint / (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _3216 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3216] = 26
                        mem[_3216 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0] > 0:
                            require ext_call.return_data[0]
                            if poolInfo[idx].field_768 + (10^12 * (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^12 * (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _3356 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3356 + idx + 68] = mem[_3216 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3356 + 68] = mem[_3356 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _3356 + -mem[64] + 100
                    _2154 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2154] = 30
                    mem[_2154 + 32] = 'SafeMath: subtraction overflow'
                    if bonusEndBlock > block.number:
                        _2166 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_2166 + idx + 68] = mem[_2154 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2166 + 68] = mem[_2166 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _2166 + -mem[64] + 100
                    _2208 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2208] = 30
                    mem[_2208 + 32] = 'SafeMath: subtraction overflow'
                    if poolInfo[idx].field_512 > bonusEndBlock:
                        _2241 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_2241 + idx + 68] = mem[_2208 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2241 + 68] = mem[_2241 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _2241 + -mem[64] + 100
                    if not bonusEndBlock - poolInfo[idx].field_512:
                        if block.number - bonusEndBlock < 0:
                            revert with 0, 'SafeMath: addition overflow'
                        if not block.number - bonusEndBlock:
                            _2548 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2548] = 26
                            mem[_2548 + 32] = 'SafeMath: division by zero'
                            if totalAllocPoint <= 0:
                                _2623 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[_2623 + idx + 68] = mem[_2548 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2623 + 68] = mem[_2623 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _2623 + -mem[64] + 100
                            require totalAllocPoint
                            _2818 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2818] = 26
                            mem[_2818 + 32] = 'SafeMath: division by zero'
                            if devFundDivRate <= 0:
                                _2907 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[_2907 + idx + 68] = mem[_2818 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2907 + 68] = mem[_2907 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _2907 + -mem[64] + 100
                            require devFundDivRate
                            require ext_code.size(sub_64d46cecAddress)
                            call sub_64d46cecAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args devaddr, 0 / totalAllocPoint / devFundDivRate
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = this.address
                            mem[mem[64] + 36] = 0 / totalAllocPoint
                            require ext_code.size(sub_64d46cecAddress)
                            call sub_64d46cecAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args address(this.address), 0 / totalAllocPoint
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if not 0 / totalAllocPoint:
                                _3612 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3612] = 26
                                mem[_3612 + 32] = 'SafeMath: division by zero'
                                if ext_call.return_data[0] > 0:
                                    require ext_call.return_data[0]
                                    if poolInfo[idx].field_768 + (0 / ext_call.return_data[0]) < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                    poolInfo[idx].field_512 = block.number
                                    idx = idx + 1
                                    continue 
                                _3707 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[_3707 + idx + 68] = mem[_3612 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3707 + 68] = mem[_3707 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _3707 + -mem[64] + 100
                            require 0 / totalAllocPoint
                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _3706 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3706] = 26
                            mem[_3706 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0] > 0:
                                require ext_call.return_data[0]
                                if poolInfo[idx].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _3796 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3796 + idx + 68] = mem[_3706 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3796 + 68] = mem[_3796 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _3796 + -mem[64] + 100
                        require block.number - bonusEndBlock
                        if (block.number * sub_a3eef5b2) - (bonusEndBlock * sub_a3eef5b2) / block.number - bonusEndBlock != sub_a3eef5b2:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        if not (block.number * sub_a3eef5b2) - (bonusEndBlock * sub_a3eef5b2):
                            _2622 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2622] = 26
                            mem[_2622 + 32] = 'SafeMath: division by zero'
                            if totalAllocPoint <= 0:
                                _2717 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[_2717 + idx + 68] = mem[_2622 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2717 + 68] = mem[_2717 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _2717 + -mem[64] + 100
                            require totalAllocPoint
                            _2905 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2905] = 26
                            mem[_2905 + 32] = 'SafeMath: division by zero'
                            if devFundDivRate <= 0:
                                _2999 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[_2999 + idx + 68] = mem[_2905 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_2999 + 68] = mem[_2999 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _2999 + -mem[64] + 100
                            require devFundDivRate
                            require ext_code.size(sub_64d46cecAddress)
                            call sub_64d46cecAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args devaddr, 0 / totalAllocPoint / devFundDivRate
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = this.address
                            mem[mem[64] + 36] = 0 / totalAllocPoint
                            require ext_code.size(sub_64d46cecAddress)
                            call sub_64d46cecAddress.0x40c10f19 with:
                                 gas gas_remaining wei
                                args address(this.address), 0 / totalAllocPoint
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            if not 0 / totalAllocPoint:
                                _3705 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_3705] = 26
                                mem[_3705 + 32] = 'SafeMath: division by zero'
                                if ext_call.return_data[0] > 0:
                                    require ext_call.return_data[0]
                                    if poolInfo[idx].field_768 + (0 / ext_call.return_data[0]) < poolInfo[idx].field_768:
                                        revert with 0, 'SafeMath: addition overflow'
                                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                    poolInfo[idx].field_512 = block.number
                                    idx = idx + 1
                                    continue 
                                _3793 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[_3793 + idx + 68] = mem[_3705 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_3793 + 68] = mem[_3793 + 74 len 26]
                                revert with memory
                                  from mem[64]
                                   len _3793 + -mem[64] + 100
                            require 0 / totalAllocPoint
                            if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                            _3792 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3792] = 26
                            mem[_3792 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0] > 0:
                                require ext_call.return_data[0]
                                if poolInfo[idx].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _3886 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3886 + idx + 68] = mem[_3792 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3886 + 68] = mem[_3886 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _3886 + -mem[64] + 100
                        require (block.number * sub_a3eef5b2) - (bonusEndBlock * sub_a3eef5b2)
                        if (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / (block.number * sub_a3eef5b2) - (bonusEndBlock * sub_a3eef5b2) != poolInfo[idx].field_256:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _2716 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2716] = 26
                        mem[_2716 + 32] = 'SafeMath: division by zero'
                        if totalAllocPoint <= 0:
                            _2814 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2814 + idx + 68] = mem[_2716 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2814 + 68] = mem[_2814 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _2814 + -mem[64] + 100
                        require totalAllocPoint
                        _2997 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2997] = 26
                        mem[_2997 + 32] = 'SafeMath: division by zero'
                        if devFundDivRate <= 0:
                            _3094 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3094 + idx + 68] = mem[_2997 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3094 + 68] = mem[_3094 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _3094 + -mem[64] + 100
                        require devFundDivRate
                        require ext_code.size(sub_64d46cecAddress)
                        call sub_64d46cecAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args devaddr, (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint
                        require ext_code.size(sub_64d46cecAddress)
                        call sub_64d46cecAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args address(this.address), (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint:
                            _3791 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3791] = 26
                            mem[_3791 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0] > 0:
                                require ext_call.return_data[0]
                                if poolInfo[idx].field_768 + (0 / ext_call.return_data[0]) < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _3883 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3883 + idx + 68] = mem[_3791 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3883 + 68] = mem[_3883 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _3883 + -mem[64] + 100
                        require (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint
                        if 10^12 * (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint / (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _3882 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3882] = 26
                        mem[_3882 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0] > 0:
                            require ext_call.return_data[0]
                            if poolInfo[idx].field_768 + (10^12 * (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^12 * (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _3979 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3979 + idx + 68] = mem[_3882 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3979 + 68] = mem[_3979 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _3979 + -mem[64] + 100
                    require bonusEndBlock - poolInfo[idx].field_512
                    if bonusEndBlock - poolInfo[idx].field_512 / bonusEndBlock - poolInfo[idx].field_512 != 1:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if block.number < bonusEndBlock:
                        revert with 0, 'SafeMath: addition overflow'
                    if not -poolInfo[idx].field_512 + block.number:
                        _2621 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2621] = 26
                        mem[_2621 + 32] = 'SafeMath: division by zero'
                        if totalAllocPoint <= 0:
                            _2713 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2713 + idx + 68] = mem[_2621 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2713 + 68] = mem[_2713 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _2713 + -mem[64] + 100
                        require totalAllocPoint
                        _2902 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2902] = 26
                        mem[_2902 + 32] = 'SafeMath: division by zero'
                        if devFundDivRate <= 0:
                            _2994 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2994 + idx + 68] = mem[_2902 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2994 + 68] = mem[_2994 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _2994 + -mem[64] + 100
                        require devFundDivRate
                        require ext_code.size(sub_64d46cecAddress)
                        call sub_64d46cecAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args devaddr, 0 / totalAllocPoint / devFundDivRate
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sub_64d46cecAddress)
                        call sub_64d46cecAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args address(this.address), 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not 0 / totalAllocPoint:
                            _3704 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3704] = 26
                            mem[_3704 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0] > 0:
                                require ext_call.return_data[0]
                                if poolInfo[idx].field_768 + (0 / ext_call.return_data[0]) < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _3788 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3788 + idx + 68] = mem[_3704 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3788 + 68] = mem[_3788 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _3788 + -mem[64] + 100
                        require 0 / totalAllocPoint
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _3787 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3787] = 26
                        mem[_3787 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0] > 0:
                            require ext_call.return_data[0]
                            if poolInfo[idx].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _3878 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3878 + idx + 68] = mem[_3787 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3878 + 68] = mem[_3878 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _3878 + -mem[64] + 100
                    require -poolInfo[idx].field_512 + block.number
                    if (-1 * poolInfo[idx].field_512 * sub_a3eef5b2) + (block.number * sub_a3eef5b2) / -poolInfo[idx].field_512 + block.number != sub_a3eef5b2:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if not (-1 * poolInfo[idx].field_512 * sub_a3eef5b2) + (block.number * sub_a3eef5b2):
                        _2712 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2712] = 26
                        mem[_2712 + 32] = 'SafeMath: division by zero'
                        if totalAllocPoint <= 0:
                            _2810 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2810 + idx + 68] = mem[_2712 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2810 + 68] = mem[_2810 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _2810 + -mem[64] + 100
                        require totalAllocPoint
                        _2992 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2992] = 26
                        mem[_2992 + 32] = 'SafeMath: division by zero'
                        if devFundDivRate <= 0:
                            _3090 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3090 + idx + 68] = mem[_2992 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3090 + 68] = mem[_3090 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _3090 + -mem[64] + 100
                        require devFundDivRate
                        require ext_code.size(sub_64d46cecAddress)
                        call sub_64d46cecAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args devaddr, 0 / totalAllocPoint / devFundDivRate
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sub_64d46cecAddress)
                        call sub_64d46cecAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args address(this.address), 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not 0 / totalAllocPoint:
                            _3786 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3786] = 26
                            mem[_3786 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0] > 0:
                                require ext_call.return_data[0]
                                if poolInfo[idx].field_768 + (0 / ext_call.return_data[0]) < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _3875 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3875 + idx + 68] = mem[_3786 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3875 + 68] = mem[_3875 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _3875 + -mem[64] + 100
                        require 0 / totalAllocPoint
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _3874 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3874] = 26
                        mem[_3874 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0] > 0:
                            require ext_call.return_data[0]
                            if poolInfo[idx].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _3973 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3973 + idx + 68] = mem[_3874 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3973 + 68] = mem[_3973 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _3973 + -mem[64] + 100
                    require (-1 * poolInfo[idx].field_512 * sub_a3eef5b2) + (block.number * sub_a3eef5b2)
                    if (-1 * poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) + (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) / (-1 * poolInfo[idx].field_512 * sub_a3eef5b2) + (block.number * sub_a3eef5b2) != poolInfo[idx].field_256:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _2809 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2809] = 26
                    mem[_2809 + 32] = 'SafeMath: division by zero'
                    if totalAllocPoint <= 0:
                        _2898 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2898 + idx + 68] = mem[_2809 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2898 + 68] = mem[_2898 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _2898 + -mem[64] + 100
                    require totalAllocPoint
                    _3088 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3088] = 26
                    mem[_3088 + 32] = 'SafeMath: division by zero'
                    if devFundDivRate <= 0:
                        _3209 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3209 + idx + 68] = mem[_3088 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3209 + 68] = mem[_3209 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _3209 + -mem[64] + 100
                    require devFundDivRate
                    require ext_code.size(sub_64d46cecAddress)
                    call sub_64d46cecAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args devaddr, (-1 * poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) + (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = (-1 * poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) + (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint
                    require ext_code.size(sub_64d46cecAddress)
                    call sub_64d46cecAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args address(this.address), (-1 * poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) + (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not (-1 * poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) + (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint:
                        _3873 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3873] = 26
                        mem[_3873 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0] > 0:
                            require ext_call.return_data[0]
                            if poolInfo[idx].field_768 + (0 / ext_call.return_data[0]) < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _3970 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3970 + idx + 68] = mem[_3873 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3970 + 68] = mem[_3970 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _3970 + -mem[64] + 100
                    require (-1 * poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) + (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint
                    if 10^12 * (-1 * poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) + (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint / (-1 * poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) + (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _3969 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3969] = 26
                    mem[_3969 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0] > 0:
                        require ext_call.return_data[0]
                        if poolInfo[idx].field_768 + (10^12 * (-1 * poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) + (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^12 * (-1 * poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) + (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4072 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_4072 + idx + 68] = mem[_3969 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_4072 + 68] = mem[_4072 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4072 + -mem[64] + 100
                if endBlock <= bonusEndBlock:
                    _2156 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2156] = 30
                    mem[_2156 + 32] = 'SafeMath: subtraction overflow'
                    if poolInfo[idx].field_512 > endBlock:
                        _2172 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_2172 + idx + 68] = mem[_2156 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2172 + 68] = mem[_2172 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _2172 + -mem[64] + 100
                    if not endBlock - poolInfo[idx].field_512:
                        _2349 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2349] = 26
                        mem[_2349 + 32] = 'SafeMath: division by zero'
                        if totalAllocPoint <= 0:
                            _2384 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2384 + idx + 68] = mem[_2349 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2384 + 68] = mem[_2384 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _2384 + -mem[64] + 100
                        require totalAllocPoint
                        _2499 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2499] = 26
                        mem[_2499 + 32] = 'SafeMath: division by zero'
                        if devFundDivRate <= 0:
                            _2566 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2566 + idx + 68] = mem[_2499 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2566 + 68] = mem[_2566 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _2566 + -mem[64] + 100
                        require devFundDivRate
                        require ext_code.size(sub_64d46cecAddress)
                        call sub_64d46cecAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args devaddr, 0 / totalAllocPoint / devFundDivRate
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sub_64d46cecAddress)
                        call sub_64d46cecAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args address(this.address), 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not 0 / totalAllocPoint:
                            _3118 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3118] = 26
                            mem[_3118 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0] > 0:
                                require ext_call.return_data[0]
                                if poolInfo[idx].field_768 + (0 / ext_call.return_data[0]) < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _3242 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3242 + idx + 68] = mem[_3118 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3242 + 68] = mem[_3242 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _3242 + -mem[64] + 100
                        require 0 / totalAllocPoint
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _3241 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3241] = 26
                        mem[_3241 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0] > 0:
                            require ext_call.return_data[0]
                            if poolInfo[idx].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _3390 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3390 + idx + 68] = mem[_3241 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3390 + 68] = mem[_3390 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _3390 + -mem[64] + 100
                    require endBlock - poolInfo[idx].field_512
                    if endBlock - poolInfo[idx].field_512 / endBlock - poolInfo[idx].field_512 != 1:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if not endBlock - poolInfo[idx].field_512:
                        _2383 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2383] = 26
                        mem[_2383 + 32] = 'SafeMath: division by zero'
                        if totalAllocPoint <= 0:
                            _2437 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2437 + idx + 68] = mem[_2383 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2437 + 68] = mem[_2437 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _2437 + -mem[64] + 100
                        require totalAllocPoint
                        _2564 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2564] = 26
                        mem[_2564 + 32] = 'SafeMath: division by zero'
                        if devFundDivRate <= 0:
                            _2645 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2645 + idx + 68] = mem[_2564 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2645 + 68] = mem[_2645 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _2645 + -mem[64] + 100
                        require devFundDivRate
                        require ext_code.size(sub_64d46cecAddress)
                        call sub_64d46cecAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args devaddr, 0 / totalAllocPoint / devFundDivRate
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sub_64d46cecAddress)
                        call sub_64d46cecAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args address(this.address), 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not 0 / totalAllocPoint:
                            _3240 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3240] = 26
                            mem[_3240 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0] > 0:
                                require ext_call.return_data[0]
                                if poolInfo[idx].field_768 + (0 / ext_call.return_data[0]) < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _3387 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3387 + idx + 68] = mem[_3240 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3387 + 68] = mem[_3387 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _3387 + -mem[64] + 100
                        require 0 / totalAllocPoint
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _3386 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3386] = 26
                        mem[_3386 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0] > 0:
                            require ext_call.return_data[0]
                            if poolInfo[idx].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _3528 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3528 + idx + 68] = mem[_3386 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3528 + 68] = mem[_3528 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _3528 + -mem[64] + 100
                    require endBlock - poolInfo[idx].field_512
                    if (endBlock * sub_a3eef5b2) - (poolInfo[idx].field_512 * sub_a3eef5b2) / endBlock - poolInfo[idx].field_512 != sub_a3eef5b2:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if not (endBlock * sub_a3eef5b2) - (poolInfo[idx].field_512 * sub_a3eef5b2):
                        _2436 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2436] = 26
                        mem[_2436 + 32] = 'SafeMath: division by zero'
                        if totalAllocPoint <= 0:
                            _2495 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2495 + idx + 68] = mem[_2436 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2495 + 68] = mem[_2495 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _2495 + -mem[64] + 100
                        require totalAllocPoint
                        _2643 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2643] = 26
                        mem[_2643 + 32] = 'SafeMath: division by zero'
                        if devFundDivRate <= 0:
                            _2738 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2738 + idx + 68] = mem[_2643 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2738 + 68] = mem[_2738 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _2738 + -mem[64] + 100
                        require devFundDivRate
                        require ext_code.size(sub_64d46cecAddress)
                        call sub_64d46cecAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args devaddr, 0 / totalAllocPoint / devFundDivRate
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sub_64d46cecAddress)
                        call sub_64d46cecAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args address(this.address), 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not 0 / totalAllocPoint:
                            _3385 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3385] = 26
                            mem[_3385 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0] > 0:
                                require ext_call.return_data[0]
                                if poolInfo[idx].field_768 + (0 / ext_call.return_data[0]) < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _3525 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3525 + idx + 68] = mem[_3385 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3525 + 68] = mem[_3525 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _3525 + -mem[64] + 100
                        require 0 / totalAllocPoint
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _3524 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3524] = 26
                        mem[_3524 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0] > 0:
                            require ext_call.return_data[0]
                            if poolInfo[idx].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _3636 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3636 + idx + 68] = mem[_3524 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3636 + 68] = mem[_3636 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _3636 + -mem[64] + 100
                    require (endBlock * sub_a3eef5b2) - (poolInfo[idx].field_512 * sub_a3eef5b2)
                    if (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) / (endBlock * sub_a3eef5b2) - (poolInfo[idx].field_512 * sub_a3eef5b2) != poolInfo[idx].field_256:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _2494 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2494] = 26
                    mem[_2494 + 32] = 'SafeMath: division by zero'
                    if totalAllocPoint <= 0:
                        _2560 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2560 + idx + 68] = mem[_2494 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2560 + 68] = mem[_2560 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _2560 + -mem[64] + 100
                    require totalAllocPoint
                    _2736 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2736] = 26
                    mem[_2736 + 32] = 'SafeMath: division by zero'
                    if devFundDivRate <= 0:
                        _2830 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2830 + idx + 68] = mem[_2736 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2830 + 68] = mem[_2830 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _2830 + -mem[64] + 100
                    require devFundDivRate
                    require ext_code.size(sub_64d46cecAddress)
                    call sub_64d46cecAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args devaddr, (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint
                    require ext_code.size(sub_64d46cecAddress)
                    call sub_64d46cecAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args address(this.address), (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint:
                        _3523 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3523] = 26
                        mem[_3523 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0] > 0:
                            require ext_call.return_data[0]
                            if poolInfo[idx].field_768 + (0 / ext_call.return_data[0]) < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _3633 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3633 + idx + 68] = mem[_3523 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3633 + 68] = mem[_3633 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _3633 + -mem[64] + 100
                    require (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint
                    if 10^12 * (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint / (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _3632 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3632] = 26
                    mem[_3632 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0] > 0:
                        require ext_call.return_data[0]
                        if poolInfo[idx].field_768 + (10^12 * (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^12 * (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _3724 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3724 + idx + 68] = mem[_3632 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3724 + 68] = mem[_3724 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _3724 + -mem[64] + 100
                if poolInfo[idx].field_512 >= bonusEndBlock:
                    _2162 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2162] = 30
                    mem[_2162 + 32] = 'SafeMath: subtraction overflow'
                    if poolInfo[idx].field_512 > endBlock:
                        _2184 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_2184 + idx + 68] = mem[_2162 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2184 + 68] = mem[_2184 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _2184 + -mem[64] + 100
                    if not endBlock - poolInfo[idx].field_512:
                        _2310 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2310] = 26
                        mem[_2310 + 32] = 'SafeMath: division by zero'
                        if totalAllocPoint <= 0:
                            _2335 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2335 + idx + 68] = mem[_2310 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2335 + 68] = mem[_2335 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _2335 + -mem[64] + 100
                        require totalAllocPoint
                        _2407 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2407] = 26
                        mem[_2407 + 32] = 'SafeMath: division by zero'
                        if devFundDivRate <= 0:
                            _2466 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2466 + idx + 68] = mem[_2407 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2466 + 68] = mem[_2466 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _2466 + -mem[64] + 100
                        require devFundDivRate
                        require ext_code.size(sub_64d46cecAddress)
                        call sub_64d46cecAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args devaddr, 0 / totalAllocPoint / devFundDivRate
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sub_64d46cecAddress)
                        call sub_64d46cecAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args address(this.address), 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not 0 / totalAllocPoint:
                            _2959 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_2959] = 26
                            mem[_2959 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0] > 0:
                                require ext_call.return_data[0]
                                if poolInfo[idx].field_768 + (0 / ext_call.return_data[0]) < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _3058 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3058 + idx + 68] = mem[_2959 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3058 + 68] = mem[_3058 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _3058 + -mem[64] + 100
                        require 0 / totalAllocPoint
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _3057 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3057] = 26
                        mem[_3057 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0] > 0:
                            require ext_call.return_data[0]
                            if poolInfo[idx].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _3176 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3176 + idx + 68] = mem[_3057 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3176 + 68] = mem[_3176 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _3176 + -mem[64] + 100
                    require endBlock - poolInfo[idx].field_512
                    if (endBlock * sub_a3eef5b2) - (poolInfo[idx].field_512 * sub_a3eef5b2) / endBlock - poolInfo[idx].field_512 != sub_a3eef5b2:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if not (endBlock * sub_a3eef5b2) - (poolInfo[idx].field_512 * sub_a3eef5b2):
                        _2334 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2334] = 26
                        mem[_2334 + 32] = 'SafeMath: division by zero'
                        if totalAllocPoint <= 0:
                            _2363 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2363 + idx + 68] = mem[_2334 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2363 + 68] = mem[_2363 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _2363 + -mem[64] + 100
                        require totalAllocPoint
                        _2464 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2464] = 26
                        mem[_2464 + 32] = 'SafeMath: division by zero'
                        if devFundDivRate <= 0:
                            _2532 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2532 + idx + 68] = mem[_2464 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2532 + 68] = mem[_2532 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _2532 + -mem[64] + 100
                        require devFundDivRate
                        require ext_code.size(sub_64d46cecAddress)
                        call sub_64d46cecAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args devaddr, 0 / totalAllocPoint / devFundDivRate
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sub_64d46cecAddress)
                        call sub_64d46cecAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args address(this.address), 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not 0 / totalAllocPoint:
                            _3056 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3056] = 26
                            mem[_3056 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0] > 0:
                                require ext_call.return_data[0]
                                if poolInfo[idx].field_768 + (0 / ext_call.return_data[0]) < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _3173 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3173 + idx + 68] = mem[_3056 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3173 + 68] = mem[_3173 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _3173 + -mem[64] + 100
                        require 0 / totalAllocPoint
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _3172 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3172] = 26
                        mem[_3172 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0] > 0:
                            require ext_call.return_data[0]
                            if poolInfo[idx].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _3310 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3310 + idx + 68] = mem[_3172 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3310 + 68] = mem[_3310 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _3310 + -mem[64] + 100
                    require (endBlock * sub_a3eef5b2) - (poolInfo[idx].field_512 * sub_a3eef5b2)
                    if (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) / (endBlock * sub_a3eef5b2) - (poolInfo[idx].field_512 * sub_a3eef5b2) != poolInfo[idx].field_256:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _2362 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2362] = 26
                    mem[_2362 + 32] = 'SafeMath: division by zero'
                    if totalAllocPoint <= 0:
                        _2403 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2403 + idx + 68] = mem[_2362 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2403 + 68] = mem[_2403 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _2403 + -mem[64] + 100
                    require totalAllocPoint
                    _2530 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2530] = 26
                    mem[_2530 + 32] = 'SafeMath: division by zero'
                    if devFundDivRate <= 0:
                        _2599 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2599 + idx + 68] = mem[_2530 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2599 + 68] = mem[_2599 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _2599 + -mem[64] + 100
                    require devFundDivRate
                    require ext_code.size(sub_64d46cecAddress)
                    call sub_64d46cecAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args devaddr, (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint
                    require ext_code.size(sub_64d46cecAddress)
                    call sub_64d46cecAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args address(this.address), (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint:
                        _3171 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3171] = 26
                        mem[_3171 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0] > 0:
                            require ext_call.return_data[0]
                            if poolInfo[idx].field_768 + (0 / ext_call.return_data[0]) < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _3307 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3307 + idx + 68] = mem[_3171 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3307 + 68] = mem[_3307 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _3307 + -mem[64] + 100
                    require (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint
                    if 10^12 * (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint / (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _3306 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3306] = 26
                    mem[_3306 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0] > 0:
                        require ext_call.return_data[0]
                        if poolInfo[idx].field_768 + (10^12 * (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^12 * (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) - (poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _3456 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3456 + idx + 68] = mem[_3306 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3456 + 68] = mem[_3456 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _3456 + -mem[64] + 100
                _2161 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2161] = 30
                mem[_2161 + 32] = 'SafeMath: subtraction overflow'
                if bonusEndBlock > endBlock:
                    _2181 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_2181 + idx + 68] = mem[_2161 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2181 + 68] = mem[_2181 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _2181 + -mem[64] + 100
                _2225 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2225] = 30
                mem[_2225 + 32] = 'SafeMath: subtraction overflow'
                if poolInfo[idx].field_512 > bonusEndBlock:
                    _2256 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_2256 + idx + 68] = mem[_2225 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2256 + 68] = mem[_2256 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _2256 + -mem[64] + 100
                if not bonusEndBlock - poolInfo[idx].field_512:
                    if endBlock - bonusEndBlock < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    if not endBlock - bonusEndBlock:
                        _2598 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2598] = 26
                        mem[_2598 + 32] = 'SafeMath: division by zero'
                        if totalAllocPoint <= 0:
                            _2683 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2683 + idx + 68] = mem[_2598 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2683 + 68] = mem[_2683 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _2683 + -mem[64] + 100
                        require totalAllocPoint
                        _2871 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2871] = 26
                        mem[_2871 + 32] = 'SafeMath: division by zero'
                        if devFundDivRate <= 0:
                            _2956 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2956 + idx + 68] = mem[_2871 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2956 + 68] = mem[_2956 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _2956 + -mem[64] + 100
                        require devFundDivRate
                        require ext_code.size(sub_64d46cecAddress)
                        call sub_64d46cecAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args devaddr, 0 / totalAllocPoint / devFundDivRate
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sub_64d46cecAddress)
                        call sub_64d46cecAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args address(this.address), 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not 0 / totalAllocPoint:
                            _3681 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3681] = 26
                            mem[_3681 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0] > 0:
                                require ext_call.return_data[0]
                                if poolInfo[idx].field_768 + (0 / ext_call.return_data[0]) < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _3757 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3757 + idx + 68] = mem[_3681 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3757 + 68] = mem[_3757 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _3757 + -mem[64] + 100
                        require 0 / totalAllocPoint
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _3756 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3756] = 26
                        mem[_3756 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0] > 0:
                            require ext_call.return_data[0]
                            if poolInfo[idx].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _3841 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3841 + idx + 68] = mem[_3756 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3841 + 68] = mem[_3841 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _3841 + -mem[64] + 100
                    require endBlock - bonusEndBlock
                    if (endBlock * sub_a3eef5b2) - (bonusEndBlock * sub_a3eef5b2) / endBlock - bonusEndBlock != sub_a3eef5b2:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if not (endBlock * sub_a3eef5b2) - (bonusEndBlock * sub_a3eef5b2):
                        _2682 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2682] = 26
                        mem[_2682 + 32] = 'SafeMath: division by zero'
                        if totalAllocPoint <= 0:
                            _2781 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_2781 + idx + 68] = mem[_2682 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_2781 + 68] = mem[_2781 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _2781 + -mem[64] + 100
                        require totalAllocPoint
                        _2954 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2954] = 26
                        mem[_2954 + 32] = 'SafeMath: division by zero'
                        if devFundDivRate <= 0:
                            _3052 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3052 + idx + 68] = mem[_2954 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3052 + 68] = mem[_3052 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _3052 + -mem[64] + 100
                        require devFundDivRate
                        require ext_code.size(sub_64d46cecAddress)
                        call sub_64d46cecAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args devaddr, 0 / totalAllocPoint / devFundDivRate
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = this.address
                        mem[mem[64] + 36] = 0 / totalAllocPoint
                        require ext_code.size(sub_64d46cecAddress)
                        call sub_64d46cecAddress.0x40c10f19 with:
                             gas gas_remaining wei
                            args address(this.address), 0 / totalAllocPoint
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        if not 0 / totalAllocPoint:
                            _3755 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_3755] = 26
                            mem[_3755 + 32] = 'SafeMath: division by zero'
                            if ext_call.return_data[0] > 0:
                                require ext_call.return_data[0]
                                if poolInfo[idx].field_768 + (0 / ext_call.return_data[0]) < poolInfo[idx].field_768:
                                    revert with 0, 'SafeMath: addition overflow'
                                poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                                poolInfo[idx].field_512 = block.number
                                idx = idx + 1
                                continue 
                            _3838 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[_3838 + idx + 68] = mem[_3755 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3838 + 68] = mem[_3838 + 74 len 26]
                            revert with memory
                              from mem[64]
                               len _3838 + -mem[64] + 100
                        require 0 / totalAllocPoint
                        if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                            revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                        _3837 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3837] = 26
                        mem[_3837 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0] > 0:
                            require ext_call.return_data[0]
                            if poolInfo[idx].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _3938 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3938 + idx + 68] = mem[_3837 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3938 + 68] = mem[_3938 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _3938 + -mem[64] + 100
                    require (endBlock * sub_a3eef5b2) - (bonusEndBlock * sub_a3eef5b2)
                    if (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / (endBlock * sub_a3eef5b2) - (bonusEndBlock * sub_a3eef5b2) != poolInfo[idx].field_256:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _2780 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2780] = 26
                    mem[_2780 + 32] = 'SafeMath: division by zero'
                    if totalAllocPoint <= 0:
                        _2867 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2867 + idx + 68] = mem[_2780 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2867 + 68] = mem[_2867 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _2867 + -mem[64] + 100
                    require totalAllocPoint
                    _3050 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3050] = 26
                    mem[_3050 + 32] = 'SafeMath: division by zero'
                    if devFundDivRate <= 0:
                        _3166 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3166 + idx + 68] = mem[_3050 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3166 + 68] = mem[_3166 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _3166 + -mem[64] + 100
                    require devFundDivRate
                    require ext_code.size(sub_64d46cecAddress)
                    call sub_64d46cecAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args devaddr, (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint
                    require ext_code.size(sub_64d46cecAddress)
                    call sub_64d46cecAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args address(this.address), (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint:
                        _3836 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3836] = 26
                        mem[_3836 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0] > 0:
                            require ext_call.return_data[0]
                            if poolInfo[idx].field_768 + (0 / ext_call.return_data[0]) < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _3935 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3935 + idx + 68] = mem[_3836 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3935 + 68] = mem[_3935 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _3935 + -mem[64] + 100
                    require (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint
                    if 10^12 * (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint / (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _3934 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3934] = 26
                    mem[_3934 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0] > 0:
                        require ext_call.return_data[0]
                        if poolInfo[idx].field_768 + (10^12 * (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^12 * (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4040 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_4040 + idx + 68] = mem[_3934 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_4040 + 68] = mem[_4040 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4040 + -mem[64] + 100
                require bonusEndBlock - poolInfo[idx].field_512
                if bonusEndBlock - poolInfo[idx].field_512 / bonusEndBlock - poolInfo[idx].field_512 != 1:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if endBlock < bonusEndBlock:
                    revert with 0, 'SafeMath: addition overflow'
                if not -poolInfo[idx].field_512 + endBlock:
                    _2681 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2681] = 26
                    mem[_2681 + 32] = 'SafeMath: division by zero'
                    if totalAllocPoint <= 0:
                        _2777 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2777 + idx + 68] = mem[_2681 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2777 + 68] = mem[_2777 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _2777 + -mem[64] + 100
                    require totalAllocPoint
                    _2951 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2951] = 26
                    mem[_2951 + 32] = 'SafeMath: division by zero'
                    if devFundDivRate <= 0:
                        _3047 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3047 + idx + 68] = mem[_2951 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3047 + 68] = mem[_3047 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _3047 + -mem[64] + 100
                    require devFundDivRate
                    require ext_code.size(sub_64d46cecAddress)
                    call sub_64d46cecAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args devaddr, 0 / totalAllocPoint / devFundDivRate
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sub_64d46cecAddress)
                    call sub_64d46cecAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args address(this.address), 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not 0 / totalAllocPoint:
                        _3754 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3754] = 26
                        mem[_3754 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0] > 0:
                            require ext_call.return_data[0]
                            if poolInfo[idx].field_768 + (0 / ext_call.return_data[0]) < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _3833 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3833 + idx + 68] = mem[_3754 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3833 + 68] = mem[_3833 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _3833 + -mem[64] + 100
                    require 0 / totalAllocPoint
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _3832 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3832] = 26
                    mem[_3832 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0] > 0:
                        require ext_call.return_data[0]
                        if poolInfo[idx].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _3930 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3930 + idx + 68] = mem[_3832 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3930 + 68] = mem[_3930 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _3930 + -mem[64] + 100
                require -poolInfo[idx].field_512 + endBlock
                if (-1 * poolInfo[idx].field_512 * sub_a3eef5b2) + (endBlock * sub_a3eef5b2) / -poolInfo[idx].field_512 + endBlock != sub_a3eef5b2:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if not (-1 * poolInfo[idx].field_512 * sub_a3eef5b2) + (endBlock * sub_a3eef5b2):
                    _2776 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2776] = 26
                    mem[_2776 + 32] = 'SafeMath: division by zero'
                    if totalAllocPoint <= 0:
                        _2863 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2863 + idx + 68] = mem[_2776 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2863 + 68] = mem[_2863 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _2863 + -mem[64] + 100
                    require totalAllocPoint
                    _3045 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3045] = 26
                    mem[_3045 + 32] = 'SafeMath: division by zero'
                    if devFundDivRate <= 0:
                        _3162 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3162 + idx + 68] = mem[_3045 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3162 + 68] = mem[_3162 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _3162 + -mem[64] + 100
                    require devFundDivRate
                    require ext_code.size(sub_64d46cecAddress)
                    call sub_64d46cecAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args devaddr, 0 / totalAllocPoint / devFundDivRate
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sub_64d46cecAddress)
                    call sub_64d46cecAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args address(this.address), 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not 0 / totalAllocPoint:
                        _3831 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3831] = 26
                        mem[_3831 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0] > 0:
                            require ext_call.return_data[0]
                            if poolInfo[idx].field_768 + (0 / ext_call.return_data[0]) < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _3927 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3927 + idx + 68] = mem[_3831 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3927 + 68] = mem[_3927 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _3927 + -mem[64] + 100
                    require 0 / totalAllocPoint
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _3926 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3926] = 26
                    mem[_3926 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0] > 0:
                        require ext_call.return_data[0]
                        if poolInfo[idx].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4034 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_4034 + idx + 68] = mem[_3926 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_4034 + 68] = mem[_4034 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4034 + -mem[64] + 100
                require (-1 * poolInfo[idx].field_512 * sub_a3eef5b2) + (endBlock * sub_a3eef5b2)
                if (-1 * poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) + (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / (-1 * poolInfo[idx].field_512 * sub_a3eef5b2) + (endBlock * sub_a3eef5b2) != poolInfo[idx].field_256:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _2862 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2862] = 26
                mem[_2862 + 32] = 'SafeMath: division by zero'
                if totalAllocPoint <= 0:
                    _2947 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2947 + idx + 68] = mem[_2862 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2947 + 68] = mem[_2947 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _2947 + -mem[64] + 100
                require totalAllocPoint
                _3160 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3160] = 26
                mem[_3160 + 32] = 'SafeMath: division by zero'
                if devFundDivRate <= 0:
                    _3299 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3299 + idx + 68] = mem[_3160 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3299 + 68] = mem[_3299 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _3299 + -mem[64] + 100
                require devFundDivRate
                require ext_code.size(sub_64d46cecAddress)
                call sub_64d46cecAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args devaddr, (-1 * poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) + (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = (-1 * poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) + (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint
                require ext_code.size(sub_64d46cecAddress)
                call sub_64d46cecAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args address(this.address), (-1 * poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) + (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if not (-1 * poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) + (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint:
                    _3925 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3925] = 26
                    mem[_3925 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0] > 0:
                        require ext_call.return_data[0]
                        if poolInfo[idx].field_768 + (0 / ext_call.return_data[0]) < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4031 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_4031 + idx + 68] = mem[_3925 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_4031 + 68] = mem[_4031 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4031 + -mem[64] + 100
                require (-1 * poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) + (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint
                if 10^12 * (-1 * poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) + (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint / (-1 * poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) + (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _4030 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4030] = 26
                mem[_4030 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0] > 0:
                    require ext_call.return_data[0]
                    if poolInfo[idx].field_768 + (10^12 * (-1 * poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) + (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^12 * (-1 * poolInfo[idx].field_512 * sub_a3eef5b2 * poolInfo[idx].field_256) + (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _4133 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_4133 + idx + 68] = mem[_4030 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_4133 + 68] = mem[_4133 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _4133 + -mem[64] + 100
            if block.number > endBlock:
                if endBlock <= bonusEndBlock:
                    _2165 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2165] = 30
                    mem[_2165 + 32] = 'SafeMath: subtraction overflow'
                    if endBlock > endBlock:
                        _2193 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_2193 + idx + 68] = mem[_2165 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2193 + 68] = mem[_2193 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _2193 + -mem[64] + 100
                    _2372 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2372] = 26
                    mem[_2372 + 32] = 'SafeMath: division by zero'
                    if totalAllocPoint <= 0:
                        _2421 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2421 + idx + 68] = mem[_2372 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2421 + 68] = mem[_2421 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _2421 + -mem[64] + 100
                    require totalAllocPoint
                    _2546 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2546] = 26
                    mem[_2546 + 32] = 'SafeMath: division by zero'
                    if devFundDivRate <= 0:
                        _2618 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2618 + idx + 68] = mem[_2546 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2618 + 68] = mem[_2618 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _2618 + -mem[64] + 100
                    require devFundDivRate
                    require ext_code.size(sub_64d46cecAddress)
                    call sub_64d46cecAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args devaddr, 0 / totalAllocPoint / devFundDivRate
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sub_64d46cecAddress)
                    call sub_64d46cecAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args address(this.address), 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not 0 / totalAllocPoint:
                        _3208 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3208] = 26
                        mem[_3208 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0] > 0:
                            require ext_call.return_data[0]
                            if poolInfo[idx].field_768 + (0 / ext_call.return_data[0]) < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _3350 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3350 + idx + 68] = mem[_3208 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3350 + 68] = mem[_3350 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _3350 + -mem[64] + 100
                    require 0 / totalAllocPoint
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _3349 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3349] = 26
                    mem[_3349 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0] > 0:
                        require ext_call.return_data[0]
                        if poolInfo[idx].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _3493 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3493 + idx + 68] = mem[_3349 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3493 + 68] = mem[_3493 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _3493 + -mem[64] + 100
                if endBlock >= bonusEndBlock:
                    _2179 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2179] = 30
                    mem[_2179 + 32] = 'SafeMath: subtraction overflow'
                    if endBlock > endBlock:
                        _2205 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[_2205 + idx + 68] = mem[_2179 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2205 + 68] = mem[_2205 + 70 len 30]
                        revert with memory
                          from mem[64]
                           len _2205 + -mem[64] + 100
                    _2330 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2330] = 26
                    mem[_2330 + 32] = 'SafeMath: division by zero'
                    if totalAllocPoint <= 0:
                        _2353 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2353 + idx + 68] = mem[_2330 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2353 + 68] = mem[_2353 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _2353 + -mem[64] + 100
                    require totalAllocPoint
                    _2450 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2450] = 26
                    mem[_2450 + 32] = 'SafeMath: division by zero'
                    if devFundDivRate <= 0:
                        _2512 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2512 + idx + 68] = mem[_2450 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2512 + 68] = mem[_2512 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _2512 + -mem[64] + 100
                    require devFundDivRate
                    require ext_code.size(sub_64d46cecAddress)
                    call sub_64d46cecAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args devaddr, 0 / totalAllocPoint / devFundDivRate
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sub_64d46cecAddress)
                    call sub_64d46cecAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args address(this.address), 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not 0 / totalAllocPoint:
                        _3034 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3034] = 26
                        mem[_3034 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0] > 0:
                            require ext_call.return_data[0]
                            if poolInfo[idx].field_768 + (0 / ext_call.return_data[0]) < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _3138 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3138 + idx + 68] = mem[_3034 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3138 + 68] = mem[_3138 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _3138 + -mem[64] + 100
                    require 0 / totalAllocPoint
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _3137 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3137] = 26
                    mem[_3137 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0] > 0:
                        require ext_call.return_data[0]
                        if poolInfo[idx].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _3268 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3268 + idx + 68] = mem[_3137 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3268 + 68] = mem[_3268 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _3268 + -mem[64] + 100
                _2178 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2178] = 30
                mem[_2178 + 32] = 'SafeMath: subtraction overflow'
                if bonusEndBlock > endBlock:
                    _2202 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_2202 + idx + 68] = mem[_2178 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2202 + 68] = mem[_2202 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _2202 + -mem[64] + 100
                _2250 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2250] = 30
                mem[_2250 + 32] = 'SafeMath: subtraction overflow'
                if endBlock > bonusEndBlock:
                    _2269 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_2269 + idx + 68] = mem[_2250 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2269 + 68] = mem[_2269 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _2269 + -mem[64] + 100
                if bonusEndBlock - endBlock:
                    require bonusEndBlock - endBlock
                    if bonusEndBlock - endBlock / bonusEndBlock - endBlock != 1:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    if 0 < bonusEndBlock - endBlock:
                        revert with 0, 'SafeMath: addition overflow'
                    _2758 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2758] = 26
                    mem[_2758 + 32] = 'SafeMath: division by zero'
                    if totalAllocPoint <= 0:
                        _2844 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2844 + idx + 68] = mem[_2758 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2844 + 68] = mem[_2844 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _2844 + -mem[64] + 100
                    require totalAllocPoint
                    _3026 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3026] = 26
                    mem[_3026 + 32] = 'SafeMath: division by zero'
                    if devFundDivRate <= 0:
                        _3128 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3128 + idx + 68] = mem[_3026 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3128 + 68] = mem[_3128 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _3128 + -mem[64] + 100
                    require devFundDivRate
                    require ext_code.size(sub_64d46cecAddress)
                    call sub_64d46cecAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args devaddr, 0 / totalAllocPoint / devFundDivRate
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sub_64d46cecAddress)
                    call sub_64d46cecAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args address(this.address), 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not 0 / totalAllocPoint:
                        _3820 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3820] = 26
                        mem[_3820 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0] > 0:
                            require ext_call.return_data[0]
                            if poolInfo[idx].field_768 + (0 / ext_call.return_data[0]) < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _3905 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3905 + idx + 68] = mem[_3820 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3905 + 68] = mem[_3905 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _3905 + -mem[64] + 100
                    require 0 / totalAllocPoint
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _3904 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3904] = 26
                    mem[_3904 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0] > 0:
                        require ext_call.return_data[0]
                        if poolInfo[idx].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4002 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_4002 + idx + 68] = mem[_3904 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_4002 + 68] = mem[_4002 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4002 + -mem[64] + 100
                if endBlock - bonusEndBlock < 0:
                    revert with 0, 'SafeMath: addition overflow'
                if not endBlock - bonusEndBlock:
                    _2664 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2664] = 26
                    mem[_2664 + 32] = 'SafeMath: division by zero'
                    if totalAllocPoint <= 0:
                        _2760 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2760 + idx + 68] = mem[_2664 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2760 + 68] = mem[_2760 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _2760 + -mem[64] + 100
                    require totalAllocPoint
                    _2938 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2938] = 26
                    mem[_2938 + 32] = 'SafeMath: division by zero'
                    if devFundDivRate <= 0:
                        _3031 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3031 + idx + 68] = mem[_2938 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3031 + 68] = mem[_3031 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _3031 + -mem[64] + 100
                    require devFundDivRate
                    require ext_code.size(sub_64d46cecAddress)
                    call sub_64d46cecAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args devaddr, 0 / totalAllocPoint / devFundDivRate
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sub_64d46cecAddress)
                    call sub_64d46cecAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args address(this.address), 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not 0 / totalAllocPoint:
                        _3744 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3744] = 26
                        mem[_3744 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0] > 0:
                            require ext_call.return_data[0]
                            if poolInfo[idx].field_768 + (0 / ext_call.return_data[0]) < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _3823 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3823 + idx + 68] = mem[_3744 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3823 + 68] = mem[_3823 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _3823 + -mem[64] + 100
                    require 0 / totalAllocPoint
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _3822 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3822] = 26
                    mem[_3822 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0] > 0:
                        require ext_call.return_data[0]
                        if poolInfo[idx].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _3913 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3913 + idx + 68] = mem[_3822 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3913 + 68] = mem[_3913 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _3913 + -mem[64] + 100
                require endBlock - bonusEndBlock
                if (endBlock * sub_a3eef5b2) - (bonusEndBlock * sub_a3eef5b2) / endBlock - bonusEndBlock != sub_a3eef5b2:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if not (endBlock * sub_a3eef5b2) - (bonusEndBlock * sub_a3eef5b2):
                    _2759 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2759] = 26
                    mem[_2759 + 32] = 'SafeMath: division by zero'
                    if totalAllocPoint <= 0:
                        _2848 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2848 + idx + 68] = mem[_2759 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2848 + 68] = mem[_2848 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _2848 + -mem[64] + 100
                    require totalAllocPoint
                    _3029 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3029] = 26
                    mem[_3029 + 32] = 'SafeMath: division by zero'
                    if devFundDivRate <= 0:
                        _3133 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3133 + idx + 68] = mem[_3029 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3133 + 68] = mem[_3133 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _3133 + -mem[64] + 100
                    require devFundDivRate
                    require ext_code.size(sub_64d46cecAddress)
                    call sub_64d46cecAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args devaddr, 0 / totalAllocPoint / devFundDivRate
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sub_64d46cecAddress)
                    call sub_64d46cecAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args address(this.address), 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not 0 / totalAllocPoint:
                        _3821 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3821] = 26
                        mem[_3821 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0] > 0:
                            require ext_call.return_data[0]
                            if poolInfo[idx].field_768 + (0 / ext_call.return_data[0]) < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _3910 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3910 + idx + 68] = mem[_3821 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3910 + 68] = mem[_3910 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _3910 + -mem[64] + 100
                    require 0 / totalAllocPoint
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _3909 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3909] = 26
                    mem[_3909 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0] > 0:
                        require ext_call.return_data[0]
                        if poolInfo[idx].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4010 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_4010 + idx + 68] = mem[_3909 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_4010 + 68] = mem[_4010 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4010 + -mem[64] + 100
                require (endBlock * sub_a3eef5b2) - (bonusEndBlock * sub_a3eef5b2)
                if (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / (endBlock * sub_a3eef5b2) - (bonusEndBlock * sub_a3eef5b2) != poolInfo[idx].field_256:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _2847 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2847] = 26
                mem[_2847 + 32] = 'SafeMath: division by zero'
                if totalAllocPoint <= 0:
                    _2934 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2934 + idx + 68] = mem[_2847 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2934 + 68] = mem[_2934 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _2934 + -mem[64] + 100
                require totalAllocPoint
                _3131 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3131] = 26
                mem[_3131 + 32] = 'SafeMath: division by zero'
                if devFundDivRate <= 0:
                    _3263 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3263 + idx + 68] = mem[_3131 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3263 + 68] = mem[_3263 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _3263 + -mem[64] + 100
                require devFundDivRate
                require ext_code.size(sub_64d46cecAddress)
                call sub_64d46cecAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args devaddr, (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint
                require ext_code.size(sub_64d46cecAddress)
                call sub_64d46cecAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args address(this.address), (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if not (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint:
                    _3908 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3908] = 26
                    mem[_3908 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0] > 0:
                        require ext_call.return_data[0]
                        if poolInfo[idx].field_768 + (0 / ext_call.return_data[0]) < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _4007 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_4007 + idx + 68] = mem[_3908 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_4007 + 68] = mem[_4007 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _4007 + -mem[64] + 100
                require (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint
                if 10^12 * (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint / (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _4006 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4006] = 26
                mem[_4006 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0] > 0:
                    require ext_call.return_data[0]
                    if poolInfo[idx].field_768 + (10^12 * (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^12 * (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _4112 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_4112 + idx + 68] = mem[_4006 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_4112 + 68] = mem[_4112 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _4112 + -mem[64] + 100
            if block.number <= bonusEndBlock:
                _2157 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2157] = 30
                mem[_2157 + 32] = 'SafeMath: subtraction overflow'
                if endBlock > block.number:
                    _2175 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_2175 + idx + 68] = mem[_2157 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2175 + 68] = mem[_2175 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _2175 + -mem[64] + 100
                if not block.number - endBlock:
                    _2350 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2350] = 26
                    mem[_2350 + 32] = 'SafeMath: division by zero'
                    if totalAllocPoint <= 0:
                        _2390 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2390 + idx + 68] = mem[_2350 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2390 + 68] = mem[_2390 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _2390 + -mem[64] + 100
                    require totalAllocPoint
                    _2510 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2510] = 26
                    mem[_2510 + 32] = 'SafeMath: division by zero'
                    if devFundDivRate <= 0:
                        _2579 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2579 + idx + 68] = mem[_2510 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2579 + 68] = mem[_2579 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _2579 + -mem[64] + 100
                    require devFundDivRate
                    require ext_code.size(sub_64d46cecAddress)
                    call sub_64d46cecAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args devaddr, 0 / totalAllocPoint / devFundDivRate
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sub_64d46cecAddress)
                    call sub_64d46cecAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args address(this.address), 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not 0 / totalAllocPoint:
                        _3127 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3127] = 26
                        mem[_3127 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0] > 0:
                            require ext_call.return_data[0]
                            if poolInfo[idx].field_768 + (0 / ext_call.return_data[0]) < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _3259 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3259 + idx + 68] = mem[_3127 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3259 + 68] = mem[_3259 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _3259 + -mem[64] + 100
                    require 0 / totalAllocPoint
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _3258 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3258] = 26
                    mem[_3258 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0] > 0:
                        require ext_call.return_data[0]
                        if poolInfo[idx].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _3417 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3417 + idx + 68] = mem[_3258 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3417 + 68] = mem[_3417 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _3417 + -mem[64] + 100
                require block.number - endBlock
                if block.number - endBlock / block.number - endBlock != 1:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if not block.number - endBlock:
                    _2389 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2389] = 26
                    mem[_2389 + 32] = 'SafeMath: division by zero'
                    if totalAllocPoint <= 0:
                        _2446 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2446 + idx + 68] = mem[_2389 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2446 + 68] = mem[_2446 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _2446 + -mem[64] + 100
                    require totalAllocPoint
                    _2577 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2577] = 26
                    mem[_2577 + 32] = 'SafeMath: division by zero'
                    if devFundDivRate <= 0:
                        _2660 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2660 + idx + 68] = mem[_2577 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2660 + 68] = mem[_2660 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _2660 + -mem[64] + 100
                    require devFundDivRate
                    require ext_code.size(sub_64d46cecAddress)
                    call sub_64d46cecAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args devaddr, 0 / totalAllocPoint / devFundDivRate
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sub_64d46cecAddress)
                    call sub_64d46cecAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args address(this.address), 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not 0 / totalAllocPoint:
                        _3257 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3257] = 26
                        mem[_3257 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0] > 0:
                            require ext_call.return_data[0]
                            if poolInfo[idx].field_768 + (0 / ext_call.return_data[0]) < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _3414 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3414 + idx + 68] = mem[_3257 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3414 + 68] = mem[_3414 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _3414 + -mem[64] + 100
                    require 0 / totalAllocPoint
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _3413 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3413] = 26
                    mem[_3413 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0] > 0:
                        require ext_call.return_data[0]
                        if poolInfo[idx].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _3555 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3555 + idx + 68] = mem[_3413 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3555 + 68] = mem[_3555 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _3555 + -mem[64] + 100
                require block.number - endBlock
                if (block.number * sub_a3eef5b2) - (endBlock * sub_a3eef5b2) / block.number - endBlock != sub_a3eef5b2:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if not (block.number * sub_a3eef5b2) - (endBlock * sub_a3eef5b2):
                    _2445 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2445] = 26
                    mem[_2445 + 32] = 'SafeMath: division by zero'
                    if totalAllocPoint <= 0:
                        _2506 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2506 + idx + 68] = mem[_2445 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2506 + 68] = mem[_2506 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _2506 + -mem[64] + 100
                    require totalAllocPoint
                    _2658 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2658] = 26
                    mem[_2658 + 32] = 'SafeMath: division by zero'
                    if devFundDivRate <= 0:
                        _2753 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2753 + idx + 68] = mem[_2658 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2753 + 68] = mem[_2753 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _2753 + -mem[64] + 100
                    require devFundDivRate
                    require ext_code.size(sub_64d46cecAddress)
                    call sub_64d46cecAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args devaddr, 0 / totalAllocPoint / devFundDivRate
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sub_64d46cecAddress)
                    call sub_64d46cecAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args address(this.address), 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not 0 / totalAllocPoint:
                        _3412 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3412] = 26
                        mem[_3412 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0] > 0:
                            require ext_call.return_data[0]
                            if poolInfo[idx].field_768 + (0 / ext_call.return_data[0]) < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _3552 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3552 + idx + 68] = mem[_3412 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3552 + 68] = mem[_3552 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _3552 + -mem[64] + 100
                    require 0 / totalAllocPoint
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _3551 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3551] = 26
                    mem[_3551 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0] > 0:
                        require ext_call.return_data[0]
                        if poolInfo[idx].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _3657 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3657 + idx + 68] = mem[_3551 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3657 + 68] = mem[_3657 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _3657 + -mem[64] + 100
                require (block.number * sub_a3eef5b2) - (endBlock * sub_a3eef5b2)
                if (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / (block.number * sub_a3eef5b2) - (endBlock * sub_a3eef5b2) != poolInfo[idx].field_256:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _2505 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2505] = 26
                mem[_2505 + 32] = 'SafeMath: division by zero'
                if totalAllocPoint <= 0:
                    _2573 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2573 + idx + 68] = mem[_2505 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2573 + 68] = mem[_2573 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _2573 + -mem[64] + 100
                require totalAllocPoint
                _2751 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2751] = 26
                mem[_2751 + 32] = 'SafeMath: division by zero'
                if devFundDivRate <= 0:
                    _2839 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2839 + idx + 68] = mem[_2751 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2839 + 68] = mem[_2839 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _2839 + -mem[64] + 100
                require devFundDivRate
                require ext_code.size(sub_64d46cecAddress)
                call sub_64d46cecAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args devaddr, (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint
                require ext_code.size(sub_64d46cecAddress)
                call sub_64d46cecAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args address(this.address), (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if not (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint:
                    _3550 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3550] = 26
                    mem[_3550 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0] > 0:
                        require ext_call.return_data[0]
                        if poolInfo[idx].field_768 + (0 / ext_call.return_data[0]) < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _3654 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3654 + idx + 68] = mem[_3550 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3654 + 68] = mem[_3654 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _3654 + -mem[64] + 100
                require (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint
                if 10^12 * (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint / (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _3653 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3653] = 26
                mem[_3653 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0] > 0:
                    require ext_call.return_data[0]
                    if poolInfo[idx].field_768 + (10^12 * (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^12 * (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _3737 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_3737 + idx + 68] = mem[_3653 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_3737 + 68] = mem[_3737 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _3737 + -mem[64] + 100
            if endBlock >= bonusEndBlock:
                _2164 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2164] = 30
                mem[_2164 + 32] = 'SafeMath: subtraction overflow'
                if endBlock > block.number:
                    _2190 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[_2190 + idx + 68] = mem[_2164 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2190 + 68] = mem[_2190 + 70 len 30]
                    revert with memory
                      from mem[64]
                       len _2190 + -mem[64] + 100
                if not block.number - endBlock:
                    _2315 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2315] = 26
                    mem[_2315 + 32] = 'SafeMath: division by zero'
                    if totalAllocPoint <= 0:
                        _2341 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2341 + idx + 68] = mem[_2315 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2341 + 68] = mem[_2341 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _2341 + -mem[64] + 100
                    require totalAllocPoint
                    _2415 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2415] = 26
                    mem[_2415 + 32] = 'SafeMath: division by zero'
                    if devFundDivRate <= 0:
                        _2474 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2474 + idx + 68] = mem[_2415 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2474 + 68] = mem[_2474 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _2474 + -mem[64] + 100
                    require devFundDivRate
                    require ext_code.size(sub_64d46cecAddress)
                    call sub_64d46cecAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args devaddr, 0 / totalAllocPoint / devFundDivRate
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sub_64d46cecAddress)
                    call sub_64d46cecAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args address(this.address), 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not 0 / totalAllocPoint:
                        _2978 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_2978] = 26
                        mem[_2978 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0] > 0:
                            require ext_call.return_data[0]
                            if poolInfo[idx].field_768 + (0 / ext_call.return_data[0]) < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _3079 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3079 + idx + 68] = mem[_2978 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3079 + 68] = mem[_3079 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _3079 + -mem[64] + 100
                    require 0 / totalAllocPoint
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _3078 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3078] = 26
                    mem[_3078 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0] > 0:
                        require ext_call.return_data[0]
                        if poolInfo[idx].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _3198 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3198 + idx + 68] = mem[_3078 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3198 + 68] = mem[_3198 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _3198 + -mem[64] + 100
                require block.number - endBlock
                if (block.number * sub_a3eef5b2) - (endBlock * sub_a3eef5b2) / block.number - endBlock != sub_a3eef5b2:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if not (block.number * sub_a3eef5b2) - (endBlock * sub_a3eef5b2):
                    _2340 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2340] = 26
                    mem[_2340 + 32] = 'SafeMath: division by zero'
                    if totalAllocPoint <= 0:
                        _2368 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2368 + idx + 68] = mem[_2340 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2368 + 68] = mem[_2368 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _2368 + -mem[64] + 100
                    require totalAllocPoint
                    _2472 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2472] = 26
                    mem[_2472 + 32] = 'SafeMath: division by zero'
                    if devFundDivRate <= 0:
                        _2540 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2540 + idx + 68] = mem[_2472 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2540 + 68] = mem[_2540 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _2540 + -mem[64] + 100
                    require devFundDivRate
                    require ext_code.size(sub_64d46cecAddress)
                    call sub_64d46cecAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args devaddr, 0 / totalAllocPoint / devFundDivRate
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sub_64d46cecAddress)
                    call sub_64d46cecAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args address(this.address), 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not 0 / totalAllocPoint:
                        _3077 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3077] = 26
                        mem[_3077 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0] > 0:
                            require ext_call.return_data[0]
                            if poolInfo[idx].field_768 + (0 / ext_call.return_data[0]) < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _3195 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3195 + idx + 68] = mem[_3077 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3195 + 68] = mem[_3195 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _3195 + -mem[64] + 100
                    require 0 / totalAllocPoint
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _3194 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3194] = 26
                    mem[_3194 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0] > 0:
                        require ext_call.return_data[0]
                        if poolInfo[idx].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _3329 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3329 + idx + 68] = mem[_3194 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3329 + 68] = mem[_3329 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _3329 + -mem[64] + 100
                require (block.number * sub_a3eef5b2) - (endBlock * sub_a3eef5b2)
                if (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / (block.number * sub_a3eef5b2) - (endBlock * sub_a3eef5b2) != poolInfo[idx].field_256:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _2367 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2367] = 26
                mem[_2367 + 32] = 'SafeMath: division by zero'
                if totalAllocPoint <= 0:
                    _2411 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2411 + idx + 68] = mem[_2367 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2411 + 68] = mem[_2411 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _2411 + -mem[64] + 100
                require totalAllocPoint
                _2538 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2538] = 26
                mem[_2538 + 32] = 'SafeMath: division by zero'
                if devFundDivRate <= 0:
                    _2607 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2607 + idx + 68] = mem[_2538 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2607 + 68] = mem[_2607 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _2607 + -mem[64] + 100
                require devFundDivRate
                require ext_code.size(sub_64d46cecAddress)
                call sub_64d46cecAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args devaddr, (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint
                require ext_code.size(sub_64d46cecAddress)
                call sub_64d46cecAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args address(this.address), (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if not (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint:
                    _3193 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3193] = 26
                    mem[_3193 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0] > 0:
                        require ext_call.return_data[0]
                        if poolInfo[idx].field_768 + (0 / ext_call.return_data[0]) < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _3326 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3326 + idx + 68] = mem[_3193 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3326 + 68] = mem[_3326 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _3326 + -mem[64] + 100
                require (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint
                if 10^12 * (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint / (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _3325 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3325] = 26
                mem[_3325 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0] > 0:
                    require ext_call.return_data[0]
                    if poolInfo[idx].field_768 + (10^12 * (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^12 * (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _3470 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_3470 + idx + 68] = mem[_3325 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_3470 + 68] = mem[_3470 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _3470 + -mem[64] + 100
            _2163 = mem[64]
            mem[64] = mem[64] + 64
            mem[_2163] = 30
            mem[_2163 + 32] = 'SafeMath: subtraction overflow'
            if bonusEndBlock > block.number:
                _2187 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_2187 + idx + 68] = mem[_2163 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_2187 + 68] = mem[_2187 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _2187 + -mem[64] + 100
            _2231 = mem[64]
            mem[64] = mem[64] + 64
            mem[_2231] = 30
            mem[_2231 + 32] = 'SafeMath: subtraction overflow'
            if endBlock > bonusEndBlock:
                _2261 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[_2261 + idx + 68] = mem[_2231 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_2261 + 68] = mem[_2261 + 70 len 30]
                revert with memory
                  from mem[64]
                   len _2261 + -mem[64] + 100
            if not bonusEndBlock - endBlock:
                if block.number - bonusEndBlock < 0:
                    revert with 0, 'SafeMath: addition overflow'
                if not block.number - bonusEndBlock:
                    _2606 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2606] = 26
                    mem[_2606 + 32] = 'SafeMath: division by zero'
                    if totalAllocPoint <= 0:
                        _2696 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2696 + idx + 68] = mem[_2606 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2696 + 68] = mem[_2696 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _2696 + -mem[64] + 100
                    require totalAllocPoint
                    _2888 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2888] = 26
                    mem[_2888 + 32] = 'SafeMath: division by zero'
                    if devFundDivRate <= 0:
                        _2975 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2975 + idx + 68] = mem[_2888 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2975 + 68] = mem[_2975 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _2975 + -mem[64] + 100
                    require devFundDivRate
                    require ext_code.size(sub_64d46cecAddress)
                    call sub_64d46cecAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args devaddr, 0 / totalAllocPoint / devFundDivRate
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sub_64d46cecAddress)
                    call sub_64d46cecAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args address(this.address), 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not 0 / totalAllocPoint:
                        _3691 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3691] = 26
                        mem[_3691 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0] > 0:
                            require ext_call.return_data[0]
                            if poolInfo[idx].field_768 + (0 / ext_call.return_data[0]) < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _3771 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3771 + idx + 68] = mem[_3691 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3771 + 68] = mem[_3771 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _3771 + -mem[64] + 100
                    require 0 / totalAllocPoint
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _3770 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3770] = 26
                    mem[_3770 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0] > 0:
                        require ext_call.return_data[0]
                        if poolInfo[idx].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _3861 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3861 + idx + 68] = mem[_3770 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3861 + 68] = mem[_3861 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _3861 + -mem[64] + 100
                require block.number - bonusEndBlock
                if (block.number * sub_a3eef5b2) - (bonusEndBlock * sub_a3eef5b2) / block.number - bonusEndBlock != sub_a3eef5b2:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                if not (block.number * sub_a3eef5b2) - (bonusEndBlock * sub_a3eef5b2):
                    _2695 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2695] = 26
                    mem[_2695 + 32] = 'SafeMath: division by zero'
                    if totalAllocPoint <= 0:
                        _2797 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_2797 + idx + 68] = mem[_2695 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_2797 + 68] = mem[_2797 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _2797 + -mem[64] + 100
                    require totalAllocPoint
                    _2973 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_2973] = 26
                    mem[_2973 + 32] = 'SafeMath: division by zero'
                    if devFundDivRate <= 0:
                        _3073 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3073 + idx + 68] = mem[_2973 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3073 + 68] = mem[_3073 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _3073 + -mem[64] + 100
                    require devFundDivRate
                    require ext_code.size(sub_64d46cecAddress)
                    call sub_64d46cecAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args devaddr, 0 / totalAllocPoint / devFundDivRate
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = this.address
                    mem[mem[64] + 36] = 0 / totalAllocPoint
                    require ext_code.size(sub_64d46cecAddress)
                    call sub_64d46cecAddress.0x40c10f19 with:
                         gas gas_remaining wei
                        args address(this.address), 0 / totalAllocPoint
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    if not 0 / totalAllocPoint:
                        _3769 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3769] = 26
                        mem[_3769 + 32] = 'SafeMath: division by zero'
                        if ext_call.return_data[0] > 0:
                            require ext_call.return_data[0]
                            if poolInfo[idx].field_768 + (0 / ext_call.return_data[0]) < poolInfo[idx].field_768:
                                revert with 0, 'SafeMath: addition overflow'
                            poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                            poolInfo[idx].field_512 = block.number
                            idx = idx + 1
                            continue 
                        _3858 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[_3858 + idx + 68] = mem[_3769 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3858 + 68] = mem[_3858 + 74 len 26]
                        revert with memory
                          from mem[64]
                           len _3858 + -mem[64] + 100
                    require 0 / totalAllocPoint
                    if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                        revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                    _3857 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3857] = 26
                    mem[_3857 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0] > 0:
                        require ext_call.return_data[0]
                        if poolInfo[idx].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _3959 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3959 + idx + 68] = mem[_3857 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3959 + 68] = mem[_3959 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _3959 + -mem[64] + 100
                require (block.number * sub_a3eef5b2) - (bonusEndBlock * sub_a3eef5b2)
                if (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / (block.number * sub_a3eef5b2) - (bonusEndBlock * sub_a3eef5b2) != poolInfo[idx].field_256:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _2796 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2796] = 26
                mem[_2796 + 32] = 'SafeMath: division by zero'
                if totalAllocPoint <= 0:
                    _2884 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2884 + idx + 68] = mem[_2796 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2884 + 68] = mem[_2884 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _2884 + -mem[64] + 100
                require totalAllocPoint
                _3071 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3071] = 26
                mem[_3071 + 32] = 'SafeMath: division by zero'
                if devFundDivRate <= 0:
                    _3188 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3188 + idx + 68] = mem[_3071 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3188 + 68] = mem[_3188 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _3188 + -mem[64] + 100
                require devFundDivRate
                require ext_code.size(sub_64d46cecAddress)
                call sub_64d46cecAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args devaddr, (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint
                require ext_code.size(sub_64d46cecAddress)
                call sub_64d46cecAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args address(this.address), (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if not (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint:
                    _3856 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3856] = 26
                    mem[_3856 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0] > 0:
                        require ext_call.return_data[0]
                        if poolInfo[idx].field_768 + (0 / ext_call.return_data[0]) < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _3956 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3956 + idx + 68] = mem[_3856 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3956 + 68] = mem[_3956 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _3956 + -mem[64] + 100
                require (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint
                if 10^12 * (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint / (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _3955 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3955] = 26
                mem[_3955 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0] > 0:
                    require ext_call.return_data[0]
                    if poolInfo[idx].field_768 + (10^12 * (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^12 * (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) - (bonusEndBlock * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _4057 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_4057 + idx + 68] = mem[_3955 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_4057 + 68] = mem[_4057 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _4057 + -mem[64] + 100
            require bonusEndBlock - endBlock
            if bonusEndBlock - endBlock / bonusEndBlock - endBlock != 1:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            if block.number < bonusEndBlock:
                revert with 0, 'SafeMath: addition overflow'
            if not -endBlock + block.number:
                _2694 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2694] = 26
                mem[_2694 + 32] = 'SafeMath: division by zero'
                if totalAllocPoint <= 0:
                    _2793 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2793 + idx + 68] = mem[_2694 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2793 + 68] = mem[_2793 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _2793 + -mem[64] + 100
                require totalAllocPoint
                _2970 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2970] = 26
                mem[_2970 + 32] = 'SafeMath: division by zero'
                if devFundDivRate <= 0:
                    _3068 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3068 + idx + 68] = mem[_2970 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3068 + 68] = mem[_3068 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _3068 + -mem[64] + 100
                require devFundDivRate
                require ext_code.size(sub_64d46cecAddress)
                call sub_64d46cecAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args devaddr, 0 / totalAllocPoint / devFundDivRate
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = 0 / totalAllocPoint
                require ext_code.size(sub_64d46cecAddress)
                call sub_64d46cecAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args address(this.address), 0 / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if not 0 / totalAllocPoint:
                    _3768 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3768] = 26
                    mem[_3768 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0] > 0:
                        require ext_call.return_data[0]
                        if poolInfo[idx].field_768 + (0 / ext_call.return_data[0]) < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _3853 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3853 + idx + 68] = mem[_3768 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3853 + 68] = mem[_3853 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _3853 + -mem[64] + 100
                require 0 / totalAllocPoint
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _3852 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3852] = 26
                mem[_3852 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0] > 0:
                    require ext_call.return_data[0]
                    if poolInfo[idx].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _3951 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_3951 + idx + 68] = mem[_3852 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_3951 + 68] = mem[_3951 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _3951 + -mem[64] + 100
            require -endBlock + block.number
            if (-1 * endBlock * sub_a3eef5b2) + (block.number * sub_a3eef5b2) / -endBlock + block.number != sub_a3eef5b2:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            if not (-1 * endBlock * sub_a3eef5b2) + (block.number * sub_a3eef5b2):
                _2792 = mem[64]
                mem[64] = mem[64] + 64
                mem[_2792] = 26
                mem[_2792 + 32] = 'SafeMath: division by zero'
                if totalAllocPoint <= 0:
                    _2880 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_2880 + idx + 68] = mem[_2792 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_2880 + 68] = mem[_2880 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _2880 + -mem[64] + 100
                require totalAllocPoint
                _3066 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3066] = 26
                mem[_3066 + 32] = 'SafeMath: division by zero'
                if devFundDivRate <= 0:
                    _3184 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3184 + idx + 68] = mem[_3066 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3184 + 68] = mem[_3184 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _3184 + -mem[64] + 100
                require devFundDivRate
                require ext_code.size(sub_64d46cecAddress)
                call sub_64d46cecAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args devaddr, 0 / totalAllocPoint / devFundDivRate
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = this.address
                mem[mem[64] + 36] = 0 / totalAllocPoint
                require ext_code.size(sub_64d46cecAddress)
                call sub_64d46cecAddress.0x40c10f19 with:
                     gas gas_remaining wei
                    args address(this.address), 0 / totalAllocPoint
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                if not 0 / totalAllocPoint:
                    _3851 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3851] = 26
                    mem[_3851 + 32] = 'SafeMath: division by zero'
                    if ext_call.return_data[0] > 0:
                        require ext_call.return_data[0]
                        if poolInfo[idx].field_768 + (0 / ext_call.return_data[0]) < poolInfo[idx].field_768:
                            revert with 0, 'SafeMath: addition overflow'
                        poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                        poolInfo[idx].field_512 = block.number
                        idx = idx + 1
                        continue 
                    _3948 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[_3948 + idx + 68] = mem[_3851 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3948 + 68] = mem[_3948 + 74 len 26]
                    revert with memory
                      from mem[64]
                       len _3948 + -mem[64] + 100
                require 0 / totalAllocPoint
                if 10^12 * 0 / totalAllocPoint / 0 / totalAllocPoint != 10^12:
                    revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
                _3947 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3947] = 26
                mem[_3947 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0] > 0:
                    require ext_call.return_data[0]
                    if poolInfo[idx].field_768 + (10^12 * 0 / totalAllocPoint / ext_call.return_data[0]) < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 10^12 * 0 / totalAllocPoint / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _4051 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_4051 + idx + 68] = mem[_3947 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_4051 + 68] = mem[_4051 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _4051 + -mem[64] + 100
            require (-1 * endBlock * sub_a3eef5b2) + (block.number * sub_a3eef5b2)
            if (-1 * endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) + (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) / (-1 * endBlock * sub_a3eef5b2) + (block.number * sub_a3eef5b2) != poolInfo[idx].field_256:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _2879 = mem[64]
            mem[64] = mem[64] + 64
            mem[_2879] = 26
            mem[_2879 + 32] = 'SafeMath: division by zero'
            if totalAllocPoint <= 0:
                _2966 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_2966 + idx + 68] = mem[_2879 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_2966 + 68] = mem[_2966 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _2966 + -mem[64] + 100
            require totalAllocPoint
            _3182 = mem[64]
            mem[64] = mem[64] + 64
            mem[_3182] = 26
            mem[_3182 + 32] = 'SafeMath: division by zero'
            if devFundDivRate <= 0:
                _3318 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_3318 + idx + 68] = mem[_3182 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_3318 + 68] = mem[_3318 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _3318 + -mem[64] + 100
            require devFundDivRate
            require ext_code.size(sub_64d46cecAddress)
            call sub_64d46cecAddress.0x40c10f19 with:
                 gas gas_remaining wei
                args devaddr, (-1 * endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) + (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint / devFundDivRate
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            mem[mem[64]] = 0x40c10f1900000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = this.address
            mem[mem[64] + 36] = (-1 * endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) + (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint
            require ext_code.size(sub_64d46cecAddress)
            call sub_64d46cecAddress.0x40c10f19 with:
                 gas gas_remaining wei
                args address(this.address), (-1 * endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) + (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            if not (-1 * endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) + (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint:
                _3946 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3946] = 26
                mem[_3946 + 32] = 'SafeMath: division by zero'
                if ext_call.return_data[0] > 0:
                    require ext_call.return_data[0]
                    if poolInfo[idx].field_768 + (0 / ext_call.return_data[0]) < poolInfo[idx].field_768:
                        revert with 0, 'SafeMath: addition overflow'
                    poolInfo[idx].field_768 += 0 / ext_call.return_data[0]
                    poolInfo[idx].field_512 = block.number
                    idx = idx + 1
                    continue 
                _4048 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[_4048 + idx + 68] = mem[_3946 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_4048 + 68] = mem[_4048 + 74 len 26]
                revert with memory
                  from mem[64]
                   len _4048 + -mem[64] + 100
            require (-1 * endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) + (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint
            if 10^12 * (-1 * endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) + (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint / (-1 * endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) + (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint != 10^12:
                revert with 0, 32, 33, 0x73536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f, mem[mem[64] + 101 len 31]
            _4047 = mem[64]
            mem[64] = mem[64] + 64
            mem[_4047] = 26
            mem[_4047 + 32] = 'SafeMath: division by zero'
            if ext_call.return_data[0] > 0:
                require ext_call.return_data[0]
                if poolInfo[idx].field_768 + (10^12 * (-1 * endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) + (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]) < poolInfo[idx].field_768:
                    revert with 0, 'SafeMath: addition overflow'
                poolInfo[idx].field_768 += 10^12 * (-1 * endBlock * sub_a3eef5b2 * poolInfo[idx].field_256) + (block.number * sub_a3eef5b2 * poolInfo[idx].field_256) / totalAllocPoint / ext_call.return_data[0]
                poolInfo[idx].field_512 = block.number
                idx = idx + 1
                continue 
            _4143 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[_4143 + idx + 68] = mem[_4047 + idx + 32]
                idx = idx + 32
                continue 
            mem[_4143 + 68] = mem[_4143 + 74 len 26]
            revert with memory
              from mem[64]
               len _4143 + -mem[64] + 100
    require arg1 < poolInfo.length
    if poolInfo[arg1].field_256 > totalAllocPoint:
        revert with 0, 'SafeMath: subtraction overflow'
    if arg2 < 0:
        revert with 0, 'SafeMath: addition overflow'
    totalAllocPoint = totalAllocPoint - poolInfo[arg1].field_256 + arg2
    require arg1 < poolInfo.length
    poolInfo[arg1].field_256 = arg2
}



}

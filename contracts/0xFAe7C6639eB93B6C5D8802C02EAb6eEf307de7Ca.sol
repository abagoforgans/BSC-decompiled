contract main {




// =====================  Runtime code  =====================


#
#  - sub_652ff988(?)
#  - sub_9bc5ec9d(?)
#
array of address stor2;
mapping of uint256 stor3;
address stor5;
mapping of uint8 stor99;

function _fallback() payable {
    revert
}

function deposit() payable {
    require ext_code.size(0xbb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c)
    call 0xbb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c.0xd0e30db0 with:
       value eth.balance(this.address) wei
         gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
}

function withdraw(uint256 arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    require msg.sender == stor5
    require ext_code.size(0xbb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c)
    call 0xbb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c.0x2e1a7d4d with:
         gas gas_remaining wei
        args arg1
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    call msg.sender with:
       value arg1 wei
         gas 2300 * is_zero(value) wei
}

function sub_7fed220f(?) {
    require calldata.size - 4 >= 64
    require cd[4] <= test266151307()
    require cd[4] + 35 < calldata.size
    require ('cd', 4).length <= test266151307()
    require (32 * ('cd', 4).length) + 128 <= test266151307() and (32 * ('cd', 4).length) + 128 >= 96
    require cd[4] + (32 * ('cd', 4).length) + 36 <= calldata.size
    idx = 0
    s = cd[4] + 36
    t = 128
    while idx < ('cd', 4).length:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[36] <= test266151307()
    require cd[36] + 35 < calldata.size
    require ('cd', 36).length <= test266151307()
    require (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + 160 <= test266151307() and (32 * ('cd', 36).length) + 160 >= 128
    mem[(32 * ('cd', 4).length) + 128] = ('cd', 36).length
    require cd[36] + (32 * ('cd', 36).length) + 36 <= calldata.size
    idx = 0
    s = cd[36] + 36
    t = (32 * ('cd', 4).length) + 160
    while idx < ('cd', 36).length:
        require cd[s] == cd[s]
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    idx = 0
    while idx < ('cd', 4).length:
        require idx < ('cd', 36).length
        require idx < ('cd', 4).length
        mem[0] = mem[(32 * idx) + 140 len 20]
        mem[32] = 3
        stor3[mem[(32 * idx) + 140 len 20]] = mem[(32 * idx) + (32 * ('cd', 4).length) + 160]
        idx = idx + 1
        continue 
}

function compareStrings(string arg1, string arg2) {
    require calldata.size - 4 >= 64
    require arg1 <= test266151307()
    require arg1 + 35 < calldata.size
    require arg1.length <= test266151307()
    require ceil32(arg1.length) + 128 <= test266151307() and ceil32(arg1.length) + 128 >= 96
    require arg1 + arg1.length + 36 <= calldata.size
    mem[128 len arg1.length] = arg1[all]
    mem[arg1.length + 128] = 0
    require arg2 <= test266151307()
    require arg2 + 35 < calldata.size
    require arg2.length <= test266151307()
    require ceil32(arg1.length) + ceil32(arg2.length) + 160 <= test266151307() and ceil32(arg2.length) + 160 >= 128
    mem[ceil32(arg1.length) + 128] = arg2.length
    require arg2 + arg2.length + 36 <= calldata.size
    mem[ceil32(arg1.length) + 160 len arg2.length] = arg2[all]
    mem[ceil32(arg1.length) + arg2.length + 160] = 0
    mem[ceil32(arg1.length) + ceil32(arg2.length) + 192 len ceil32(arg2.length)] = arg2[all], mem[ceil32(arg1.length) + arg2.length + 160 len ceil32(arg2.length) - arg2.length]
    if ceil32(arg2.length) > arg2.length:
        mem[ceil32(arg1.length) + ceil32(arg2.length) + arg2.length + 192] = 0
    mem[ceil32(arg1.length) + ceil32(arg2.length) + 160] = arg2.length
    return (sha3(Mask(8 * arg1.length, -(8 * arg1.length) + 256, arg1[all], mem[arg1.length + 128 len ceil32(arg1.length) - arg1.length]) << (8 * arg1.length) - 256) == sha3(mem[ceil32(arg1.length) + ceil32(arg2.length) + 192 len Mask(8 * -ceil32(arg2.length) + arg2.length + 32, 0, 0), mem[ceil32(arg1.length) + arg2.length + 192 len -arg2.length + ceil32(arg2.length)]]))
}

function sub_b10a42d3(?) {
    require calldata.size - 4 >= 128
    require cd[4] <= test266151307()
    require cd[4] + 35 < calldata.size
    require ('cd', 4).length <= test266151307()
    require (32 * ('cd', 4).length) + 128 <= test266151307() and (32 * ('cd', 4).length) + 128 >= 96
    mem[96] = ('cd', 4).length
    require cd[4] + (32 * ('cd', 4).length) + 36 <= calldata.size
    idx = 0
    s = cd[4] + 36
    t = 128
    while idx < ('cd', 4).length:
        require cd[s] == address(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[36] <= test266151307()
    require cd[36] + 35 < calldata.size
    require ('cd', 36).length <= test266151307()
    require (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + 160 <= test266151307() and (32 * ('cd', 36).length) + 160 >= 128
    mem[64] = (32 * ('cd', 4).length) + (32 * ('cd', 36).length) + 160
    mem[(32 * ('cd', 4).length) + 128] = ('cd', 36).length
    idx = 0
    s = cd[36] + 36
    t = (32 * ('cd', 4).length) + 160
    while idx < ('cd', 36).length:
        require cd[36] + cd[s] + 67 < calldata.size
        require cd[(cd[36] + cd[s] + 36)] <= test266151307()
        _746 = mem[64]
        require mem[64] + ceil32(cd[(cd[36] + cd[s] + 36)]) + 32 <= test266151307() and mem[64] + ceil32(cd[(cd[36] + cd[s] + 36)]) + 32 >= mem[64]
        mem[64] = mem[64] + ceil32(cd[(cd[36] + cd[s] + 36)]) + 32
        mem[_746] = cd[(cd[36] + cd[s] + 36)]
        require cd[36] + cd[s] + cd[(cd[36] + cd[s] + 36)] + 68 <= calldata.size
        mem[_746 + 32 len cd[(cd[36] + cd[s] + 36)]] = call.data[cd[36] + cd[s] + 68 len cd[(cd[36] + cd[s] + 36)]]
        mem[_746 + cd[(cd[36] + cd[s] + 36)] + 32] = 0
        mem[t] = _746
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[68] <= test266151307()
    require cd[68] + 35 < calldata.size
    require ('cd', 68).length <= test266151307()
    _747 = mem[64]
    require mem[64] + (32 * ('cd', 68).length) + 32 <= test266151307() and mem[64] + (32 * ('cd', 68).length) + 32 >= mem[64]
    mem[64] = mem[64] + (32 * ('cd', 68).length) + 32
    mem[_747] = ('cd', 68).length
    require cd[68] + (32 * ('cd', 68).length) + 36 <= calldata.size
    idx = 0
    s = cd[68] + 36
    t = _747 + 32
    while idx < ('cd', 68).length:
        require cd[s] == bool(cd[s])
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    require cd[100] <= test266151307()
    require cd[100] + 35 < calldata.size
    require ('cd', 100).length <= test266151307()
    _1117 = mem[64]
    require mem[64] + (32 * ('cd', 100).length) + 32 <= test266151307() and mem[64] + (32 * ('cd', 100).length) + 32 >= mem[64]
    mem[64] = mem[64] + (32 * ('cd', 100).length) + 32
    mem[_1117] = ('cd', 100).length
    require cd[100] + (32 * ('cd', 100).length) + 36 <= calldata.size
    idx = 0
    s = cd[100] + 36
    t = _1117 + 32
    while idx < ('cd', 100).length:
        require cd[s] == cd[s]
        mem[t] = cd[s]
        idx = idx + 1
        s = s + 32
        t = t + 32
        continue 
    _1486 = mem[96]
    require mem[96] <= test266151307()
    _1487 = mem[64]
    mem[mem[64]] = mem[96]
    mem[64] = mem[64] + (32 * _1486) + 32
    if not _1486:
        _1488 = mem[_1487]
        stor2.length = mem[_1487]
        mem[0] = 2
        if not _1488:
            idx = 0
            while stor2.length > idx:
                stor2[idx] = 0
                idx = idx + 1
                continue 
            _2216 = mem[96]
            idx = 0
            while idx < _2216:
                require idx < mem[96]
                _2220 = mem[(32 * idx) + 128]
                require idx < mem[(32 * ('cd', 4).length) + 128]
                _2224 = mem[(32 * idx) + (32 * ('cd', 4).length) + 160]
                _2225 = mem[64]
                _2232 = mem[mem[(32 * idx) + (32 * ('cd', 4).length) + 160]]
                s = 0
                while s < _2232:
                    mem[_2225 + s] = mem[_2224 + s + 32]
                    _2216 = mem[96]
                    s = s + 32
                    continue 
                mem[_2225 + _2232] = 0
                address(stor[sha3(mem[mem[64] len _2225 + _2232 + -mem[64] + 32])]) = address(_2220)
                require idx < mem[_747]
                if ceil32(_2232) <= _2232:
                    _2596 = mem[(32 * idx) + _747 + 32]
                    require idx < mem[(32 * ('cd', 4).length) + 128]
                    _2608 = mem[(32 * idx) + (32 * ('cd', 4).length) + 160]
                    _2609 = mem[64]
                    _2620 = mem[mem[(32 * idx) + (32 * ('cd', 4).length) + 160]]
                    s = 0
                    while s < _2620:
                        mem[_2609 + s] = mem[_2608 + s + 32]
                        _2216 = mem[96]
                        s = s + 32
                        continue 
                    mem[_2609 + _2620] = 1
                    uint8(stor[sha3(mem[mem[64] len _2609 + _2620 + -mem[64] + 32])]) = uint8(bool(_2596))
                    require idx < mem[96]
                    require idx < stor2.length
                    mem[0] = 2
                    stor2[idx] = mem[(32 * idx) + 140 len 20]
                    require idx < mem[_1117]
                    if ceil32(_2620) <= _2620:
                        _2992 = mem[(32 * idx) + _1117 + 32]
                        require idx < mem[(32 * ('cd', 4).length) + 128]
                        _3012 = mem[(32 * idx) + (32 * ('cd', 4).length) + 160]
                        _3013 = mem[64]
                        _3040 = mem[mem[(32 * idx) + (32 * ('cd', 4).length) + 160]]
                        s = 0
                        while s < _3040:
                            mem[_3013 + s] = mem[_3012 + s + 32]
                            _2216 = mem[96]
                            s = s + 32
                            continue 
                        mem[_3013 + _3040] = 4
                        uint256(stor[sha3(mem[mem[64] len _3013 + _3040 + -mem[64] + 32])]) = _2992
                    else:
                        _3014 = mem[(32 * idx) + _1117 + 32]
                        require idx < mem[(32 * ('cd', 4).length) + 128]
                        _3028 = mem[(32 * idx) + (32 * ('cd', 4).length) + 160]
                        _3029 = mem[64]
                        _3044 = mem[mem[(32 * idx) + (32 * ('cd', 4).length) + 160]]
                        s = 0
                        while s < _3044:
                            mem[_3029 + s] = mem[_3028 + s + 32]
                            _2216 = mem[96]
                            s = s + 32
                            continue 
                        mem[_3029 + _3044] = 4
                        uint256(stor[sha3(mem[mem[64] len _3029 + _3044 + -mem[64] + 32])]) = _3014
                else:
                    _2610 = mem[(32 * idx) + _747 + 32]
                    require idx < mem[(32 * ('cd', 4).length) + 128]
                    _2616 = mem[(32 * idx) + (32 * ('cd', 4).length) + 160]
                    _2617 = mem[64]
                    _2622 = mem[mem[(32 * idx) + (32 * ('cd', 4).length) + 160]]
                    s = 0
                    while s < _2622:
                        mem[_2617 + s] = mem[_2616 + s + 32]
                        _2216 = mem[96]
                        s = s + 32
                        continue 
                    mem[_2617 + _2622] = 1
                    uint8(stor[sha3(mem[mem[64] len _2617 + _2622 + -mem[64] + 32])]) = uint8(bool(_2610))
                    require idx < mem[96]
                    require idx < stor2.length
                    mem[0] = 2
                    stor2[idx] = mem[(32 * idx) + 140 len 20]
                    require idx < mem[_1117]
                    if ceil32(_2622) <= _2622:
                        _2996 = mem[(32 * idx) + _1117 + 32]
                        require idx < mem[(32 * ('cd', 4).length) + 128]
                        _3016 = mem[(32 * idx) + (32 * ('cd', 4).length) + 160]
                        _3017 = mem[64]
                        _3041 = mem[mem[(32 * idx) + (32 * ('cd', 4).length) + 160]]
                        s = 0
                        while s < _3041:
                            mem[_3017 + s] = mem[_3016 + s + 32]
                            _2216 = mem[96]
                            s = s + 32
                            continue 
                        mem[_3017 + _3041] = 4
                        uint256(stor[sha3(mem[mem[64] len _3017 + _3041 + -mem[64] + 32])]) = _2996
                    else:
                        _3018 = mem[(32 * idx) + _1117 + 32]
                        require idx < mem[(32 * ('cd', 4).length) + 128]
                        _3030 = mem[(32 * idx) + (32 * ('cd', 4).length) + 160]
                        _3031 = mem[64]
                        _3045 = mem[mem[(32 * idx) + (32 * ('cd', 4).length) + 160]]
                        s = 0
                        while s < _3045:
                            mem[_3031 + s] = mem[_3030 + s + 32]
                            _2216 = mem[96]
                            s = s + 32
                            continue 
                        mem[_3031 + _3045] = 4
                        uint256(stor[sha3(mem[mem[64] len _3031 + _3045 + -mem[64] + 32])]) = _3018
                _2216 = mem[96]
                idx = idx + 1
                continue 
        else:
            s = 0
            idx = _1487 + 32
            while _1487 + (32 * _1488) + 32 > idx:
                stor2[s] = mem[idx + 12 len 20]
                s = s + 1
                idx = idx + 32
                continue 
            idx = Mask(251, 0, (32 * _1488) + 31) >> 5
            while stor2.length > idx:
                stor2[idx] = 0
                idx = idx + 1
                continue 
            _2576 = mem[96]
            idx = 0
            while idx < _2576:
                require idx < mem[96]
                _2582 = mem[(32 * idx) + 128]
                require idx < mem[(32 * ('cd', 4).length) + 128]
                _2586 = mem[(32 * idx) + (32 * ('cd', 4).length) + 160]
                _2587 = mem[64]
                _2601 = mem[mem[(32 * idx) + (32 * ('cd', 4).length) + 160]]
                s = 0
                while s < _2601:
                    mem[_2587 + s] = mem[_2586 + s + 32]
                    _2576 = mem[96]
                    s = s + 32
                    continue 
                mem[_2587 + _2601] = 0
                address(stor[sha3(mem[mem[64] len _2587 + _2601 + -mem[64] + 32])]) = address(_2582)
                require idx < mem[_747]
                if ceil32(_2601) <= _2601:
                    _2954 = mem[(32 * idx) + _747 + 32]
                    require idx < mem[(32 * ('cd', 4).length) + 128]
                    _2978 = mem[(32 * idx) + (32 * ('cd', 4).length) + 160]
                    _2979 = mem[64]
                    _3032 = mem[mem[(32 * idx) + (32 * ('cd', 4).length) + 160]]
                    s = 0
                    while s < _3032:
                        mem[_2979 + s] = mem[_2978 + s + 32]
                        _2576 = mem[96]
                        s = s + 32
                        continue 
                    mem[_2979 + _3032] = 1
                    uint8(stor[sha3(mem[mem[64] len _2979 + _3032 + -mem[64] + 32])]) = uint8(bool(_2954))
                    require idx < mem[96]
                    require idx < stor2.length
                    mem[0] = 2
                    stor2[idx] = mem[(32 * idx) + 140 len 20]
                    require idx < mem[_1117]
                    if ceil32(_3032) <= _3032:
                        _3304 = mem[(32 * idx) + _1117 + 32]
                        require idx < mem[(32 * ('cd', 4).length) + 128]
                        _3320 = mem[(32 * idx) + (32 * ('cd', 4).length) + 160]
                        _3321 = mem[64]
                        _3344 = mem[mem[(32 * idx) + (32 * ('cd', 4).length) + 160]]
                        s = 0
                        while s < _3344:
                            mem[_3321 + s] = mem[_3320 + s + 32]
                            _2576 = mem[96]
                            s = s + 32
                            continue 
                        mem[_3321 + _3344] = 4
                        uint256(stor[sha3(mem[mem[64] len _3321 + _3344 + -mem[64] + 32])]) = _3304
                    else:
                        _3322 = mem[(32 * idx) + _1117 + 32]
                        require idx < mem[(32 * ('cd', 4).length) + 128]
                        _3336 = mem[(32 * idx) + (32 * ('cd', 4).length) + 160]
                        _3337 = mem[64]
                        _3348 = mem[mem[(32 * idx) + (32 * ('cd', 4).length) + 160]]
                        s = 0
                        while s < _3348:
                            mem[_3337 + s] = mem[_3336 + s + 32]
                            _2576 = mem[96]
                            s = s + 32
                            continue 
                        mem[_3337 + _3348] = 4
                        uint256(stor[sha3(mem[mem[64] len _3337 + _3348 + -mem[64] + 32])]) = _3322
                else:
                    _2980 = mem[(32 * idx) + _747 + 32]
                    require idx < mem[(32 * ('cd', 4).length) + 128]
                    _3000 = mem[(32 * idx) + (32 * ('cd', 4).length) + 160]
                    _3001 = mem[64]
                    _3038 = mem[mem[(32 * idx) + (32 * ('cd', 4).length) + 160]]
                    s = 0
                    while s < _3038:
                        mem[_3001 + s] = mem[_3000 + s + 32]
                        _2576 = mem[96]
                        s = s + 32
                        continue 
                    mem[_3001 + _3038] = 1
                    uint8(stor[sha3(mem[mem[64] len _3001 + _3038 + -mem[64] + 32])]) = uint8(bool(_2980))
                    require idx < mem[96]
                    require idx < stor2.length
                    mem[0] = 2
                    stor2[idx] = mem[(32 * idx) + 140 len 20]
                    require idx < mem[_1117]
                    if ceil32(_3038) <= _3038:
                        _3308 = mem[(32 * idx) + _1117 + 32]
                        require idx < mem[(32 * ('cd', 4).length) + 128]
                        _3324 = mem[(32 * idx) + (32 * ('cd', 4).length) + 160]
                        _3325 = mem[64]
                        _3345 = mem[mem[(32 * idx) + (32 * ('cd', 4).length) + 160]]
                        s = 0
                        while s < _3345:
                            mem[_3325 + s] = mem[_3324 + s + 32]
                            _2576 = mem[96]
                            s = s + 32
                            continue 
                        mem[_3325 + _3345] = 4
                        uint256(stor[sha3(mem[mem[64] len _3325 + _3345 + -mem[64] + 32])]) = _3308
                    else:
                        _3326 = mem[(32 * idx) + _1117 + 32]
                        require idx < mem[(32 * ('cd', 4).length) + 128]
                        _3338 = mem[(32 * idx) + (32 * ('cd', 4).length) + 160]
                        _3339 = mem[64]
                        _3349 = mem[mem[(32 * idx) + (32 * ('cd', 4).length) + 160]]
                        s = 0
                        while s < _3349:
                            mem[_3339 + s] = mem[_3338 + s + 32]
                            _2576 = mem[96]
                            s = s + 32
                            continue 
                        mem[_3339 + _3349] = 4
                        uint256(stor[sha3(mem[mem[64] len _3339 + _3349 + -mem[64] + 32])]) = _3326
                _2576 = mem[96]
                idx = idx + 1
                continue 
    else:
        mem[_1487 + 32 len 32 * _1486] = call.data[calldata.size len 32 * _1486]
        _1490 = mem[_1487]
        stor2.length = mem[_1487]
        mem[0] = 2
        if not _1490:
            idx = 0
            while stor2.length > idx:
                stor2[idx] = 0
                idx = idx + 1
                continue 
            _2217 = mem[96]
            idx = 0
            while idx < _2217:
                require idx < mem[96]
                _2222 = mem[(32 * idx) + 128]
                require idx < mem[(32 * ('cd', 4).length) + 128]
                _2226 = mem[(32 * idx) + (32 * ('cd', 4).length) + 160]
                _2227 = mem[64]
                _2235 = mem[mem[(32 * idx) + (32 * ('cd', 4).length) + 160]]
                s = 0
                while s < _2235:
                    mem[_2227 + s] = mem[_2226 + s + 32]
                    _2217 = mem[96]
                    s = s + 32
                    continue 
                mem[_2227 + _2235] = 0
                address(stor[sha3(mem[mem[64] len _2227 + _2235 + -mem[64] + 32])]) = address(_2222)
                require idx < mem[_747]
                if ceil32(_2235) <= _2235:
                    _2602 = mem[(32 * idx) + _747 + 32]
                    require idx < mem[(32 * ('cd', 4).length) + 128]
                    _2612 = mem[(32 * idx) + (32 * ('cd', 4).length) + 160]
                    _2613 = mem[64]
                    _2621 = mem[mem[(32 * idx) + (32 * ('cd', 4).length) + 160]]
                    s = 0
                    while s < _2621:
                        mem[_2613 + s] = mem[_2612 + s + 32]
                        _2217 = mem[96]
                        s = s + 32
                        continue 
                    mem[_2613 + _2621] = 1
                    uint8(stor[sha3(mem[mem[64] len _2613 + _2621 + -mem[64] + 32])]) = uint8(bool(_2602))
                    require idx < mem[96]
                    require idx < stor2.length
                    mem[0] = 2
                    stor2[idx] = mem[(32 * idx) + 140 len 20]
                    require idx < mem[_1117]
                    if ceil32(_2621) <= _2621:
                        _3002 = mem[(32 * idx) + _1117 + 32]
                        require idx < mem[(32 * ('cd', 4).length) + 128]
                        _3020 = mem[(32 * idx) + (32 * ('cd', 4).length) + 160]
                        _3021 = mem[64]
                        _3042 = mem[mem[(32 * idx) + (32 * ('cd', 4).length) + 160]]
                        s = 0
                        while s < _3042:
                            mem[_3021 + s] = mem[_3020 + s + 32]
                            _2217 = mem[96]
                            s = s + 32
                            continue 
                        mem[_3021 + _3042] = 4
                        uint256(stor[sha3(mem[mem[64] len _3021 + _3042 + -mem[64] + 32])]) = _3002
                    else:
                        _3022 = mem[(32 * idx) + _1117 + 32]
                        require idx < mem[(32 * ('cd', 4).length) + 128]
                        _3033 = mem[(32 * idx) + (32 * ('cd', 4).length) + 160]
                        _3034 = mem[64]
                        _3046 = mem[mem[(32 * idx) + (32 * ('cd', 4).length) + 160]]
                        s = 0
                        while s < _3046:
                            mem[_3034 + s] = mem[_3033 + s + 32]
                            _2217 = mem[96]
                            s = s + 32
                            continue 
                        mem[_3034 + _3046] = 4
                        uint256(stor[sha3(mem[mem[64] len _3034 + _3046 + -mem[64] + 32])]) = _3022
                else:
                    _2614 = mem[(32 * idx) + _747 + 32]
                    require idx < mem[(32 * ('cd', 4).length) + 128]
                    _2618 = mem[(32 * idx) + (32 * ('cd', 4).length) + 160]
                    _2619 = mem[64]
                    _2623 = mem[mem[(32 * idx) + (32 * ('cd', 4).length) + 160]]
                    s = 0
                    while s < _2623:
                        mem[_2619 + s] = mem[_2618 + s + 32]
                        _2217 = mem[96]
                        s = s + 32
                        continue 
                    mem[_2619 + _2623] = 1
                    uint8(stor[sha3(mem[mem[64] len _2619 + _2623 + -mem[64] + 32])]) = uint8(bool(_2614))
                    require idx < mem[96]
                    require idx < stor2.length
                    mem[0] = 2
                    stor2[idx] = mem[(32 * idx) + 140 len 20]
                    require idx < mem[_1117]
                    if ceil32(_2623) <= _2623:
                        _3006 = mem[(32 * idx) + _1117 + 32]
                        require idx < mem[(32 * ('cd', 4).length) + 128]
                        _3024 = mem[(32 * idx) + (32 * ('cd', 4).length) + 160]
                        _3025 = mem[64]
                        _3043 = mem[mem[(32 * idx) + (32 * ('cd', 4).length) + 160]]
                        s = 0
                        while s < _3043:
                            mem[_3025 + s] = mem[_3024 + s + 32]
                            _2217 = mem[96]
                            s = s + 32
                            continue 
                        mem[_3025 + _3043] = 4
                        uint256(stor[sha3(mem[mem[64] len _3025 + _3043 + -mem[64] + 32])]) = _3006
                    else:
                        _3026 = mem[(32 * idx) + _1117 + 32]
                        require idx < mem[(32 * ('cd', 4).length) + 128]
                        _3035 = mem[(32 * idx) + (32 * ('cd', 4).length) + 160]
                        _3036 = mem[64]
                        _3047 = mem[mem[(32 * idx) + (32 * ('cd', 4).length) + 160]]
                        s = 0
                        while s < _3047:
                            mem[_3036 + s] = mem[_3035 + s + 32]
                            _2217 = mem[96]
                            s = s + 32
                            continue 
                        mem[_3036 + _3047] = 4
                        uint256(stor[sha3(mem[mem[64] len _3036 + _3047 + -mem[64] + 32])]) = _3026
                _2217 = mem[96]
                idx = idx + 1
                continue 
        else:
            s = 0
            idx = _1487 + 32
            while _1487 + (32 * _1490) + 32 > idx:
                stor2[s] = mem[idx + 12 len 20]
                s = s + 1
                idx = idx + 32
                continue 
            idx = Mask(251, 0, (32 * _1490) + 31) >> 5
            while stor2.length > idx:
                stor2[idx] = 0
                idx = idx + 1
                continue 
            _2577 = mem[96]
            idx = 0
            while idx < _2577:
                require idx < mem[96]
                _2584 = mem[(32 * idx) + 128]
                require idx < mem[(32 * ('cd', 4).length) + 128]
                _2588 = mem[(32 * idx) + (32 * ('cd', 4).length) + 160]
                _2589 = mem[64]
                _2607 = mem[mem[(32 * idx) + (32 * ('cd', 4).length) + 160]]
                s = 0
                while s < _2607:
                    mem[_2589 + s] = mem[_2588 + s + 32]
                    _2577 = mem[96]
                    s = s + 32
                    continue 
                mem[_2589 + _2607] = 0
                address(stor[sha3(mem[mem[64] len _2589 + _2607 + -mem[64] + 32])]) = address(_2584)
                require idx < mem[_747]
                if ceil32(_2607) <= _2607:
                    _2967 = mem[(32 * idx) + _747 + 32]
                    require idx < mem[(32 * ('cd', 4).length) + 128]
                    _2988 = mem[(32 * idx) + (32 * ('cd', 4).length) + 160]
                    _2989 = mem[64]
                    _3037 = mem[mem[(32 * idx) + (32 * ('cd', 4).length) + 160]]
                    s = 0
                    while s < _3037:
                        mem[_2989 + s] = mem[_2988 + s + 32]
                        _2577 = mem[96]
                        s = s + 32
                        continue 
                    mem[_2989 + _3037] = 1
                    uint8(stor[sha3(mem[mem[64] len _2989 + _3037 + -mem[64] + 32])]) = uint8(bool(_2967))
                    require idx < mem[96]
                    require idx < stor2.length
                    mem[0] = 2
                    stor2[idx] = mem[(32 * idx) + 140 len 20]
                    require idx < mem[_1117]
                    if ceil32(_3037) <= _3037:
                        _3312 = mem[(32 * idx) + _1117 + 32]
                        require idx < mem[(32 * ('cd', 4).length) + 128]
                        _3328 = mem[(32 * idx) + (32 * ('cd', 4).length) + 160]
                        _3329 = mem[64]
                        _3346 = mem[mem[(32 * idx) + (32 * ('cd', 4).length) + 160]]
                        s = 0
                        while s < _3346:
                            mem[_3329 + s] = mem[_3328 + s + 32]
                            _2577 = mem[96]
                            s = s + 32
                            continue 
                        mem[_3329 + _3346] = 4
                        uint256(stor[sha3(mem[mem[64] len _3329 + _3346 + -mem[64] + 32])]) = _3312
                    else:
                        _3330 = mem[(32 * idx) + _1117 + 32]
                        require idx < mem[(32 * ('cd', 4).length) + 128]
                        _3340 = mem[(32 * idx) + (32 * ('cd', 4).length) + 160]
                        _3341 = mem[64]
                        _3350 = mem[mem[(32 * idx) + (32 * ('cd', 4).length) + 160]]
                        s = 0
                        while s < _3350:
                            mem[_3341 + s] = mem[_3340 + s + 32]
                            _2577 = mem[96]
                            s = s + 32
                            continue 
                        mem[_3341 + _3350] = 4
                        uint256(stor[sha3(mem[mem[64] len _3341 + _3350 + -mem[64] + 32])]) = _3330
                else:
                    _2990 = mem[(32 * idx) + _747 + 32]
                    require idx < mem[(32 * ('cd', 4).length) + 128]
                    _3010 = mem[(32 * idx) + (32 * ('cd', 4).length) + 160]
                    _3011 = mem[64]
                    _3039 = mem[mem[(32 * idx) + (32 * ('cd', 4).length) + 160]]
                    s = 0
                    while s < _3039:
                        mem[_3011 + s] = mem[_3010 + s + 32]
                        _2577 = mem[96]
                        s = s + 32
                        continue 
                    mem[_3011 + _3039] = 1
                    uint8(stor[sha3(mem[mem[64] len _3011 + _3039 + -mem[64] + 32])]) = uint8(bool(_2990))
                    require idx < mem[96]
                    require idx < stor2.length
                    mem[0] = 2
                    stor2[idx] = mem[(32 * idx) + 140 len 20]
                    require idx < mem[_1117]
                    if ceil32(_3039) <= _3039:
                        _3316 = mem[(32 * idx) + _1117 + 32]
                        require idx < mem[(32 * ('cd', 4).length) + 128]
                        _3332 = mem[(32 * idx) + (32 * ('cd', 4).length) + 160]
                        _3333 = mem[64]
                        _3347 = mem[mem[(32 * idx) + (32 * ('cd', 4).length) + 160]]
                        s = 0
                        while s < _3347:
                            mem[_3333 + s] = mem[_3332 + s + 32]
                            _2577 = mem[96]
                            s = s + 32
                            continue 
                        mem[_3333 + _3347] = 4
                        uint256(stor[sha3(mem[mem[64] len _3333 + _3347 + -mem[64] + 32])]) = _3316
                    else:
                        _3334 = mem[(32 * idx) + _1117 + 32]
                        require idx < mem[(32 * ('cd', 4).length) + 128]
                        _3342 = mem[(32 * idx) + (32 * ('cd', 4).length) + 160]
                        _3343 = mem[64]
                        _3351 = mem[mem[(32 * idx) + (32 * ('cd', 4).length) + 160]]
                        s = 0
                        while s < _3351:
                            mem[_3343 + s] = mem[_3342 + s + 32]
                            _2577 = mem[96]
                            s = s + 32
                            continue 
                        mem[_3343 + _3351] = 4
                        uint256(stor[sha3(mem[mem[64] len _3343 + _3351 + -mem[64] + 32])]) = _3334
                _2577 = mem[96]
                idx = idx + 1
                continue 
}

function sub_17ca2126(?) {
    require calldata.size - 4 >= 128
    require arg1 == address(arg1)
    require arg2 == address(arg2)
    require arg3 <= test266151307()
    require arg3 + 35 < calldata.size
    require arg3.length <= test266151307()
    require ceil32(arg3.length) + 128 <= test266151307() and ceil32(arg3.length) + 128 >= 96
    mem[96] = arg3.length
    require arg3 + arg3.length + 36 <= calldata.size
    mem[128 len arg3.length] = arg3[all]
    mem[arg3.length + 128] = 0
    require arg4 == arg4
    mem[ceil32(arg3.length) + 128] = 2
    mem[ceil32(arg3.length) + 160 len 64] = call.data[calldata.size len 64]
    mem[ceil32(arg3.length) + 224 len ceil32(arg3.length)] = arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]
    mem[ceil32(arg3.length) + arg3.length + 224] = 0
    if ceil32(arg3.length) <= arg3.length:
        _725 = sha3(Mask(8 * ceil32(arg3.length), -(8 * ceil32(arg3.length)) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * ceil32(arg3.length)) - 256, mem[(2 * ceil32(arg3.length)) + 224 len arg3.length + -ceil32(arg3.length) + 32])
        require 0 < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
        mem[ceil32(arg3.length) + 160] = address(arg1)
        require 1 < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
        mem[ceil32(arg3.length) + 192] = address(arg2)
        require 0 < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
        mem[ceil32(arg3.length) + 228] = this.address
        require ext_code.size(address(arg1))
        call address(arg1).0x70a08231 with:
             gas gas_remaining wei
            args this.address
        mem[ceil32(arg3.length) + 224] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[0]
        if ext_call.return_data[0] <= 0:
            revert with 0, 'Failed'
        require 0 < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
        mem[ceil32(arg3.length) + ceil32(return_data.size) + 224 len ceil32(arg3.length)] = arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]
        mem[ceil32(arg3.length) + ceil32(return_data.size) + arg3.length + 224] = 0
        if ceil32(arg3.length) <= arg3.length:
            _1813 = sha3(Mask(8 * ceil32(arg3.length), -(8 * ceil32(arg3.length)) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * ceil32(arg3.length)) - 256, mem[(2 * ceil32(arg3.length)) + ceil32(return_data.size) + 224 len arg3.length + -ceil32(arg3.length) + 32])
            mem[ceil32(arg3.length) + ceil32(return_data.size) + 228] = this.address
            mem[ceil32(arg3.length) + ceil32(return_data.size) + 260] = address(stor[_1813])
            require ext_code.size(address(arg1))
            staticcall address(arg1).0xdd62ed3e with:
                    gas gas_remaining wei
                   args address(this.address), address(stor[_1813])
            mem[ceil32(arg3.length) + ceil32(return_data.size) + 224] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[0]
            if ext_call.return_data[0] >= ext_call.return_data[0]:
                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + 224] = 10
                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + 256] = 'BurgerSwap'
                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + 320] = 'BurgerSwap'
                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + 288] = 10
                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + 362 len ceil32(arg3.length)] = arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]
                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + 330] = arg3.length
                mem[64] = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362
                if ceil32(arg3.length) <= arg3.length:
                    if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                        mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                        mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                        mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 398] = 0
                        mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 430] = 160
                        _4130 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                        mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                        idx = 0
                        s = ceil32(arg3.length) + 160
                        t = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 558
                        while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        require ext_code.size(address(stor[_725]))
                        call address(stor[_725]).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                             gas gas_remaining wei
                            args ext_call.return_data[0], 0, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _4130) + 32]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                    else:
                        mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                        mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 398] = 0
                        mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 430] = 160
                        _4131 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                        mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                        idx = 0
                        s = ceil32(arg3.length) + 160
                        t = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 558
                        while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                        mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                        require ext_code.size(address(stor[_725]))
                        call address(stor[_725]).swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                             gas gas_remaining wei
                            args ext_call.return_data[0], 0, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _4131) + 32]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362
                        require return_data.size >= 32
                        _5002 = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362]
                        require mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                        require ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                        _5018 = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                        require mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                        require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                        mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                        require _5002 + (32 * _5018) + 32 <= return_data.size
                        idx = 0
                        s = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + _5002 + 394
                        t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 394
                        while idx < _5018:
                            require mem[s] == mem[s]
                            mem[t] = mem[s]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                else:
                    if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                        mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                        mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                        mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 398] = 0
                        mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 430] = 160
                        _4186 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                        mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                        idx = 0
                        s = ceil32(arg3.length) + 160
                        t = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 558
                        while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        require ext_code.size(address(stor[_725]))
                        call address(stor[_725]).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                             gas gas_remaining wei
                            args ext_call.return_data[0], 0, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _4186) + 32]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                    else:
                        mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                        mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 398] = 0
                        mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 430] = 160
                        _4187 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                        mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                        idx = 0
                        s = ceil32(arg3.length) + 160
                        t = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 558
                        while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                        mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                        require ext_code.size(address(stor[_725]))
                        call address(stor[_725]).swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                             gas gas_remaining wei
                            args ext_call.return_data[0], 0, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _4187) + 32]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362
                        require return_data.size >= 32
                        _5003 = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362]
                        require mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                        require ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                        _5019 = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                        require mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                        require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                        mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                        require _5003 + (32 * _5019) + 32 <= return_data.size
                        idx = 0
                        s = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + _5003 + 394
                        t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 394
                        while idx < _5019:
                            require mem[s] == mem[s]
                            mem[t] = mem[s]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
            else:
                require 0 < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + 224 len ceil32(arg3.length)] = arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]
                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 224] = 0
                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + 228] = address(stor[mem[(2 * ceil32(arg3.length)) + (2 * ceil32(return_data.size)) + 224 len arg3.length + -ceil32(arg3.length) + 32]][Mask(8 * ceil32(arg3.length), -(8 * ceil32(arg3.length)) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * ceil32(arg3.length)) - 256])
                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + 260] = -1
                require ext_code.size(address(arg1))
                call address(arg1).approve(address rg1, uint256 rg2) with:
                     gas gas_remaining wei
                    args mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + 228], -1
                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + 224] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + 224] = 10
                mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + 256] = 'BurgerSwap'
                mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + 320] = 'BurgerSwap'
                mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + 288] = 10
                mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + 362 len ceil32(arg3.length)] = arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]
                mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + 330] = arg3.length
                mem[64] = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362
                if ceil32(arg3.length) <= arg3.length:
                    if ceil32(arg3.length) <= arg3.length:
                        if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = 0
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                            _5022 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                            idx = 0
                            s = ceil32(arg3.length) + 160
                            t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                            while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            require ext_code.size(address(stor[_725]))
                            call address(stor[_725]).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 0, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _5022) + 32]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                        else:
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = 0
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                            _5023 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                            idx = 0
                            s = ceil32(arg3.length) + 160
                            t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                            while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                            require ext_code.size(address(stor[_725]))
                            call address(stor[_725]).swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 0, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _5023) + 32]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362
                            require return_data.size >= 32
                            _5594 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362]
                            require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                            require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                            _5626 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                            require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                            require ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                            mem[ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                            require _5594 + (32 * _5626) + 32 <= return_data.size
                            idx = 0
                            s = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + _5594 + 394
                            t = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 394
                            while idx < _5626:
                                require mem[s] == mem[s]
                                mem[t] = mem[s]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                    else:
                        if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = 0
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                            _5066 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                            idx = 0
                            s = ceil32(arg3.length) + 160
                            t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                            while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            require ext_code.size(address(stor[_725]))
                            call address(stor[_725]).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 0, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _5066) + 32]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                        else:
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = 0
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                            _5067 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                            idx = 0
                            s = ceil32(arg3.length) + 160
                            t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                            while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                            require ext_code.size(address(stor[_725]))
                            call address(stor[_725]).swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 0, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _5067) + 32]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362
                            require return_data.size >= 32
                            _5595 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362]
                            require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                            require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                            _5627 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                            require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                            require ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                            mem[ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                            require _5595 + (32 * _5627) + 32 <= return_data.size
                            idx = 0
                            s = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + _5595 + 394
                            t = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 394
                            while idx < _5627:
                                require mem[s] == mem[s]
                                mem[t] = mem[s]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                else:
                    if ceil32(arg3.length) <= arg3.length:
                        if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = 0
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                            _5026 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                            idx = 0
                            s = ceil32(arg3.length) + 160
                            t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                            while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            require ext_code.size(address(stor[_725]))
                            call address(stor[_725]).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 0, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _5026) + 32]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                        else:
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = 0
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                            _5027 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                            idx = 0
                            s = ceil32(arg3.length) + 160
                            t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                            while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                            require ext_code.size(address(stor[_725]))
                            call address(stor[_725]).swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 0, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _5027) + 32]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362
                            require return_data.size >= 32
                            _5598 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362]
                            require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                            require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                            _5630 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                            require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                            require ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                            mem[ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                            require _5598 + (32 * _5630) + 32 <= return_data.size
                            idx = 0
                            s = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + _5598 + 394
                            t = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 394
                            while idx < _5630:
                                require mem[s] == mem[s]
                                mem[t] = mem[s]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                    else:
                        if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = 0
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                            _5070 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                            idx = 0
                            s = ceil32(arg3.length) + 160
                            t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                            while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            require ext_code.size(address(stor[_725]))
                            call address(stor[_725]).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 0, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _5070) + 32]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                        else:
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = 0
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                            _5071 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                            idx = 0
                            s = ceil32(arg3.length) + 160
                            t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                            while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                            require ext_code.size(address(stor[_725]))
                            call address(stor[_725]).swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 0, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _5071) + 32]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362
                            require return_data.size >= 32
                            _5599 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362]
                            require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                            require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                            _5631 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                            require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                            require ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                            mem[ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                            require _5599 + (32 * _5631) + 32 <= return_data.size
                            idx = 0
                            s = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + _5599 + 394
                            t = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 394
                            while idx < _5631:
                                require mem[s] == mem[s]
                                mem[t] = mem[s]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
        else:
            _1819 = sha3(Mask(8 * ceil32(arg3.length), -(8 * ceil32(arg3.length)) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * ceil32(arg3.length)) - 256, mem[(2 * ceil32(arg3.length)) + ceil32(return_data.size) + 224 len arg3.length + -ceil32(arg3.length) + 32])
            mem[ceil32(arg3.length) + ceil32(return_data.size) + 228] = this.address
            mem[ceil32(arg3.length) + ceil32(return_data.size) + 260] = address(stor[_1819])
            require ext_code.size(address(arg1))
            staticcall address(arg1).0xdd62ed3e with:
                    gas gas_remaining wei
                   args address(this.address), address(stor[_1819])
            mem[ceil32(arg3.length) + ceil32(return_data.size) + 224] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[0]
            if ext_call.return_data[0] >= ext_call.return_data[0]:
                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + 224] = 10
                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + 256] = 'BurgerSwap'
                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + 320] = 'BurgerSwap'
                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + 288] = 10
                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + 362 len ceil32(arg3.length)] = arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]
                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + 330] = arg3.length
                mem[64] = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362
                if ceil32(arg3.length) <= arg3.length:
                    if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                        mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                        mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                        mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 398] = 0
                        mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 430] = 160
                        _4144 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                        mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                        idx = 0
                        s = ceil32(arg3.length) + 160
                        t = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 558
                        while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        require ext_code.size(address(stor[_725]))
                        call address(stor[_725]).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                             gas gas_remaining wei
                            args ext_call.return_data[0], 0, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _4144) + 32]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                    else:
                        mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                        mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 398] = 0
                        mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 430] = 160
                        _4145 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                        mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                        idx = 0
                        s = ceil32(arg3.length) + 160
                        t = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 558
                        while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                        mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                        require ext_code.size(address(stor[_725]))
                        call address(stor[_725]).swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                             gas gas_remaining wei
                            args ext_call.return_data[0], 0, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _4145) + 32]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362
                        require return_data.size >= 32
                        _5006 = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362]
                        require mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                        require ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                        _5030 = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                        require mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                        require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                        mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                        require _5006 + (32 * _5030) + 32 <= return_data.size
                        idx = 0
                        s = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + _5006 + 394
                        t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 394
                        while idx < _5030:
                            require mem[s] == mem[s]
                            mem[t] = mem[s]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                else:
                    if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                        mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                        mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                        mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 398] = 0
                        mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 430] = 160
                        _4198 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                        mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                        idx = 0
                        s = ceil32(arg3.length) + 160
                        t = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 558
                        while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        require ext_code.size(address(stor[_725]))
                        call address(stor[_725]).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                             gas gas_remaining wei
                            args ext_call.return_data[0], 0, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _4198) + 32]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                    else:
                        mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                        mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 398] = 0
                        mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 430] = 160
                        _4199 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                        mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                        idx = 0
                        s = ceil32(arg3.length) + 160
                        t = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 558
                        while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                        mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                        require ext_code.size(address(stor[_725]))
                        call address(stor[_725]).swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                             gas gas_remaining wei
                            args ext_call.return_data[0], 0, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _4199) + 32]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362
                        require return_data.size >= 32
                        _5007 = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362]
                        require mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                        require ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                        _5031 = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                        require mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                        require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                        mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                        require _5007 + (32 * _5031) + 32 <= return_data.size
                        idx = 0
                        s = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + _5007 + 394
                        t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 394
                        while idx < _5031:
                            require mem[s] == mem[s]
                            mem[t] = mem[s]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
            else:
                require 0 < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + 224 len ceil32(arg3.length)] = arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]
                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 224] = 0
                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + 228] = address(stor[mem[(2 * ceil32(arg3.length)) + (2 * ceil32(return_data.size)) + 224 len arg3.length + -ceil32(arg3.length) + 32]][Mask(8 * ceil32(arg3.length), -(8 * ceil32(arg3.length)) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * ceil32(arg3.length)) - 256])
                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + 260] = -1
                require ext_code.size(address(arg1))
                call address(arg1).approve(address rg1, uint256 rg2) with:
                     gas gas_remaining wei
                    args mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + 228], -1
                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + 224] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + 224] = 10
                mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + 256] = 'BurgerSwap'
                mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + 320] = 'BurgerSwap'
                mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + 288] = 10
                mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + 362 len ceil32(arg3.length)] = arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]
                mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + 330] = arg3.length
                mem[64] = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362
                if ceil32(arg3.length) <= arg3.length:
                    if ceil32(arg3.length) <= arg3.length:
                        if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = 0
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                            _5034 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                            idx = 0
                            s = ceil32(arg3.length) + 160
                            t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                            while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            require ext_code.size(address(stor[_725]))
                            call address(stor[_725]).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 0, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _5034) + 32]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                        else:
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = 0
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                            _5035 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                            idx = 0
                            s = ceil32(arg3.length) + 160
                            t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                            while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                            require ext_code.size(address(stor[_725]))
                            call address(stor[_725]).swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 0, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _5035) + 32]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362
                            require return_data.size >= 32
                            _5602 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362]
                            require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                            require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                            _5634 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                            require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                            require ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                            mem[ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                            require _5602 + (32 * _5634) + 32 <= return_data.size
                            idx = 0
                            s = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + _5602 + 394
                            t = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 394
                            while idx < _5634:
                                require mem[s] == mem[s]
                                mem[t] = mem[s]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                    else:
                        if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = 0
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                            _5074 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                            idx = 0
                            s = ceil32(arg3.length) + 160
                            t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                            while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            require ext_code.size(address(stor[_725]))
                            call address(stor[_725]).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 0, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _5074) + 32]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                        else:
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = 0
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                            _5075 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                            idx = 0
                            s = ceil32(arg3.length) + 160
                            t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                            while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                            require ext_code.size(address(stor[_725]))
                            call address(stor[_725]).swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 0, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _5075) + 32]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362
                            require return_data.size >= 32
                            _5603 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362]
                            require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                            require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                            _5635 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                            require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                            require ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                            mem[ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                            require _5603 + (32 * _5635) + 32 <= return_data.size
                            idx = 0
                            s = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + _5603 + 394
                            t = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 394
                            while idx < _5635:
                                require mem[s] == mem[s]
                                mem[t] = mem[s]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                else:
                    if ceil32(arg3.length) <= arg3.length:
                        if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = 0
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                            _5038 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                            idx = 0
                            s = ceil32(arg3.length) + 160
                            t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                            while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            require ext_code.size(address(stor[_725]))
                            call address(stor[_725]).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 0, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _5038) + 32]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                        else:
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = 0
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                            _5039 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                            idx = 0
                            s = ceil32(arg3.length) + 160
                            t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                            while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                            require ext_code.size(address(stor[_725]))
                            call address(stor[_725]).swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 0, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _5039) + 32]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362
                            require return_data.size >= 32
                            _5606 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362]
                            require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                            require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                            _5638 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                            require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                            require ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                            mem[ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                            require _5606 + (32 * _5638) + 32 <= return_data.size
                            idx = 0
                            s = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + _5606 + 394
                            t = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 394
                            while idx < _5638:
                                require mem[s] == mem[s]
                                mem[t] = mem[s]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                    else:
                        if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = 0
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                            _5078 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                            idx = 0
                            s = ceil32(arg3.length) + 160
                            t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                            while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            require ext_code.size(address(stor[_725]))
                            call address(stor[_725]).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 0, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _5078) + 32]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                        else:
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = 0
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                            _5079 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                            idx = 0
                            s = ceil32(arg3.length) + 160
                            t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                            while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                            require ext_code.size(address(stor[_725]))
                            call address(stor[_725]).swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 0, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _5079) + 32]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362
                            require return_data.size >= 32
                            _5607 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362]
                            require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                            require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                            _5639 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                            require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                            require ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                            mem[ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                            require _5607 + (32 * _5639) + 32 <= return_data.size
                            idx = 0
                            s = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + _5607 + 394
                            t = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 394
                            while idx < _5639:
                                require mem[s] == mem[s]
                                mem[t] = mem[s]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
    else:
        _729 = sha3(Mask(8 * ceil32(arg3.length), -(8 * ceil32(arg3.length)) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * ceil32(arg3.length)) - 256, mem[(2 * ceil32(arg3.length)) + 224 len arg3.length + -ceil32(arg3.length) + 32])
        require 0 < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
        mem[ceil32(arg3.length) + 160] = address(arg1)
        require 1 < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
        mem[ceil32(arg3.length) + 192] = address(arg2)
        require 0 < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
        mem[ceil32(arg3.length) + 228] = this.address
        require ext_code.size(address(arg1))
        call address(arg1).0x70a08231 with:
             gas gas_remaining wei
            args this.address
        mem[ceil32(arg3.length) + 224] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[0]
        if ext_call.return_data[0] <= 0:
            revert with 0, 'Failed'
        require 0 < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
        mem[ceil32(arg3.length) + ceil32(return_data.size) + 224 len ceil32(arg3.length)] = arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]
        mem[ceil32(arg3.length) + ceil32(return_data.size) + arg3.length + 224] = 0
        if ceil32(arg3.length) <= arg3.length:
            _1816 = sha3(Mask(8 * ceil32(arg3.length), -(8 * ceil32(arg3.length)) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * ceil32(arg3.length)) - 256, mem[(2 * ceil32(arg3.length)) + ceil32(return_data.size) + 224 len arg3.length + -ceil32(arg3.length) + 32])
            mem[ceil32(arg3.length) + ceil32(return_data.size) + 228] = this.address
            mem[ceil32(arg3.length) + ceil32(return_data.size) + 260] = address(stor[_1816])
            require ext_code.size(address(arg1))
            staticcall address(arg1).0xdd62ed3e with:
                    gas gas_remaining wei
                   args address(this.address), address(stor[_1816])
            mem[ceil32(arg3.length) + ceil32(return_data.size) + 224] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[0]
            if ext_call.return_data[0] >= ext_call.return_data[0]:
                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + 224] = 10
                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + 256] = 'BurgerSwap'
                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + 320] = 'BurgerSwap'
                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + 288] = 10
                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + 362 len ceil32(arg3.length)] = arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]
                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + 330] = arg3.length
                mem[64] = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362
                if ceil32(arg3.length) <= arg3.length:
                    if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                        mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                        mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                        mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 398] = 0
                        mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 430] = 160
                        _4158 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                        mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                        idx = 0
                        s = ceil32(arg3.length) + 160
                        t = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 558
                        while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        require ext_code.size(address(stor[_729]))
                        call address(stor[_729]).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                             gas gas_remaining wei
                            args ext_call.return_data[0], 0, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _4158) + 32]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                    else:
                        mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                        mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 398] = 0
                        mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 430] = 160
                        _4159 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                        mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                        idx = 0
                        s = ceil32(arg3.length) + 160
                        t = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 558
                        while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                        mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                        require ext_code.size(address(stor[_729]))
                        call address(stor[_729]).swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                             gas gas_remaining wei
                            args ext_call.return_data[0], 0, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _4159) + 32]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362
                        require return_data.size >= 32
                        _5010 = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362]
                        require mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                        require ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                        _5042 = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                        require mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                        require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                        mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                        require _5010 + (32 * _5042) + 32 <= return_data.size
                        idx = 0
                        s = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + _5010 + 394
                        t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 394
                        while idx < _5042:
                            require mem[s] == mem[s]
                            mem[t] = mem[s]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                else:
                    if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                        mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                        mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                        mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 398] = 0
                        mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 430] = 160
                        _4210 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                        mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                        idx = 0
                        s = ceil32(arg3.length) + 160
                        t = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 558
                        while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        require ext_code.size(address(stor[_729]))
                        call address(stor[_729]).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                             gas gas_remaining wei
                            args ext_call.return_data[0], 0, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _4210) + 32]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                    else:
                        mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                        mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 398] = 0
                        mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 430] = 160
                        _4211 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                        mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                        idx = 0
                        s = ceil32(arg3.length) + 160
                        t = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 558
                        while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                        mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                        require ext_code.size(address(stor[_729]))
                        call address(stor[_729]).swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                             gas gas_remaining wei
                            args ext_call.return_data[0], 0, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _4211) + 32]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362
                        require return_data.size >= 32
                        _5011 = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362]
                        require mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                        require ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                        _5043 = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                        require mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                        require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                        mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                        require _5011 + (32 * _5043) + 32 <= return_data.size
                        idx = 0
                        s = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + _5011 + 394
                        t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 394
                        while idx < _5043:
                            require mem[s] == mem[s]
                            mem[t] = mem[s]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
            else:
                require 0 < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + 224 len ceil32(arg3.length)] = arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]
                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 224] = 0
                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + 228] = address(stor[mem[(2 * ceil32(arg3.length)) + (2 * ceil32(return_data.size)) + 224 len arg3.length + -ceil32(arg3.length) + 32]][Mask(8 * ceil32(arg3.length), -(8 * ceil32(arg3.length)) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * ceil32(arg3.length)) - 256])
                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + 260] = -1
                require ext_code.size(address(arg1))
                call address(arg1).approve(address rg1, uint256 rg2) with:
                     gas gas_remaining wei
                    args mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + 228], -1
                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + 224] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + 224] = 10
                mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + 256] = 'BurgerSwap'
                mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + 320] = 'BurgerSwap'
                mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + 288] = 10
                mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + 362 len ceil32(arg3.length)] = arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]
                mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + 330] = arg3.length
                mem[64] = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362
                if ceil32(arg3.length) <= arg3.length:
                    if ceil32(arg3.length) <= arg3.length:
                        if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = 0
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                            _5046 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                            idx = 0
                            s = ceil32(arg3.length) + 160
                            t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                            while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            require ext_code.size(address(stor[_729]))
                            call address(stor[_729]).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 0, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _5046) + 32]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                        else:
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = 0
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                            _5047 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                            idx = 0
                            s = ceil32(arg3.length) + 160
                            t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                            while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                            require ext_code.size(address(stor[_729]))
                            call address(stor[_729]).swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 0, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _5047) + 32]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362
                            require return_data.size >= 32
                            _5610 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362]
                            require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                            require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                            _5642 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                            require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                            require ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                            mem[ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                            require _5610 + (32 * _5642) + 32 <= return_data.size
                            idx = 0
                            s = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + _5610 + 394
                            t = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 394
                            while idx < _5642:
                                require mem[s] == mem[s]
                                mem[t] = mem[s]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                    else:
                        if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = 0
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                            _5082 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                            idx = 0
                            s = ceil32(arg3.length) + 160
                            t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                            while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            require ext_code.size(address(stor[_729]))
                            call address(stor[_729]).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 0, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _5082) + 32]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                        else:
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = 0
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                            _5083 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                            idx = 0
                            s = ceil32(arg3.length) + 160
                            t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                            while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                            require ext_code.size(address(stor[_729]))
                            call address(stor[_729]).swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 0, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _5083) + 32]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362
                            require return_data.size >= 32
                            _5611 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362]
                            require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                            require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                            _5643 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                            require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                            require ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                            mem[ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                            require _5611 + (32 * _5643) + 32 <= return_data.size
                            idx = 0
                            s = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + _5611 + 394
                            t = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 394
                            while idx < _5643:
                                require mem[s] == mem[s]
                                mem[t] = mem[s]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                else:
                    if ceil32(arg3.length) <= arg3.length:
                        if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = 0
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                            _5050 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                            idx = 0
                            s = ceil32(arg3.length) + 160
                            t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                            while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            require ext_code.size(address(stor[_729]))
                            call address(stor[_729]).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 0, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _5050) + 32]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                        else:
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = 0
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                            _5051 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                            idx = 0
                            s = ceil32(arg3.length) + 160
                            t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                            while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                            require ext_code.size(address(stor[_729]))
                            call address(stor[_729]).swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 0, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _5051) + 32]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362
                            require return_data.size >= 32
                            _5614 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362]
                            require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                            require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                            _5646 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                            require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                            require ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                            mem[ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                            require _5614 + (32 * _5646) + 32 <= return_data.size
                            idx = 0
                            s = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + _5614 + 394
                            t = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 394
                            while idx < _5646:
                                require mem[s] == mem[s]
                                mem[t] = mem[s]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                    else:
                        if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = 0
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                            _5086 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                            idx = 0
                            s = ceil32(arg3.length) + 160
                            t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                            while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            require ext_code.size(address(stor[_729]))
                            call address(stor[_729]).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 0, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _5086) + 32]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                        else:
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = 0
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                            _5087 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                            idx = 0
                            s = ceil32(arg3.length) + 160
                            t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                            while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                            require ext_code.size(address(stor[_729]))
                            call address(stor[_729]).swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 0, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _5087) + 32]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362
                            require return_data.size >= 32
                            _5615 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362]
                            require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                            require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                            _5647 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                            require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                            require ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                            mem[ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                            require _5615 + (32 * _5647) + 32 <= return_data.size
                            idx = 0
                            s = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + _5615 + 394
                            t = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 394
                            while idx < _5647:
                                require mem[s] == mem[s]
                                mem[t] = mem[s]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
        else:
            _1822 = sha3(Mask(8 * ceil32(arg3.length), -(8 * ceil32(arg3.length)) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * ceil32(arg3.length)) - 256, mem[(2 * ceil32(arg3.length)) + ceil32(return_data.size) + 224 len arg3.length + -ceil32(arg3.length) + 32])
            mem[ceil32(arg3.length) + ceil32(return_data.size) + 228] = this.address
            mem[ceil32(arg3.length) + ceil32(return_data.size) + 260] = address(stor[_1822])
            require ext_code.size(address(arg1))
            staticcall address(arg1).0xdd62ed3e with:
                    gas gas_remaining wei
                   args address(this.address), address(stor[_1822])
            mem[ceil32(arg3.length) + ceil32(return_data.size) + 224] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[0]
            if ext_call.return_data[0] >= ext_call.return_data[0]:
                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + 224] = 10
                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + 256] = 'BurgerSwap'
                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + 320] = 'BurgerSwap'
                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + 288] = 10
                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + 362 len ceil32(arg3.length)] = arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]
                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + 330] = arg3.length
                mem[64] = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362
                if ceil32(arg3.length) <= arg3.length:
                    if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                        mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                        mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                        mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 398] = 0
                        mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 430] = 160
                        _4172 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                        mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                        idx = 0
                        s = ceil32(arg3.length) + 160
                        t = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 558
                        while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        require ext_code.size(address(stor[_729]))
                        call address(stor[_729]).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                             gas gas_remaining wei
                            args ext_call.return_data[0], 0, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _4172) + 32]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                    else:
                        mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                        mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 398] = 0
                        mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 430] = 160
                        _4173 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                        mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                        idx = 0
                        s = ceil32(arg3.length) + 160
                        t = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 558
                        while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                        mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                        require ext_code.size(address(stor[_729]))
                        call address(stor[_729]).swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                             gas gas_remaining wei
                            args ext_call.return_data[0], 0, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _4173) + 32]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362
                        require return_data.size >= 32
                        _5014 = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362]
                        require mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                        require ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                        _5054 = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                        require mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                        require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                        mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                        require _5014 + (32 * _5054) + 32 <= return_data.size
                        idx = 0
                        s = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + _5014 + 394
                        t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 394
                        while idx < _5054:
                            require mem[s] == mem[s]
                            mem[t] = mem[s]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                else:
                    if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                        mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                        mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                        mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 398] = 0
                        mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 430] = 160
                        _4222 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                        mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                        idx = 0
                        s = ceil32(arg3.length) + 160
                        t = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 558
                        while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        require ext_code.size(address(stor[_729]))
                        call address(stor[_729]).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                             gas gas_remaining wei
                            args ext_call.return_data[0], 0, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _4222) + 32]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                    else:
                        mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                        mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                        mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 398] = 0
                        mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 430] = 160
                        _4223 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                        mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                        idx = 0
                        s = ceil32(arg3.length) + 160
                        t = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 558
                        while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                            mem[t] = mem[s + 12 len 20]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
                        mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                        mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                        require ext_code.size(address(stor[_729]))
                        call address(stor[_729]).swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                             gas gas_remaining wei
                            args ext_call.return_data[0], 0, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _4223) + 32]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                        mem[64] = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362
                        require return_data.size >= 32
                        _5015 = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362]
                        require mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                        require ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                        _5055 = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                        require mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                        require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                        mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                        require _5015 + (32 * _5055) + 32 <= return_data.size
                        idx = 0
                        s = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + _5015 + 394
                        t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 394
                        while idx < _5055:
                            require mem[s] == mem[s]
                            mem[t] = mem[s]
                            idx = idx + 1
                            s = s + 32
                            t = t + 32
                            continue 
            else:
                require 0 < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + 224 len ceil32(arg3.length)] = arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]
                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 224] = 0
                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + 228] = address(stor[mem[(2 * ceil32(arg3.length)) + (2 * ceil32(return_data.size)) + 224 len arg3.length + -ceil32(arg3.length) + 32]][Mask(8 * ceil32(arg3.length), -(8 * ceil32(arg3.length)) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * ceil32(arg3.length)) - 256])
                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + 260] = -1
                require ext_code.size(address(arg1))
                call address(arg1).approve(address rg1, uint256 rg2) with:
                     gas gas_remaining wei
                    args mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + 228], -1
                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + 224] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + 224] = 10
                mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + 256] = 'BurgerSwap'
                mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + 320] = 'BurgerSwap'
                mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + 288] = 10
                mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + 362 len ceil32(arg3.length)] = arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]
                mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + 330] = arg3.length
                mem[64] = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362
                if ceil32(arg3.length) <= arg3.length:
                    if ceil32(arg3.length) <= arg3.length:
                        if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = 0
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                            _5058 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                            idx = 0
                            s = ceil32(arg3.length) + 160
                            t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                            while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            require ext_code.size(address(stor[_729]))
                            call address(stor[_729]).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 0, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _5058) + 32]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                        else:
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = 0
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                            _5059 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                            idx = 0
                            s = ceil32(arg3.length) + 160
                            t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                            while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                            require ext_code.size(address(stor[_729]))
                            call address(stor[_729]).swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 0, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _5059) + 32]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362
                            require return_data.size >= 32
                            _5618 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362]
                            require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                            require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                            _5650 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                            require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                            require ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                            mem[ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                            require _5618 + (32 * _5650) + 32 <= return_data.size
                            idx = 0
                            s = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + _5618 + 394
                            t = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 394
                            while idx < _5650:
                                require mem[s] == mem[s]
                                mem[t] = mem[s]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                    else:
                        if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = 0
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                            _5090 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                            idx = 0
                            s = ceil32(arg3.length) + 160
                            t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                            while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            require ext_code.size(address(stor[_729]))
                            call address(stor[_729]).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 0, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _5090) + 32]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                        else:
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = 0
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                            _5091 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                            idx = 0
                            s = ceil32(arg3.length) + 160
                            t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                            while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                            require ext_code.size(address(stor[_729]))
                            call address(stor[_729]).swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 0, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _5091) + 32]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362
                            require return_data.size >= 32
                            _5619 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362]
                            require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                            require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                            _5651 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                            require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                            require ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                            mem[ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                            require _5619 + (32 * _5651) + 32 <= return_data.size
                            idx = 0
                            s = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + _5619 + 394
                            t = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 394
                            while idx < _5651:
                                require mem[s] == mem[s]
                                mem[t] = mem[s]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                else:
                    if ceil32(arg3.length) <= arg3.length:
                        if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = 0
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                            _5062 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                            idx = 0
                            s = ceil32(arg3.length) + 160
                            t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                            while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            require ext_code.size(address(stor[_729]))
                            call address(stor[_729]).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 0, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _5062) + 32]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                        else:
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = 0
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                            _5063 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                            idx = 0
                            s = ceil32(arg3.length) + 160
                            t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                            while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                            require ext_code.size(address(stor[_729]))
                            call address(stor[_729]).swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 0, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _5063) + 32]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362
                            require return_data.size >= 32
                            _5622 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362]
                            require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                            require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                            _5654 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                            require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                            require ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                            mem[ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                            require _5622 + (32 * _5654) + 32 <= return_data.size
                            idx = 0
                            s = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + _5622 + 394
                            t = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 394
                            while idx < _5654:
                                require mem[s] == mem[s]
                                mem[t] = mem[s]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                    else:
                        if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x5c11d79500000000000000000000000000000000000000000000000000000000
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = 0
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                            _5094 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                            idx = 0
                            s = ceil32(arg3.length) + 160
                            t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                            while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            require ext_code.size(address(stor[_729]))
                            call address(stor[_729]).swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 0, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _5094) + 32]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                        else:
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x38ed173900000000000000000000000000000000000000000000000000000000
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = 0
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                            _5095 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                            idx = 0
                            s = ceil32(arg3.length) + 160
                            t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                            while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                mem[t] = mem[s + 12 len 20]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                            require ext_code.size(address(stor[_729]))
                            call address(stor[_729]).swapExactTokensForTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                 gas gas_remaining wei
                                args ext_call.return_data[0], 0, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _5095) + 32]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                            mem[64] = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362
                            require return_data.size >= 32
                            _5623 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362]
                            require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                            require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                            _5655 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                            require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                            require ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                            mem[ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                            require _5623 + (32 * _5655) + 32 <= return_data.size
                            idx = 0
                            s = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + _5623 + 394
                            t = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 394
                            while idx < _5655:
                                require mem[s] == mem[s]
                                mem[t] = mem[s]
                                idx = idx + 1
                                s = s + 32
                                t = t + 32
                                continue 
}

function sub_a730bfc8(?) {
    require calldata.size - 4 >= 128
    require arg1 == address(arg1)
    require arg2 == arg2
    require arg3 <= test266151307()
    require arg3 + 35 < calldata.size
    require arg3.length <= test266151307()
    require ceil32(arg3.length) + 128 <= test266151307() and ceil32(arg3.length) + 128 >= 96
    mem[96] = arg3.length
    require arg3 + arg3.length + 36 <= calldata.size
    mem[128 len arg3.length] = arg3[all]
    mem[arg3.length + 128] = 0
    require arg4 == arg4
    mem[ceil32(arg3.length) + 128] = 2
    mem[ceil32(arg3.length) + 160 len 64] = call.data[calldata.size len 64]
    mem[ceil32(arg3.length) + 224 len ceil32(arg3.length)] = arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]
    mem[ceil32(arg3.length) + arg3.length + 224] = 0
    if ceil32(arg3.length) <= arg3.length:
        _1818 = sha3(Mask(8 * ceil32(arg3.length), -(8 * ceil32(arg3.length)) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * ceil32(arg3.length)) - 256, mem[(2 * ceil32(arg3.length)) + 224 len arg3.length + -ceil32(arg3.length) + 32])
        require 0 < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
        mem[ceil32(arg3.length) + 160] = address(arg1)
        mem[ceil32(arg3.length) + 228] = this.address
        require ext_code.size(address(arg1))
        call address(arg1).0x70a08231 with:
             gas gas_remaining wei
            args this.address
        mem[ceil32(arg3.length) + 224] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[0]
        if ext_call.return_data[0] <= 0:
            revert with 0, 'Failed'
        mem[ceil32(arg3.length) + ceil32(return_data.size) + 224 len ceil32(arg3.length)] = arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]
        mem[ceil32(arg3.length) + ceil32(return_data.size) + arg3.length + 224] = 0
        if ceil32(arg3.length) <= arg3.length:
            _5856 = sha3(Mask(8 * ceil32(arg3.length), -(8 * ceil32(arg3.length)) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * ceil32(arg3.length)) - 256, mem[(2 * ceil32(arg3.length)) + ceil32(return_data.size) + 224 len arg3.length + -ceil32(arg3.length) + 32])
            mem[ceil32(arg3.length) + ceil32(return_data.size) + 228] = this.address
            mem[ceil32(arg3.length) + ceil32(return_data.size) + 260] = address(stor[_5856])
            require ext_code.size(address(arg1))
            staticcall address(arg1).0xdd62ed3e with:
                    gas gas_remaining wei
                   args address(this.address), address(stor[_5856])
            mem[ceil32(arg3.length) + ceil32(return_data.size) + 224] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[0]
            mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + 224 len ceil32(arg3.length)] = arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]
            if ext_call.return_data[0] >= ext_call.return_data[0]:
                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 224] = 1
                require 1 < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                mem[ceil32(arg3.length) + 192] = 0xbb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c
                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + 224] = 10
                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + 256] = 'BurgerSwap'
                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + 320] = 'BurgerSwap'
                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + 288] = 10
                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + 362 len ceil32(arg3.length)] = arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]
                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + 330] = arg3.length
                mem[64] = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362
                if ceil32(arg3.length) <= arg3.length:
                    if bool(uint8(stor[mem[(2 * ceil32(arg3.length)) + (2 * ceil32(return_data.size)) + 224 len arg3.length + -ceil32(arg3.length) + 32]][Mask(8 * ceil32(arg3.length), -(8 * ceil32(arg3.length)) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * ceil32(arg3.length)) - 256])) != 1:
                        if ceil32(arg3.length) <= arg3.length:
                            if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] = 0x791ac94700000000000000000000000000000000000000000000000000000000
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                _18561 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                idx = 0
                                s = ceil32(arg3.length) + 160
                                t = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 558
                                while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(address(stor[_1818]))
                                call address(stor[_1818]).swapExactTokensForETHSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _18561) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                            else:
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                _18562 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                idx = 0
                                s = ceil32(arg3.length) + 160
                                t = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 558
                                while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                                require ext_code.size(address(stor[_1818]))
                                call address(stor[_1818]).swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _18562) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362
                                require return_data.size >= 32
                                _22337 = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362]
                                require mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                                require ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                                _22657 = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                require mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                                require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                                mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                require _22337 + (32 * _22657) + 32 <= return_data.size
                                idx = 0
                                s = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + _22337 + 394
                                t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 394
                                while idx < _22657:
                                    require mem[s] == mem[s]
                                    mem[t] = mem[s]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                        else:
                            if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] = 0x791ac94700000000000000000000000000000000000000000000000000000000
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                _18721 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                idx = 0
                                s = ceil32(arg3.length) + 160
                                t = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 558
                                while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(address(stor[_1818]))
                                call address(stor[_1818]).swapExactTokensForETHSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _18721) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                            else:
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                _18722 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                idx = 0
                                s = ceil32(arg3.length) + 160
                                t = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 558
                                while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                                require ext_code.size(address(stor[_1818]))
                                call address(stor[_1818]).swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _18722) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362
                                require return_data.size >= 32
                                _22338 = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362]
                                require mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                                require ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                                _22658 = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                require mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                                require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                                mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                require _22338 + (32 * _22658) + 32 <= return_data.size
                                idx = 0
                                s = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + _22338 + 394
                                t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 394
                                while idx < _22658:
                                    require mem[s] == mem[s]
                                    mem[t] = mem[s]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                    else:
                        if ceil32(arg3.length) <= arg3.length:
                            if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] = 0xd46d2f8300000000000000000000000000000000000000000000000000000000
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                _18565 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                idx = 0
                                s = ceil32(arg3.length) + 160
                                t = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 558
                                while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(address(stor[_1818]))
                                call address(stor[_1818]).0xd46d2f83 with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _18565) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                            else:
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] = 0x5d616c5b00000000000000000000000000000000000000000000000000000000
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                _18566 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                idx = 0
                                s = ceil32(arg3.length) + 160
                                t = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 558
                                while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                                require ext_code.size(address(stor[_1818]))
                                call address(stor[_1818]).0x5d616c5b with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _18566) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362
                                require return_data.size >= 32
                                _22341 = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362]
                                require mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                                require ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                                _22661 = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                require mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                                require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                                mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                require _22341 + (32 * _22661) + 32 <= return_data.size
                                idx = 0
                                s = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + _22341 + 394
                                t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 394
                                while idx < _22661:
                                    require mem[s] == mem[s]
                                    mem[t] = mem[s]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                        else:
                            if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] = 0xd46d2f8300000000000000000000000000000000000000000000000000000000
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                _18725 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                idx = 0
                                s = ceil32(arg3.length) + 160
                                t = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 558
                                while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(address(stor[_1818]))
                                call address(stor[_1818]).0xd46d2f83 with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _18725) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                            else:
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] = 0x5d616c5b00000000000000000000000000000000000000000000000000000000
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                _18726 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                idx = 0
                                s = ceil32(arg3.length) + 160
                                t = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 558
                                while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                                require ext_code.size(address(stor[_1818]))
                                call address(stor[_1818]).0x5d616c5b with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _18726) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362
                                require return_data.size >= 32
                                _22342 = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362]
                                require mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                                require ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                                _22662 = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                require mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                                require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                                mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                require _22342 + (32 * _22662) + 32 <= return_data.size
                                idx = 0
                                s = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + _22342 + 394
                                t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 394
                                while idx < _22662:
                                    require mem[s] == mem[s]
                                    mem[t] = mem[s]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                else:
                    if bool(uint8(stor[mem[(2 * ceil32(arg3.length)) + (2 * ceil32(return_data.size)) + 224 len arg3.length + -ceil32(arg3.length) + 32]][Mask(8 * ceil32(arg3.length), -(8 * ceil32(arg3.length)) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * ceil32(arg3.length)) - 256])) != 1:
                        if ceil32(arg3.length) <= arg3.length:
                            if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] = 0x791ac94700000000000000000000000000000000000000000000000000000000
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                _18569 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                idx = 0
                                s = ceil32(arg3.length) + 160
                                t = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 558
                                while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(address(stor[_1818]))
                                call address(stor[_1818]).swapExactTokensForETHSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _18569) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                            else:
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                _18570 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                idx = 0
                                s = ceil32(arg3.length) + 160
                                t = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 558
                                while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                                require ext_code.size(address(stor[_1818]))
                                call address(stor[_1818]).swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _18570) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362
                                require return_data.size >= 32
                                _22345 = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362]
                                require mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                                require ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                                _22665 = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                require mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                                require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                                mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                require _22345 + (32 * _22665) + 32 <= return_data.size
                                idx = 0
                                s = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + _22345 + 394
                                t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 394
                                while idx < _22665:
                                    require mem[s] == mem[s]
                                    mem[t] = mem[s]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                        else:
                            if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] = 0x791ac94700000000000000000000000000000000000000000000000000000000
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                _18729 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                idx = 0
                                s = ceil32(arg3.length) + 160
                                t = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 558
                                while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(address(stor[_1818]))
                                call address(stor[_1818]).swapExactTokensForETHSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _18729) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                            else:
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                _18730 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                idx = 0
                                s = ceil32(arg3.length) + 160
                                t = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 558
                                while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                                require ext_code.size(address(stor[_1818]))
                                call address(stor[_1818]).swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _18730) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362
                                require return_data.size >= 32
                                _22346 = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362]
                                require mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                                require ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                                _22666 = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                require mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                                require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                                mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                require _22346 + (32 * _22666) + 32 <= return_data.size
                                idx = 0
                                s = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + _22346 + 394
                                t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 394
                                while idx < _22666:
                                    require mem[s] == mem[s]
                                    mem[t] = mem[s]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                    else:
                        if ceil32(arg3.length) <= arg3.length:
                            if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] = 0xd46d2f8300000000000000000000000000000000000000000000000000000000
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                _18573 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                idx = 0
                                s = ceil32(arg3.length) + 160
                                t = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 558
                                while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(address(stor[_1818]))
                                call address(stor[_1818]).0xd46d2f83 with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _18573) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                            else:
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] = 0x5d616c5b00000000000000000000000000000000000000000000000000000000
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                _18574 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                idx = 0
                                s = ceil32(arg3.length) + 160
                                t = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 558
                                while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                                require ext_code.size(address(stor[_1818]))
                                call address(stor[_1818]).0x5d616c5b with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _18574) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362
                                require return_data.size >= 32
                                _22349 = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362]
                                require mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                                require ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                                _22669 = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                require mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                                require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                                mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                require _22349 + (32 * _22669) + 32 <= return_data.size
                                idx = 0
                                s = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + _22349 + 394
                                t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 394
                                while idx < _22669:
                                    require mem[s] == mem[s]
                                    mem[t] = mem[s]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                        else:
                            if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] = 0xd46d2f8300000000000000000000000000000000000000000000000000000000
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                _18733 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                idx = 0
                                s = ceil32(arg3.length) + 160
                                t = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 558
                                while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(address(stor[_1818]))
                                call address(stor[_1818]).0xd46d2f83 with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _18733) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                            else:
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] = 0x5d616c5b00000000000000000000000000000000000000000000000000000000
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                _18734 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                idx = 0
                                s = ceil32(arg3.length) + 160
                                t = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 558
                                while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                                require ext_code.size(address(stor[_1818]))
                                call address(stor[_1818]).0x5d616c5b with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _18734) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362
                                require return_data.size >= 32
                                _22350 = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362]
                                require mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                                require ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                                _22670 = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                require mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                                require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                                mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                require _22350 + (32 * _22670) + 32 <= return_data.size
                                idx = 0
                                s = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + _22350 + 394
                                t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 394
                                while idx < _22670:
                                    require mem[s] == mem[s]
                                    mem[t] = mem[s]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
            else:
                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 224] = 0
                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + 228] = address(stor[mem[(2 * ceil32(arg3.length)) + (2 * ceil32(return_data.size)) + 224 len arg3.length + -ceil32(arg3.length) + 32]][Mask(8 * ceil32(arg3.length), -(8 * ceil32(arg3.length)) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * ceil32(arg3.length)) - 256])
                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + 260] = -1
                require ext_code.size(address(arg1))
                call address(arg1).approve(address rg1, uint256 rg2) with:
                     gas gas_remaining wei
                    args mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + 228], -1
                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + 224] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + 224 len ceil32(arg3.length)] = arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]
                mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 224] = 1
                require 1 < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                mem[ceil32(arg3.length) + 192] = 0xbb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c
                mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + 224] = 10
                mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + 256] = 'BurgerSwap'
                mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + 320] = 'BurgerSwap'
                mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + 288] = 10
                mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + 362 len ceil32(arg3.length)] = arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]
                mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + 330] = arg3.length
                mem[64] = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362
                if ceil32(arg3.length) <= arg3.length:
                    if ceil32(arg3.length) <= arg3.length:
                        if bool(uint8(stor[mem[(2 * ceil32(arg3.length)) + (4 * ceil32(return_data.size)) + 224 len arg3.length + -ceil32(arg3.length) + 32]][Mask(8 * ceil32(arg3.length), -(8 * ceil32(arg3.length)) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * ceil32(arg3.length)) - 256])) != 1:
                            if ceil32(arg3.length) <= arg3.length:
                                if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x791ac94700000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22401 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(address(stor[_1818]))
                                    call address(stor[_1818]).swapExactTokensForETHSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22401) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                else:
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22402 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                                    require ext_code.size(address(stor[_1818]))
                                    call address(stor[_1818]).swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22402) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362
                                    require return_data.size >= 32
                                    _24705 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                                    require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                                    _24833 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                                    require ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                                    mem[ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require _24705 + (32 * _24833) + 32 <= return_data.size
                                    idx = 0
                                    s = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + _24705 + 394
                                    t = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 394
                                    while idx < _24833:
                                        require mem[s] == mem[s]
                                        mem[t] = mem[s]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                            else:
                                if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x791ac94700000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22529 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(address(stor[_1818]))
                                    call address(stor[_1818]).swapExactTokensForETHSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22529) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                else:
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22530 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                                    require ext_code.size(address(stor[_1818]))
                                    call address(stor[_1818]).swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22530) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362
                                    require return_data.size >= 32
                                    _24706 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                                    require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                                    _24834 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                                    require ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                                    mem[ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require _24706 + (32 * _24834) + 32 <= return_data.size
                                    idx = 0
                                    s = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + _24706 + 394
                                    t = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 394
                                    while idx < _24834:
                                        require mem[s] == mem[s]
                                        mem[t] = mem[s]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                        else:
                            if ceil32(arg3.length) <= arg3.length:
                                if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0xd46d2f8300000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22405 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(address(stor[_1818]))
                                    call address(stor[_1818]).0xd46d2f83 with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22405) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                else:
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x5d616c5b00000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22406 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                                    require ext_code.size(address(stor[_1818]))
                                    call address(stor[_1818]).0x5d616c5b with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22406) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362
                                    require return_data.size >= 32
                                    _24709 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                                    require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                                    _24837 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                                    require ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                                    mem[ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require _24709 + (32 * _24837) + 32 <= return_data.size
                                    idx = 0
                                    s = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + _24709 + 394
                                    t = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 394
                                    while idx < _24837:
                                        require mem[s] == mem[s]
                                        mem[t] = mem[s]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                            else:
                                if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0xd46d2f8300000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22533 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(address(stor[_1818]))
                                    call address(stor[_1818]).0xd46d2f83 with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22533) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                else:
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x5d616c5b00000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22534 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                                    require ext_code.size(address(stor[_1818]))
                                    call address(stor[_1818]).0x5d616c5b with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22534) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362
                                    require return_data.size >= 32
                                    _24710 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                                    require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                                    _24838 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                                    require ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                                    mem[ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require _24710 + (32 * _24838) + 32 <= return_data.size
                                    idx = 0
                                    s = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + _24710 + 394
                                    t = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 394
                                    while idx < _24838:
                                        require mem[s] == mem[s]
                                        mem[t] = mem[s]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                    else:
                        if bool(uint8(stor[mem[(2 * ceil32(arg3.length)) + (4 * ceil32(return_data.size)) + 224 len arg3.length + -ceil32(arg3.length) + 32]][Mask(8 * ceil32(arg3.length), -(8 * ceil32(arg3.length)) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * ceil32(arg3.length)) - 256])) != 1:
                            if ceil32(arg3.length) <= arg3.length:
                                if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x791ac94700000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22409 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(address(stor[_1818]))
                                    call address(stor[_1818]).swapExactTokensForETHSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22409) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                else:
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22410 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                                    require ext_code.size(address(stor[_1818]))
                                    call address(stor[_1818]).swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22410) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362
                                    require return_data.size >= 32
                                    _24713 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                                    require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                                    _24841 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                                    require ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                                    mem[ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require _24713 + (32 * _24841) + 32 <= return_data.size
                                    idx = 0
                                    s = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + _24713 + 394
                                    t = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 394
                                    while idx < _24841:
                                        require mem[s] == mem[s]
                                        mem[t] = mem[s]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                            else:
                                if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x791ac94700000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22537 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(address(stor[_1818]))
                                    call address(stor[_1818]).swapExactTokensForETHSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22537) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                else:
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22538 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                                    require ext_code.size(address(stor[_1818]))
                                    call address(stor[_1818]).swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22538) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362
                                    require return_data.size >= 32
                                    _24714 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                                    require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                                    _24842 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                                    require ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                                    mem[ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require _24714 + (32 * _24842) + 32 <= return_data.size
                                    idx = 0
                                    s = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + _24714 + 394
                                    t = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 394
                                    while idx < _24842:
                                        require mem[s] == mem[s]
                                        mem[t] = mem[s]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                        else:
                            if ceil32(arg3.length) <= arg3.length:
                                if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0xd46d2f8300000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22413 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(address(stor[_1818]))
                                    call address(stor[_1818]).0xd46d2f83 with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22413) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                else:
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x5d616c5b00000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22414 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                                    require ext_code.size(address(stor[_1818]))
                                    call address(stor[_1818]).0x5d616c5b with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22414) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362
                                    require return_data.size >= 32
                                    _24717 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                                    require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                                    _24845 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                                    require ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                                    mem[ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require _24717 + (32 * _24845) + 32 <= return_data.size
                                    idx = 0
                                    s = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + _24717 + 394
                                    t = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 394
                                    while idx < _24845:
                                        require mem[s] == mem[s]
                                        mem[t] = mem[s]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                            else:
                                if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0xd46d2f8300000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22541 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(address(stor[_1818]))
                                    call address(stor[_1818]).0xd46d2f83 with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22541) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                else:
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x5d616c5b00000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22542 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                                    require ext_code.size(address(stor[_1818]))
                                    call address(stor[_1818]).0x5d616c5b with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22542) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362
                                    require return_data.size >= 32
                                    _24718 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                                    require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                                    _24846 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                                    require ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                                    mem[ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require _24718 + (32 * _24846) + 32 <= return_data.size
                                    idx = 0
                                    s = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + _24718 + 394
                                    t = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 394
                                    while idx < _24846:
                                        require mem[s] == mem[s]
                                        mem[t] = mem[s]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                else:
                    if ceil32(arg3.length) <= arg3.length:
                        if bool(uint8(stor[mem[(2 * ceil32(arg3.length)) + (4 * ceil32(return_data.size)) + 224 len arg3.length + -ceil32(arg3.length) + 32]][Mask(8 * ceil32(arg3.length), -(8 * ceil32(arg3.length)) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * ceil32(arg3.length)) - 256])) != 1:
                            if ceil32(arg3.length) <= arg3.length:
                                if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x791ac94700000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22417 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(address(stor[_1818]))
                                    call address(stor[_1818]).swapExactTokensForETHSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22417) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                else:
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22418 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                                    require ext_code.size(address(stor[_1818]))
                                    call address(stor[_1818]).swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22418) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362
                                    require return_data.size >= 32
                                    _24721 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                                    require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                                    _24849 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                                    require ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                                    mem[ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require _24721 + (32 * _24849) + 32 <= return_data.size
                                    idx = 0
                                    s = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + _24721 + 394
                                    t = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 394
                                    while idx < _24849:
                                        require mem[s] == mem[s]
                                        mem[t] = mem[s]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                            else:
                                if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x791ac94700000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22545 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(address(stor[_1818]))
                                    call address(stor[_1818]).swapExactTokensForETHSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22545) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                else:
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22546 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                                    require ext_code.size(address(stor[_1818]))
                                    call address(stor[_1818]).swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22546) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362
                                    require return_data.size >= 32
                                    _24722 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                                    require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                                    _24850 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                                    require ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                                    mem[ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require _24722 + (32 * _24850) + 32 <= return_data.size
                                    idx = 0
                                    s = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + _24722 + 394
                                    t = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 394
                                    while idx < _24850:
                                        require mem[s] == mem[s]
                                        mem[t] = mem[s]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                        else:
                            if ceil32(arg3.length) <= arg3.length:
                                if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0xd46d2f8300000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22421 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(address(stor[_1818]))
                                    call address(stor[_1818]).0xd46d2f83 with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22421) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                else:
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x5d616c5b00000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22422 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                                    require ext_code.size(address(stor[_1818]))
                                    call address(stor[_1818]).0x5d616c5b with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22422) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362
                                    require return_data.size >= 32
                                    _24725 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                                    require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                                    _24853 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                                    require ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                                    mem[ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require _24725 + (32 * _24853) + 32 <= return_data.size
                                    idx = 0
                                    s = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + _24725 + 394
                                    t = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 394
                                    while idx < _24853:
                                        require mem[s] == mem[s]
                                        mem[t] = mem[s]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                            else:
                                if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0xd46d2f8300000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22549 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(address(stor[_1818]))
                                    call address(stor[_1818]).0xd46d2f83 with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22549) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                else:
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x5d616c5b00000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22550 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                                    require ext_code.size(address(stor[_1818]))
                                    call address(stor[_1818]).0x5d616c5b with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22550) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362
                                    require return_data.size >= 32
                                    _24726 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                                    require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                                    _24854 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                                    require ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                                    mem[ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require _24726 + (32 * _24854) + 32 <= return_data.size
                                    idx = 0
                                    s = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + _24726 + 394
                                    t = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 394
                                    while idx < _24854:
                                        require mem[s] == mem[s]
                                        mem[t] = mem[s]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                    else:
                        if bool(uint8(stor[mem[(2 * ceil32(arg3.length)) + (4 * ceil32(return_data.size)) + 224 len arg3.length + -ceil32(arg3.length) + 32]][Mask(8 * ceil32(arg3.length), -(8 * ceil32(arg3.length)) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * ceil32(arg3.length)) - 256])) != 1:
                            if ceil32(arg3.length) <= arg3.length:
                                if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x791ac94700000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22425 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(address(stor[_1818]))
                                    call address(stor[_1818]).swapExactTokensForETHSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22425) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                else:
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22426 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                                    require ext_code.size(address(stor[_1818]))
                                    call address(stor[_1818]).swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22426) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362
                                    require return_data.size >= 32
                                    _24729 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                                    require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                                    _24857 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                                    require ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                                    mem[ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require _24729 + (32 * _24857) + 32 <= return_data.size
                                    idx = 0
                                    s = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + _24729 + 394
                                    t = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 394
                                    while idx < _24857:
                                        require mem[s] == mem[s]
                                        mem[t] = mem[s]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                            else:
                                if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x791ac94700000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22553 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(address(stor[_1818]))
                                    call address(stor[_1818]).swapExactTokensForETHSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22553) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                else:
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22554 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                                    require ext_code.size(address(stor[_1818]))
                                    call address(stor[_1818]).swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22554) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362
                                    require return_data.size >= 32
                                    _24730 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                                    require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                                    _24858 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                                    require ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                                    mem[ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require _24730 + (32 * _24858) + 32 <= return_data.size
                                    idx = 0
                                    s = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + _24730 + 394
                                    t = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 394
                                    while idx < _24858:
                                        require mem[s] == mem[s]
                                        mem[t] = mem[s]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                        else:
                            if ceil32(arg3.length) <= arg3.length:
                                if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0xd46d2f8300000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22429 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(address(stor[_1818]))
                                    call address(stor[_1818]).0xd46d2f83 with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22429) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                else:
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x5d616c5b00000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22430 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                                    require ext_code.size(address(stor[_1818]))
                                    call address(stor[_1818]).0x5d616c5b with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22430) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362
                                    require return_data.size >= 32
                                    _24733 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                                    require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                                    _24861 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                                    require ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                                    mem[ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require _24733 + (32 * _24861) + 32 <= return_data.size
                                    idx = 0
                                    s = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + _24733 + 394
                                    t = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 394
                                    while idx < _24861:
                                        require mem[s] == mem[s]
                                        mem[t] = mem[s]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                            else:
                                if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0xd46d2f8300000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22557 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(address(stor[_1818]))
                                    call address(stor[_1818]).0xd46d2f83 with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22557) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                else:
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x5d616c5b00000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22558 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                                    require ext_code.size(address(stor[_1818]))
                                    call address(stor[_1818]).0x5d616c5b with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22558) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362
                                    require return_data.size >= 32
                                    _24734 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                                    require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                                    _24862 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                                    require ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                                    mem[ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require _24734 + (32 * _24862) + 32 <= return_data.size
                                    idx = 0
                                    s = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + _24734 + 394
                                    t = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 394
                                    while idx < _24862:
                                        require mem[s] == mem[s]
                                        mem[t] = mem[s]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
        else:
            _5862 = sha3(Mask(8 * ceil32(arg3.length), -(8 * ceil32(arg3.length)) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * ceil32(arg3.length)) - 256, mem[(2 * ceil32(arg3.length)) + ceil32(return_data.size) + 224 len arg3.length + -ceil32(arg3.length) + 32])
            mem[ceil32(arg3.length) + ceil32(return_data.size) + 228] = this.address
            mem[ceil32(arg3.length) + ceil32(return_data.size) + 260] = address(stor[_5862])
            require ext_code.size(address(arg1))
            staticcall address(arg1).0xdd62ed3e with:
                    gas gas_remaining wei
                   args address(this.address), address(stor[_5862])
            mem[ceil32(arg3.length) + ceil32(return_data.size) + 224] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[0]
            mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + 224 len ceil32(arg3.length)] = arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]
            if ext_call.return_data[0] >= ext_call.return_data[0]:
                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 224] = 1
                require 1 < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                mem[ceil32(arg3.length) + 192] = 0xbb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c
                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + 224] = 10
                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + 256] = 'BurgerSwap'
                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + 320] = 'BurgerSwap'
                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + 288] = 10
                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + 362 len ceil32(arg3.length)] = arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]
                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + 330] = arg3.length
                mem[64] = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362
                if ceil32(arg3.length) <= arg3.length:
                    if bool(uint8(stor[mem[(2 * ceil32(arg3.length)) + (2 * ceil32(return_data.size)) + 224 len arg3.length + -ceil32(arg3.length) + 32]][Mask(8 * ceil32(arg3.length), -(8 * ceil32(arg3.length)) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * ceil32(arg3.length)) - 256])) != 1:
                        if ceil32(arg3.length) <= arg3.length:
                            if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] = 0x791ac94700000000000000000000000000000000000000000000000000000000
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                _18601 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                idx = 0
                                s = ceil32(arg3.length) + 160
                                t = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 558
                                while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(address(stor[_1818]))
                                call address(stor[_1818]).swapExactTokensForETHSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _18601) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                            else:
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                _18602 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                idx = 0
                                s = ceil32(arg3.length) + 160
                                t = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 558
                                while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                                require ext_code.size(address(stor[_1818]))
                                call address(stor[_1818]).swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _18602) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362
                                require return_data.size >= 32
                                _22353 = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362]
                                require mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                                require ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                                _22673 = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                require mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                                require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                                mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                require _22353 + (32 * _22673) + 32 <= return_data.size
                                idx = 0
                                s = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + _22353 + 394
                                t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 394
                                while idx < _22673:
                                    require mem[s] == mem[s]
                                    mem[t] = mem[s]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                        else:
                            if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] = 0x791ac94700000000000000000000000000000000000000000000000000000000
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                _18785 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                idx = 0
                                s = ceil32(arg3.length) + 160
                                t = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 558
                                while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(address(stor[_1818]))
                                call address(stor[_1818]).swapExactTokensForETHSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _18785) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                            else:
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                _18786 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                idx = 0
                                s = ceil32(arg3.length) + 160
                                t = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 558
                                while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                                require ext_code.size(address(stor[_1818]))
                                call address(stor[_1818]).swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _18786) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362
                                require return_data.size >= 32
                                _22354 = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362]
                                require mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                                require ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                                _22674 = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                require mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                                require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                                mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                require _22354 + (32 * _22674) + 32 <= return_data.size
                                idx = 0
                                s = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + _22354 + 394
                                t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 394
                                while idx < _22674:
                                    require mem[s] == mem[s]
                                    mem[t] = mem[s]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                    else:
                        if ceil32(arg3.length) <= arg3.length:
                            if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] = 0xd46d2f8300000000000000000000000000000000000000000000000000000000
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                _18605 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                idx = 0
                                s = ceil32(arg3.length) + 160
                                t = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 558
                                while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(address(stor[_1818]))
                                call address(stor[_1818]).0xd46d2f83 with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _18605) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                            else:
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] = 0x5d616c5b00000000000000000000000000000000000000000000000000000000
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                _18606 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                idx = 0
                                s = ceil32(arg3.length) + 160
                                t = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 558
                                while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                                require ext_code.size(address(stor[_1818]))
                                call address(stor[_1818]).0x5d616c5b with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _18606) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362
                                require return_data.size >= 32
                                _22357 = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362]
                                require mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                                require ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                                _22677 = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                require mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                                require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                                mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                require _22357 + (32 * _22677) + 32 <= return_data.size
                                idx = 0
                                s = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + _22357 + 394
                                t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 394
                                while idx < _22677:
                                    require mem[s] == mem[s]
                                    mem[t] = mem[s]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                        else:
                            if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] = 0xd46d2f8300000000000000000000000000000000000000000000000000000000
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                _18789 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                idx = 0
                                s = ceil32(arg3.length) + 160
                                t = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 558
                                while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(address(stor[_1818]))
                                call address(stor[_1818]).0xd46d2f83 with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _18789) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                            else:
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] = 0x5d616c5b00000000000000000000000000000000000000000000000000000000
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                _18790 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                idx = 0
                                s = ceil32(arg3.length) + 160
                                t = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 558
                                while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                                require ext_code.size(address(stor[_1818]))
                                call address(stor[_1818]).0x5d616c5b with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _18790) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362
                                require return_data.size >= 32
                                _22358 = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362]
                                require mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                                require ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                                _22678 = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                require mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                                require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                                mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                require _22358 + (32 * _22678) + 32 <= return_data.size
                                idx = 0
                                s = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + _22358 + 394
                                t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 394
                                while idx < _22678:
                                    require mem[s] == mem[s]
                                    mem[t] = mem[s]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                else:
                    if bool(uint8(stor[mem[(2 * ceil32(arg3.length)) + (2 * ceil32(return_data.size)) + 224 len arg3.length + -ceil32(arg3.length) + 32]][Mask(8 * ceil32(arg3.length), -(8 * ceil32(arg3.length)) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * ceil32(arg3.length)) - 256])) != 1:
                        if ceil32(arg3.length) <= arg3.length:
                            if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] = 0x791ac94700000000000000000000000000000000000000000000000000000000
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                _18609 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                idx = 0
                                s = ceil32(arg3.length) + 160
                                t = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 558
                                while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(address(stor[_1818]))
                                call address(stor[_1818]).swapExactTokensForETHSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _18609) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                            else:
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                _18610 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                idx = 0
                                s = ceil32(arg3.length) + 160
                                t = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 558
                                while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                                require ext_code.size(address(stor[_1818]))
                                call address(stor[_1818]).swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _18610) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362
                                require return_data.size >= 32
                                _22361 = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362]
                                require mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                                require ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                                _22681 = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                require mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                                require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                                mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                require _22361 + (32 * _22681) + 32 <= return_data.size
                                idx = 0
                                s = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + _22361 + 394
                                t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 394
                                while idx < _22681:
                                    require mem[s] == mem[s]
                                    mem[t] = mem[s]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                        else:
                            if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] = 0x791ac94700000000000000000000000000000000000000000000000000000000
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                _18793 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                idx = 0
                                s = ceil32(arg3.length) + 160
                                t = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 558
                                while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(address(stor[_1818]))
                                call address(stor[_1818]).swapExactTokensForETHSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _18793) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                            else:
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                _18794 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                idx = 0
                                s = ceil32(arg3.length) + 160
                                t = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 558
                                while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                                require ext_code.size(address(stor[_1818]))
                                call address(stor[_1818]).swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _18794) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362
                                require return_data.size >= 32
                                _22362 = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362]
                                require mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                                require ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                                _22682 = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                require mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                                require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                                mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                require _22362 + (32 * _22682) + 32 <= return_data.size
                                idx = 0
                                s = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + _22362 + 394
                                t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 394
                                while idx < _22682:
                                    require mem[s] == mem[s]
                                    mem[t] = mem[s]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                    else:
                        if ceil32(arg3.length) <= arg3.length:
                            if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] = 0xd46d2f8300000000000000000000000000000000000000000000000000000000
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                _18613 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                idx = 0
                                s = ceil32(arg3.length) + 160
                                t = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 558
                                while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(address(stor[_1818]))
                                call address(stor[_1818]).0xd46d2f83 with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _18613) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                            else:
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] = 0x5d616c5b00000000000000000000000000000000000000000000000000000000
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                _18614 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                idx = 0
                                s = ceil32(arg3.length) + 160
                                t = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 558
                                while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                                require ext_code.size(address(stor[_1818]))
                                call address(stor[_1818]).0x5d616c5b with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _18614) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362
                                require return_data.size >= 32
                                _22365 = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362]
                                require mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                                require ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                                _22685 = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                require mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                                require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                                mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                require _22365 + (32 * _22685) + 32 <= return_data.size
                                idx = 0
                                s = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + _22365 + 394
                                t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 394
                                while idx < _22685:
                                    require mem[s] == mem[s]
                                    mem[t] = mem[s]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                        else:
                            if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] = 0xd46d2f8300000000000000000000000000000000000000000000000000000000
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                _18797 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                idx = 0
                                s = ceil32(arg3.length) + 160
                                t = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 558
                                while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(address(stor[_1818]))
                                call address(stor[_1818]).0xd46d2f83 with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _18797) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                            else:
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] = 0x5d616c5b00000000000000000000000000000000000000000000000000000000
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                _18798 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                idx = 0
                                s = ceil32(arg3.length) + 160
                                t = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 558
                                while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                                require ext_code.size(address(stor[_1818]))
                                call address(stor[_1818]).0x5d616c5b with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _18798) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362
                                require return_data.size >= 32
                                _22366 = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362]
                                require mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                                require ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                                _22686 = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                require mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                                require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                                mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                require _22366 + (32 * _22686) + 32 <= return_data.size
                                idx = 0
                                s = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + _22366 + 394
                                t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 394
                                while idx < _22686:
                                    require mem[s] == mem[s]
                                    mem[t] = mem[s]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
            else:
                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 224] = 0
                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + 228] = address(stor[mem[(2 * ceil32(arg3.length)) + (2 * ceil32(return_data.size)) + 224 len arg3.length + -ceil32(arg3.length) + 32]][Mask(8 * ceil32(arg3.length), -(8 * ceil32(arg3.length)) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * ceil32(arg3.length)) - 256])
                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + 260] = -1
                require ext_code.size(address(arg1))
                call address(arg1).approve(address rg1, uint256 rg2) with:
                     gas gas_remaining wei
                    args mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + 228], -1
                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + 224] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + 224 len ceil32(arg3.length)] = arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]
                mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 224] = 1
                require 1 < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                mem[ceil32(arg3.length) + 192] = 0xbb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c
                mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + 224] = 10
                mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + 256] = 'BurgerSwap'
                mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + 320] = 'BurgerSwap'
                mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + 288] = 10
                mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + 362 len ceil32(arg3.length)] = arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]
                mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + 330] = arg3.length
                mem[64] = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362
                if ceil32(arg3.length) <= arg3.length:
                    if ceil32(arg3.length) <= arg3.length:
                        if bool(uint8(stor[mem[(2 * ceil32(arg3.length)) + (4 * ceil32(return_data.size)) + 224 len arg3.length + -ceil32(arg3.length) + 32]][Mask(8 * ceil32(arg3.length), -(8 * ceil32(arg3.length)) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * ceil32(arg3.length)) - 256])) != 1:
                            if ceil32(arg3.length) <= arg3.length:
                                if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x791ac94700000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22433 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(address(stor[_1818]))
                                    call address(stor[_1818]).swapExactTokensForETHSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22433) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                else:
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22434 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                                    require ext_code.size(address(stor[_1818]))
                                    call address(stor[_1818]).swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22434) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362
                                    require return_data.size >= 32
                                    _24737 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                                    require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                                    _24865 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                                    require ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                                    mem[ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require _24737 + (32 * _24865) + 32 <= return_data.size
                                    idx = 0
                                    s = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + _24737 + 394
                                    t = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 394
                                    while idx < _24865:
                                        require mem[s] == mem[s]
                                        mem[t] = mem[s]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                            else:
                                if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x791ac94700000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22561 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(address(stor[_1818]))
                                    call address(stor[_1818]).swapExactTokensForETHSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22561) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                else:
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22562 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                                    require ext_code.size(address(stor[_1818]))
                                    call address(stor[_1818]).swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22562) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362
                                    require return_data.size >= 32
                                    _24738 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                                    require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                                    _24866 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                                    require ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                                    mem[ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require _24738 + (32 * _24866) + 32 <= return_data.size
                                    idx = 0
                                    s = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + _24738 + 394
                                    t = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 394
                                    while idx < _24866:
                                        require mem[s] == mem[s]
                                        mem[t] = mem[s]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                        else:
                            if ceil32(arg3.length) <= arg3.length:
                                if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0xd46d2f8300000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22437 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(address(stor[_1818]))
                                    call address(stor[_1818]).0xd46d2f83 with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22437) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                else:
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x5d616c5b00000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22438 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                                    require ext_code.size(address(stor[_1818]))
                                    call address(stor[_1818]).0x5d616c5b with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22438) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362
                                    require return_data.size >= 32
                                    _24741 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                                    require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                                    _24869 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                                    require ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                                    mem[ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require _24741 + (32 * _24869) + 32 <= return_data.size
                                    idx = 0
                                    s = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + _24741 + 394
                                    t = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 394
                                    while idx < _24869:
                                        require mem[s] == mem[s]
                                        mem[t] = mem[s]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                            else:
                                if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0xd46d2f8300000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22565 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(address(stor[_1818]))
                                    call address(stor[_1818]).0xd46d2f83 with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22565) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                else:
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x5d616c5b00000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22566 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                                    require ext_code.size(address(stor[_1818]))
                                    call address(stor[_1818]).0x5d616c5b with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22566) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362
                                    require return_data.size >= 32
                                    _24742 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                                    require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                                    _24870 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                                    require ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                                    mem[ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require _24742 + (32 * _24870) + 32 <= return_data.size
                                    idx = 0
                                    s = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + _24742 + 394
                                    t = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 394
                                    while idx < _24870:
                                        require mem[s] == mem[s]
                                        mem[t] = mem[s]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                    else:
                        if bool(uint8(stor[mem[(2 * ceil32(arg3.length)) + (4 * ceil32(return_data.size)) + 224 len arg3.length + -ceil32(arg3.length) + 32]][Mask(8 * ceil32(arg3.length), -(8 * ceil32(arg3.length)) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * ceil32(arg3.length)) - 256])) != 1:
                            if ceil32(arg3.length) <= arg3.length:
                                if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x791ac94700000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22441 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(address(stor[_1818]))
                                    call address(stor[_1818]).swapExactTokensForETHSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22441) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                else:
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22442 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                                    require ext_code.size(address(stor[_1818]))
                                    call address(stor[_1818]).swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22442) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362
                                    require return_data.size >= 32
                                    _24745 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                                    require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                                    _24873 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                                    require ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                                    mem[ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require _24745 + (32 * _24873) + 32 <= return_data.size
                                    idx = 0
                                    s = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + _24745 + 394
                                    t = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 394
                                    while idx < _24873:
                                        require mem[s] == mem[s]
                                        mem[t] = mem[s]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                            else:
                                if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x791ac94700000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22569 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(address(stor[_1818]))
                                    call address(stor[_1818]).swapExactTokensForETHSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22569) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                else:
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22570 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                                    require ext_code.size(address(stor[_1818]))
                                    call address(stor[_1818]).swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22570) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362
                                    require return_data.size >= 32
                                    _24746 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                                    require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                                    _24874 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                                    require ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                                    mem[ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require _24746 + (32 * _24874) + 32 <= return_data.size
                                    idx = 0
                                    s = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + _24746 + 394
                                    t = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 394
                                    while idx < _24874:
                                        require mem[s] == mem[s]
                                        mem[t] = mem[s]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                        else:
                            if ceil32(arg3.length) <= arg3.length:
                                if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0xd46d2f8300000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22445 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(address(stor[_1818]))
                                    call address(stor[_1818]).0xd46d2f83 with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22445) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                else:
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x5d616c5b00000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22446 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                                    require ext_code.size(address(stor[_1818]))
                                    call address(stor[_1818]).0x5d616c5b with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22446) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362
                                    require return_data.size >= 32
                                    _24749 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                                    require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                                    _24877 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                                    require ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                                    mem[ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require _24749 + (32 * _24877) + 32 <= return_data.size
                                    idx = 0
                                    s = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + _24749 + 394
                                    t = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 394
                                    while idx < _24877:
                                        require mem[s] == mem[s]
                                        mem[t] = mem[s]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                            else:
                                if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0xd46d2f8300000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22573 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(address(stor[_1818]))
                                    call address(stor[_1818]).0xd46d2f83 with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22573) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                else:
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x5d616c5b00000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22574 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                                    require ext_code.size(address(stor[_1818]))
                                    call address(stor[_1818]).0x5d616c5b with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22574) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362
                                    require return_data.size >= 32
                                    _24750 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                                    require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                                    _24878 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                                    require ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                                    mem[ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require _24750 + (32 * _24878) + 32 <= return_data.size
                                    idx = 0
                                    s = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + _24750 + 394
                                    t = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 394
                                    while idx < _24878:
                                        require mem[s] == mem[s]
                                        mem[t] = mem[s]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                else:
                    if ceil32(arg3.length) <= arg3.length:
                        if bool(uint8(stor[mem[(2 * ceil32(arg3.length)) + (4 * ceil32(return_data.size)) + 224 len arg3.length + -ceil32(arg3.length) + 32]][Mask(8 * ceil32(arg3.length), -(8 * ceil32(arg3.length)) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * ceil32(arg3.length)) - 256])) != 1:
                            if ceil32(arg3.length) <= arg3.length:
                                if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x791ac94700000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22449 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(address(stor[_1818]))
                                    call address(stor[_1818]).swapExactTokensForETHSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22449) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                else:
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22450 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                                    require ext_code.size(address(stor[_1818]))
                                    call address(stor[_1818]).swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22450) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362
                                    require return_data.size >= 32
                                    _24753 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                                    require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                                    _24881 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                                    require ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                                    mem[ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require _24753 + (32 * _24881) + 32 <= return_data.size
                                    idx = 0
                                    s = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + _24753 + 394
                                    t = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 394
                                    while idx < _24881:
                                        require mem[s] == mem[s]
                                        mem[t] = mem[s]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                            else:
                                if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x791ac94700000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22577 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(address(stor[_1818]))
                                    call address(stor[_1818]).swapExactTokensForETHSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22577) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                else:
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22578 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                                    require ext_code.size(address(stor[_1818]))
                                    call address(stor[_1818]).swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22578) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362
                                    require return_data.size >= 32
                                    _24754 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                                    require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                                    _24882 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                                    require ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                                    mem[ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require _24754 + (32 * _24882) + 32 <= return_data.size
                                    idx = 0
                                    s = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + _24754 + 394
                                    t = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 394
                                    while idx < _24882:
                                        require mem[s] == mem[s]
                                        mem[t] = mem[s]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                        else:
                            if ceil32(arg3.length) <= arg3.length:
                                if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0xd46d2f8300000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22453 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(address(stor[_1818]))
                                    call address(stor[_1818]).0xd46d2f83 with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22453) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                else:
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x5d616c5b00000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22454 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                                    require ext_code.size(address(stor[_1818]))
                                    call address(stor[_1818]).0x5d616c5b with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22454) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362
                                    require return_data.size >= 32
                                    _24757 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                                    require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                                    _24885 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                                    require ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                                    mem[ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require _24757 + (32 * _24885) + 32 <= return_data.size
                                    idx = 0
                                    s = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + _24757 + 394
                                    t = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 394
                                    while idx < _24885:
                                        require mem[s] == mem[s]
                                        mem[t] = mem[s]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                            else:
                                if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0xd46d2f8300000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22581 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(address(stor[_1818]))
                                    call address(stor[_1818]).0xd46d2f83 with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22581) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                else:
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x5d616c5b00000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22582 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                                    require ext_code.size(address(stor[_1818]))
                                    call address(stor[_1818]).0x5d616c5b with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22582) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362
                                    require return_data.size >= 32
                                    _24758 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                                    require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                                    _24886 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                                    require ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                                    mem[ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require _24758 + (32 * _24886) + 32 <= return_data.size
                                    idx = 0
                                    s = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + _24758 + 394
                                    t = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 394
                                    while idx < _24886:
                                        require mem[s] == mem[s]
                                        mem[t] = mem[s]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                    else:
                        if bool(uint8(stor[mem[(2 * ceil32(arg3.length)) + (4 * ceil32(return_data.size)) + 224 len arg3.length + -ceil32(arg3.length) + 32]][Mask(8 * ceil32(arg3.length), -(8 * ceil32(arg3.length)) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * ceil32(arg3.length)) - 256])) != 1:
                            if ceil32(arg3.length) <= arg3.length:
                                if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x791ac94700000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22457 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(address(stor[_1818]))
                                    call address(stor[_1818]).swapExactTokensForETHSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22457) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                else:
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22458 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                                    require ext_code.size(address(stor[_1818]))
                                    call address(stor[_1818]).swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22458) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362
                                    require return_data.size >= 32
                                    _24761 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                                    require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                                    _24889 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                                    require ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                                    mem[ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require _24761 + (32 * _24889) + 32 <= return_data.size
                                    idx = 0
                                    s = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + _24761 + 394
                                    t = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 394
                                    while idx < _24889:
                                        require mem[s] == mem[s]
                                        mem[t] = mem[s]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                            else:
                                if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x791ac94700000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22585 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(address(stor[_1818]))
                                    call address(stor[_1818]).swapExactTokensForETHSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22585) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                else:
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22586 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                                    require ext_code.size(address(stor[_1818]))
                                    call address(stor[_1818]).swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22586) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362
                                    require return_data.size >= 32
                                    _24762 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                                    require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                                    _24890 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                                    require ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                                    mem[ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require _24762 + (32 * _24890) + 32 <= return_data.size
                                    idx = 0
                                    s = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + _24762 + 394
                                    t = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 394
                                    while idx < _24890:
                                        require mem[s] == mem[s]
                                        mem[t] = mem[s]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                        else:
                            if ceil32(arg3.length) <= arg3.length:
                                if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0xd46d2f8300000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22461 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(address(stor[_1818]))
                                    call address(stor[_1818]).0xd46d2f83 with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22461) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                else:
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x5d616c5b00000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22462 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                                    require ext_code.size(address(stor[_1818]))
                                    call address(stor[_1818]).0x5d616c5b with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22462) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362
                                    require return_data.size >= 32
                                    _24765 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                                    require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                                    _24893 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                                    require ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                                    mem[ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require _24765 + (32 * _24893) + 32 <= return_data.size
                                    idx = 0
                                    s = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + _24765 + 394
                                    t = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 394
                                    while idx < _24893:
                                        require mem[s] == mem[s]
                                        mem[t] = mem[s]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                            else:
                                if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0xd46d2f8300000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22589 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(address(stor[_1818]))
                                    call address(stor[_1818]).0xd46d2f83 with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22589) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                else:
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x5d616c5b00000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22590 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                                    require ext_code.size(address(stor[_1818]))
                                    call address(stor[_1818]).0x5d616c5b with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22590) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362
                                    require return_data.size >= 32
                                    _24766 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                                    require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                                    _24894 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                                    require ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                                    mem[ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require _24766 + (32 * _24894) + 32 <= return_data.size
                                    idx = 0
                                    s = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + _24766 + 394
                                    t = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 394
                                    while idx < _24894:
                                        require mem[s] == mem[s]
                                        mem[t] = mem[s]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
    else:
        _1822 = sha3(Mask(8 * ceil32(arg3.length), -(8 * ceil32(arg3.length)) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * ceil32(arg3.length)) - 256, mem[(2 * ceil32(arg3.length)) + 224 len arg3.length + -ceil32(arg3.length) + 32])
        require 0 < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
        mem[ceil32(arg3.length) + 160] = address(arg1)
        mem[ceil32(arg3.length) + 228] = this.address
        require ext_code.size(address(arg1))
        call address(arg1).0x70a08231 with:
             gas gas_remaining wei
            args this.address
        mem[ceil32(arg3.length) + 224] = ext_call.return_data[0]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 32
        require ext_call.return_data[0] == ext_call.return_data[0]
        if ext_call.return_data[0] <= 0:
            revert with 0, 'Failed'
        mem[ceil32(arg3.length) + ceil32(return_data.size) + 224 len ceil32(arg3.length)] = arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]
        mem[ceil32(arg3.length) + ceil32(return_data.size) + arg3.length + 224] = 0
        if ceil32(arg3.length) <= arg3.length:
            _5859 = sha3(Mask(8 * ceil32(arg3.length), -(8 * ceil32(arg3.length)) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * ceil32(arg3.length)) - 256, mem[(2 * ceil32(arg3.length)) + ceil32(return_data.size) + 224 len arg3.length + -ceil32(arg3.length) + 32])
            mem[ceil32(arg3.length) + ceil32(return_data.size) + 228] = this.address
            mem[ceil32(arg3.length) + ceil32(return_data.size) + 260] = address(stor[_5859])
            require ext_code.size(address(arg1))
            staticcall address(arg1).0xdd62ed3e with:
                    gas gas_remaining wei
                   args address(this.address), address(stor[_5859])
            mem[ceil32(arg3.length) + ceil32(return_data.size) + 224] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[0]
            mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + 224 len ceil32(arg3.length)] = arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]
            if ext_call.return_data[0] >= ext_call.return_data[0]:
                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 224] = 1
                require 1 < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                mem[ceil32(arg3.length) + 192] = 0xbb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c
                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + 224] = 10
                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + 256] = 'BurgerSwap'
                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + 320] = 'BurgerSwap'
                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + 288] = 10
                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + 362 len ceil32(arg3.length)] = arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]
                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + 330] = arg3.length
                mem[64] = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362
                if ceil32(arg3.length) <= arg3.length:
                    if bool(uint8(stor[mem[(2 * ceil32(arg3.length)) + (2 * ceil32(return_data.size)) + 224 len arg3.length + -ceil32(arg3.length) + 32]][Mask(8 * ceil32(arg3.length), -(8 * ceil32(arg3.length)) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * ceil32(arg3.length)) - 256])) != 1:
                        if ceil32(arg3.length) <= arg3.length:
                            if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] = 0x791ac94700000000000000000000000000000000000000000000000000000000
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                _18641 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                idx = 0
                                s = ceil32(arg3.length) + 160
                                t = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 558
                                while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(address(stor[_1822]))
                                call address(stor[_1822]).swapExactTokensForETHSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _18641) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                            else:
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                _18642 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                idx = 0
                                s = ceil32(arg3.length) + 160
                                t = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 558
                                while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                                require ext_code.size(address(stor[_1822]))
                                call address(stor[_1822]).swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _18642) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362
                                require return_data.size >= 32
                                _22369 = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362]
                                require mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                                require ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                                _22689 = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                require mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                                require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                                mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                require _22369 + (32 * _22689) + 32 <= return_data.size
                                idx = 0
                                s = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + _22369 + 394
                                t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 394
                                while idx < _22689:
                                    require mem[s] == mem[s]
                                    mem[t] = mem[s]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                        else:
                            if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] = 0x791ac94700000000000000000000000000000000000000000000000000000000
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                _18849 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                idx = 0
                                s = ceil32(arg3.length) + 160
                                t = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 558
                                while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(address(stor[_1822]))
                                call address(stor[_1822]).swapExactTokensForETHSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _18849) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                            else:
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                _18850 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                idx = 0
                                s = ceil32(arg3.length) + 160
                                t = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 558
                                while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                                require ext_code.size(address(stor[_1822]))
                                call address(stor[_1822]).swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _18850) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362
                                require return_data.size >= 32
                                _22370 = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362]
                                require mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                                require ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                                _22690 = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                require mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                                require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                                mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                require _22370 + (32 * _22690) + 32 <= return_data.size
                                idx = 0
                                s = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + _22370 + 394
                                t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 394
                                while idx < _22690:
                                    require mem[s] == mem[s]
                                    mem[t] = mem[s]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                    else:
                        if ceil32(arg3.length) <= arg3.length:
                            if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] = 0xd46d2f8300000000000000000000000000000000000000000000000000000000
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                _18645 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                idx = 0
                                s = ceil32(arg3.length) + 160
                                t = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 558
                                while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(address(stor[_1822]))
                                call address(stor[_1822]).0xd46d2f83 with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _18645) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                            else:
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] = 0x5d616c5b00000000000000000000000000000000000000000000000000000000
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                _18646 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                idx = 0
                                s = ceil32(arg3.length) + 160
                                t = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 558
                                while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                                require ext_code.size(address(stor[_1822]))
                                call address(stor[_1822]).0x5d616c5b with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _18646) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362
                                require return_data.size >= 32
                                _22373 = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362]
                                require mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                                require ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                                _22693 = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                require mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                                require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                                mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                require _22373 + (32 * _22693) + 32 <= return_data.size
                                idx = 0
                                s = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + _22373 + 394
                                t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 394
                                while idx < _22693:
                                    require mem[s] == mem[s]
                                    mem[t] = mem[s]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                        else:
                            if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] = 0xd46d2f8300000000000000000000000000000000000000000000000000000000
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                _18853 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                idx = 0
                                s = ceil32(arg3.length) + 160
                                t = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 558
                                while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(address(stor[_1822]))
                                call address(stor[_1822]).0xd46d2f83 with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _18853) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                            else:
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] = 0x5d616c5b00000000000000000000000000000000000000000000000000000000
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                _18854 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                idx = 0
                                s = ceil32(arg3.length) + 160
                                t = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 558
                                while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                                require ext_code.size(address(stor[_1822]))
                                call address(stor[_1822]).0x5d616c5b with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _18854) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362
                                require return_data.size >= 32
                                _22374 = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362]
                                require mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                                require ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                                _22694 = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                require mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                                require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                                mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                require _22374 + (32 * _22694) + 32 <= return_data.size
                                idx = 0
                                s = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + _22374 + 394
                                t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 394
                                while idx < _22694:
                                    require mem[s] == mem[s]
                                    mem[t] = mem[s]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                else:
                    if bool(uint8(stor[mem[(2 * ceil32(arg3.length)) + (2 * ceil32(return_data.size)) + 224 len arg3.length + -ceil32(arg3.length) + 32]][Mask(8 * ceil32(arg3.length), -(8 * ceil32(arg3.length)) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * ceil32(arg3.length)) - 256])) != 1:
                        if ceil32(arg3.length) <= arg3.length:
                            if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] = 0x791ac94700000000000000000000000000000000000000000000000000000000
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                _18649 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                idx = 0
                                s = ceil32(arg3.length) + 160
                                t = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 558
                                while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(address(stor[_1822]))
                                call address(stor[_1822]).swapExactTokensForETHSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _18649) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                            else:
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                _18650 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                idx = 0
                                s = ceil32(arg3.length) + 160
                                t = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 558
                                while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                                require ext_code.size(address(stor[_1822]))
                                call address(stor[_1822]).swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _18650) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362
                                require return_data.size >= 32
                                _22377 = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362]
                                require mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                                require ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                                _22697 = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                require mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                                require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                                mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                require _22377 + (32 * _22697) + 32 <= return_data.size
                                idx = 0
                                s = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + _22377 + 394
                                t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 394
                                while idx < _22697:
                                    require mem[s] == mem[s]
                                    mem[t] = mem[s]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                        else:
                            if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] = 0x791ac94700000000000000000000000000000000000000000000000000000000
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                _18857 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                idx = 0
                                s = ceil32(arg3.length) + 160
                                t = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 558
                                while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(address(stor[_1822]))
                                call address(stor[_1822]).swapExactTokensForETHSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _18857) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                            else:
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                _18858 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                idx = 0
                                s = ceil32(arg3.length) + 160
                                t = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 558
                                while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                                require ext_code.size(address(stor[_1822]))
                                call address(stor[_1822]).swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _18858) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362
                                require return_data.size >= 32
                                _22378 = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362]
                                require mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                                require ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                                _22698 = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                require mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                                require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                                mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                require _22378 + (32 * _22698) + 32 <= return_data.size
                                idx = 0
                                s = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + _22378 + 394
                                t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 394
                                while idx < _22698:
                                    require mem[s] == mem[s]
                                    mem[t] = mem[s]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                    else:
                        if ceil32(arg3.length) <= arg3.length:
                            if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] = 0xd46d2f8300000000000000000000000000000000000000000000000000000000
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                _18653 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                idx = 0
                                s = ceil32(arg3.length) + 160
                                t = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 558
                                while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(address(stor[_1822]))
                                call address(stor[_1822]).0xd46d2f83 with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _18653) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                            else:
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] = 0x5d616c5b00000000000000000000000000000000000000000000000000000000
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                _18654 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                idx = 0
                                s = ceil32(arg3.length) + 160
                                t = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 558
                                while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                                require ext_code.size(address(stor[_1822]))
                                call address(stor[_1822]).0x5d616c5b with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _18654) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362
                                require return_data.size >= 32
                                _22381 = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362]
                                require mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                                require ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                                _22701 = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                require mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                                require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                                mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                require _22381 + (32 * _22701) + 32 <= return_data.size
                                idx = 0
                                s = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + _22381 + 394
                                t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 394
                                while idx < _22701:
                                    require mem[s] == mem[s]
                                    mem[t] = mem[s]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                        else:
                            if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] = 0xd46d2f8300000000000000000000000000000000000000000000000000000000
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                _18861 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                idx = 0
                                s = ceil32(arg3.length) + 160
                                t = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 558
                                while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(address(stor[_1822]))
                                call address(stor[_1822]).0xd46d2f83 with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _18861) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                            else:
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] = 0x5d616c5b00000000000000000000000000000000000000000000000000000000
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                _18862 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                idx = 0
                                s = ceil32(arg3.length) + 160
                                t = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 558
                                while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                                require ext_code.size(address(stor[_1822]))
                                call address(stor[_1822]).0x5d616c5b with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _18862) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362
                                require return_data.size >= 32
                                _22382 = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362]
                                require mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                                require ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                                _22702 = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                require mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                                require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                                mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                require _22382 + (32 * _22702) + 32 <= return_data.size
                                idx = 0
                                s = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + _22382 + 394
                                t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 394
                                while idx < _22702:
                                    require mem[s] == mem[s]
                                    mem[t] = mem[s]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
            else:
                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 224] = 0
                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + 228] = address(stor[mem[(2 * ceil32(arg3.length)) + (2 * ceil32(return_data.size)) + 224 len arg3.length + -ceil32(arg3.length) + 32]][Mask(8 * ceil32(arg3.length), -(8 * ceil32(arg3.length)) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * ceil32(arg3.length)) - 256])
                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + 260] = -1
                require ext_code.size(address(arg1))
                call address(arg1).approve(address rg1, uint256 rg2) with:
                     gas gas_remaining wei
                    args mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + 228], -1
                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + 224] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + 224 len ceil32(arg3.length)] = arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]
                mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 224] = 1
                require 1 < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                mem[ceil32(arg3.length) + 192] = 0xbb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c
                mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + 224] = 10
                mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + 256] = 'BurgerSwap'
                mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + 320] = 'BurgerSwap'
                mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + 288] = 10
                mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + 362 len ceil32(arg3.length)] = arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]
                mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + 330] = arg3.length
                mem[64] = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362
                if ceil32(arg3.length) <= arg3.length:
                    if ceil32(arg3.length) <= arg3.length:
                        if bool(uint8(stor[mem[(2 * ceil32(arg3.length)) + (4 * ceil32(return_data.size)) + 224 len arg3.length + -ceil32(arg3.length) + 32]][Mask(8 * ceil32(arg3.length), -(8 * ceil32(arg3.length)) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * ceil32(arg3.length)) - 256])) != 1:
                            if ceil32(arg3.length) <= arg3.length:
                                if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x791ac94700000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22465 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(address(stor[_1822]))
                                    call address(stor[_1822]).swapExactTokensForETHSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22465) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                else:
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22466 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                                    require ext_code.size(address(stor[_1822]))
                                    call address(stor[_1822]).swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22466) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362
                                    require return_data.size >= 32
                                    _24769 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                                    require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                                    _24897 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                                    require ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                                    mem[ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require _24769 + (32 * _24897) + 32 <= return_data.size
                                    idx = 0
                                    s = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + _24769 + 394
                                    t = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 394
                                    while idx < _24897:
                                        require mem[s] == mem[s]
                                        mem[t] = mem[s]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                            else:
                                if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x791ac94700000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22593 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(address(stor[_1822]))
                                    call address(stor[_1822]).swapExactTokensForETHSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22593) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                else:
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22594 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                                    require ext_code.size(address(stor[_1822]))
                                    call address(stor[_1822]).swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22594) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362
                                    require return_data.size >= 32
                                    _24770 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                                    require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                                    _24898 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                                    require ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                                    mem[ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require _24770 + (32 * _24898) + 32 <= return_data.size
                                    idx = 0
                                    s = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + _24770 + 394
                                    t = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 394
                                    while idx < _24898:
                                        require mem[s] == mem[s]
                                        mem[t] = mem[s]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                        else:
                            if ceil32(arg3.length) <= arg3.length:
                                if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0xd46d2f8300000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22469 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(address(stor[_1822]))
                                    call address(stor[_1822]).0xd46d2f83 with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22469) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                else:
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x5d616c5b00000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22470 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                                    require ext_code.size(address(stor[_1822]))
                                    call address(stor[_1822]).0x5d616c5b with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22470) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362
                                    require return_data.size >= 32
                                    _24773 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                                    require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                                    _24901 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                                    require ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                                    mem[ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require _24773 + (32 * _24901) + 32 <= return_data.size
                                    idx = 0
                                    s = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + _24773 + 394
                                    t = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 394
                                    while idx < _24901:
                                        require mem[s] == mem[s]
                                        mem[t] = mem[s]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                            else:
                                if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0xd46d2f8300000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22597 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(address(stor[_1822]))
                                    call address(stor[_1822]).0xd46d2f83 with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22597) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                else:
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x5d616c5b00000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22598 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                                    require ext_code.size(address(stor[_1822]))
                                    call address(stor[_1822]).0x5d616c5b with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22598) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362
                                    require return_data.size >= 32
                                    _24774 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                                    require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                                    _24902 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                                    require ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                                    mem[ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require _24774 + (32 * _24902) + 32 <= return_data.size
                                    idx = 0
                                    s = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + _24774 + 394
                                    t = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 394
                                    while idx < _24902:
                                        require mem[s] == mem[s]
                                        mem[t] = mem[s]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                    else:
                        if bool(uint8(stor[mem[(2 * ceil32(arg3.length)) + (4 * ceil32(return_data.size)) + 224 len arg3.length + -ceil32(arg3.length) + 32]][Mask(8 * ceil32(arg3.length), -(8 * ceil32(arg3.length)) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * ceil32(arg3.length)) - 256])) != 1:
                            if ceil32(arg3.length) <= arg3.length:
                                if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x791ac94700000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22473 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(address(stor[_1822]))
                                    call address(stor[_1822]).swapExactTokensForETHSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22473) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                else:
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22474 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                                    require ext_code.size(address(stor[_1822]))
                                    call address(stor[_1822]).swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22474) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362
                                    require return_data.size >= 32
                                    _24777 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                                    require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                                    _24905 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                                    require ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                                    mem[ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require _24777 + (32 * _24905) + 32 <= return_data.size
                                    idx = 0
                                    s = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + _24777 + 394
                                    t = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 394
                                    while idx < _24905:
                                        require mem[s] == mem[s]
                                        mem[t] = mem[s]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                            else:
                                if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x791ac94700000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22601 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(address(stor[_1822]))
                                    call address(stor[_1822]).swapExactTokensForETHSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22601) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                else:
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22602 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                                    require ext_code.size(address(stor[_1822]))
                                    call address(stor[_1822]).swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22602) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362
                                    require return_data.size >= 32
                                    _24778 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                                    require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                                    _24906 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                                    require ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                                    mem[ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require _24778 + (32 * _24906) + 32 <= return_data.size
                                    idx = 0
                                    s = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + _24778 + 394
                                    t = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 394
                                    while idx < _24906:
                                        require mem[s] == mem[s]
                                        mem[t] = mem[s]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                        else:
                            if ceil32(arg3.length) <= arg3.length:
                                if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0xd46d2f8300000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22477 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(address(stor[_1822]))
                                    call address(stor[_1822]).0xd46d2f83 with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22477) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                else:
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x5d616c5b00000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22478 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                                    require ext_code.size(address(stor[_1822]))
                                    call address(stor[_1822]).0x5d616c5b with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22478) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362
                                    require return_data.size >= 32
                                    _24781 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                                    require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                                    _24909 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                                    require ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                                    mem[ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require _24781 + (32 * _24909) + 32 <= return_data.size
                                    idx = 0
                                    s = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + _24781 + 394
                                    t = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 394
                                    while idx < _24909:
                                        require mem[s] == mem[s]
                                        mem[t] = mem[s]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                            else:
                                if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0xd46d2f8300000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22605 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(address(stor[_1822]))
                                    call address(stor[_1822]).0xd46d2f83 with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22605) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                else:
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x5d616c5b00000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22606 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                                    require ext_code.size(address(stor[_1822]))
                                    call address(stor[_1822]).0x5d616c5b with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22606) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362
                                    require return_data.size >= 32
                                    _24782 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                                    require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                                    _24910 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                                    require ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                                    mem[ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require _24782 + (32 * _24910) + 32 <= return_data.size
                                    idx = 0
                                    s = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + _24782 + 394
                                    t = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 394
                                    while idx < _24910:
                                        require mem[s] == mem[s]
                                        mem[t] = mem[s]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                else:
                    if ceil32(arg3.length) <= arg3.length:
                        if bool(uint8(stor[mem[(2 * ceil32(arg3.length)) + (4 * ceil32(return_data.size)) + 224 len arg3.length + -ceil32(arg3.length) + 32]][Mask(8 * ceil32(arg3.length), -(8 * ceil32(arg3.length)) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * ceil32(arg3.length)) - 256])) != 1:
                            if ceil32(arg3.length) <= arg3.length:
                                if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x791ac94700000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22481 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(address(stor[_1822]))
                                    call address(stor[_1822]).swapExactTokensForETHSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22481) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                else:
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22482 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                                    require ext_code.size(address(stor[_1822]))
                                    call address(stor[_1822]).swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22482) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362
                                    require return_data.size >= 32
                                    _24785 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                                    require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                                    _24913 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                                    require ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                                    mem[ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require _24785 + (32 * _24913) + 32 <= return_data.size
                                    idx = 0
                                    s = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + _24785 + 394
                                    t = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 394
                                    while idx < _24913:
                                        require mem[s] == mem[s]
                                        mem[t] = mem[s]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                            else:
                                if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x791ac94700000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22609 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(address(stor[_1822]))
                                    call address(stor[_1822]).swapExactTokensForETHSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22609) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                else:
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22610 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                                    require ext_code.size(address(stor[_1822]))
                                    call address(stor[_1822]).swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22610) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362
                                    require return_data.size >= 32
                                    _24786 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                                    require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                                    _24914 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                                    require ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                                    mem[ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require _24786 + (32 * _24914) + 32 <= return_data.size
                                    idx = 0
                                    s = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + _24786 + 394
                                    t = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 394
                                    while idx < _24914:
                                        require mem[s] == mem[s]
                                        mem[t] = mem[s]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                        else:
                            if ceil32(arg3.length) <= arg3.length:
                                if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0xd46d2f8300000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22485 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(address(stor[_1822]))
                                    call address(stor[_1822]).0xd46d2f83 with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22485) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                else:
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x5d616c5b00000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22486 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                                    require ext_code.size(address(stor[_1822]))
                                    call address(stor[_1822]).0x5d616c5b with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22486) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362
                                    require return_data.size >= 32
                                    _24789 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                                    require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                                    _24917 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                                    require ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                                    mem[ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require _24789 + (32 * _24917) + 32 <= return_data.size
                                    idx = 0
                                    s = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + _24789 + 394
                                    t = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 394
                                    while idx < _24917:
                                        require mem[s] == mem[s]
                                        mem[t] = mem[s]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                            else:
                                if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0xd46d2f8300000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22613 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(address(stor[_1822]))
                                    call address(stor[_1822]).0xd46d2f83 with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22613) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                else:
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x5d616c5b00000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22614 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                                    require ext_code.size(address(stor[_1822]))
                                    call address(stor[_1822]).0x5d616c5b with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22614) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362
                                    require return_data.size >= 32
                                    _24790 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                                    require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                                    _24918 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                                    require ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                                    mem[ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require _24790 + (32 * _24918) + 32 <= return_data.size
                                    idx = 0
                                    s = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + _24790 + 394
                                    t = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 394
                                    while idx < _24918:
                                        require mem[s] == mem[s]
                                        mem[t] = mem[s]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                    else:
                        if bool(uint8(stor[mem[(2 * ceil32(arg3.length)) + (4 * ceil32(return_data.size)) + 224 len arg3.length + -ceil32(arg3.length) + 32]][Mask(8 * ceil32(arg3.length), -(8 * ceil32(arg3.length)) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * ceil32(arg3.length)) - 256])) != 1:
                            if ceil32(arg3.length) <= arg3.length:
                                if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x791ac94700000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22489 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(address(stor[_1822]))
                                    call address(stor[_1822]).swapExactTokensForETHSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22489) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                else:
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22490 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                                    require ext_code.size(address(stor[_1822]))
                                    call address(stor[_1822]).swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22490) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362
                                    require return_data.size >= 32
                                    _24793 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                                    require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                                    _24921 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                                    require ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                                    mem[ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require _24793 + (32 * _24921) + 32 <= return_data.size
                                    idx = 0
                                    s = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + _24793 + 394
                                    t = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 394
                                    while idx < _24921:
                                        require mem[s] == mem[s]
                                        mem[t] = mem[s]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                            else:
                                if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x791ac94700000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22617 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(address(stor[_1822]))
                                    call address(stor[_1822]).swapExactTokensForETHSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22617) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                else:
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22618 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                                    require ext_code.size(address(stor[_1822]))
                                    call address(stor[_1822]).swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22618) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362
                                    require return_data.size >= 32
                                    _24794 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                                    require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                                    _24922 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                                    require ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                                    mem[ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require _24794 + (32 * _24922) + 32 <= return_data.size
                                    idx = 0
                                    s = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + _24794 + 394
                                    t = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 394
                                    while idx < _24922:
                                        require mem[s] == mem[s]
                                        mem[t] = mem[s]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                        else:
                            if ceil32(arg3.length) <= arg3.length:
                                if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0xd46d2f8300000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22493 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(address(stor[_1822]))
                                    call address(stor[_1822]).0xd46d2f83 with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22493) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                else:
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x5d616c5b00000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22494 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                                    require ext_code.size(address(stor[_1822]))
                                    call address(stor[_1822]).0x5d616c5b with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22494) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362
                                    require return_data.size >= 32
                                    _24797 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                                    require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                                    _24925 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                                    require ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                                    mem[ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require _24797 + (32 * _24925) + 32 <= return_data.size
                                    idx = 0
                                    s = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + _24797 + 394
                                    t = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 394
                                    while idx < _24925:
                                        require mem[s] == mem[s]
                                        mem[t] = mem[s]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                            else:
                                if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0xd46d2f8300000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22621 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(address(stor[_1822]))
                                    call address(stor[_1822]).0xd46d2f83 with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22621) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                else:
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x5d616c5b00000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22622 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                                    require ext_code.size(address(stor[_1822]))
                                    call address(stor[_1822]).0x5d616c5b with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22622) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362
                                    require return_data.size >= 32
                                    _24798 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                                    require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                                    _24926 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                                    require ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                                    mem[ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require _24798 + (32 * _24926) + 32 <= return_data.size
                                    idx = 0
                                    s = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + _24798 + 394
                                    t = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 394
                                    while idx < _24926:
                                        require mem[s] == mem[s]
                                        mem[t] = mem[s]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
        else:
            _5865 = sha3(Mask(8 * ceil32(arg3.length), -(8 * ceil32(arg3.length)) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * ceil32(arg3.length)) - 256, mem[(2 * ceil32(arg3.length)) + ceil32(return_data.size) + 224 len arg3.length + -ceil32(arg3.length) + 32])
            mem[ceil32(arg3.length) + ceil32(return_data.size) + 228] = this.address
            mem[ceil32(arg3.length) + ceil32(return_data.size) + 260] = address(stor[_5865])
            require ext_code.size(address(arg1))
            staticcall address(arg1).0xdd62ed3e with:
                    gas gas_remaining wei
                   args address(this.address), address(stor[_5865])
            mem[ceil32(arg3.length) + ceil32(return_data.size) + 224] = ext_call.return_data[0]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 32
            require ext_call.return_data[0] == ext_call.return_data[0]
            mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + 224 len ceil32(arg3.length)] = arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]
            if ext_call.return_data[0] >= ext_call.return_data[0]:
                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 224] = 1
                require 1 < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                mem[ceil32(arg3.length) + 192] = 0xbb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c
                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + 224] = 10
                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + 256] = 'BurgerSwap'
                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + 320] = 'BurgerSwap'
                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + 288] = 10
                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + 362 len ceil32(arg3.length)] = arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]
                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + 330] = arg3.length
                mem[64] = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362
                if ceil32(arg3.length) <= arg3.length:
                    if bool(uint8(stor[mem[(2 * ceil32(arg3.length)) + (2 * ceil32(return_data.size)) + 224 len arg3.length + -ceil32(arg3.length) + 32]][Mask(8 * ceil32(arg3.length), -(8 * ceil32(arg3.length)) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * ceil32(arg3.length)) - 256])) != 1:
                        if ceil32(arg3.length) <= arg3.length:
                            if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] = 0x791ac94700000000000000000000000000000000000000000000000000000000
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                _18681 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                idx = 0
                                s = ceil32(arg3.length) + 160
                                t = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 558
                                while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(address(stor[_1822]))
                                call address(stor[_1822]).swapExactTokensForETHSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _18681) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                            else:
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                _18682 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                idx = 0
                                s = ceil32(arg3.length) + 160
                                t = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 558
                                while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                                require ext_code.size(address(stor[_1822]))
                                call address(stor[_1822]).swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _18682) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362
                                require return_data.size >= 32
                                _22385 = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362]
                                require mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                                require ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                                _22705 = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                require mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                                require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                                mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                require _22385 + (32 * _22705) + 32 <= return_data.size
                                idx = 0
                                s = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + _22385 + 394
                                t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 394
                                while idx < _22705:
                                    require mem[s] == mem[s]
                                    mem[t] = mem[s]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                        else:
                            if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] = 0x791ac94700000000000000000000000000000000000000000000000000000000
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                _18913 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                idx = 0
                                s = ceil32(arg3.length) + 160
                                t = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 558
                                while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(address(stor[_1822]))
                                call address(stor[_1822]).swapExactTokensForETHSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _18913) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                            else:
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                _18914 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                idx = 0
                                s = ceil32(arg3.length) + 160
                                t = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 558
                                while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                                require ext_code.size(address(stor[_1822]))
                                call address(stor[_1822]).swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _18914) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362
                                require return_data.size >= 32
                                _22386 = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362]
                                require mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                                require ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                                _22706 = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                require mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                                require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                                mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                require _22386 + (32 * _22706) + 32 <= return_data.size
                                idx = 0
                                s = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + _22386 + 394
                                t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 394
                                while idx < _22706:
                                    require mem[s] == mem[s]
                                    mem[t] = mem[s]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                    else:
                        if ceil32(arg3.length) <= arg3.length:
                            if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] = 0xd46d2f8300000000000000000000000000000000000000000000000000000000
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                _18685 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                idx = 0
                                s = ceil32(arg3.length) + 160
                                t = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 558
                                while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(address(stor[_1822]))
                                call address(stor[_1822]).0xd46d2f83 with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _18685) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                            else:
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] = 0x5d616c5b00000000000000000000000000000000000000000000000000000000
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                _18686 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                idx = 0
                                s = ceil32(arg3.length) + 160
                                t = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 558
                                while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                                require ext_code.size(address(stor[_1822]))
                                call address(stor[_1822]).0x5d616c5b with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _18686) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362
                                require return_data.size >= 32
                                _22389 = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362]
                                require mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                                require ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                                _22709 = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                require mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                                require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                                mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                require _22389 + (32 * _22709) + 32 <= return_data.size
                                idx = 0
                                s = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + _22389 + 394
                                t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 394
                                while idx < _22709:
                                    require mem[s] == mem[s]
                                    mem[t] = mem[s]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                        else:
                            if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] = 0xd46d2f8300000000000000000000000000000000000000000000000000000000
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                _18917 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                idx = 0
                                s = ceil32(arg3.length) + 160
                                t = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 558
                                while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(address(stor[_1822]))
                                call address(stor[_1822]).0xd46d2f83 with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _18917) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                            else:
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] = 0x5d616c5b00000000000000000000000000000000000000000000000000000000
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                _18918 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                idx = 0
                                s = ceil32(arg3.length) + 160
                                t = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 558
                                while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                                require ext_code.size(address(stor[_1822]))
                                call address(stor[_1822]).0x5d616c5b with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _18918) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362
                                require return_data.size >= 32
                                _22390 = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362]
                                require mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                                require ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                                _22710 = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                require mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                                require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                                mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                require _22390 + (32 * _22710) + 32 <= return_data.size
                                idx = 0
                                s = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + _22390 + 394
                                t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 394
                                while idx < _22710:
                                    require mem[s] == mem[s]
                                    mem[t] = mem[s]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                else:
                    if bool(uint8(stor[mem[(2 * ceil32(arg3.length)) + (2 * ceil32(return_data.size)) + 224 len arg3.length + -ceil32(arg3.length) + 32]][Mask(8 * ceil32(arg3.length), -(8 * ceil32(arg3.length)) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * ceil32(arg3.length)) - 256])) != 1:
                        if ceil32(arg3.length) <= arg3.length:
                            if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] = 0x791ac94700000000000000000000000000000000000000000000000000000000
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                _18689 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                idx = 0
                                s = ceil32(arg3.length) + 160
                                t = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 558
                                while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(address(stor[_1822]))
                                call address(stor[_1822]).swapExactTokensForETHSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _18689) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                            else:
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                _18690 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                idx = 0
                                s = ceil32(arg3.length) + 160
                                t = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 558
                                while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                                require ext_code.size(address(stor[_1822]))
                                call address(stor[_1822]).swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _18690) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362
                                require return_data.size >= 32
                                _22393 = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362]
                                require mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                                require ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                                _22713 = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                require mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                                require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                                mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                require _22393 + (32 * _22713) + 32 <= return_data.size
                                idx = 0
                                s = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + _22393 + 394
                                t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 394
                                while idx < _22713:
                                    require mem[s] == mem[s]
                                    mem[t] = mem[s]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                        else:
                            if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] = 0x791ac94700000000000000000000000000000000000000000000000000000000
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                _18921 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                idx = 0
                                s = ceil32(arg3.length) + 160
                                t = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 558
                                while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(address(stor[_1822]))
                                call address(stor[_1822]).swapExactTokensForETHSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _18921) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                            else:
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                _18922 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                idx = 0
                                s = ceil32(arg3.length) + 160
                                t = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 558
                                while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                                require ext_code.size(address(stor[_1822]))
                                call address(stor[_1822]).swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _18922) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362
                                require return_data.size >= 32
                                _22394 = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362]
                                require mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                                require ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                                _22714 = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                require mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                                require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                                mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                require _22394 + (32 * _22714) + 32 <= return_data.size
                                idx = 0
                                s = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + _22394 + 394
                                t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 394
                                while idx < _22714:
                                    require mem[s] == mem[s]
                                    mem[t] = mem[s]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                    else:
                        if ceil32(arg3.length) <= arg3.length:
                            if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] = 0xd46d2f8300000000000000000000000000000000000000000000000000000000
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                _18693 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                idx = 0
                                s = ceil32(arg3.length) + 160
                                t = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 558
                                while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(address(stor[_1822]))
                                call address(stor[_1822]).0xd46d2f83 with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _18693) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                            else:
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] = 0x5d616c5b00000000000000000000000000000000000000000000000000000000
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                _18694 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                idx = 0
                                s = ceil32(arg3.length) + 160
                                t = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 558
                                while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                                require ext_code.size(address(stor[_1822]))
                                call address(stor[_1822]).0x5d616c5b with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _18694) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362
                                require return_data.size >= 32
                                _22397 = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362]
                                require mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                                require ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                                _22717 = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                require mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                                require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                                mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                require _22397 + (32 * _22717) + 32 <= return_data.size
                                idx = 0
                                s = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + _22397 + 394
                                t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 394
                                while idx < _22717:
                                    require mem[s] == mem[s]
                                    mem[t] = mem[s]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                        else:
                            if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] = 0xd46d2f8300000000000000000000000000000000000000000000000000000000
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                _18925 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                idx = 0
                                s = ceil32(arg3.length) + 160
                                t = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 558
                                while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                require ext_code.size(address(stor[_1822]))
                                call address(stor[_1822]).0xd46d2f83 with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _18925) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                            else:
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] = 0x5d616c5b00000000000000000000000000000000000000000000000000000000
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                _18926 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                idx = 0
                                s = ceil32(arg3.length) + 160
                                t = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 558
                                while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                    mem[t] = mem[s + 12 len 20]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                                require ext_code.size(address(stor[_1822]))
                                call address(stor[_1822]).0x5d616c5b with:
                                     gas gas_remaining wei
                                    args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _18926) + 32]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                mem[64] = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362
                                require return_data.size >= 32
                                _22398 = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362]
                                require mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                                require ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                                _22718 = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                require mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                                require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                                mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                require _22398 + (32 * _22718) + 32 <= return_data.size
                                idx = 0
                                s = ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + _22398 + 394
                                t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 394
                                while idx < _22718:
                                    require mem[s] == mem[s]
                                    mem[t] = mem[s]
                                    idx = idx + 1
                                    s = s + 32
                                    t = t + 32
                                    continue 
            else:
                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + arg3.length + 224] = 0
                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + 228] = address(stor[mem[(2 * ceil32(arg3.length)) + (2 * ceil32(return_data.size)) + 224 len arg3.length + -ceil32(arg3.length) + 32]][Mask(8 * ceil32(arg3.length), -(8 * ceil32(arg3.length)) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * ceil32(arg3.length)) - 256])
                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + 260] = -1
                require ext_code.size(address(arg1))
                call address(arg1).approve(address rg1, uint256 rg2) with:
                     gas gas_remaining wei
                    args mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + 228], -1
                mem[ceil32(arg3.length) + (2 * ceil32(return_data.size)) + 224] = ext_call.return_data[0]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 32
                require ext_call.return_data[0] == bool(ext_call.return_data[0])
                mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + 224 len ceil32(arg3.length)] = arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]
                mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 224] = 1
                require 1 < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                mem[ceil32(arg3.length) + 192] = 0xbb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c
                mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + 224] = 10
                mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + 256] = 'BurgerSwap'
                mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + 320] = 'BurgerSwap'
                mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + 288] = 10
                mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + 362 len ceil32(arg3.length)] = arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]
                mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + 330] = arg3.length
                mem[64] = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362
                if ceil32(arg3.length) <= arg3.length:
                    if ceil32(arg3.length) <= arg3.length:
                        if bool(uint8(stor[mem[(2 * ceil32(arg3.length)) + (4 * ceil32(return_data.size)) + 224 len arg3.length + -ceil32(arg3.length) + 32]][Mask(8 * ceil32(arg3.length), -(8 * ceil32(arg3.length)) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * ceil32(arg3.length)) - 256])) != 1:
                            if ceil32(arg3.length) <= arg3.length:
                                if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x791ac94700000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22497 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(address(stor[_1822]))
                                    call address(stor[_1822]).swapExactTokensForETHSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22497) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                else:
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22498 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                                    require ext_code.size(address(stor[_1822]))
                                    call address(stor[_1822]).swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22498) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362
                                    require return_data.size >= 32
                                    _24801 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                                    require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                                    _24929 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                                    require ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                                    mem[ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require _24801 + (32 * _24929) + 32 <= return_data.size
                                    idx = 0
                                    s = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + _24801 + 394
                                    t = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 394
                                    while idx < _24929:
                                        require mem[s] == mem[s]
                                        mem[t] = mem[s]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                            else:
                                if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x791ac94700000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22625 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(address(stor[_1822]))
                                    call address(stor[_1822]).swapExactTokensForETHSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22625) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                else:
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22626 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                                    require ext_code.size(address(stor[_1822]))
                                    call address(stor[_1822]).swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22626) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362
                                    require return_data.size >= 32
                                    _24802 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                                    require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                                    _24930 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                                    require ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                                    mem[ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require _24802 + (32 * _24930) + 32 <= return_data.size
                                    idx = 0
                                    s = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + _24802 + 394
                                    t = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 394
                                    while idx < _24930:
                                        require mem[s] == mem[s]
                                        mem[t] = mem[s]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                        else:
                            if ceil32(arg3.length) <= arg3.length:
                                if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0xd46d2f8300000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22501 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(address(stor[_1822]))
                                    call address(stor[_1822]).0xd46d2f83 with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22501) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                else:
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x5d616c5b00000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22502 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                                    require ext_code.size(address(stor[_1822]))
                                    call address(stor[_1822]).0x5d616c5b with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22502) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362
                                    require return_data.size >= 32
                                    _24805 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                                    require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                                    _24933 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                                    require ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                                    mem[ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require _24805 + (32 * _24933) + 32 <= return_data.size
                                    idx = 0
                                    s = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + _24805 + 394
                                    t = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 394
                                    while idx < _24933:
                                        require mem[s] == mem[s]
                                        mem[t] = mem[s]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                            else:
                                if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0xd46d2f8300000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22629 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(address(stor[_1822]))
                                    call address(stor[_1822]).0xd46d2f83 with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22629) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                else:
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x5d616c5b00000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22630 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                                    require ext_code.size(address(stor[_1822]))
                                    call address(stor[_1822]).0x5d616c5b with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22630) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362
                                    require return_data.size >= 32
                                    _24806 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                                    require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                                    _24934 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                                    require ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                                    mem[ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require _24806 + (32 * _24934) + 32 <= return_data.size
                                    idx = 0
                                    s = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + _24806 + 394
                                    t = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 394
                                    while idx < _24934:
                                        require mem[s] == mem[s]
                                        mem[t] = mem[s]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                    else:
                        if bool(uint8(stor[mem[(2 * ceil32(arg3.length)) + (4 * ceil32(return_data.size)) + 224 len arg3.length + -ceil32(arg3.length) + 32]][Mask(8 * ceil32(arg3.length), -(8 * ceil32(arg3.length)) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * ceil32(arg3.length)) - 256])) != 1:
                            if ceil32(arg3.length) <= arg3.length:
                                if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x791ac94700000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22505 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(address(stor[_1822]))
                                    call address(stor[_1822]).swapExactTokensForETHSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22505) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                else:
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22506 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                                    require ext_code.size(address(stor[_1822]))
                                    call address(stor[_1822]).swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22506) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362
                                    require return_data.size >= 32
                                    _24809 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                                    require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                                    _24937 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                                    require ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                                    mem[ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require _24809 + (32 * _24937) + 32 <= return_data.size
                                    idx = 0
                                    s = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + _24809 + 394
                                    t = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 394
                                    while idx < _24937:
                                        require mem[s] == mem[s]
                                        mem[t] = mem[s]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                            else:
                                if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x791ac94700000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22633 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(address(stor[_1822]))
                                    call address(stor[_1822]).swapExactTokensForETHSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22633) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                else:
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22634 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                                    require ext_code.size(address(stor[_1822]))
                                    call address(stor[_1822]).swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22634) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362
                                    require return_data.size >= 32
                                    _24810 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                                    require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                                    _24938 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                                    require ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                                    mem[ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require _24810 + (32 * _24938) + 32 <= return_data.size
                                    idx = 0
                                    s = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + _24810 + 394
                                    t = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 394
                                    while idx < _24938:
                                        require mem[s] == mem[s]
                                        mem[t] = mem[s]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                        else:
                            if ceil32(arg3.length) <= arg3.length:
                                if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0xd46d2f8300000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22509 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(address(stor[_1822]))
                                    call address(stor[_1822]).0xd46d2f83 with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22509) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                else:
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x5d616c5b00000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22510 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                                    require ext_code.size(address(stor[_1822]))
                                    call address(stor[_1822]).0x5d616c5b with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22510) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362
                                    require return_data.size >= 32
                                    _24813 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                                    require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                                    _24941 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                                    require ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                                    mem[ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require _24813 + (32 * _24941) + 32 <= return_data.size
                                    idx = 0
                                    s = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + _24813 + 394
                                    t = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 394
                                    while idx < _24941:
                                        require mem[s] == mem[s]
                                        mem[t] = mem[s]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                            else:
                                if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0xd46d2f8300000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22637 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(address(stor[_1822]))
                                    call address(stor[_1822]).0xd46d2f83 with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22637) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                else:
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x5d616c5b00000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22638 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                                    require ext_code.size(address(stor[_1822]))
                                    call address(stor[_1822]).0x5d616c5b with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22638) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362
                                    require return_data.size >= 32
                                    _24814 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                                    require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                                    _24942 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                                    require ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                                    mem[ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require _24814 + (32 * _24942) + 32 <= return_data.size
                                    idx = 0
                                    s = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + _24814 + 394
                                    t = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 394
                                    while idx < _24942:
                                        require mem[s] == mem[s]
                                        mem[t] = mem[s]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                else:
                    if ceil32(arg3.length) <= arg3.length:
                        if bool(uint8(stor[mem[(2 * ceil32(arg3.length)) + (4 * ceil32(return_data.size)) + 224 len arg3.length + -ceil32(arg3.length) + 32]][Mask(8 * ceil32(arg3.length), -(8 * ceil32(arg3.length)) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * ceil32(arg3.length)) - 256])) != 1:
                            if ceil32(arg3.length) <= arg3.length:
                                if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x791ac94700000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22513 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(address(stor[_1822]))
                                    call address(stor[_1822]).swapExactTokensForETHSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22513) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                else:
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22514 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                                    require ext_code.size(address(stor[_1822]))
                                    call address(stor[_1822]).swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22514) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362
                                    require return_data.size >= 32
                                    _24817 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                                    require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                                    _24945 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                                    require ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                                    mem[ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require _24817 + (32 * _24945) + 32 <= return_data.size
                                    idx = 0
                                    s = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + _24817 + 394
                                    t = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 394
                                    while idx < _24945:
                                        require mem[s] == mem[s]
                                        mem[t] = mem[s]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                            else:
                                if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x791ac94700000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22641 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(address(stor[_1822]))
                                    call address(stor[_1822]).swapExactTokensForETHSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22641) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                else:
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22642 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                                    require ext_code.size(address(stor[_1822]))
                                    call address(stor[_1822]).swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22642) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362
                                    require return_data.size >= 32
                                    _24818 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                                    require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                                    _24946 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                                    require ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                                    mem[ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require _24818 + (32 * _24946) + 32 <= return_data.size
                                    idx = 0
                                    s = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + _24818 + 394
                                    t = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 394
                                    while idx < _24946:
                                        require mem[s] == mem[s]
                                        mem[t] = mem[s]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                        else:
                            if ceil32(arg3.length) <= arg3.length:
                                if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0xd46d2f8300000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22517 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(address(stor[_1822]))
                                    call address(stor[_1822]).0xd46d2f83 with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22517) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                else:
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x5d616c5b00000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22518 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                                    require ext_code.size(address(stor[_1822]))
                                    call address(stor[_1822]).0x5d616c5b with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22518) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362
                                    require return_data.size >= 32
                                    _24821 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                                    require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                                    _24949 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                                    require ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                                    mem[ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require _24821 + (32 * _24949) + 32 <= return_data.size
                                    idx = 0
                                    s = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + _24821 + 394
                                    t = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 394
                                    while idx < _24949:
                                        require mem[s] == mem[s]
                                        mem[t] = mem[s]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                            else:
                                if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0xd46d2f8300000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22645 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(address(stor[_1822]))
                                    call address(stor[_1822]).0xd46d2f83 with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22645) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                else:
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x5d616c5b00000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22646 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                                    require ext_code.size(address(stor[_1822]))
                                    call address(stor[_1822]).0x5d616c5b with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22646) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362
                                    require return_data.size >= 32
                                    _24822 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                                    require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                                    _24950 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                                    require ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                                    mem[ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require _24822 + (32 * _24950) + 32 <= return_data.size
                                    idx = 0
                                    s = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + _24822 + 394
                                    t = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 394
                                    while idx < _24950:
                                        require mem[s] == mem[s]
                                        mem[t] = mem[s]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                    else:
                        if bool(uint8(stor[mem[(2 * ceil32(arg3.length)) + (4 * ceil32(return_data.size)) + 224 len arg3.length + -ceil32(arg3.length) + 32]][Mask(8 * ceil32(arg3.length), -(8 * ceil32(arg3.length)) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * ceil32(arg3.length)) - 256])) != 1:
                            if ceil32(arg3.length) <= arg3.length:
                                if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x791ac94700000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22521 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(address(stor[_1822]))
                                    call address(stor[_1822]).swapExactTokensForETHSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22521) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                else:
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22522 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                                    require ext_code.size(address(stor[_1822]))
                                    call address(stor[_1822]).swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22522) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362
                                    require return_data.size >= 32
                                    _24825 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                                    require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                                    _24953 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                                    require ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                                    mem[ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require _24825 + (32 * _24953) + 32 <= return_data.size
                                    idx = 0
                                    s = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + _24825 + 394
                                    t = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 394
                                    while idx < _24953:
                                        require mem[s] == mem[s]
                                        mem[t] = mem[s]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                            else:
                                if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x791ac94700000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22649 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(address(stor[_1822]))
                                    call address(stor[_1822]).swapExactTokensForETHSupportingFeeOnTransferTokens(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22649) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                else:
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x18cbafe500000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22650 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                                    require ext_code.size(address(stor[_1822]))
                                    call address(stor[_1822]).swapExactTokensForETH(uint256 rg1, uint256 rg2, address[] rg3, address rg4, uint256 rg5) with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22650) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362
                                    require return_data.size >= 32
                                    _24826 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                                    require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                                    _24954 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                                    require ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                                    mem[ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require _24826 + (32 * _24954) + 32 <= return_data.size
                                    idx = 0
                                    s = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + _24826 + 394
                                    t = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 394
                                    while idx < _24954:
                                        require mem[s] == mem[s]
                                        mem[t] = mem[s]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                        else:
                            if ceil32(arg3.length) <= arg3.length:
                                if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0xd46d2f8300000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22525 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(address(stor[_1822]))
                                    call address(stor[_1822]).0xd46d2f83 with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22525) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                else:
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x5d616c5b00000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22526 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                                    require ext_code.size(address(stor[_1822]))
                                    call address(stor[_1822]).0x5d616c5b with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22526) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362
                                    require return_data.size >= 32
                                    _24829 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                                    require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                                    _24957 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                                    require ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                                    mem[ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require _24829 + (32 * _24957) + 32 <= return_data.size
                                    idx = 0
                                    s = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + _24829 + 394
                                    t = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 394
                                    while idx < _24957:
                                        require mem[s] == mem[s]
                                        mem[t] = mem[s]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                            else:
                                if sha3(Mask(8 * arg3.length, -(8 * arg3.length) + 256, arg3[all], mem[arg3.length + 128 len ceil32(arg3.length) - arg3.length]) << (8 * arg3.length) - 256) != sha3('BurgerSwap'):
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0xd46d2f8300000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22653 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    require ext_code.size(address(stor[_1822]))
                                    call address(stor[_1822]).0xd46d2f83 with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22653) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                else:
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] = 0x5d616c5b00000000000000000000000000000000000000000000000000000000
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 366] = ext_call.return_data[0]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 398] = arg2
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 430] = 160
                                    _22654 = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526] = Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]
                                    idx = 0
                                    s = ceil32(arg3.length) + 160
                                    t = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 558
                                    while idx < Mask(8 * -ceil32(arg3.length) + arg3.length + 32, 0, 0), mem[arg3.length + 160 len -arg3.length + ceil32(arg3.length)]:
                                        mem[t] = mem[s + 12 len 20]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 462] = this.address
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 494] = arg4
                                    require ext_code.size(address(stor[_1822]))
                                    call address(stor[_1822]).0x5d616c5b with:
                                         gas gas_remaining wei
                                        args ext_call.return_data[0], arg2, 160, address(this.address), arg4, mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 526 len (32 * _22654) + 32]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362 len return_data.size] = ext_call.return_data[0 len return_data.size]
                                    mem[64] = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362
                                    require return_data.size >= 32
                                    _24830 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] <= test266151307()
                                    require ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 393 < ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + return_data.size + 362
                                    _24958 = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362] <= test266151307()
                                    require ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 394 <= test266151307() and (32 * mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]) + 32 >= 0
                                    mem[ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 362] = mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + mem[ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + 362] + 362]
                                    require _24830 + (32 * _24958) + 32 <= return_data.size
                                    idx = 0
                                    s = ceil32(arg3.length) + (4 * ceil32(return_data.size)) + arg3.length + _24830 + 394
                                    t = ceil32(arg3.length) + (6 * ceil32(return_data.size)) + arg3.length + 394
                                    while idx < _24958:
                                        require mem[s] == mem[s]
                                        mem[t] = mem[s]
                                        idx = idx + 1
                                        s = s + 32
                                        t = t + 32
                                        continue 
}



}

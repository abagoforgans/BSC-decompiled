contract main {




// =====================  Runtime code  =====================


#
#  - sub_9caa9dae(?)
#
address sub_413c05c6Address;
uint8 stor1; offset 160
uint128 stor1; offset 160
address sub_76089ab4Address;
uint256 sub_d8830c7d;
uint256 DENOMINATOR;
uint256 sub_be647a94;
uint256 sub_ed73481d;
mapping of uint256 sub_2c8bff0e;
mapping of uint256 sub_1b385a01;
mapping of uint8 stor8;
mapping of uint8 stor9;
uint256 sub_d3a8b1da;
uint256 sub_ab7789c0;
mapping of struct sub_4c86259e;
uint256 sub_f4a8f345;
uint256 sub_04b4a313;
address TOKEN_DEFINERAddress;

function sub_04b4a313(?) {
    return sub_04b4a313
}

function sub_1b385a01(?) {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    return sub_1b385a01[arg1]
}

function sub_2c8bff0e(?) {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    return sub_2c8bff0e[arg1]
}

function sub_413c05c6(?) {
    return sub_413c05c6Address
}

function sub_4c86259e(?) {
    require calldata.size - 4 >= 32
    return sub_4c86259e[arg1].field_0, Mask(128, 128, sub_4c86259e[arg1].field_256)
}

function TOKEN_DEFINER() {
    return TOKEN_DEFINERAddress
}

function sub_76089ab4(?) {
    return sub_76089ab4Address
}

function DENOMINATOR() {
    return DENOMINATOR
}

function sub_a4b4ea9a(?) {
    require calldata.size - 4 >= 64
    require arg1 == address(arg1)
    require arg2 == Mask(128, 128, arg2)
    return bool(stor9[arg1][arg2])
}

function sub_ab7789c0(?) {
    return sub_ab7789c0
}

function sub_be647a94(?) {
    return sub_be647a94
}

function sub_d3a8b1da(?) {
    return sub_d3a8b1da
}

function sub_d8830c7d(?) {
    return sub_d8830c7d
}

function sub_ddeed3d5(?) {
    return bool(uint8(stor1.field_160))
}

function sub_e6a4f059(?) {
    require calldata.size - 4 >= 64
    require arg1 == address(arg1)
    require arg2 == Mask(128, 128, arg2)
    return bool(stor8[arg1][arg2])
}

function sub_ed73481d(?) {
    return sub_ed73481d
}

function sub_f4a8f345(?) {
    return sub_f4a8f345
}

function revokeAccess() {
    if TOKEN_DEFINERAddress != msg.sender:
        revert with 0, 'Wrong sender.'
    TOKEN_DEFINERAddress = 0
}

function sub_226fc72a(?) {
    require calldata.size - 4 >= 32
    if TOKEN_DEFINERAddress != msg.sender:
        revert with 0, 'Wrong sender.'
    sub_ed73481d = arg1
}

function sub_382c0ab3(?) {
    require calldata.size - 4 >= 32
    if TOKEN_DEFINERAddress != msg.sender:
        revert with 0, 'Wrong sender.'
    sub_be647a94 = arg1
}

function setRatio(uint256 arg1, uint256 arg2) {
    require calldata.size - 4 >= 64
    if TOKEN_DEFINERAddress != msg.sender:
        revert with 0, 'Wrong sender.'
    sub_d8830c7d = arg1
    DENOMINATOR = arg2
}

function sub_64229836(?) {
    require calldata.size - 4 >= 32
    require arg1 == bool(arg1)
    if TOKEN_DEFINERAddress != msg.sender:
        revert with 0, 'Wrong sender.'
    Mask(96, 0, stor1.field_160) = Mask(96, 0, bool(arg1))
}

function setContracts(address arg1, address arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 == arg2
    if TOKEN_DEFINERAddress != msg.sender:
        revert with 0, 'Wrong sender.'
    sub_413c05c6Address = arg1
    sub_76089ab4Address = arg2
}

function sub_461e356f(?) {
    require calldata.size - 4 >= 96
    require arg1 == address(arg1)
    require arg2 == Mask(128, 128, arg2)
    staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
            gas gas_remaining wei
           args address(arg1), Mask(128, 128, arg2)
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 352
    if not bool(ceil32(return_data.size) + 800 <= test266151307()):
        revert with 0, 65
    require ext_call.return_data[0] == Mask(128, 128, ext_call.return_data[0])
    require ext_call.return_data[128] < 5
    if Mask(128, 128, ext_call.return_data[0]) != Mask(128, 128, arg2):
        if ext_call.return_data[128] >= 5:
            revert with 0, 33
        return Mask(128, 128, ext_call.return_data[0]), 
               ext_call.return_data[32],
               ext_call.return_data[64],
               ext_call.return_data[96],
               ext_call.return_data[128],
               ext_call.return_data[160],
               ext_call.return_data[192],
               ext_call.return_data[224],
               ext_call.return_data[256],
               ext_call.return_data[288],
               ext_call.return_data[320],
               0,
               416,
               46,
               0xfe53656e64657220646f6573206e6f7420636f6e7461696e207374616b6520776974682070726f76696465642069, mem[ceil32(return_data.size) + 878 len 18] >> 112,
               0
    if stor9[address(arg1)][Mask(128, 128, arg2)]:
        if ext_call.return_data[128] >= 5:
            revert with 0, 33
        return Mask(128, 128, ext_call.return_data[0]), 
               ext_call.return_data[32],
               ext_call.return_data[64],
               ext_call.return_data[96],
               ext_call.return_data[128],
               ext_call.return_data[160],
               ext_call.return_data[192],
               ext_call.return_data[224],
               ext_call.return_data[256],
               ext_call.return_data[288],
               ext_call.return_data[320],
               0,
               416,
               32,
               'Stake has already been converted'
    if ext_call.return_data[128] > 4:
        revert with 0, 33
    if ext_call.return_data[128] != 2:
        if ext_call.return_data[128] >= 5:
            revert with 0, 33
        return Mask(128, 128, ext_call.return_data[0]), 
               ext_call.return_data[32],
               ext_call.return_data[64],
               ext_call.return_data[96],
               ext_call.return_data[128],
               ext_call.return_data[160],
               ext_call.return_data[192],
               ext_call.return_data[224],
               ext_call.return_data[256],
               ext_call.return_data[288],
               ext_call.return_data[320],
               0,
               416,
               44,
               0x795374616b65206973206f6e6c7920656c696769626c6520696620697420686173206265656e20636c6f7365, mem[ceil32(return_data.size) + 876 len 20] >> 96,
               0
    if ext_call.return_data[192] >= arg3:
        if ext_call.return_data[128] >= 5:
            revert with 0, 33
        return Mask(128, 128, ext_call.return_data[0]), 
               ext_call.return_data[32],
               ext_call.return_data[64],
               ext_call.return_data[96],
               ext_call.return_data[128],
               ext_call.return_data[160],
               ext_call.return_data[192],
               ext_call.return_data[224],
               ext_call.return_data[256],
               ext_call.return_data[288],
               ext_call.return_data[320],
               0,
               416,
               65,
               0x645374616b65206973206f6e6c7920656c696769626c65206966206974207761732063726561746564207072696f7220746f2074686520637574206f6666206461, mem[ceil32(return_data.size) + 897 len 31] >> 264,
               0
    if ext_call.return_data[192] > !ext_call.return_data[224]:
        revert with 0, 17
    if ext_call.return_data[128] >= 5:
        revert with 0, 33
    if ext_call.return_data[192] + ext_call.return_data[224] >= arg3:
        return Mask(128, 128, ext_call.return_data[0]), 
               ext_call.return_data[32],
               ext_call.return_data[64],
               ext_call.return_data[96],
               ext_call.return_data[128],
               ext_call.return_data[160],
               ext_call.return_data[192],
               ext_call.return_data[224],
               ext_call.return_data[256],
               ext_call.return_data[288],
               ext_call.return_data[320],
               1,
               416,
               17,
               'Stake is eligible',
               0
    return Mask(128, 128, ext_call.return_data[0]), 
           ext_call.return_data[32],
           ext_call.return_data[64],
           ext_call.return_data[96],
           ext_call.return_data[128],
           ext_call.return_data[160],
           ext_call.return_data[192],
           ext_call.return_data[224],
           ext_call.return_data[256],
           ext_call.return_data[288],
           ext_call.return_data[320],
           0,
           416,
           66,
           0x645374616b65206973206f6e6c7920656c696769626c652069662069742077617320656e646564206f6e2074686520637574206f666620646179206f722061667465, mem[ceil32(return_data.size) + 898 len 30] >> 272,
           0
}

function sub_86ba6c67(?) {
    require calldata.size - 4 >= 64
    if sub_d3a8b1da < 1:
        revert with 0, 17
    if arg1 > sub_d3a8b1da - 1:
        mem[96] = 0
        mem[64] = 128
        mem[128] = 32
        mem[160] = 0
        idx = 0
        s = 128
        t = 192
        while idx < mem[96]:
            _50 = mem[s]
            mem[t] = mem[mem[s] + 12 len 20]
            mem[t + 32] = Mask(128, 128, mem[_50 + 32])
            idx = idx + 1
            s = s + 32
            t = t + 64
            continue 
        return memory
          from mem[64]
           len -mem[64] + 192
    if sub_d3a8b1da < 1:
        revert with 0, 17
    if arg1 > !arg2:
        revert with 0, 17
    if arg1 + arg2 <= sub_d3a8b1da - 1:
        if arg2 > test266151307():
            revert with 0, 65
        mem[96] = arg2
        mem[64] = (32 * arg2) + 128
        if not arg2:
            if arg1 > !arg2:
                revert with 0, 17
            s = 0
            idx = arg1
            while idx < arg1 + arg2:
                if 1 > !idx:
                    revert with 0, 17
                mem[0] = idx + 1
                mem[32] = 12
                _58 = mem[64]
                mem[64] = mem[64] + 64
                mem[_58] = sub_4c86259e[idx + 1].field_0
                mem[_58 + 32] = Mask(128, 128, sub_4c86259e[idx + 1].field_256)
                if s >= mem[96]:
                    revert with 0, 50
                mem[(32 * s) + 128] = _58
                if s == -1:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                s = s + 1
                idx = idx + 1
                continue 
            _54 = mem[64]
            mem[mem[64]] = 32
            _56 = mem[96]
            mem[mem[64] + 32] = mem[96]
            idx = 0
            s = 128
            t = mem[64] + 64
            while idx < _56:
                _90 = mem[s]
                mem[t] = mem[mem[s] + 12 len 20]
                mem[t + 32] = Mask(128, 128, mem[_90 + 32])
                idx = idx + 1
                s = s + 32
                t = t + 64
                continue 
            return memory
              from mem[64]
               len _54 + (64 * _56) + -mem[64] + 64
        mem[64] = (32 * arg2) + 192
        mem[(32 * arg2) + 128] = 0
        mem[(32 * arg2) + 160] = 0
        mem[128] = (32 * arg2) + 128
        s = 128
        idx = arg2
        while idx - 1:
            mem[64] = mem[64] + 64
            mem[(32 * arg2) + 128] = 0
            mem[(32 * arg2) + 160] = 0
            mem[s + 32] = (32 * arg2) + 128
            s = s + 32
            idx = idx - 1
            continue 
        if arg1 > !arg2:
            revert with 0, 17
        s = 0
        idx = arg1
        while idx < arg1 + arg2:
            if 1 > !idx:
                revert with 0, 17
            mem[0] = idx + 1
            mem[32] = 12
            _102 = mem[64]
            mem[64] = mem[64] + 64
            mem[_102] = sub_4c86259e[idx + 1].field_0
            mem[_102 + 32] = Mask(128, 128, sub_4c86259e[idx + 1].field_256)
            if s >= mem[96]:
                revert with 0, 50
            mem[(32 * s) + 128] = _102
            if s == -1:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            s = s + 1
            idx = idx + 1
            continue 
        _98 = mem[64]
        mem[mem[64]] = 32
        _100 = mem[96]
        mem[mem[64] + 32] = mem[96]
        idx = 0
        s = 128
        t = mem[64] + 64
        while idx < _100:
            _116 = mem[s]
            mem[t] = mem[mem[s] + 12 len 20]
            mem[t + 32] = Mask(128, 128, mem[_116 + 32])
            idx = idx + 1
            s = s + 32
            t = t + 64
            continue 
        return memory
          from mem[64]
           len _98 + (64 * _100) + -mem[64] + 64
    if sub_d3a8b1da < 1:
        revert with 0, 17
    if sub_d3a8b1da - 1 < arg1:
        revert with 0, 17
    if sub_d3a8b1da + -arg1 - 1 > test266151307():
        revert with 0, 65
    mem[96] = sub_d3a8b1da + -arg1 - 1
    mem[64] = (32 * sub_d3a8b1da + -arg1 - 1) + 128
    if not sub_d3a8b1da + -arg1 - 1:
        if arg1 > !(sub_d3a8b1da + -arg1 - 1):
            revert with 0, 17
        s = 0
        idx = arg1
        while idx < sub_d3a8b1da - 1:
            if 1 > !idx:
                revert with 0, 17
            mem[0] = idx + 1
            mem[32] = 12
            _62 = mem[64]
            mem[64] = mem[64] + 64
            mem[_62] = sub_4c86259e[idx + 1].field_0
            mem[_62 + 32] = Mask(128, 128, sub_4c86259e[idx + 1].field_256)
            if s >= mem[96]:
                revert with 0, 50
            mem[(32 * s) + 128] = _62
            if s == -1:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            s = s + 1
            idx = idx + 1
            continue 
        _55 = mem[64]
        mem[mem[64]] = 32
        _60 = mem[96]
        mem[mem[64] + 32] = mem[96]
        idx = 0
        s = 128
        t = mem[64] + 64
        while idx < _60:
            _93 = mem[s]
            mem[t] = mem[mem[s] + 12 len 20]
            mem[t + 32] = Mask(128, 128, mem[_93 + 32])
            idx = idx + 1
            s = s + 32
            t = t + 64
            continue 
        return memory
          from mem[64]
           len _55 + (64 * _60) + -mem[64] + 64
    mem[64] = (32 * sub_d3a8b1da + -arg1 - 1) + 192
    mem[(32 * sub_d3a8b1da + -arg1 - 1) + 128] = 0
    mem[(32 * sub_d3a8b1da + -arg1 - 1) + 160] = 0
    mem[128] = (32 * sub_d3a8b1da + -arg1 - 1) + 128
    s = 128
    idx = sub_d3a8b1da + -arg1 - 1
    while idx - 1:
        mem[64] = mem[64] + 64
        mem[(32 * sub_d3a8b1da + -arg1 - 1) + 128] = 0
        mem[(32 * sub_d3a8b1da + -arg1 - 1) + 160] = 0
        mem[s + 32] = (32 * sub_d3a8b1da + -arg1 - 1) + 128
        s = s + 32
        idx = idx - 1
        continue 
    if arg1 > !(sub_d3a8b1da + -arg1 - 1):
        revert with 0, 17
    s = 0
    idx = arg1
    while idx < sub_d3a8b1da - 1:
        if 1 > !idx:
            revert with 0, 17
        mem[0] = idx + 1
        mem[32] = 12
        _106 = mem[64]
        mem[64] = mem[64] + 64
        mem[_106] = sub_4c86259e[idx + 1].field_0
        mem[_106 + 32] = Mask(128, 128, sub_4c86259e[idx + 1].field_256)
        if s >= mem[96]:
            revert with 0, 50
        mem[(32 * s) + 128] = _106
        if s == -1:
            revert with 0, 17
        if idx == -1:
            revert with 0, 17
        s = s + 1
        idx = idx + 1
        continue 
    _99 = mem[64]
    mem[mem[64]] = 32
    _104 = mem[96]
    mem[mem[64] + 32] = mem[96]
    idx = 0
    s = 128
    t = mem[64] + 64
    while idx < _104:
        _119 = mem[s]
        mem[t] = mem[mem[s] + 12 len 20]
        mem[t + 32] = Mask(128, 128, mem[_119 + 32])
        idx = idx + 1
        s = s + 32
        t = t + 64
        continue 
    return memory
      from mem[64]
       len _99 + (64 * _104) + -mem[64] + 64
}

function sub_88b1d22d(?) {
    require calldata.size - 4 >= 96
    require arg1 == address(arg1)
    require arg2 == Mask(128, 128, arg2)
    staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
            gas gas_remaining wei
           args address(arg1), Mask(128, 128, arg2)
    mem[96 len 352] = ext_call.return_data[0 len 352]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 352
    if not bool(ceil32(return_data.size) + 448 <= test266151307()):
        revert with 0, 65
    mem[64] = ceil32(return_data.size) + 448
    require ext_call.return_data[0] == Mask(128, 128, ext_call.return_data[0])
    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
    mem[ceil32(return_data.size) + 128] = ext_call.return_data[32]
    mem[ceil32(return_data.size) + 160] = ext_call.return_data[64]
    mem[ceil32(return_data.size) + 192] = ext_call.return_data[96]
    require ext_call.return_data[128] < 5
    mem[ceil32(return_data.size) + 224] = ext_call.return_data[128]
    mem[ceil32(return_data.size) + 256] = ext_call.return_data[160]
    mem[ceil32(return_data.size) + 288] = ext_call.return_data[192]
    mem[ceil32(return_data.size) + 320] = ext_call.return_data[224]
    mem[ceil32(return_data.size) + 352] = ext_call.return_data[256]
    mem[ceil32(return_data.size) + 384] = ext_call.return_data[288]
    mem[ceil32(return_data.size) + 416] = ext_call.return_data[320]
    if Mask(128, 128, ext_call.return_data[0]) != Mask(128, 128, arg2):
        revert with 0, 'Address does not contain stake with provided id'
    idx = mem[ceil32(return_data.size) + 288]
    s = 0
    while idx < arg3:
        staticcall sub_413c05c6Address.0x8ce1d9e4 with:
                gas gas_remaining wei
               args idx
        mem[mem[64] len 160] = ext_call.return_data[0 len 160]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _88 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 160
        _90 = mem[64]
        if mem[64] + 160 > test266151307() or mem[64] + 160 < mem[64]:
            revert with 0, 65
        mem[64] = mem[64] + 160
        mem[_90] = mem[_88]
        mem[_90 + 32] = mem[_88 + 32]
        mem[_90 + 64] = mem[_88 + 64]
        mem[_90 + 96] = mem[_88 + 96]
        mem[_90 + 128] = mem[_88 + 128]
        _96 = mem[_90 + 64]
        _97 = mem[_90 + 32]
        _98 = mem[ceil32(return_data.size) + 160]
        _99 = mem[_90]
        _100 = mem[_90 + 128]
        _101 = mem[_90 + 96]
        if mem[_90 + 96] > !mem[_90 + 128]:
            revert with 0, 17
        if mem[_90 + 96] + mem[_90 + 128] < mem[_90 + 96]:
            revert with 0, 'SafeMath: addition overflow'
        if not mem[_90 + 96] + mem[_90 + 128]:
            _105 = mem[64]
            mem[64] = mem[64] + 64
            mem[_105] = 26
            mem[_105 + 32] = 'SafeMath: division by zero'
            if not _97:
                _107 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _107 + 68] = mem[_105 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_107 + 94] = 0
                revert with memory
                  from mem[64]
                   len _107 + -mem[64] + 100
            _112 = mem[64]
            mem[64] = mem[64] + 64
            mem[_112] = 26
            mem[_112 + 32] = 'SafeMath: division by zero'
            if _96:
                if s > !(0 / _97 / _96):
                    revert with 0, 17
                if s + (0 / _97 / _96) < s:
                    revert with 0, 'SafeMath: addition overflow'
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + (0 / _97 / _96)
                continue 
            _116 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _116 + 68] = mem[_112 + idx + 32]
                idx = idx + 32
                continue 
            mem[_116 + 94] = 0
            revert with memory
              from mem[64]
               len _116 + -mem[64] + 100
        if mem[_90 + 96] + mem[_90 + 128] and mem[_90] > -1 / mem[_90 + 96] + mem[_90 + 128]:
            revert with 0, 17
        if not mem[_90 + 96] + mem[_90 + 128]:
            revert with 0, 18
        if (mem[_90 + 96] * mem[_90]) + (mem[_90 + 128] * mem[_90]) / mem[_90 + 96] + mem[_90 + 128] != mem[_90]:
            revert with 0, 'SafeMath: multiplication overflow'
        if not (mem[_90 + 96] * mem[_90]) + (mem[_90 + 128] * mem[_90]):
            _109 = mem[64]
            mem[64] = mem[64] + 64
            mem[_109] = 26
            mem[_109 + 32] = 'SafeMath: division by zero'
            if not _97:
                _111 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _111 + 68] = mem[_109 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_111 + 94] = 0
                revert with memory
                  from mem[64]
                   len _111 + -mem[64] + 100
            _123 = mem[64]
            mem[64] = mem[64] + 64
            mem[_123] = 26
            mem[_123 + 32] = 'SafeMath: division by zero'
            if _96:
                if s > !(0 / _97 / _96):
                    revert with 0, 17
                if s + (0 / _97 / _96) < s:
                    revert with 0, 'SafeMath: addition overflow'
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + (0 / _97 / _96)
                continue 
            _127 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _127 + 68] = mem[_123 + idx + 32]
                idx = idx + 32
                continue 
            mem[_127 + 94] = 0
            revert with memory
              from mem[64]
               len _127 + -mem[64] + 100
        if (mem[_90 + 96] * mem[_90]) + (mem[_90 + 128] * mem[_90]) and mem[ceil32(return_data.size) + 160] > -1 / (mem[_90 + 96] * mem[_90]) + (mem[_90 + 128] * mem[_90]):
            revert with 0, 17
        if not (mem[_90 + 96] * mem[_90]) + (mem[_90 + 128] * mem[_90]):
            revert with 0, 18
        if (mem[_90 + 96] * mem[_90] * mem[ceil32(return_data.size) + 160]) + (mem[_90 + 128] * mem[_90] * mem[ceil32(return_data.size) + 160]) / (mem[_90 + 96] * mem[_90]) + (mem[_90 + 128] * mem[_90]) != mem[ceil32(return_data.size) + 160]:
            revert with 0, 'SafeMath: multiplication overflow'
        _119 = mem[64]
        mem[64] = mem[64] + 64
        mem[_119] = 26
        mem[_119 + 32] = 'SafeMath: division by zero'
        if not _97:
            _122 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _122 + 68] = mem[_119 + idx + 32]
                idx = idx + 32
                continue 
            mem[_122 + 94] = 0
            revert with memory
              from mem[64]
               len _122 + -mem[64] + 100
        _133 = mem[64]
        mem[64] = mem[64] + 64
        mem[_133] = 26
        mem[_133 + 32] = 'SafeMath: division by zero'
        if _96:
            if s > !((_101 * _99 * _98) + (_100 * _99 * _98) / _97 / _96):
                revert with 0, 17
            if s + ((_101 * _99 * _98) + (_100 * _99 * _98) / _97 / _96) < s:
                revert with 0, 'SafeMath: addition overflow'
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s + ((_101 * _99 * _98) + (_100 * _99 * _98) / _97 / _96)
            continue 
        _138 = mem[64]
        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 32
        mem[mem[64] + 36] = 26
        idx = 0
        while idx < 26:
            mem[idx + _138 + 68] = mem[_133 + idx + 32]
            idx = idx + 32
            continue 
        mem[_138 + 94] = 0
        revert with memory
          from mem[64]
           len _138 + -mem[64] + 100
    return s
}

function sub_f5eb88fe(?) {
    require calldata.size - 4 >= 96
    require arg1 == address(arg1)
    require arg2 == Mask(128, 128, arg2)
    staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
            gas gas_remaining wei
           args address(arg1), Mask(128, 128, arg2)
    mem[96 len 352] = ext_call.return_data[0 len 352]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 352
    if not bool(ceil32(return_data.size) + 448 <= test266151307()):
        revert with 0, 65
    require ext_call.return_data[0] == Mask(128, 128, ext_call.return_data[0])
    mem[ceil32(return_data.size) + 96] = ext_call.return_data[0]
    mem[ceil32(return_data.size) + 128] = ext_call.return_data[32]
    mem[ceil32(return_data.size) + 160] = ext_call.return_data[64]
    mem[ceil32(return_data.size) + 192] = ext_call.return_data[96]
    require ext_call.return_data[128] < 5
    mem[ceil32(return_data.size) + 224] = ext_call.return_data[128]
    mem[ceil32(return_data.size) + 256] = ext_call.return_data[160]
    mem[ceil32(return_data.size) + 288] = ext_call.return_data[192]
    mem[ceil32(return_data.size) + 320] = ext_call.return_data[224]
    mem[ceil32(return_data.size) + 352] = ext_call.return_data[256]
    mem[ceil32(return_data.size) + 384] = ext_call.return_data[288]
    mem[ceil32(return_data.size) + 416] = ext_call.return_data[320]
    if Mask(128, 128, ext_call.return_data[0]) != Mask(128, 128, arg2):
        revert with 0, 'Address does not contain stake with provided id'
    if ext_call.return_data[128] > 4:
        revert with 0, 33
    if ext_call.return_data[128] == 3:
        return 0
    if ext_call.return_data[128] > 4:
        revert with 0, 33
    if ext_call.return_data[128] == 4:
        return 0
    if ext_call.return_data[128] > 4:
        revert with 0, 33
    if ext_call.return_data[128] == 1:
        return 0
    if ext_call.return_data[128] > 4:
        revert with 0, 33
    if not ext_call.return_data[128]:
        staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                gas gas_remaining wei
               args address(arg1), Mask(128, 128, ext_call.return_data[0])
        mem[ceil32(return_data.size) + 448 len 352] = ext_call.return_data[0 len 352]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 352
        if not bool((2 * ceil32(return_data.size)) + 800 <= test266151307()):
            revert with 0, 65
        mem[64] = (2 * ceil32(return_data.size)) + 800
        require ext_call.return_data[0] == Mask(128, 128, ext_call.return_data[0])
        mem[(2 * ceil32(return_data.size)) + 448] = ext_call.return_data[0]
        mem[(2 * ceil32(return_data.size)) + 480] = ext_call.return_data[32]
        mem[(2 * ceil32(return_data.size)) + 512] = ext_call.return_data[64]
        mem[(2 * ceil32(return_data.size)) + 544] = ext_call.return_data[96]
        require ext_call.return_data[128] < 5
        mem[(2 * ceil32(return_data.size)) + 576] = ext_call.return_data[128]
        mem[(2 * ceil32(return_data.size)) + 608] = ext_call.return_data[160]
        mem[(2 * ceil32(return_data.size)) + 640] = ext_call.return_data[192]
        mem[(2 * ceil32(return_data.size)) + 672] = ext_call.return_data[224]
        mem[(2 * ceil32(return_data.size)) + 704] = ext_call.return_data[256]
        mem[(2 * ceil32(return_data.size)) + 736] = ext_call.return_data[288]
        mem[(2 * ceil32(return_data.size)) + 768] = ext_call.return_data[320]
        if Mask(128, 128, ext_call.return_data[0]) != Mask(128, 128, ext_call.return_data[0]):
            revert with 0, 'Address does not contain stake with provided id'
        idx = mem[(2 * ceil32(return_data.size)) + 640]
        s = 0
        while idx < arg3:
            staticcall sub_413c05c6Address.0x8ce1d9e4 with:
                    gas gas_remaining wei
                   args idx
            mem[mem[64] len 160] = ext_call.return_data[0 len 160]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _662 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 160
            _673 = mem[64]
            if mem[64] + 160 > test266151307() or mem[64] + 160 < mem[64]:
                revert with 0, 65
            mem[64] = mem[64] + 160
            mem[_673] = mem[_662]
            mem[_673 + 32] = mem[_662 + 32]
            mem[_673 + 64] = mem[_662 + 64]
            mem[_673 + 96] = mem[_662 + 96]
            mem[_673 + 128] = mem[_662 + 128]
            _705 = mem[_673 + 64]
            _706 = mem[_673 + 32]
            _707 = mem[(2 * ceil32(return_data.size)) + 512]
            _708 = mem[_673]
            _709 = mem[_673 + 128]
            _710 = mem[_673 + 96]
            if mem[_673 + 96] > !mem[_673 + 128]:
                revert with 0, 17
            if mem[_673 + 96] + mem[_673 + 128] < mem[_673 + 96]:
                revert with 0, 'SafeMath: addition overflow'
            if not mem[_673 + 96] + mem[_673 + 128]:
                _774 = mem[64]
                mem[64] = mem[64] + 64
                mem[_774] = 26
                mem[_774 + 32] = 'SafeMath: division by zero'
                if not _706:
                    _784 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _784 + 68] = mem[_774 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_784 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _784 + -mem[64] + 100
                _859 = mem[64]
                mem[64] = mem[64] + 64
                mem[_859] = 26
                mem[_859 + 32] = 'SafeMath: division by zero'
                if _705:
                    if s > !(0 / _706 / _705):
                        revert with 0, 17
                    if s + (0 / _706 / _705) < s:
                        revert with 0, 'SafeMath: addition overflow'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + (0 / _706 / _705)
                    continue 
                _877 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _877 + 68] = mem[_859 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_877 + 94] = 0
                revert with memory
                  from mem[64]
                   len _877 + -mem[64] + 100
            if mem[_673 + 96] + mem[_673 + 128] and mem[_673] > -1 / mem[_673 + 96] + mem[_673 + 128]:
                revert with 0, 17
            if not mem[_673 + 96] + mem[_673 + 128]:
                revert with 0, 18
            if (mem[_673 + 96] * mem[_673]) + (mem[_673 + 128] * mem[_673]) / mem[_673 + 96] + mem[_673 + 128] != mem[_673]:
                revert with 0, 'SafeMath: multiplication overflow'
            if not (mem[_673 + 96] * mem[_673]) + (mem[_673 + 128] * mem[_673]):
                _814 = mem[64]
                mem[64] = mem[64] + 64
                mem[_814] = 26
                mem[_814 + 32] = 'SafeMath: division by zero'
                if not _706:
                    _858 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _858 + 68] = mem[_814 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_858 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _858 + -mem[64] + 100
                _914 = mem[64]
                mem[64] = mem[64] + 64
                mem[_914] = 26
                mem[_914 + 32] = 'SafeMath: division by zero'
                if _705:
                    if s > !(0 / _706 / _705):
                        revert with 0, 17
                    if s + (0 / _706 / _705) < s:
                        revert with 0, 'SafeMath: addition overflow'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + (0 / _706 / _705)
                    continue 
                _948 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _948 + 68] = mem[_914 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_948 + 94] = 0
                revert with memory
                  from mem[64]
                   len _948 + -mem[64] + 100
            if (mem[_673 + 96] * mem[_673]) + (mem[_673 + 128] * mem[_673]) and mem[(2 * ceil32(return_data.size)) + 512] > -1 / (mem[_673 + 96] * mem[_673]) + (mem[_673 + 128] * mem[_673]):
                revert with 0, 17
            if not (mem[_673 + 96] * mem[_673]) + (mem[_673 + 128] * mem[_673]):
                revert with 0, 18
            if (mem[_673 + 96] * mem[_673] * mem[(2 * ceil32(return_data.size)) + 512]) + (mem[_673 + 128] * mem[_673] * mem[(2 * ceil32(return_data.size)) + 512]) / (mem[_673 + 96] * mem[_673]) + (mem[_673 + 128] * mem[_673]) != mem[(2 * ceil32(return_data.size)) + 512]:
                revert with 0, 'SafeMath: multiplication overflow'
            _898 = mem[64]
            mem[64] = mem[64] + 64
            mem[_898] = 26
            mem[_898 + 32] = 'SafeMath: division by zero'
            if not _706:
                _913 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _913 + 68] = mem[_898 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_913 + 94] = 0
                revert with memory
                  from mem[64]
                   len _913 + -mem[64] + 100
            _974 = mem[64]
            mem[64] = mem[64] + 64
            mem[_974] = 26
            mem[_974 + 32] = 'SafeMath: division by zero'
            if _705:
                if s > !((_710 * _708 * _707) + (_709 * _708 * _707) / _706 / _705):
                    revert with 0, 17
                if s + ((_710 * _708 * _707) + (_709 * _708 * _707) / _706 / _705) < s:
                    revert with 0, 'SafeMath: addition overflow'
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + ((_710 * _708 * _707) + (_709 * _708 * _707) / _706 / _705)
                continue 
            _993 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _993 + 68] = mem[_974 + idx + 32]
                idx = idx + 32
                continue 
            mem[_993 + 94] = 0
            revert with memory
              from mem[64]
               len _993 + -mem[64] + 100
        _661 = mem[ceil32(return_data.size) + 256]
        if mem[ceil32(return_data.size) + 256] > !s:
            revert with 0, 17
        if mem[ceil32(return_data.size) + 256] + s < mem[ceil32(return_data.size) + 256]:
            revert with 0, 'SafeMath: addition overflow'
        mem[mem[64]] = mem[ceil32(return_data.size) + 128]
        return mem[mem[64]], _661 + s
    if ext_call.return_data[192] > !ext_call.return_data[224]:
        revert with 0, 17
    staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
            gas gas_remaining wei
           args address(arg1), Mask(128, 128, ext_call.return_data[0])
    mem[ceil32(return_data.size) + 448 len 352] = ext_call.return_data[0 len 352]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 352
    if not bool((2 * ceil32(return_data.size)) + 800 <= test266151307()):
        revert with 0, 65
    mem[64] = (2 * ceil32(return_data.size)) + 800
    require ext_call.return_data[0] == Mask(128, 128, ext_call.return_data[0])
    mem[(2 * ceil32(return_data.size)) + 448] = ext_call.return_data[0]
    mem[(2 * ceil32(return_data.size)) + 480] = ext_call.return_data[32]
    mem[(2 * ceil32(return_data.size)) + 512] = ext_call.return_data[64]
    mem[(2 * ceil32(return_data.size)) + 544] = ext_call.return_data[96]
    require ext_call.return_data[128] < 5
    mem[(2 * ceil32(return_data.size)) + 576] = ext_call.return_data[128]
    mem[(2 * ceil32(return_data.size)) + 608] = ext_call.return_data[160]
    mem[(2 * ceil32(return_data.size)) + 640] = ext_call.return_data[192]
    mem[(2 * ceil32(return_data.size)) + 672] = ext_call.return_data[224]
    mem[(2 * ceil32(return_data.size)) + 704] = ext_call.return_data[256]
    mem[(2 * ceil32(return_data.size)) + 736] = ext_call.return_data[288]
    mem[(2 * ceil32(return_data.size)) + 768] = ext_call.return_data[320]
    if Mask(128, 128, ext_call.return_data[0]) != Mask(128, 128, ext_call.return_data[0]):
        revert with 0, 'Address does not contain stake with provided id'
    if arg3 < ext_call.return_data[192] + ext_call.return_data[224]:
        idx = mem[(2 * ceil32(return_data.size)) + 640]
        s = 0
        while idx < ext_call.return_data[192] + ext_call.return_data[224]:
            staticcall sub_413c05c6Address.0x8ce1d9e4 with:
                    gas gas_remaining wei
                   args idx
            mem[mem[64] len 160] = ext_call.return_data[0 len 160]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _657 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 160
            _669 = mem[64]
            if mem[64] + 160 > test266151307() or mem[64] + 160 < mem[64]:
                revert with 0, 65
            mem[64] = mem[64] + 160
            mem[_669] = mem[_657]
            mem[_669 + 32] = mem[_657 + 32]
            mem[_669 + 64] = mem[_657 + 64]
            mem[_669 + 96] = mem[_657 + 96]
            mem[_669 + 128] = mem[_657 + 128]
            _691 = mem[_669 + 64]
            _692 = mem[_669 + 32]
            _693 = mem[(2 * ceil32(return_data.size)) + 512]
            _694 = mem[_669]
            _695 = mem[_669 + 128]
            _696 = mem[_669 + 96]
            if mem[_669 + 96] > !mem[_669 + 128]:
                revert with 0, 17
            if mem[_669 + 96] + mem[_669 + 128] < mem[_669 + 96]:
                revert with 0, 'SafeMath: addition overflow'
            if not mem[_669 + 96] + mem[_669 + 128]:
                _768 = mem[64]
                mem[64] = mem[64] + 64
                mem[_768] = 26
                mem[_768 + 32] = 'SafeMath: division by zero'
                if not _692:
                    _782 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _782 + 68] = mem[_768 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_782 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _782 + -mem[64] + 100
                _848 = mem[64]
                mem[64] = mem[64] + 64
                mem[_848] = 26
                mem[_848 + 32] = 'SafeMath: division by zero'
                if _691:
                    if s > !(0 / _692 / _691):
                        revert with 0, 17
                    if s + (0 / _692 / _691) < s:
                        revert with 0, 'SafeMath: addition overflow'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + (0 / _692 / _691)
                    continue 
                _869 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _869 + 68] = mem[_848 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_869 + 94] = 0
                revert with memory
                  from mem[64]
                   len _869 + -mem[64] + 100
            if mem[_669 + 96] + mem[_669 + 128] and mem[_669] > -1 / mem[_669 + 96] + mem[_669 + 128]:
                revert with 0, 17
            if not mem[_669 + 96] + mem[_669 + 128]:
                revert with 0, 18
            if (mem[_669 + 96] * mem[_669]) + (mem[_669 + 128] * mem[_669]) / mem[_669 + 96] + mem[_669 + 128] != mem[_669]:
                revert with 0, 'SafeMath: multiplication overflow'
            if not (mem[_669 + 96] * mem[_669]) + (mem[_669 + 128] * mem[_669]):
                _808 = mem[64]
                mem[64] = mem[64] + 64
                mem[_808] = 26
                mem[_808 + 32] = 'SafeMath: division by zero'
                if not _692:
                    _847 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _847 + 68] = mem[_808 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_847 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _847 + -mem[64] + 100
                _906 = mem[64]
                mem[64] = mem[64] + 64
                mem[_906] = 26
                mem[_906 + 32] = 'SafeMath: division by zero'
                if _691:
                    if s > !(0 / _692 / _691):
                        revert with 0, 17
                    if s + (0 / _692 / _691) < s:
                        revert with 0, 'SafeMath: addition overflow'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + (0 / _692 / _691)
                    continue 
                _936 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _936 + 68] = mem[_906 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_936 + 94] = 0
                revert with memory
                  from mem[64]
                   len _936 + -mem[64] + 100
            if (mem[_669 + 96] * mem[_669]) + (mem[_669 + 128] * mem[_669]) and mem[(2 * ceil32(return_data.size)) + 512] > -1 / (mem[_669 + 96] * mem[_669]) + (mem[_669 + 128] * mem[_669]):
                revert with 0, 17
            if not (mem[_669 + 96] * mem[_669]) + (mem[_669 + 128] * mem[_669]):
                revert with 0, 18
            if (mem[_669 + 96] * mem[_669] * mem[(2 * ceil32(return_data.size)) + 512]) + (mem[_669 + 128] * mem[_669] * mem[(2 * ceil32(return_data.size)) + 512]) / (mem[_669 + 96] * mem[_669]) + (mem[_669 + 128] * mem[_669]) != mem[(2 * ceil32(return_data.size)) + 512]:
                revert with 0, 'SafeMath: multiplication overflow'
            _890 = mem[64]
            mem[64] = mem[64] + 64
            mem[_890] = 26
            mem[_890 + 32] = 'SafeMath: division by zero'
            if not _692:
                _905 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _905 + 68] = mem[_890 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_905 + 94] = 0
                revert with memory
                  from mem[64]
                   len _905 + -mem[64] + 100
            _967 = mem[64]
            mem[64] = mem[64] + 64
            mem[_967] = 26
            mem[_967 + 32] = 'SafeMath: division by zero'
            if _691:
                if s > !((_696 * _694 * _693) + (_695 * _694 * _693) / _692 / _691):
                    revert with 0, 17
                if s + ((_696 * _694 * _693) + (_695 * _694 * _693) / _692 / _691) < s:
                    revert with 0, 'SafeMath: addition overflow'
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + ((_696 * _694 * _693) + (_695 * _694 * _693) / _692 / _691)
                continue 
            _988 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _988 + 68] = mem[_967 + idx + 32]
                idx = idx + 32
                continue 
            mem[_988 + 94] = 0
            revert with memory
              from mem[64]
               len _988 + -mem[64] + 100
        if s >= mem[ceil32(return_data.size) + 256]:
            _663 = mem[ceil32(return_data.size) + 96]
            staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                    gas gas_remaining wei
                   args address(arg1), Mask(128, 128, mem[ceil32(return_data.size) + 96])
            mem[mem[64] len 352] = ext_call.return_data[0 len 352]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _711 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 352
            _717 = mem[64]
            if mem[64] + 352 < mem[64] or mem[64] + 352 > test266151307():
                revert with 0, 65
            mem[64] = mem[64] + 352
            require mem[_711] == Mask(128, 128, mem[_711])
            mem[_717] = mem[_711]
            mem[_717 + 32] = mem[_711 + 32]
            mem[_717 + 64] = mem[_711 + 64]
            mem[_717 + 96] = mem[_711 + 96]
            require mem[_711 + 128] < 5
            mem[_717 + 128] = mem[_711 + 128]
            mem[_717 + 160] = mem[_711 + 160]
            mem[_717 + 192] = mem[_711 + 192]
            mem[_717 + 224] = mem[_711 + 224]
            mem[_717 + 256] = mem[_711 + 256]
            mem[_717 + 288] = mem[_711 + 288]
            mem[_717 + 320] = mem[_711 + 320]
            if Mask(128, 128, mem[_717]) != Mask(128, 128, _663):
                revert with 0, 'Address does not contain stake with provided id'
            idx = mem[_717 + 192]
            s = 0
            while idx < arg3:
                staticcall sub_413c05c6Address.0x8ce1d9e4 with:
                        gas gas_remaining wei
                       args idx
                mem[mem[64] len 160] = ext_call.return_data[0 len 160]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1238 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 160
                _1246 = mem[64]
                if mem[64] + 160 > test266151307() or mem[64] + 160 < mem[64]:
                    revert with 0, 65
                mem[64] = mem[64] + 160
                mem[_1246] = mem[_1238]
                mem[_1246 + 32] = mem[_1238 + 32]
                mem[_1246 + 64] = mem[_1238 + 64]
                mem[_1246 + 96] = mem[_1238 + 96]
                mem[_1246 + 128] = mem[_1238 + 128]
                _1313 = mem[_1246 + 64]
                _1314 = mem[_1246 + 32]
                _1315 = mem[_717 + 64]
                _1316 = mem[_1246]
                _1317 = mem[_1246 + 128]
                _1318 = mem[_1246 + 96]
                if mem[_1246 + 96] > !mem[_1246 + 128]:
                    revert with 0, 17
                if mem[_1246 + 96] + mem[_1246 + 128] < mem[_1246 + 96]:
                    revert with 0, 'SafeMath: addition overflow'
                if not mem[_1246 + 96] + mem[_1246 + 128]:
                    _1354 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1354] = 26
                    mem[_1354 + 32] = 'SafeMath: division by zero'
                    if not _1314:
                        _1365 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _1365 + 68] = mem[_1354 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1365 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1365 + -mem[64] + 100
                    _1382 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1382] = 26
                    mem[_1382 + 32] = 'SafeMath: division by zero'
                    if _1313:
                        if s > !(0 / _1314 / _1313):
                            revert with 0, 17
                        if s + (0 / _1314 / _1313) < s:
                            revert with 0, 'SafeMath: addition overflow'
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + (0 / _1314 / _1313)
                        continue 
                    _1395 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _1395 + 68] = mem[_1382 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1395 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _1395 + -mem[64] + 100
                if mem[_1246 + 96] + mem[_1246 + 128] and mem[_1246] > -1 / mem[_1246 + 96] + mem[_1246 + 128]:
                    revert with 0, 17
                if not mem[_1246 + 96] + mem[_1246 + 128]:
                    revert with 0, 18
                if (mem[_1246 + 96] * mem[_1246]) + (mem[_1246 + 128] * mem[_1246]) / mem[_1246 + 96] + mem[_1246 + 128] != mem[_1246]:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not (mem[_1246 + 96] * mem[_1246]) + (mem[_1246 + 128] * mem[_1246]):
                    _1373 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1373] = 26
                    mem[_1373 + 32] = 'SafeMath: division by zero'
                    if not _1314:
                        _1381 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _1381 + 68] = mem[_1373 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1381 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1381 + -mem[64] + 100
                    _1426 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1426] = 26
                    mem[_1426 + 32] = 'SafeMath: division by zero'
                    if _1313:
                        if s > !(0 / _1314 / _1313):
                            revert with 0, 17
                        if s + (0 / _1314 / _1313) < s:
                            revert with 0, 'SafeMath: addition overflow'
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + (0 / _1314 / _1313)
                        continue 
                    _1442 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _1442 + 68] = mem[_1426 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1442 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _1442 + -mem[64] + 100
                if (mem[_1246 + 96] * mem[_1246]) + (mem[_1246 + 128] * mem[_1246]) and mem[_717 + 64] > -1 / (mem[_1246 + 96] * mem[_1246]) + (mem[_1246 + 128] * mem[_1246]):
                    revert with 0, 17
                if not (mem[_1246 + 96] * mem[_1246]) + (mem[_1246 + 128] * mem[_1246]):
                    revert with 0, 18
                if (mem[_1246 + 96] * mem[_1246] * mem[_717 + 64]) + (mem[_1246 + 128] * mem[_1246] * mem[_717 + 64]) / (mem[_1246 + 96] * mem[_1246]) + (mem[_1246 + 128] * mem[_1246]) != mem[_717 + 64]:
                    revert with 0, 'SafeMath: multiplication overflow'
                _1413 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1413] = 26
                mem[_1413 + 32] = 'SafeMath: division by zero'
                if not _1314:
                    _1425 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _1425 + 68] = mem[_1413 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1425 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _1425 + -mem[64] + 100
                _1469 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1469] = 26
                mem[_1469 + 32] = 'SafeMath: division by zero'
                if _1313:
                    if s > !((_1318 * _1316 * _1315) + (_1317 * _1316 * _1315) / _1314 / _1313):
                        revert with 0, 17
                    if s + ((_1318 * _1316 * _1315) + (_1317 * _1316 * _1315) / _1314 / _1313) < s:
                        revert with 0, 'SafeMath: addition overflow'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + ((_1318 * _1316 * _1315) + (_1317 * _1316 * _1315) / _1314 / _1313)
                    continue 
                _1489 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _1489 + 68] = mem[_1469 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_1489 + 94] = 0
                revert with memory
                  from mem[64]
                   len _1489 + -mem[64] + 100
            mem[mem[64]] = mem[ceil32(return_data.size) + 128]
            return mem[mem[64]], s
        _664 = mem[ceil32(return_data.size) + 256]
        _668 = mem[64]
        mem[64] = mem[64] + 64
        mem[_668] = 30
        mem[_668 + 32] = 'SafeMath: subtraction overflow'
        if s > _664:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if _664 < s:
            revert with 0, 17
        _722 = mem[ceil32(return_data.size) + 96]
        staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                gas gas_remaining wei
               args address(arg1), Mask(128, 128, mem[ceil32(return_data.size) + 96])
        mem[mem[64] len 352] = ext_call.return_data[0 len 352]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _741 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 352
        _750 = mem[64]
        if mem[64] + 352 < mem[64] or mem[64] + 352 > test266151307():
            revert with 0, 65
        mem[64] = mem[64] + 352
        require mem[_741] == Mask(128, 128, mem[_741])
        mem[_750] = mem[_741]
        mem[_750 + 32] = mem[_741 + 32]
        mem[_750 + 64] = mem[_741 + 64]
        mem[_750 + 96] = mem[_741 + 96]
        require mem[_741 + 128] < 5
        mem[_750 + 128] = mem[_741 + 128]
        mem[_750 + 160] = mem[_741 + 160]
        mem[_750 + 192] = mem[_741 + 192]
        mem[_750 + 224] = mem[_741 + 224]
        mem[_750 + 256] = mem[_741 + 256]
        mem[_750 + 288] = mem[_741 + 288]
        mem[_750 + 320] = mem[_741 + 320]
        if Mask(128, 128, mem[_750]) != Mask(128, 128, _722):
            revert with 0, 'Address does not contain stake with provided id'
        idx = mem[_750 + 192]
        t = 0
        while idx < arg3:
            staticcall sub_413c05c6Address.0x8ce1d9e4 with:
                    gas gas_remaining wei
                   args idx
            mem[mem[64] len 160] = ext_call.return_data[0 len 160]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1240 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 160
            _1247 = mem[64]
            if mem[64] + 160 > test266151307() or mem[64] + 160 < mem[64]:
                revert with 0, 65
            mem[64] = mem[64] + 160
            mem[_1247] = mem[_1240]
            mem[_1247 + 32] = mem[_1240 + 32]
            mem[_1247 + 64] = mem[_1240 + 64]
            mem[_1247 + 96] = mem[_1240 + 96]
            mem[_1247 + 128] = mem[_1240 + 128]
            _1319 = mem[_1247 + 64]
            _1320 = mem[_1247 + 32]
            _1321 = mem[_750 + 64]
            _1322 = mem[_1247]
            _1323 = mem[_1247 + 128]
            _1324 = mem[_1247 + 96]
            if mem[_1247 + 96] > !mem[_1247 + 128]:
                revert with 0, 17
            if mem[_1247 + 96] + mem[_1247 + 128] < mem[_1247 + 96]:
                revert with 0, 'SafeMath: addition overflow'
            if not mem[_1247 + 96] + mem[_1247 + 128]:
                _1356 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1356] = 26
                mem[_1356 + 32] = 'SafeMath: division by zero'
                if not _1320:
                    _1366 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _1366 + 68] = mem[_1356 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1366 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _1366 + -mem[64] + 100
                _1384 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1384] = 26
                mem[_1384 + 32] = 'SafeMath: division by zero'
                if _1319:
                    if t > !(0 / _1320 / _1319):
                        revert with 0, 17
                    if t + (0 / _1320 / _1319) < t:
                        revert with 0, 'SafeMath: addition overflow'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    t = t + (0 / _1320 / _1319)
                    continue 
                _1399 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _1399 + 68] = mem[_1384 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_1399 + 94] = 0
                revert with memory
                  from mem[64]
                   len _1399 + -mem[64] + 100
            if mem[_1247 + 96] + mem[_1247 + 128] and mem[_1247] > -1 / mem[_1247 + 96] + mem[_1247 + 128]:
                revert with 0, 17
            if not mem[_1247 + 96] + mem[_1247 + 128]:
                revert with 0, 18
            if (mem[_1247 + 96] * mem[_1247]) + (mem[_1247 + 128] * mem[_1247]) / mem[_1247 + 96] + mem[_1247 + 128] != mem[_1247]:
                revert with 0, 'SafeMath: multiplication overflow'
            if not (mem[_1247 + 96] * mem[_1247]) + (mem[_1247 + 128] * mem[_1247]):
                _1375 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1375] = 26
                mem[_1375 + 32] = 'SafeMath: division by zero'
                if not _1320:
                    _1383 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _1383 + 68] = mem[_1375 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1383 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _1383 + -mem[64] + 100
                _1429 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1429] = 26
                mem[_1429 + 32] = 'SafeMath: division by zero'
                if _1319:
                    if t > !(0 / _1320 / _1319):
                        revert with 0, 17
                    if t + (0 / _1320 / _1319) < t:
                        revert with 0, 'SafeMath: addition overflow'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    t = t + (0 / _1320 / _1319)
                    continue 
                _1445 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _1445 + 68] = mem[_1429 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_1445 + 94] = 0
                revert with memory
                  from mem[64]
                   len _1445 + -mem[64] + 100
            if (mem[_1247 + 96] * mem[_1247]) + (mem[_1247 + 128] * mem[_1247]) and mem[_750 + 64] > -1 / (mem[_1247 + 96] * mem[_1247]) + (mem[_1247 + 128] * mem[_1247]):
                revert with 0, 17
            if not (mem[_1247 + 96] * mem[_1247]) + (mem[_1247 + 128] * mem[_1247]):
                revert with 0, 18
            if (mem[_1247 + 96] * mem[_1247] * mem[_750 + 64]) + (mem[_1247 + 128] * mem[_1247] * mem[_750 + 64]) / (mem[_1247 + 96] * mem[_1247]) + (mem[_1247 + 128] * mem[_1247]) != mem[_750 + 64]:
                revert with 0, 'SafeMath: multiplication overflow'
            _1416 = mem[64]
            mem[64] = mem[64] + 64
            mem[_1416] = 26
            mem[_1416 + 32] = 'SafeMath: division by zero'
            if not _1320:
                _1428 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _1428 + 68] = mem[_1416 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_1428 + 94] = 0
                revert with memory
                  from mem[64]
                   len _1428 + -mem[64] + 100
            _1472 = mem[64]
            mem[64] = mem[64] + 64
            mem[_1472] = 26
            mem[_1472 + 32] = 'SafeMath: division by zero'
            if _1319:
                if t > !((_1324 * _1322 * _1321) + (_1323 * _1322 * _1321) / _1320 / _1319):
                    revert with 0, 17
                if t + ((_1324 * _1322 * _1321) + (_1323 * _1322 * _1321) / _1320 / _1319) < t:
                    revert with 0, 'SafeMath: addition overflow'
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                t = t + ((_1324 * _1322 * _1321) + (_1323 * _1322 * _1321) / _1320 / _1319)
                continue 
            _1491 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _1491 + 68] = mem[_1472 + idx + 32]
                idx = idx + 32
                continue 
            mem[_1491 + 94] = 0
            revert with memory
              from mem[64]
               len _1491 + -mem[64] + 100
        if _664 - s > !t:
            revert with 0, 17
        if t < 0:
            revert with 0, 'SafeMath: addition overflow'
        mem[mem[64]] = mem[ceil32(return_data.size) + 128]
        return mem[mem[64]], _664 - s + t
    idx = mem[(2 * ceil32(return_data.size)) + 640]
    s = 0
    while idx < ext_call.return_data[192] + ext_call.return_data[224]:
        staticcall sub_413c05c6Address.0x8ce1d9e4 with:
                gas gas_remaining wei
               args idx
        mem[mem[64] len 160] = ext_call.return_data[0 len 160]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _659 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 160
        _672 = mem[64]
        if mem[64] + 160 > test266151307() or mem[64] + 160 < mem[64]:
            revert with 0, 65
        mem[64] = mem[64] + 160
        mem[_672] = mem[_659]
        mem[_672 + 32] = mem[_659 + 32]
        mem[_672 + 64] = mem[_659 + 64]
        mem[_672 + 96] = mem[_659 + 96]
        mem[_672 + 128] = mem[_659 + 128]
        _699 = mem[_672 + 64]
        _700 = mem[_672 + 32]
        _701 = mem[(2 * ceil32(return_data.size)) + 512]
        _702 = mem[_672]
        _703 = mem[_672 + 128]
        _704 = mem[_672 + 96]
        if mem[_672 + 96] > !mem[_672 + 128]:
            revert with 0, 17
        if mem[_672 + 96] + mem[_672 + 128] < mem[_672 + 96]:
            revert with 0, 'SafeMath: addition overflow'
        if not mem[_672 + 96] + mem[_672 + 128]:
            _772 = mem[64]
            mem[64] = mem[64] + 64
            mem[_772] = 26
            mem[_772 + 32] = 'SafeMath: division by zero'
            if not _700:
                _783 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _783 + 68] = mem[_772 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_783 + 94] = 0
                revert with memory
                  from mem[64]
                   len _783 + -mem[64] + 100
            _857 = mem[64]
            mem[64] = mem[64] + 64
            mem[_857] = 26
            mem[_857 + 32] = 'SafeMath: division by zero'
            if _699:
                if s > !(0 / _700 / _699):
                    revert with 0, 17
                if s + (0 / _700 / _699) < s:
                    revert with 0, 'SafeMath: addition overflow'
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + (0 / _700 / _699)
                continue 
            _873 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _873 + 68] = mem[_857 + idx + 32]
                idx = idx + 32
                continue 
            mem[_873 + 94] = 0
            revert with memory
              from mem[64]
               len _873 + -mem[64] + 100
        if mem[_672 + 96] + mem[_672 + 128] and mem[_672] > -1 / mem[_672 + 96] + mem[_672 + 128]:
            revert with 0, 17
        if not mem[_672 + 96] + mem[_672 + 128]:
            revert with 0, 18
        if (mem[_672 + 96] * mem[_672]) + (mem[_672 + 128] * mem[_672]) / mem[_672 + 96] + mem[_672 + 128] != mem[_672]:
            revert with 0, 'SafeMath: multiplication overflow'
        if not (mem[_672 + 96] * mem[_672]) + (mem[_672 + 128] * mem[_672]):
            _812 = mem[64]
            mem[64] = mem[64] + 64
            mem[_812] = 26
            mem[_812 + 32] = 'SafeMath: division by zero'
            if not _700:
                _856 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _856 + 68] = mem[_812 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_856 + 94] = 0
                revert with memory
                  from mem[64]
                   len _856 + -mem[64] + 100
            _911 = mem[64]
            mem[64] = mem[64] + 64
            mem[_911] = 26
            mem[_911 + 32] = 'SafeMath: division by zero'
            if _699:
                if s > !(0 / _700 / _699):
                    revert with 0, 17
                if s + (0 / _700 / _699) < s:
                    revert with 0, 'SafeMath: addition overflow'
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + (0 / _700 / _699)
                continue 
            _945 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _945 + 68] = mem[_911 + idx + 32]
                idx = idx + 32
                continue 
            mem[_945 + 94] = 0
            revert with memory
              from mem[64]
               len _945 + -mem[64] + 100
        if (mem[_672 + 96] * mem[_672]) + (mem[_672 + 128] * mem[_672]) and mem[(2 * ceil32(return_data.size)) + 512] > -1 / (mem[_672 + 96] * mem[_672]) + (mem[_672 + 128] * mem[_672]):
            revert with 0, 17
        if not (mem[_672 + 96] * mem[_672]) + (mem[_672 + 128] * mem[_672]):
            revert with 0, 18
        if (mem[_672 + 96] * mem[_672] * mem[(2 * ceil32(return_data.size)) + 512]) + (mem[_672 + 128] * mem[_672] * mem[(2 * ceil32(return_data.size)) + 512]) / (mem[_672 + 96] * mem[_672]) + (mem[_672 + 128] * mem[_672]) != mem[(2 * ceil32(return_data.size)) + 512]:
            revert with 0, 'SafeMath: multiplication overflow'
        _895 = mem[64]
        mem[64] = mem[64] + 64
        mem[_895] = 26
        mem[_895 + 32] = 'SafeMath: division by zero'
        if not _700:
            _910 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _910 + 68] = mem[_895 + idx + 32]
                idx = idx + 32
                continue 
            mem[_910 + 94] = 0
            revert with memory
              from mem[64]
               len _910 + -mem[64] + 100
        _971 = mem[64]
        mem[64] = mem[64] + 64
        mem[_971] = 26
        mem[_971 + 32] = 'SafeMath: division by zero'
        if _699:
            if s > !((_704 * _702 * _701) + (_703 * _702 * _701) / _700 / _699):
                revert with 0, 17
            if s + ((_704 * _702 * _701) + (_703 * _702 * _701) / _700 / _699) < s:
                revert with 0, 'SafeMath: addition overflow'
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s + ((_704 * _702 * _701) + (_703 * _702 * _701) / _700 / _699)
            continue 
        _991 = mem[64]
        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 32
        mem[mem[64] + 36] = 26
        idx = 0
        while idx < 26:
            mem[idx + _991 + 68] = mem[_971 + idx + 32]
            idx = idx + 32
            continue 
        mem[_991 + 94] = 0
        revert with memory
          from mem[64]
           len _991 + -mem[64] + 100
    if s >= mem[ceil32(return_data.size) + 256]:
        _665 = mem[ceil32(return_data.size) + 96]
        staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                gas gas_remaining wei
               args address(arg1), Mask(128, 128, mem[ceil32(return_data.size) + 96])
        mem[mem[64] len 352] = ext_call.return_data[0 len 352]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _712 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 352
        _719 = mem[64]
        if mem[64] + 352 < mem[64] or mem[64] + 352 > test266151307():
            revert with 0, 65
        mem[64] = mem[64] + 352
        require mem[_712] == Mask(128, 128, mem[_712])
        mem[_719] = mem[_712]
        mem[_719 + 32] = mem[_712 + 32]
        mem[_719 + 64] = mem[_712 + 64]
        mem[_719 + 96] = mem[_712 + 96]
        require mem[_712 + 128] < 5
        mem[_719 + 128] = mem[_712 + 128]
        mem[_719 + 160] = mem[_712 + 160]
        mem[_719 + 192] = mem[_712 + 192]
        mem[_719 + 224] = mem[_712 + 224]
        mem[_719 + 256] = mem[_712 + 256]
        mem[_719 + 288] = mem[_712 + 288]
        mem[_719 + 320] = mem[_712 + 320]
        if Mask(128, 128, mem[_719]) != Mask(128, 128, _665):
            revert with 0, 'Address does not contain stake with provided id'
        idx = mem[_719 + 192]
        s = 0
        while idx < ext_call.return_data[192] + ext_call.return_data[224]:
            staticcall sub_413c05c6Address.0x8ce1d9e4 with:
                    gas gas_remaining wei
                   args idx
            mem[mem[64] len 160] = ext_call.return_data[0 len 160]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1242 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 160
            _1256 = mem[64]
            if mem[64] + 160 > test266151307() or mem[64] + 160 < mem[64]:
                revert with 0, 65
            mem[64] = mem[64] + 160
            mem[_1256] = mem[_1242]
            mem[_1256 + 32] = mem[_1242 + 32]
            mem[_1256 + 64] = mem[_1242 + 64]
            mem[_1256 + 96] = mem[_1242 + 96]
            mem[_1256 + 128] = mem[_1242 + 128]
            _1325 = mem[_1256 + 64]
            _1326 = mem[_1256 + 32]
            _1327 = mem[_719 + 64]
            _1328 = mem[_1256]
            _1329 = mem[_1256 + 128]
            _1330 = mem[_1256 + 96]
            if mem[_1256 + 96] > !mem[_1256 + 128]:
                revert with 0, 17
            if mem[_1256 + 96] + mem[_1256 + 128] < mem[_1256 + 96]:
                revert with 0, 'SafeMath: addition overflow'
            if not mem[_1256 + 96] + mem[_1256 + 128]:
                _1358 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1358] = 26
                mem[_1358 + 32] = 'SafeMath: division by zero'
                if not _1326:
                    _1367 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _1367 + 68] = mem[_1358 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1367 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _1367 + -mem[64] + 100
                _1386 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1386] = 26
                mem[_1386 + 32] = 'SafeMath: division by zero'
                if _1325:
                    if s > !(0 / _1326 / _1325):
                        revert with 0, 17
                    if s + (0 / _1326 / _1325) < s:
                        revert with 0, 'SafeMath: addition overflow'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + (0 / _1326 / _1325)
                    continue 
                _1403 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _1403 + 68] = mem[_1386 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_1403 + 94] = 0
                revert with memory
                  from mem[64]
                   len _1403 + -mem[64] + 100
            if mem[_1256 + 96] + mem[_1256 + 128] and mem[_1256] > -1 / mem[_1256 + 96] + mem[_1256 + 128]:
                revert with 0, 17
            if not mem[_1256 + 96] + mem[_1256 + 128]:
                revert with 0, 18
            if (mem[_1256 + 96] * mem[_1256]) + (mem[_1256 + 128] * mem[_1256]) / mem[_1256 + 96] + mem[_1256 + 128] != mem[_1256]:
                revert with 0, 'SafeMath: multiplication overflow'
            if not (mem[_1256 + 96] * mem[_1256]) + (mem[_1256 + 128] * mem[_1256]):
                _1377 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1377] = 26
                mem[_1377 + 32] = 'SafeMath: division by zero'
                if not _1326:
                    _1385 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _1385 + 68] = mem[_1377 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1385 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _1385 + -mem[64] + 100
                _1432 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1432] = 26
                mem[_1432 + 32] = 'SafeMath: division by zero'
                if _1325:
                    if s > !(0 / _1326 / _1325):
                        revert with 0, 17
                    if s + (0 / _1326 / _1325) < s:
                        revert with 0, 'SafeMath: addition overflow'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + (0 / _1326 / _1325)
                    continue 
                _1448 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _1448 + 68] = mem[_1432 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_1448 + 94] = 0
                revert with memory
                  from mem[64]
                   len _1448 + -mem[64] + 100
            if (mem[_1256 + 96] * mem[_1256]) + (mem[_1256 + 128] * mem[_1256]) and mem[_719 + 64] > -1 / (mem[_1256 + 96] * mem[_1256]) + (mem[_1256 + 128] * mem[_1256]):
                revert with 0, 17
            if not (mem[_1256 + 96] * mem[_1256]) + (mem[_1256 + 128] * mem[_1256]):
                revert with 0, 18
            if (mem[_1256 + 96] * mem[_1256] * mem[_719 + 64]) + (mem[_1256 + 128] * mem[_1256] * mem[_719 + 64]) / (mem[_1256 + 96] * mem[_1256]) + (mem[_1256 + 128] * mem[_1256]) != mem[_719 + 64]:
                revert with 0, 'SafeMath: multiplication overflow'
            _1419 = mem[64]
            mem[64] = mem[64] + 64
            mem[_1419] = 26
            mem[_1419 + 32] = 'SafeMath: division by zero'
            if not _1326:
                _1431 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _1431 + 68] = mem[_1419 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_1431 + 94] = 0
                revert with memory
                  from mem[64]
                   len _1431 + -mem[64] + 100
            _1475 = mem[64]
            mem[64] = mem[64] + 64
            mem[_1475] = 26
            mem[_1475 + 32] = 'SafeMath: division by zero'
            if _1325:
                if s > !((_1330 * _1328 * _1327) + (_1329 * _1328 * _1327) / _1326 / _1325):
                    revert with 0, 17
                if s + ((_1330 * _1328 * _1327) + (_1329 * _1328 * _1327) / _1326 / _1325) < s:
                    revert with 0, 'SafeMath: addition overflow'
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + ((_1330 * _1328 * _1327) + (_1329 * _1328 * _1327) / _1326 / _1325)
                continue 
            _1493 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _1493 + 68] = mem[_1475 + idx + 32]
                idx = idx + 32
                continue 
            mem[_1493 + 94] = 0
            revert with memory
              from mem[64]
               len _1493 + -mem[64] + 100
        mem[mem[64]] = mem[ceil32(return_data.size) + 128]
        return mem[mem[64]], s
    _666 = mem[ceil32(return_data.size) + 256]
    _671 = mem[64]
    mem[64] = mem[64] + 64
    mem[_671] = 30
    mem[_671 + 32] = 'SafeMath: subtraction overflow'
    if s > _666:
        revert with 0, 'SafeMath: subtraction overflow', 0
    if _666 < s:
        revert with 0, 17
    _724 = mem[ceil32(return_data.size) + 96]
    staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
            gas gas_remaining wei
           args address(arg1), Mask(128, 128, mem[ceil32(return_data.size) + 96])
    mem[mem[64] len 352] = ext_call.return_data[0 len 352]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _742 = mem[64]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 352
    _752 = mem[64]
    if mem[64] + 352 < mem[64] or mem[64] + 352 > test266151307():
        revert with 0, 65
    mem[64] = mem[64] + 352
    require mem[_742] == Mask(128, 128, mem[_742])
    mem[_752] = mem[_742]
    mem[_752 + 32] = mem[_742 + 32]
    mem[_752 + 64] = mem[_742 + 64]
    mem[_752 + 96] = mem[_742 + 96]
    require mem[_742 + 128] < 5
    mem[_752 + 128] = mem[_742 + 128]
    mem[_752 + 160] = mem[_742 + 160]
    mem[_752 + 192] = mem[_742 + 192]
    mem[_752 + 224] = mem[_742 + 224]
    mem[_752 + 256] = mem[_742 + 256]
    mem[_752 + 288] = mem[_742 + 288]
    mem[_752 + 320] = mem[_742 + 320]
    if Mask(128, 128, mem[_752]) != Mask(128, 128, _724):
        revert with 0, 'Address does not contain stake with provided id'
    idx = mem[_752 + 192]
    t = 0
    while idx < ext_call.return_data[192] + ext_call.return_data[224]:
        staticcall sub_413c05c6Address.0x8ce1d9e4 with:
                gas gas_remaining wei
               args idx
        mem[mem[64] len 160] = ext_call.return_data[0 len 160]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _1244 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 160
        _1257 = mem[64]
        if mem[64] + 160 > test266151307() or mem[64] + 160 < mem[64]:
            revert with 0, 65
        mem[64] = mem[64] + 160
        mem[_1257] = mem[_1244]
        mem[_1257 + 32] = mem[_1244 + 32]
        mem[_1257 + 64] = mem[_1244 + 64]
        mem[_1257 + 96] = mem[_1244 + 96]
        mem[_1257 + 128] = mem[_1244 + 128]
        _1331 = mem[_1257 + 64]
        _1332 = mem[_1257 + 32]
        _1333 = mem[_752 + 64]
        _1334 = mem[_1257]
        _1335 = mem[_1257 + 128]
        _1336 = mem[_1257 + 96]
        if mem[_1257 + 96] > !mem[_1257 + 128]:
            revert with 0, 17
        if mem[_1257 + 96] + mem[_1257 + 128] < mem[_1257 + 96]:
            revert with 0, 'SafeMath: addition overflow'
        if not mem[_1257 + 96] + mem[_1257 + 128]:
            _1360 = mem[64]
            mem[64] = mem[64] + 64
            mem[_1360] = 26
            mem[_1360 + 32] = 'SafeMath: division by zero'
            if not _1332:
                _1368 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _1368 + 68] = mem[_1360 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_1368 + 94] = 0
                revert with memory
                  from mem[64]
                   len _1368 + -mem[64] + 100
            _1388 = mem[64]
            mem[64] = mem[64] + 64
            mem[_1388] = 26
            mem[_1388 + 32] = 'SafeMath: division by zero'
            if _1331:
                if t > !(0 / _1332 / _1331):
                    revert with 0, 17
                if t + (0 / _1332 / _1331) < t:
                    revert with 0, 'SafeMath: addition overflow'
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                t = t + (0 / _1332 / _1331)
                continue 
            _1407 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _1407 + 68] = mem[_1388 + idx + 32]
                idx = idx + 32
                continue 
            mem[_1407 + 94] = 0
            revert with memory
              from mem[64]
               len _1407 + -mem[64] + 100
        if mem[_1257 + 96] + mem[_1257 + 128] and mem[_1257] > -1 / mem[_1257 + 96] + mem[_1257 + 128]:
            revert with 0, 17
        if not mem[_1257 + 96] + mem[_1257 + 128]:
            revert with 0, 18
        if (mem[_1257 + 96] * mem[_1257]) + (mem[_1257 + 128] * mem[_1257]) / mem[_1257 + 96] + mem[_1257 + 128] != mem[_1257]:
            revert with 0, 'SafeMath: multiplication overflow'
        if not (mem[_1257 + 96] * mem[_1257]) + (mem[_1257 + 128] * mem[_1257]):
            _1379 = mem[64]
            mem[64] = mem[64] + 64
            mem[_1379] = 26
            mem[_1379 + 32] = 'SafeMath: division by zero'
            if not _1332:
                _1387 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _1387 + 68] = mem[_1379 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_1387 + 94] = 0
                revert with memory
                  from mem[64]
                   len _1387 + -mem[64] + 100
            _1435 = mem[64]
            mem[64] = mem[64] + 64
            mem[_1435] = 26
            mem[_1435 + 32] = 'SafeMath: division by zero'
            if _1331:
                if t > !(0 / _1332 / _1331):
                    revert with 0, 17
                if t + (0 / _1332 / _1331) < t:
                    revert with 0, 'SafeMath: addition overflow'
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                t = t + (0 / _1332 / _1331)
                continue 
            _1451 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _1451 + 68] = mem[_1435 + idx + 32]
                idx = idx + 32
                continue 
            mem[_1451 + 94] = 0
            revert with memory
              from mem[64]
               len _1451 + -mem[64] + 100
        if (mem[_1257 + 96] * mem[_1257]) + (mem[_1257 + 128] * mem[_1257]) and mem[_752 + 64] > -1 / (mem[_1257 + 96] * mem[_1257]) + (mem[_1257 + 128] * mem[_1257]):
            revert with 0, 17
        if not (mem[_1257 + 96] * mem[_1257]) + (mem[_1257 + 128] * mem[_1257]):
            revert with 0, 18
        if (mem[_1257 + 96] * mem[_1257] * mem[_752 + 64]) + (mem[_1257 + 128] * mem[_1257] * mem[_752 + 64]) / (mem[_1257 + 96] * mem[_1257]) + (mem[_1257 + 128] * mem[_1257]) != mem[_752 + 64]:
            revert with 0, 'SafeMath: multiplication overflow'
        _1422 = mem[64]
        mem[64] = mem[64] + 64
        mem[_1422] = 26
        mem[_1422 + 32] = 'SafeMath: division by zero'
        if not _1332:
            _1434 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _1434 + 68] = mem[_1422 + idx + 32]
                idx = idx + 32
                continue 
            mem[_1434 + 94] = 0
            revert with memory
              from mem[64]
               len _1434 + -mem[64] + 100
        _1478 = mem[64]
        mem[64] = mem[64] + 64
        mem[_1478] = 26
        mem[_1478 + 32] = 'SafeMath: division by zero'
        if _1331:
            if t > !((_1336 * _1334 * _1333) + (_1335 * _1334 * _1333) / _1332 / _1331):
                revert with 0, 17
            if t + ((_1336 * _1334 * _1333) + (_1335 * _1334 * _1333) / _1332 / _1331) < t:
                revert with 0, 'SafeMath: addition overflow'
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            t = t + ((_1336 * _1334 * _1333) + (_1335 * _1334 * _1333) / _1332 / _1331)
            continue 
        _1495 = mem[64]
        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 32
        mem[mem[64] + 36] = 26
        idx = 0
        while idx < 26:
            mem[idx + _1495 + 68] = mem[_1478 + idx + 32]
            idx = idx + 32
            continue 
        mem[_1495 + 94] = 0
        revert with memory
          from mem[64]
           len _1495 + -mem[64] + 100
    if _666 - s > !t:
        revert with 0, 17
    if t < 0:
        revert with 0, 'SafeMath: addition overflow'
    mem[mem[64]] = mem[ceil32(return_data.size) + 128]
    return mem[mem[64]], _666 - s + t
}

function sub_db45a4ec(?) {
    require calldata.size - 4 >= 128
    require arg1 == address(arg1)
    require arg2 == Mask(128, 128, arg2)
    mem[96] = 0
    mem[128] = 0
    mem[160] = 0
    mem[192] = 0
    mem[224] = 0
    mem[256] = 0
    mem[288] = 0
    mem[320] = 0
    mem[352] = 0
    mem[384] = 0
    mem[416] = 0
    staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
            gas gas_remaining wei
           args address(arg1), Mask(128, 128, arg2)
    mem[448 len 352] = ext_call.return_data[0 len 352]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 352
    if not bool(ceil32(return_data.size) + 800 <= test266151307()):
        revert with 0, 65
    require ext_call.return_data[0] == Mask(128, 128, ext_call.return_data[0])
    mem[ceil32(return_data.size) + 448] = ext_call.return_data[0]
    mem[ceil32(return_data.size) + 480] = ext_call.return_data[32]
    mem[ceil32(return_data.size) + 512] = ext_call.return_data[64]
    mem[ceil32(return_data.size) + 544] = ext_call.return_data[96]
    require ext_call.return_data[128] < 5
    mem[ceil32(return_data.size) + 576] = ext_call.return_data[128]
    mem[ceil32(return_data.size) + 608] = ext_call.return_data[160]
    mem[ceil32(return_data.size) + 640] = ext_call.return_data[192]
    mem[ceil32(return_data.size) + 672] = ext_call.return_data[224]
    mem[ceil32(return_data.size) + 704] = ext_call.return_data[256]
    mem[ceil32(return_data.size) + 736] = ext_call.return_data[288]
    mem[ceil32(return_data.size) + 768] = ext_call.return_data[320]
    if Mask(128, 128, ext_call.return_data[0]) != Mask(128, 128, arg2):
        return 0
    mem[0] = Mask(128, 128, arg2)
    mem[32] = sha3(address(arg1), 9)
    if stor9[address(arg1)][Mask(128, 128, arg2)]:
        return 0
    if ext_call.return_data[128] > 4:
        revert with 0, 33
    if ext_call.return_data[128] != 2:
        return 0
    if ext_call.return_data[192] >= arg3:
        return 0
    if ext_call.return_data[192] > !ext_call.return_data[224]:
        revert with 0, 17
    if ext_call.return_data[192] + ext_call.return_data[224] < arg3:
        return 0
    mem[ceil32(return_data.size) + 800] = 17
    mem[ceil32(return_data.size) + 832] = 'Stake is eligible' << 120
    staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
            gas gas_remaining wei
           args address(arg1), Mask(128, 128, arg2)
    mem[ceil32(return_data.size) + 864 len 352] = ext_call.return_data[0 len 352]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 352
    if not bool((2 * ceil32(return_data.size)) + 1216 <= test266151307()):
        revert with 0, 65
    require ext_call.return_data[0] == Mask(128, 128, ext_call.return_data[0])
    mem[(2 * ceil32(return_data.size)) + 864] = ext_call.return_data[0]
    mem[(2 * ceil32(return_data.size)) + 896] = ext_call.return_data[32]
    mem[(2 * ceil32(return_data.size)) + 928] = ext_call.return_data[64]
    mem[(2 * ceil32(return_data.size)) + 960] = ext_call.return_data[96]
    require ext_call.return_data[128] < 5
    mem[(2 * ceil32(return_data.size)) + 992] = ext_call.return_data[128]
    mem[(2 * ceil32(return_data.size)) + 1024] = ext_call.return_data[160]
    mem[(2 * ceil32(return_data.size)) + 1056] = ext_call.return_data[192]
    mem[(2 * ceil32(return_data.size)) + 1088] = ext_call.return_data[224]
    mem[(2 * ceil32(return_data.size)) + 1120] = ext_call.return_data[256]
    mem[(2 * ceil32(return_data.size)) + 1152] = ext_call.return_data[288]
    mem[(2 * ceil32(return_data.size)) + 1184] = ext_call.return_data[320]
    if Mask(128, 128, ext_call.return_data[0]) != Mask(128, 128, arg2):
        revert with 0, 'Address does not contain stake with provided id'
    if ext_call.return_data[128] > 4:
        revert with 0, 33
    if ext_call.return_data[128] == 3:
        return 0
    if ext_call.return_data[128] > 4:
        revert with 0, 33
    if ext_call.return_data[128] == 4:
        return 0
    if ext_call.return_data[128] > 4:
        revert with 0, 33
    if ext_call.return_data[128] == 1:
        return 0
    if ext_call.return_data[128] > 4:
        revert with 0, 33
    if not ext_call.return_data[128]:
        staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                gas gas_remaining wei
               args address(arg1), Mask(128, 128, ext_call.return_data[0])
        mem[(2 * ceil32(return_data.size)) + 1216 len 352] = ext_call.return_data[0 len 352]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 352
        if not bool((4 * ceil32(return_data.size)) + 1568 <= test266151307()):
            revert with 0, 65
        mem[64] = (4 * ceil32(return_data.size)) + 1568
        require ext_call.return_data[0] == Mask(128, 128, ext_call.return_data[0])
        mem[(4 * ceil32(return_data.size)) + 1216] = ext_call.return_data[0]
        mem[(4 * ceil32(return_data.size)) + 1248] = ext_call.return_data[32]
        mem[(4 * ceil32(return_data.size)) + 1280] = ext_call.return_data[64]
        mem[(4 * ceil32(return_data.size)) + 1312] = ext_call.return_data[96]
        require ext_call.return_data[128] < 5
        mem[(4 * ceil32(return_data.size)) + 1344] = ext_call.return_data[128]
        mem[(4 * ceil32(return_data.size)) + 1376] = ext_call.return_data[160]
        mem[(4 * ceil32(return_data.size)) + 1408] = ext_call.return_data[192]
        mem[(4 * ceil32(return_data.size)) + 1440] = ext_call.return_data[224]
        mem[(4 * ceil32(return_data.size)) + 1472] = ext_call.return_data[256]
        mem[(4 * ceil32(return_data.size)) + 1504] = ext_call.return_data[288]
        mem[(4 * ceil32(return_data.size)) + 1536] = ext_call.return_data[320]
        if Mask(128, 128, ext_call.return_data[0]) != Mask(128, 128, ext_call.return_data[0]):
            revert with 0, 'Address does not contain stake with provided id'
        idx = mem[(4 * ceil32(return_data.size)) + 1408]
        s = 0
        while idx < arg4:
            staticcall sub_413c05c6Address.0x8ce1d9e4 with:
                    gas gas_remaining wei
                   args idx
            mem[mem[64] len 160] = ext_call.return_data[0 len 160]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _701 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 160
            _712 = mem[64]
            if mem[64] + 160 > test266151307() or mem[64] + 160 < mem[64]:
                revert with 0, 65
            mem[64] = mem[64] + 160
            mem[_712] = mem[_701]
            mem[_712 + 32] = mem[_701 + 32]
            mem[_712 + 64] = mem[_701 + 64]
            mem[_712 + 96] = mem[_701 + 96]
            mem[_712 + 128] = mem[_701 + 128]
            _744 = mem[_712 + 64]
            _745 = mem[_712 + 32]
            _746 = mem[(4 * ceil32(return_data.size)) + 1280]
            _747 = mem[_712]
            _748 = mem[_712 + 128]
            _749 = mem[_712 + 96]
            if mem[_712 + 96] > !mem[_712 + 128]:
                revert with 0, 17
            if mem[_712 + 96] + mem[_712 + 128] < mem[_712 + 96]:
                revert with 0, 'SafeMath: addition overflow'
            if not mem[_712 + 96] + mem[_712 + 128]:
                _813 = mem[64]
                mem[64] = mem[64] + 64
                mem[_813] = 26
                mem[_813 + 32] = 'SafeMath: division by zero'
                if not _745:
                    _823 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _823 + 68] = mem[_813 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_823 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _823 + -mem[64] + 100
                _896 = mem[64]
                mem[64] = mem[64] + 64
                mem[_896] = 26
                mem[_896 + 32] = 'SafeMath: division by zero'
                if _744:
                    if s > !(0 / _745 / _744):
                        revert with 0, 17
                    if s + (0 / _745 / _744) < s:
                        revert with 0, 'SafeMath: addition overflow'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + (0 / _745 / _744)
                    continue 
                _916 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _916 + 68] = mem[_896 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_916 + 94] = 0
                revert with memory
                  from mem[64]
                   len _916 + -mem[64] + 100
            if mem[_712 + 96] + mem[_712 + 128] and mem[_712] > -1 / mem[_712 + 96] + mem[_712 + 128]:
                revert with 0, 17
            if not mem[_712 + 96] + mem[_712 + 128]:
                revert with 0, 18
            if (mem[_712 + 96] * mem[_712]) + (mem[_712 + 128] * mem[_712]) / mem[_712 + 96] + mem[_712 + 128] != mem[_712]:
                revert with 0, 'SafeMath: multiplication overflow'
            if not (mem[_712 + 96] * mem[_712]) + (mem[_712 + 128] * mem[_712]):
                _851 = mem[64]
                mem[64] = mem[64] + 64
                mem[_851] = 26
                mem[_851 + 32] = 'SafeMath: division by zero'
                if not _745:
                    _895 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _895 + 68] = mem[_851 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_895 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _895 + -mem[64] + 100
                _953 = mem[64]
                mem[64] = mem[64] + 64
                mem[_953] = 26
                mem[_953 + 32] = 'SafeMath: division by zero'
                if _744:
                    if s > !(0 / _745 / _744):
                        revert with 0, 17
                    if s + (0 / _745 / _744) < s:
                        revert with 0, 'SafeMath: addition overflow'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + (0 / _745 / _744)
                    continue 
                _987 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _987 + 68] = mem[_953 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_987 + 94] = 0
                revert with memory
                  from mem[64]
                   len _987 + -mem[64] + 100
            if (mem[_712 + 96] * mem[_712]) + (mem[_712 + 128] * mem[_712]) and mem[(4 * ceil32(return_data.size)) + 1280] > -1 / (mem[_712 + 96] * mem[_712]) + (mem[_712 + 128] * mem[_712]):
                revert with 0, 17
            if not (mem[_712 + 96] * mem[_712]) + (mem[_712 + 128] * mem[_712]):
                revert with 0, 18
            if (mem[_712 + 96] * mem[_712] * mem[(4 * ceil32(return_data.size)) + 1280]) + (mem[_712 + 128] * mem[_712] * mem[(4 * ceil32(return_data.size)) + 1280]) / (mem[_712 + 96] * mem[_712]) + (mem[_712 + 128] * mem[_712]) != mem[(4 * ceil32(return_data.size)) + 1280]:
                revert with 0, 'SafeMath: multiplication overflow'
            _937 = mem[64]
            mem[64] = mem[64] + 64
            mem[_937] = 26
            mem[_937 + 32] = 'SafeMath: division by zero'
            if not _745:
                _952 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _952 + 68] = mem[_937 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_952 + 94] = 0
                revert with memory
                  from mem[64]
                   len _952 + -mem[64] + 100
            _1011 = mem[64]
            mem[64] = mem[64] + 64
            mem[_1011] = 26
            mem[_1011 + 32] = 'SafeMath: division by zero'
            if _744:
                if s > !((_749 * _747 * _746) + (_748 * _747 * _746) / _745 / _744):
                    revert with 0, 17
                if s + ((_749 * _747 * _746) + (_748 * _747 * _746) / _745 / _744) < s:
                    revert with 0, 'SafeMath: addition overflow'
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + ((_749 * _747 * _746) + (_748 * _747 * _746) / _745 / _744)
                continue 
            _1030 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _1030 + 68] = mem[_1011 + idx + 32]
                idx = idx + 32
                continue 
            mem[_1030 + 94] = 0
            revert with memory
              from mem[64]
               len _1030 + -mem[64] + 100
        _700 = mem[(2 * ceil32(return_data.size)) + 1024]
        if mem[(2 * ceil32(return_data.size)) + 1024] > !s:
            revert with 0, 17
        if mem[(2 * ceil32(return_data.size)) + 1024] + s < mem[(2 * ceil32(return_data.size)) + 1024]:
            revert with 0, 'SafeMath: addition overflow'
        mem[mem[64]] = mem[(2 * ceil32(return_data.size)) + 896]
        return mem[mem[64]], _700 + s
    if ext_call.return_data[192] > !ext_call.return_data[224]:
        revert with 0, 17
    staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
            gas gas_remaining wei
           args address(arg1), Mask(128, 128, ext_call.return_data[0])
    mem[(2 * ceil32(return_data.size)) + 1216 len 352] = ext_call.return_data[0 len 352]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 352
    if not bool((4 * ceil32(return_data.size)) + 1568 <= test266151307()):
        revert with 0, 65
    mem[64] = (4 * ceil32(return_data.size)) + 1568
    require ext_call.return_data[0] == Mask(128, 128, ext_call.return_data[0])
    mem[(4 * ceil32(return_data.size)) + 1216] = ext_call.return_data[0]
    mem[(4 * ceil32(return_data.size)) + 1248] = ext_call.return_data[32]
    mem[(4 * ceil32(return_data.size)) + 1280] = ext_call.return_data[64]
    mem[(4 * ceil32(return_data.size)) + 1312] = ext_call.return_data[96]
    require ext_call.return_data[128] < 5
    mem[(4 * ceil32(return_data.size)) + 1344] = ext_call.return_data[128]
    mem[(4 * ceil32(return_data.size)) + 1376] = ext_call.return_data[160]
    mem[(4 * ceil32(return_data.size)) + 1408] = ext_call.return_data[192]
    mem[(4 * ceil32(return_data.size)) + 1440] = ext_call.return_data[224]
    mem[(4 * ceil32(return_data.size)) + 1472] = ext_call.return_data[256]
    mem[(4 * ceil32(return_data.size)) + 1504] = ext_call.return_data[288]
    mem[(4 * ceil32(return_data.size)) + 1536] = ext_call.return_data[320]
    if Mask(128, 128, ext_call.return_data[0]) != Mask(128, 128, ext_call.return_data[0]):
        revert with 0, 'Address does not contain stake with provided id'
    if arg4 < ext_call.return_data[192] + ext_call.return_data[224]:
        idx = mem[(4 * ceil32(return_data.size)) + 1408]
        s = 0
        while idx < ext_call.return_data[192] + ext_call.return_data[224]:
            staticcall sub_413c05c6Address.0x8ce1d9e4 with:
                    gas gas_remaining wei
                   args idx
            mem[mem[64] len 160] = ext_call.return_data[0 len 160]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _696 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 160
            _708 = mem[64]
            if mem[64] + 160 > test266151307() or mem[64] + 160 < mem[64]:
                revert with 0, 65
            mem[64] = mem[64] + 160
            mem[_708] = mem[_696]
            mem[_708 + 32] = mem[_696 + 32]
            mem[_708 + 64] = mem[_696 + 64]
            mem[_708 + 96] = mem[_696 + 96]
            mem[_708 + 128] = mem[_696 + 128]
            _730 = mem[_708 + 64]
            _731 = mem[_708 + 32]
            _732 = mem[(4 * ceil32(return_data.size)) + 1280]
            _733 = mem[_708]
            _734 = mem[_708 + 128]
            _735 = mem[_708 + 96]
            if mem[_708 + 96] > !mem[_708 + 128]:
                revert with 0, 17
            if mem[_708 + 96] + mem[_708 + 128] < mem[_708 + 96]:
                revert with 0, 'SafeMath: addition overflow'
            if not mem[_708 + 96] + mem[_708 + 128]:
                _807 = mem[64]
                mem[64] = mem[64] + 64
                mem[_807] = 26
                mem[_807 + 32] = 'SafeMath: division by zero'
                if not _731:
                    _821 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _821 + 68] = mem[_807 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_821 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _821 + -mem[64] + 100
                _884 = mem[64]
                mem[64] = mem[64] + 64
                mem[_884] = 26
                mem[_884 + 32] = 'SafeMath: division by zero'
                if _730:
                    if s > !(0 / _731 / _730):
                        revert with 0, 17
                    if s + (0 / _731 / _730) < s:
                        revert with 0, 'SafeMath: addition overflow'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + (0 / _731 / _730)
                    continue 
                _908 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _908 + 68] = mem[_884 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_908 + 94] = 0
                revert with memory
                  from mem[64]
                   len _908 + -mem[64] + 100
            if mem[_708 + 96] + mem[_708 + 128] and mem[_708] > -1 / mem[_708 + 96] + mem[_708 + 128]:
                revert with 0, 17
            if not mem[_708 + 96] + mem[_708 + 128]:
                revert with 0, 18
            if (mem[_708 + 96] * mem[_708]) + (mem[_708 + 128] * mem[_708]) / mem[_708 + 96] + mem[_708 + 128] != mem[_708]:
                revert with 0, 'SafeMath: multiplication overflow'
            if not (mem[_708 + 96] * mem[_708]) + (mem[_708 + 128] * mem[_708]):
                _846 = mem[64]
                mem[64] = mem[64] + 64
                mem[_846] = 26
                mem[_846 + 32] = 'SafeMath: division by zero'
                if not _731:
                    _883 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _883 + 68] = mem[_846 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_883 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _883 + -mem[64] + 100
                _945 = mem[64]
                mem[64] = mem[64] + 64
                mem[_945] = 26
                mem[_945 + 32] = 'SafeMath: division by zero'
                if _730:
                    if s > !(0 / _731 / _730):
                        revert with 0, 17
                    if s + (0 / _731 / _730) < s:
                        revert with 0, 'SafeMath: addition overflow'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + (0 / _731 / _730)
                    continue 
                _975 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _975 + 68] = mem[_945 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_975 + 94] = 0
                revert with memory
                  from mem[64]
                   len _975 + -mem[64] + 100
            if (mem[_708 + 96] * mem[_708]) + (mem[_708 + 128] * mem[_708]) and mem[(4 * ceil32(return_data.size)) + 1280] > -1 / (mem[_708 + 96] * mem[_708]) + (mem[_708 + 128] * mem[_708]):
                revert with 0, 17
            if not (mem[_708 + 96] * mem[_708]) + (mem[_708 + 128] * mem[_708]):
                revert with 0, 18
            if (mem[_708 + 96] * mem[_708] * mem[(4 * ceil32(return_data.size)) + 1280]) + (mem[_708 + 128] * mem[_708] * mem[(4 * ceil32(return_data.size)) + 1280]) / (mem[_708 + 96] * mem[_708]) + (mem[_708 + 128] * mem[_708]) != mem[(4 * ceil32(return_data.size)) + 1280]:
                revert with 0, 'SafeMath: multiplication overflow'
            _929 = mem[64]
            mem[64] = mem[64] + 64
            mem[_929] = 26
            mem[_929 + 32] = 'SafeMath: division by zero'
            if not _731:
                _944 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _944 + 68] = mem[_929 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_944 + 94] = 0
                revert with memory
                  from mem[64]
                   len _944 + -mem[64] + 100
            _1005 = mem[64]
            mem[64] = mem[64] + 64
            mem[_1005] = 26
            mem[_1005 + 32] = 'SafeMath: division by zero'
            if _730:
                if s > !((_735 * _733 * _732) + (_734 * _733 * _732) / _731 / _730):
                    revert with 0, 17
                if s + ((_735 * _733 * _732) + (_734 * _733 * _732) / _731 / _730) < s:
                    revert with 0, 'SafeMath: addition overflow'
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + ((_735 * _733 * _732) + (_734 * _733 * _732) / _731 / _730)
                continue 
            _1024 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _1024 + 68] = mem[_1005 + idx + 32]
                idx = idx + 32
                continue 
            mem[_1024 + 94] = 0
            revert with memory
              from mem[64]
               len _1024 + -mem[64] + 100
        if s >= mem[(2 * ceil32(return_data.size)) + 1024]:
            _702 = mem[(2 * ceil32(return_data.size)) + 864]
            staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                    gas gas_remaining wei
                   args address(arg1), Mask(128, 128, mem[(2 * ceil32(return_data.size)) + 864])
            mem[mem[64] len 352] = ext_call.return_data[0 len 352]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _750 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 352
            _756 = mem[64]
            if mem[64] + 352 < mem[64] or mem[64] + 352 > test266151307():
                revert with 0, 65
            mem[64] = mem[64] + 352
            require mem[_750] == Mask(128, 128, mem[_750])
            mem[_756] = mem[_750]
            mem[_756 + 32] = mem[_750 + 32]
            mem[_756 + 64] = mem[_750 + 64]
            mem[_756 + 96] = mem[_750 + 96]
            require mem[_750 + 128] < 5
            mem[_756 + 128] = mem[_750 + 128]
            mem[_756 + 160] = mem[_750 + 160]
            mem[_756 + 192] = mem[_750 + 192]
            mem[_756 + 224] = mem[_750 + 224]
            mem[_756 + 256] = mem[_750 + 256]
            mem[_756 + 288] = mem[_750 + 288]
            mem[_756 + 320] = mem[_750 + 320]
            if Mask(128, 128, mem[_756]) != Mask(128, 128, _702):
                revert with 0, 'Address does not contain stake with provided id'
            idx = mem[_756 + 192]
            s = 0
            while idx < arg4:
                staticcall sub_413c05c6Address.0x8ce1d9e4 with:
                        gas gas_remaining wei
                       args idx
                mem[mem[64] len 160] = ext_call.return_data[0 len 160]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1277 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 160
                _1284 = mem[64]
                if mem[64] + 160 > test266151307() or mem[64] + 160 < mem[64]:
                    revert with 0, 65
                mem[64] = mem[64] + 160
                mem[_1284] = mem[_1277]
                mem[_1284 + 32] = mem[_1277 + 32]
                mem[_1284 + 64] = mem[_1277 + 64]
                mem[_1284 + 96] = mem[_1277 + 96]
                mem[_1284 + 128] = mem[_1277 + 128]
                _1349 = mem[_1284 + 64]
                _1350 = mem[_1284 + 32]
                _1351 = mem[_756 + 64]
                _1352 = mem[_1284]
                _1353 = mem[_1284 + 128]
                _1354 = mem[_1284 + 96]
                if mem[_1284 + 96] > !mem[_1284 + 128]:
                    revert with 0, 17
                if mem[_1284 + 96] + mem[_1284 + 128] < mem[_1284 + 96]:
                    revert with 0, 'SafeMath: addition overflow'
                if not mem[_1284 + 96] + mem[_1284 + 128]:
                    _1393 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1393] = 26
                    mem[_1393 + 32] = 'SafeMath: division by zero'
                    if not _1350:
                        _1404 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _1404 + 68] = mem[_1393 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1404 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1404 + -mem[64] + 100
                    _1421 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1421] = 26
                    mem[_1421 + 32] = 'SafeMath: division by zero'
                    if _1349:
                        if s > !(0 / _1350 / _1349):
                            revert with 0, 17
                        if s + (0 / _1350 / _1349) < s:
                            revert with 0, 'SafeMath: addition overflow'
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + (0 / _1350 / _1349)
                        continue 
                    _1434 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _1434 + 68] = mem[_1421 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1434 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _1434 + -mem[64] + 100
                if mem[_1284 + 96] + mem[_1284 + 128] and mem[_1284] > -1 / mem[_1284 + 96] + mem[_1284 + 128]:
                    revert with 0, 17
                if not mem[_1284 + 96] + mem[_1284 + 128]:
                    revert with 0, 18
                if (mem[_1284 + 96] * mem[_1284]) + (mem[_1284 + 128] * mem[_1284]) / mem[_1284 + 96] + mem[_1284 + 128] != mem[_1284]:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not (mem[_1284 + 96] * mem[_1284]) + (mem[_1284 + 128] * mem[_1284]):
                    _1412 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1412] = 26
                    mem[_1412 + 32] = 'SafeMath: division by zero'
                    if not _1350:
                        _1420 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _1420 + 68] = mem[_1412 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_1420 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _1420 + -mem[64] + 100
                    _1465 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_1465] = 26
                    mem[_1465 + 32] = 'SafeMath: division by zero'
                    if _1349:
                        if s > !(0 / _1350 / _1349):
                            revert with 0, 17
                        if s + (0 / _1350 / _1349) < s:
                            revert with 0, 'SafeMath: addition overflow'
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + (0 / _1350 / _1349)
                        continue 
                    _1481 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _1481 + 68] = mem[_1465 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1481 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _1481 + -mem[64] + 100
                if (mem[_1284 + 96] * mem[_1284]) + (mem[_1284 + 128] * mem[_1284]) and mem[_756 + 64] > -1 / (mem[_1284 + 96] * mem[_1284]) + (mem[_1284 + 128] * mem[_1284]):
                    revert with 0, 17
                if not (mem[_1284 + 96] * mem[_1284]) + (mem[_1284 + 128] * mem[_1284]):
                    revert with 0, 18
                if (mem[_1284 + 96] * mem[_1284] * mem[_756 + 64]) + (mem[_1284 + 128] * mem[_1284] * mem[_756 + 64]) / (mem[_1284 + 96] * mem[_1284]) + (mem[_1284 + 128] * mem[_1284]) != mem[_756 + 64]:
                    revert with 0, 'SafeMath: multiplication overflow'
                _1452 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1452] = 26
                mem[_1452 + 32] = 'SafeMath: division by zero'
                if not _1350:
                    _1464 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _1464 + 68] = mem[_1452 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1464 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _1464 + -mem[64] + 100
                _1508 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1508] = 26
                mem[_1508 + 32] = 'SafeMath: division by zero'
                if _1349:
                    if s > !((_1354 * _1352 * _1351) + (_1353 * _1352 * _1351) / _1350 / _1349):
                        revert with 0, 17
                    if s + ((_1354 * _1352 * _1351) + (_1353 * _1352 * _1351) / _1350 / _1349) < s:
                        revert with 0, 'SafeMath: addition overflow'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + ((_1354 * _1352 * _1351) + (_1353 * _1352 * _1351) / _1350 / _1349)
                    continue 
                _1528 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _1528 + 68] = mem[_1508 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_1528 + 94] = 0
                revert with memory
                  from mem[64]
                   len _1528 + -mem[64] + 100
            mem[mem[64]] = mem[(2 * ceil32(return_data.size)) + 896]
            return mem[mem[64]], s
        _703 = mem[(2 * ceil32(return_data.size)) + 1024]
        _707 = mem[64]
        mem[64] = mem[64] + 64
        mem[_707] = 30
        mem[_707 + 32] = 'SafeMath: subtraction overflow'
        if s > _703:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if _703 < s:
            revert with 0, 17
        _760 = mem[(2 * ceil32(return_data.size)) + 864]
        staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                gas gas_remaining wei
               args address(arg1), Mask(128, 128, mem[(2 * ceil32(return_data.size)) + 864])
        mem[mem[64] len 352] = ext_call.return_data[0 len 352]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _780 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 352
        _789 = mem[64]
        if mem[64] + 352 < mem[64] or mem[64] + 352 > test266151307():
            revert with 0, 65
        mem[64] = mem[64] + 352
        require mem[_780] == Mask(128, 128, mem[_780])
        mem[_789] = mem[_780]
        mem[_789 + 32] = mem[_780 + 32]
        mem[_789 + 64] = mem[_780 + 64]
        mem[_789 + 96] = mem[_780 + 96]
        require mem[_780 + 128] < 5
        mem[_789 + 128] = mem[_780 + 128]
        mem[_789 + 160] = mem[_780 + 160]
        mem[_789 + 192] = mem[_780 + 192]
        mem[_789 + 224] = mem[_780 + 224]
        mem[_789 + 256] = mem[_780 + 256]
        mem[_789 + 288] = mem[_780 + 288]
        mem[_789 + 320] = mem[_780 + 320]
        if Mask(128, 128, mem[_789]) != Mask(128, 128, _760):
            revert with 0, 'Address does not contain stake with provided id'
        idx = mem[_789 + 192]
        t = 0
        while idx < arg4:
            staticcall sub_413c05c6Address.0x8ce1d9e4 with:
                    gas gas_remaining wei
                   args idx
            mem[mem[64] len 160] = ext_call.return_data[0 len 160]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1279 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 160
            _1285 = mem[64]
            if mem[64] + 160 > test266151307() or mem[64] + 160 < mem[64]:
                revert with 0, 65
            mem[64] = mem[64] + 160
            mem[_1285] = mem[_1279]
            mem[_1285 + 32] = mem[_1279 + 32]
            mem[_1285 + 64] = mem[_1279 + 64]
            mem[_1285 + 96] = mem[_1279 + 96]
            mem[_1285 + 128] = mem[_1279 + 128]
            _1355 = mem[_1285 + 64]
            _1356 = mem[_1285 + 32]
            _1357 = mem[_789 + 64]
            _1358 = mem[_1285]
            _1359 = mem[_1285 + 128]
            _1360 = mem[_1285 + 96]
            if mem[_1285 + 96] > !mem[_1285 + 128]:
                revert with 0, 17
            if mem[_1285 + 96] + mem[_1285 + 128] < mem[_1285 + 96]:
                revert with 0, 'SafeMath: addition overflow'
            if not mem[_1285 + 96] + mem[_1285 + 128]:
                _1395 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1395] = 26
                mem[_1395 + 32] = 'SafeMath: division by zero'
                if not _1356:
                    _1405 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _1405 + 68] = mem[_1395 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1405 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _1405 + -mem[64] + 100
                _1423 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1423] = 26
                mem[_1423 + 32] = 'SafeMath: division by zero'
                if _1355:
                    if t > !(0 / _1356 / _1355):
                        revert with 0, 17
                    if t + (0 / _1356 / _1355) < t:
                        revert with 0, 'SafeMath: addition overflow'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    t = t + (0 / _1356 / _1355)
                    continue 
                _1438 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _1438 + 68] = mem[_1423 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_1438 + 94] = 0
                revert with memory
                  from mem[64]
                   len _1438 + -mem[64] + 100
            if mem[_1285 + 96] + mem[_1285 + 128] and mem[_1285] > -1 / mem[_1285 + 96] + mem[_1285 + 128]:
                revert with 0, 17
            if not mem[_1285 + 96] + mem[_1285 + 128]:
                revert with 0, 18
            if (mem[_1285 + 96] * mem[_1285]) + (mem[_1285 + 128] * mem[_1285]) / mem[_1285 + 96] + mem[_1285 + 128] != mem[_1285]:
                revert with 0, 'SafeMath: multiplication overflow'
            if not (mem[_1285 + 96] * mem[_1285]) + (mem[_1285 + 128] * mem[_1285]):
                _1414 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1414] = 26
                mem[_1414 + 32] = 'SafeMath: division by zero'
                if not _1356:
                    _1422 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _1422 + 68] = mem[_1414 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1422 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _1422 + -mem[64] + 100
                _1468 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1468] = 26
                mem[_1468 + 32] = 'SafeMath: division by zero'
                if _1355:
                    if t > !(0 / _1356 / _1355):
                        revert with 0, 17
                    if t + (0 / _1356 / _1355) < t:
                        revert with 0, 'SafeMath: addition overflow'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    t = t + (0 / _1356 / _1355)
                    continue 
                _1484 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _1484 + 68] = mem[_1468 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_1484 + 94] = 0
                revert with memory
                  from mem[64]
                   len _1484 + -mem[64] + 100
            if (mem[_1285 + 96] * mem[_1285]) + (mem[_1285 + 128] * mem[_1285]) and mem[_789 + 64] > -1 / (mem[_1285 + 96] * mem[_1285]) + (mem[_1285 + 128] * mem[_1285]):
                revert with 0, 17
            if not (mem[_1285 + 96] * mem[_1285]) + (mem[_1285 + 128] * mem[_1285]):
                revert with 0, 18
            if (mem[_1285 + 96] * mem[_1285] * mem[_789 + 64]) + (mem[_1285 + 128] * mem[_1285] * mem[_789 + 64]) / (mem[_1285 + 96] * mem[_1285]) + (mem[_1285 + 128] * mem[_1285]) != mem[_789 + 64]:
                revert with 0, 'SafeMath: multiplication overflow'
            _1455 = mem[64]
            mem[64] = mem[64] + 64
            mem[_1455] = 26
            mem[_1455 + 32] = 'SafeMath: division by zero'
            if not _1356:
                _1467 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _1467 + 68] = mem[_1455 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_1467 + 94] = 0
                revert with memory
                  from mem[64]
                   len _1467 + -mem[64] + 100
            _1511 = mem[64]
            mem[64] = mem[64] + 64
            mem[_1511] = 26
            mem[_1511 + 32] = 'SafeMath: division by zero'
            if _1355:
                if t > !((_1360 * _1358 * _1357) + (_1359 * _1358 * _1357) / _1356 / _1355):
                    revert with 0, 17
                if t + ((_1360 * _1358 * _1357) + (_1359 * _1358 * _1357) / _1356 / _1355) < t:
                    revert with 0, 'SafeMath: addition overflow'
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                t = t + ((_1360 * _1358 * _1357) + (_1359 * _1358 * _1357) / _1356 / _1355)
                continue 
            _1530 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _1530 + 68] = mem[_1511 + idx + 32]
                idx = idx + 32
                continue 
            mem[_1530 + 94] = 0
            revert with memory
              from mem[64]
               len _1530 + -mem[64] + 100
        if _703 - s > !t:
            revert with 0, 17
        if t < 0:
            revert with 0, 'SafeMath: addition overflow'
        mem[mem[64]] = mem[(2 * ceil32(return_data.size)) + 896]
        return mem[mem[64]], _703 - s + t
    idx = mem[(4 * ceil32(return_data.size)) + 1408]
    s = 0
    while idx < ext_call.return_data[192] + ext_call.return_data[224]:
        staticcall sub_413c05c6Address.0x8ce1d9e4 with:
                gas gas_remaining wei
               args idx
        mem[mem[64] len 160] = ext_call.return_data[0 len 160]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _698 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 160
        _711 = mem[64]
        if mem[64] + 160 > test266151307() or mem[64] + 160 < mem[64]:
            revert with 0, 65
        mem[64] = mem[64] + 160
        mem[_711] = mem[_698]
        mem[_711 + 32] = mem[_698 + 32]
        mem[_711 + 64] = mem[_698 + 64]
        mem[_711 + 96] = mem[_698 + 96]
        mem[_711 + 128] = mem[_698 + 128]
        _738 = mem[_711 + 64]
        _739 = mem[_711 + 32]
        _740 = mem[(4 * ceil32(return_data.size)) + 1280]
        _741 = mem[_711]
        _742 = mem[_711 + 128]
        _743 = mem[_711 + 96]
        if mem[_711 + 96] > !mem[_711 + 128]:
            revert with 0, 17
        if mem[_711 + 96] + mem[_711 + 128] < mem[_711 + 96]:
            revert with 0, 'SafeMath: addition overflow'
        if not mem[_711 + 96] + mem[_711 + 128]:
            _811 = mem[64]
            mem[64] = mem[64] + 64
            mem[_811] = 26
            mem[_811 + 32] = 'SafeMath: division by zero'
            if not _739:
                _822 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _822 + 68] = mem[_811 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_822 + 94] = 0
                revert with memory
                  from mem[64]
                   len _822 + -mem[64] + 100
            _894 = mem[64]
            mem[64] = mem[64] + 64
            mem[_894] = 26
            mem[_894 + 32] = 'SafeMath: division by zero'
            if _738:
                if s > !(0 / _739 / _738):
                    revert with 0, 17
                if s + (0 / _739 / _738) < s:
                    revert with 0, 'SafeMath: addition overflow'
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + (0 / _739 / _738)
                continue 
            _912 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _912 + 68] = mem[_894 + idx + 32]
                idx = idx + 32
                continue 
            mem[_912 + 94] = 0
            revert with memory
              from mem[64]
               len _912 + -mem[64] + 100
        if mem[_711 + 96] + mem[_711 + 128] and mem[_711] > -1 / mem[_711 + 96] + mem[_711 + 128]:
            revert with 0, 17
        if not mem[_711 + 96] + mem[_711 + 128]:
            revert with 0, 18
        if (mem[_711 + 96] * mem[_711]) + (mem[_711 + 128] * mem[_711]) / mem[_711 + 96] + mem[_711 + 128] != mem[_711]:
            revert with 0, 'SafeMath: multiplication overflow'
        if not (mem[_711 + 96] * mem[_711]) + (mem[_711 + 128] * mem[_711]):
            _849 = mem[64]
            mem[64] = mem[64] + 64
            mem[_849] = 26
            mem[_849 + 32] = 'SafeMath: division by zero'
            if not _739:
                _893 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _893 + 68] = mem[_849 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_893 + 94] = 0
                revert with memory
                  from mem[64]
                   len _893 + -mem[64] + 100
            _950 = mem[64]
            mem[64] = mem[64] + 64
            mem[_950] = 26
            mem[_950 + 32] = 'SafeMath: division by zero'
            if _738:
                if s > !(0 / _739 / _738):
                    revert with 0, 17
                if s + (0 / _739 / _738) < s:
                    revert with 0, 'SafeMath: addition overflow'
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + (0 / _739 / _738)
                continue 
            _984 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _984 + 68] = mem[_950 + idx + 32]
                idx = idx + 32
                continue 
            mem[_984 + 94] = 0
            revert with memory
              from mem[64]
               len _984 + -mem[64] + 100
        if (mem[_711 + 96] * mem[_711]) + (mem[_711 + 128] * mem[_711]) and mem[(4 * ceil32(return_data.size)) + 1280] > -1 / (mem[_711 + 96] * mem[_711]) + (mem[_711 + 128] * mem[_711]):
            revert with 0, 17
        if not (mem[_711 + 96] * mem[_711]) + (mem[_711 + 128] * mem[_711]):
            revert with 0, 18
        if (mem[_711 + 96] * mem[_711] * mem[(4 * ceil32(return_data.size)) + 1280]) + (mem[_711 + 128] * mem[_711] * mem[(4 * ceil32(return_data.size)) + 1280]) / (mem[_711 + 96] * mem[_711]) + (mem[_711 + 128] * mem[_711]) != mem[(4 * ceil32(return_data.size)) + 1280]:
            revert with 0, 'SafeMath: multiplication overflow'
        _934 = mem[64]
        mem[64] = mem[64] + 64
        mem[_934] = 26
        mem[_934 + 32] = 'SafeMath: division by zero'
        if not _739:
            _949 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _949 + 68] = mem[_934 + idx + 32]
                idx = idx + 32
                continue 
            mem[_949 + 94] = 0
            revert with memory
              from mem[64]
               len _949 + -mem[64] + 100
        _1008 = mem[64]
        mem[64] = mem[64] + 64
        mem[_1008] = 26
        mem[_1008 + 32] = 'SafeMath: division by zero'
        if _738:
            if s > !((_743 * _741 * _740) + (_742 * _741 * _740) / _739 / _738):
                revert with 0, 17
            if s + ((_743 * _741 * _740) + (_742 * _741 * _740) / _739 / _738) < s:
                revert with 0, 'SafeMath: addition overflow'
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s + ((_743 * _741 * _740) + (_742 * _741 * _740) / _739 / _738)
            continue 
        _1028 = mem[64]
        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 32
        mem[mem[64] + 36] = 26
        idx = 0
        while idx < 26:
            mem[idx + _1028 + 68] = mem[_1008 + idx + 32]
            idx = idx + 32
            continue 
        mem[_1028 + 94] = 0
        revert with memory
          from mem[64]
           len _1028 + -mem[64] + 100
    if s >= mem[(2 * ceil32(return_data.size)) + 1024]:
        _704 = mem[(2 * ceil32(return_data.size)) + 864]
        staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                gas gas_remaining wei
               args address(arg1), Mask(128, 128, mem[(2 * ceil32(return_data.size)) + 864])
        mem[mem[64] len 352] = ext_call.return_data[0 len 352]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _751 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 352
        _758 = mem[64]
        if mem[64] + 352 < mem[64] or mem[64] + 352 > test266151307():
            revert with 0, 65
        mem[64] = mem[64] + 352
        require mem[_751] == Mask(128, 128, mem[_751])
        mem[_758] = mem[_751]
        mem[_758 + 32] = mem[_751 + 32]
        mem[_758 + 64] = mem[_751 + 64]
        mem[_758 + 96] = mem[_751 + 96]
        require mem[_751 + 128] < 5
        mem[_758 + 128] = mem[_751 + 128]
        mem[_758 + 160] = mem[_751 + 160]
        mem[_758 + 192] = mem[_751 + 192]
        mem[_758 + 224] = mem[_751 + 224]
        mem[_758 + 256] = mem[_751 + 256]
        mem[_758 + 288] = mem[_751 + 288]
        mem[_758 + 320] = mem[_751 + 320]
        if Mask(128, 128, mem[_758]) != Mask(128, 128, _704):
            revert with 0, 'Address does not contain stake with provided id'
        idx = mem[_758 + 192]
        s = 0
        while idx < ext_call.return_data[192] + ext_call.return_data[224]:
            staticcall sub_413c05c6Address.0x8ce1d9e4 with:
                    gas gas_remaining wei
                   args idx
            mem[mem[64] len 160] = ext_call.return_data[0 len 160]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1281 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 160
            _1293 = mem[64]
            if mem[64] + 160 > test266151307() or mem[64] + 160 < mem[64]:
                revert with 0, 65
            mem[64] = mem[64] + 160
            mem[_1293] = mem[_1281]
            mem[_1293 + 32] = mem[_1281 + 32]
            mem[_1293 + 64] = mem[_1281 + 64]
            mem[_1293 + 96] = mem[_1281 + 96]
            mem[_1293 + 128] = mem[_1281 + 128]
            _1362 = mem[_1293 + 64]
            _1363 = mem[_1293 + 32]
            _1364 = mem[_758 + 64]
            _1365 = mem[_1293]
            _1366 = mem[_1293 + 128]
            _1367 = mem[_1293 + 96]
            if mem[_1293 + 96] > !mem[_1293 + 128]:
                revert with 0, 17
            if mem[_1293 + 96] + mem[_1293 + 128] < mem[_1293 + 96]:
                revert with 0, 'SafeMath: addition overflow'
            if not mem[_1293 + 96] + mem[_1293 + 128]:
                _1397 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1397] = 26
                mem[_1397 + 32] = 'SafeMath: division by zero'
                if not _1363:
                    _1406 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _1406 + 68] = mem[_1397 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1406 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _1406 + -mem[64] + 100
                _1425 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1425] = 26
                mem[_1425 + 32] = 'SafeMath: division by zero'
                if _1362:
                    if s > !(0 / _1363 / _1362):
                        revert with 0, 17
                    if s + (0 / _1363 / _1362) < s:
                        revert with 0, 'SafeMath: addition overflow'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + (0 / _1363 / _1362)
                    continue 
                _1442 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _1442 + 68] = mem[_1425 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_1442 + 94] = 0
                revert with memory
                  from mem[64]
                   len _1442 + -mem[64] + 100
            if mem[_1293 + 96] + mem[_1293 + 128] and mem[_1293] > -1 / mem[_1293 + 96] + mem[_1293 + 128]:
                revert with 0, 17
            if not mem[_1293 + 96] + mem[_1293 + 128]:
                revert with 0, 18
            if (mem[_1293 + 96] * mem[_1293]) + (mem[_1293 + 128] * mem[_1293]) / mem[_1293 + 96] + mem[_1293 + 128] != mem[_1293]:
                revert with 0, 'SafeMath: multiplication overflow'
            if not (mem[_1293 + 96] * mem[_1293]) + (mem[_1293 + 128] * mem[_1293]):
                _1416 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1416] = 26
                mem[_1416 + 32] = 'SafeMath: division by zero'
                if not _1363:
                    _1424 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _1424 + 68] = mem[_1416 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_1424 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _1424 + -mem[64] + 100
                _1471 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1471] = 26
                mem[_1471 + 32] = 'SafeMath: division by zero'
                if _1362:
                    if s > !(0 / _1363 / _1362):
                        revert with 0, 17
                    if s + (0 / _1363 / _1362) < s:
                        revert with 0, 'SafeMath: addition overflow'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + (0 / _1363 / _1362)
                    continue 
                _1487 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _1487 + 68] = mem[_1471 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_1487 + 94] = 0
                revert with memory
                  from mem[64]
                   len _1487 + -mem[64] + 100
            if (mem[_1293 + 96] * mem[_1293]) + (mem[_1293 + 128] * mem[_1293]) and mem[_758 + 64] > -1 / (mem[_1293 + 96] * mem[_1293]) + (mem[_1293 + 128] * mem[_1293]):
                revert with 0, 17
            if not (mem[_1293 + 96] * mem[_1293]) + (mem[_1293 + 128] * mem[_1293]):
                revert with 0, 18
            if (mem[_1293 + 96] * mem[_1293] * mem[_758 + 64]) + (mem[_1293 + 128] * mem[_1293] * mem[_758 + 64]) / (mem[_1293 + 96] * mem[_1293]) + (mem[_1293 + 128] * mem[_1293]) != mem[_758 + 64]:
                revert with 0, 'SafeMath: multiplication overflow'
            _1458 = mem[64]
            mem[64] = mem[64] + 64
            mem[_1458] = 26
            mem[_1458 + 32] = 'SafeMath: division by zero'
            if not _1363:
                _1470 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _1470 + 68] = mem[_1458 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_1470 + 94] = 0
                revert with memory
                  from mem[64]
                   len _1470 + -mem[64] + 100
            _1514 = mem[64]
            mem[64] = mem[64] + 64
            mem[_1514] = 26
            mem[_1514 + 32] = 'SafeMath: division by zero'
            if _1362:
                if s > !((_1367 * _1365 * _1364) + (_1366 * _1365 * _1364) / _1363 / _1362):
                    revert with 0, 17
                if s + ((_1367 * _1365 * _1364) + (_1366 * _1365 * _1364) / _1363 / _1362) < s:
                    revert with 0, 'SafeMath: addition overflow'
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + ((_1367 * _1365 * _1364) + (_1366 * _1365 * _1364) / _1363 / _1362)
                continue 
            _1532 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _1532 + 68] = mem[_1514 + idx + 32]
                idx = idx + 32
                continue 
            mem[_1532 + 94] = 0
            revert with memory
              from mem[64]
               len _1532 + -mem[64] + 100
        mem[mem[64]] = mem[(2 * ceil32(return_data.size)) + 896]
        return mem[mem[64]], s
    _705 = mem[(2 * ceil32(return_data.size)) + 1024]
    _710 = mem[64]
    mem[64] = mem[64] + 64
    mem[_710] = 30
    mem[_710 + 32] = 'SafeMath: subtraction overflow'
    if s > _705:
        revert with 0, 'SafeMath: subtraction overflow', 0
    if _705 < s:
        revert with 0, 17
    _762 = mem[(2 * ceil32(return_data.size)) + 864]
    staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
            gas gas_remaining wei
           args address(arg1), Mask(128, 128, mem[(2 * ceil32(return_data.size)) + 864])
    mem[mem[64] len 352] = ext_call.return_data[0 len 352]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    _781 = mem[64]
    mem[64] = mem[64] + ceil32(return_data.size)
    require return_data.size >= 352
    _791 = mem[64]
    if mem[64] + 352 < mem[64] or mem[64] + 352 > test266151307():
        revert with 0, 65
    mem[64] = mem[64] + 352
    require mem[_781] == Mask(128, 128, mem[_781])
    mem[_791] = mem[_781]
    mem[_791 + 32] = mem[_781 + 32]
    mem[_791 + 64] = mem[_781 + 64]
    mem[_791 + 96] = mem[_781 + 96]
    require mem[_781 + 128] < 5
    mem[_791 + 128] = mem[_781 + 128]
    mem[_791 + 160] = mem[_781 + 160]
    mem[_791 + 192] = mem[_781 + 192]
    mem[_791 + 224] = mem[_781 + 224]
    mem[_791 + 256] = mem[_781 + 256]
    mem[_791 + 288] = mem[_781 + 288]
    mem[_791 + 320] = mem[_781 + 320]
    if Mask(128, 128, mem[_791]) != Mask(128, 128, _762):
        revert with 0, 'Address does not contain stake with provided id'
    idx = mem[_791 + 192]
    t = 0
    while idx < ext_call.return_data[192] + ext_call.return_data[224]:
        staticcall sub_413c05c6Address.0x8ce1d9e4 with:
                gas gas_remaining wei
               args idx
        mem[mem[64] len 160] = ext_call.return_data[0 len 160]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _1283 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 160
        _1294 = mem[64]
        if mem[64] + 160 > test266151307() or mem[64] + 160 < mem[64]:
            revert with 0, 65
        mem[64] = mem[64] + 160
        mem[_1294] = mem[_1283]
        mem[_1294 + 32] = mem[_1283 + 32]
        mem[_1294 + 64] = mem[_1283 + 64]
        mem[_1294 + 96] = mem[_1283 + 96]
        mem[_1294 + 128] = mem[_1283 + 128]
        _1368 = mem[_1294 + 64]
        _1369 = mem[_1294 + 32]
        _1370 = mem[_791 + 64]
        _1371 = mem[_1294]
        _1372 = mem[_1294 + 128]
        _1373 = mem[_1294 + 96]
        if mem[_1294 + 96] > !mem[_1294 + 128]:
            revert with 0, 17
        if mem[_1294 + 96] + mem[_1294 + 128] < mem[_1294 + 96]:
            revert with 0, 'SafeMath: addition overflow'
        if not mem[_1294 + 96] + mem[_1294 + 128]:
            _1399 = mem[64]
            mem[64] = mem[64] + 64
            mem[_1399] = 26
            mem[_1399 + 32] = 'SafeMath: division by zero'
            if not _1369:
                _1407 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _1407 + 68] = mem[_1399 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_1407 + 94] = 0
                revert with memory
                  from mem[64]
                   len _1407 + -mem[64] + 100
            _1427 = mem[64]
            mem[64] = mem[64] + 64
            mem[_1427] = 26
            mem[_1427 + 32] = 'SafeMath: division by zero'
            if _1368:
                if t > !(0 / _1369 / _1368):
                    revert with 0, 17
                if t + (0 / _1369 / _1368) < t:
                    revert with 0, 'SafeMath: addition overflow'
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                t = t + (0 / _1369 / _1368)
                continue 
            _1446 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _1446 + 68] = mem[_1427 + idx + 32]
                idx = idx + 32
                continue 
            mem[_1446 + 94] = 0
            revert with memory
              from mem[64]
               len _1446 + -mem[64] + 100
        if mem[_1294 + 96] + mem[_1294 + 128] and mem[_1294] > -1 / mem[_1294 + 96] + mem[_1294 + 128]:
            revert with 0, 17
        if not mem[_1294 + 96] + mem[_1294 + 128]:
            revert with 0, 18
        if (mem[_1294 + 96] * mem[_1294]) + (mem[_1294 + 128] * mem[_1294]) / mem[_1294 + 96] + mem[_1294 + 128] != mem[_1294]:
            revert with 0, 'SafeMath: multiplication overflow'
        if not (mem[_1294 + 96] * mem[_1294]) + (mem[_1294 + 128] * mem[_1294]):
            _1418 = mem[64]
            mem[64] = mem[64] + 64
            mem[_1418] = 26
            mem[_1418 + 32] = 'SafeMath: division by zero'
            if not _1369:
                _1426 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _1426 + 68] = mem[_1418 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_1426 + 94] = 0
                revert with memory
                  from mem[64]
                   len _1426 + -mem[64] + 100
            _1474 = mem[64]
            mem[64] = mem[64] + 64
            mem[_1474] = 26
            mem[_1474 + 32] = 'SafeMath: division by zero'
            if _1368:
                if t > !(0 / _1369 / _1368):
                    revert with 0, 17
                if t + (0 / _1369 / _1368) < t:
                    revert with 0, 'SafeMath: addition overflow'
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                t = t + (0 / _1369 / _1368)
                continue 
            _1490 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _1490 + 68] = mem[_1474 + idx + 32]
                idx = idx + 32
                continue 
            mem[_1490 + 94] = 0
            revert with memory
              from mem[64]
               len _1490 + -mem[64] + 100
        if (mem[_1294 + 96] * mem[_1294]) + (mem[_1294 + 128] * mem[_1294]) and mem[_791 + 64] > -1 / (mem[_1294 + 96] * mem[_1294]) + (mem[_1294 + 128] * mem[_1294]):
            revert with 0, 17
        if not (mem[_1294 + 96] * mem[_1294]) + (mem[_1294 + 128] * mem[_1294]):
            revert with 0, 18
        if (mem[_1294 + 96] * mem[_1294] * mem[_791 + 64]) + (mem[_1294 + 128] * mem[_1294] * mem[_791 + 64]) / (mem[_1294 + 96] * mem[_1294]) + (mem[_1294 + 128] * mem[_1294]) != mem[_791 + 64]:
            revert with 0, 'SafeMath: multiplication overflow'
        _1461 = mem[64]
        mem[64] = mem[64] + 64
        mem[_1461] = 26
        mem[_1461 + 32] = 'SafeMath: division by zero'
        if not _1369:
            _1473 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _1473 + 68] = mem[_1461 + idx + 32]
                idx = idx + 32
                continue 
            mem[_1473 + 94] = 0
            revert with memory
              from mem[64]
               len _1473 + -mem[64] + 100
        _1517 = mem[64]
        mem[64] = mem[64] + 64
        mem[_1517] = 26
        mem[_1517 + 32] = 'SafeMath: division by zero'
        if _1368:
            if t > !((_1373 * _1371 * _1370) + (_1372 * _1371 * _1370) / _1369 / _1368):
                revert with 0, 17
            if t + ((_1373 * _1371 * _1370) + (_1372 * _1371 * _1370) / _1369 / _1368) < t:
                revert with 0, 'SafeMath: addition overflow'
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            t = t + ((_1373 * _1371 * _1370) + (_1372 * _1371 * _1370) / _1369 / _1368)
            continue 
        _1534 = mem[64]
        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 32
        mem[mem[64] + 36] = 26
        idx = 0
        while idx < 26:
            mem[idx + _1534 + 68] = mem[_1517 + idx + 32]
            idx = idx + 32
            continue 
        mem[_1534 + 94] = 0
        revert with memory
          from mem[64]
           len _1534 + -mem[64] + 100
    if _705 - s > !t:
        revert with 0, 17
    if t < 0:
        revert with 0, 'SafeMath: addition overflow'
    mem[mem[64]] = mem[(2 * ceil32(return_data.size)) + 896]
    return mem[mem[64]], _705 - s + t
}

function sub_39df9599(?) {
    require calldata.size - 4 >= 32
    require arg1 == Mask(128, 128, arg1)
    if not uint8(stor1.field_160):
        revert with 0, 'Register is disabled'
    mem[96] = 0
    mem[128] = 0
    mem[160] = 0
    mem[192] = 0
    mem[224] = 0
    mem[256] = 0
    mem[288] = 0
    mem[320] = 0
    mem[352] = 0
    mem[384] = 0
    mem[416] = 0
    staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
            gas gas_remaining wei
           args msg.sender, Mask(128, 128, arg1)
    mem[448 len 352] = ext_call.return_data[0 len 352]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 352
    if not bool(ceil32(return_data.size) + 800 <= test266151307()):
        revert with 0, 65
    require ext_call.return_data[0] == Mask(128, 128, ext_call.return_data[0])
    mem[ceil32(return_data.size) + 448] = ext_call.return_data[0]
    mem[ceil32(return_data.size) + 480] = ext_call.return_data[32]
    mem[ceil32(return_data.size) + 512] = ext_call.return_data[64]
    mem[ceil32(return_data.size) + 544] = ext_call.return_data[96]
    require ext_call.return_data[128] < 5
    mem[ceil32(return_data.size) + 576] = ext_call.return_data[128]
    mem[ceil32(return_data.size) + 608] = ext_call.return_data[160]
    mem[ceil32(return_data.size) + 640] = ext_call.return_data[192]
    mem[ceil32(return_data.size) + 672] = ext_call.return_data[224]
    mem[ceil32(return_data.size) + 704] = ext_call.return_data[256]
    mem[ceil32(return_data.size) + 736] = ext_call.return_data[288]
    mem[ceil32(return_data.size) + 768] = ext_call.return_data[320]
    if Mask(128, 128, ext_call.return_data[0]) != Mask(128, 128, arg1):
        revert with 0, 
                    32,
                    46,
                    0xfe53656e64657220646f6573206e6f7420636f6e7461696e207374616b6520776974682070726f76696465642069, mem[ceil32(return_data.size) + 878 len 18] >> 112,
                    0
    if stor9[address(msg.sender)][Mask(128, 128, arg1)]:
        revert with 0, 'Stake has already been converted'
    if ext_call.return_data[128] > 4:
        revert with 0, 33
    if ext_call.return_data[128] != 2:
        revert with 0, 
                    32,
                    44,
                    0x795374616b65206973206f6e6c7920656c696769626c6520696620697420686173206265656e20636c6f7365, mem[ceil32(return_data.size) + 876 len 20] >> 96,
                    0
    if ext_call.return_data[192] >= sub_be647a94:
        revert with 0, 
                    32,
                    65,
                    0x645374616b65206973206f6e6c7920656c696769626c65206966206974207761732063726561746564207072696f7220746f2074686520637574206f6666206461, mem[ceil32(return_data.size) + 897 len 31] >> 264,
                    0
    if ext_call.return_data[192] > !ext_call.return_data[224]:
        revert with 0, 17
    if ext_call.return_data[192] + ext_call.return_data[224] < sub_be647a94:
        revert with 0, 
                    32,
                    66,
                    0x645374616b65206973206f6e6c7920656c696769626c652069662069742077617320656e646564206f6e2074686520637574206f666620646179206f722061667465, mem[ceil32(return_data.size) + 898 len 30] >> 272,
                    0
    mem[ceil32(return_data.size) + 800] = 17
    mem[ceil32(return_data.size) + 832] = 'Stake is eligible' << 120
    if stor8[msg.sender][Mask(128, 128, arg1)]:
        revert with 0, 'Stake has already been registered'
    stor8[msg.sender][Mask(128, 128, arg1)] = 1
    mem[ceil32(return_data.size) + 864] = msg.sender
    mem[ceil32(return_data.size) + 896] = Mask(128, 128, arg1)
    sub_4c86259e[stor10].field_0 = msg.sender
    sub_4c86259e[stor10].field_256 = 0
    sub_4c86259e[stor10].field_512 = 0
    if sub_d3a8b1da == -1:
        revert with 0, 17
    sub_d3a8b1da++
    if 1 > !sub_2c8bff0e[msg.sender]:
        revert with 0, 17
    sub_2c8bff0e[msg.sender]++
    if 1 > !sub_ed73481d:
        revert with 0, 17
    mem[ceil32(return_data.size) + 928] = 0
    mem[ceil32(return_data.size) + 960] = 0
    mem[ceil32(return_data.size) + 992] = 0
    mem[ceil32(return_data.size) + 1024] = 0
    mem[ceil32(return_data.size) + 1056] = 0
    mem[ceil32(return_data.size) + 1088] = 0
    mem[ceil32(return_data.size) + 1120] = 0
    mem[ceil32(return_data.size) + 1152] = 0
    mem[ceil32(return_data.size) + 1184] = 0
    mem[ceil32(return_data.size) + 1216] = 0
    mem[ceil32(return_data.size) + 1248] = 0
    staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
            gas gas_remaining wei
           args msg.sender, Mask(128, 128, arg1)
    mem[ceil32(return_data.size) + 1280 len 352] = ext_call.return_data[0 len 352]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 352
    if not bool((2 * ceil32(return_data.size)) + 1632 <= test266151307()):
        revert with 0, 65
    require ext_call.return_data[0] == Mask(128, 128, ext_call.return_data[0])
    mem[(2 * ceil32(return_data.size)) + 1280] = ext_call.return_data[0]
    mem[(2 * ceil32(return_data.size)) + 1312] = ext_call.return_data[32]
    mem[(2 * ceil32(return_data.size)) + 1344] = ext_call.return_data[64]
    mem[(2 * ceil32(return_data.size)) + 1376] = ext_call.return_data[96]
    require ext_call.return_data[128] < 5
    mem[(2 * ceil32(return_data.size)) + 1408] = ext_call.return_data[128]
    mem[(2 * ceil32(return_data.size)) + 1440] = ext_call.return_data[160]
    mem[(2 * ceil32(return_data.size)) + 1472] = ext_call.return_data[192]
    mem[(2 * ceil32(return_data.size)) + 1504] = ext_call.return_data[224]
    mem[(2 * ceil32(return_data.size)) + 1536] = ext_call.return_data[256]
    mem[(2 * ceil32(return_data.size)) + 1568] = ext_call.return_data[288]
    mem[(2 * ceil32(return_data.size)) + 1600] = ext_call.return_data[320]
    if Mask(128, 128, ext_call.return_data[0]) != Mask(128, 128, arg1):
        if sub_f4a8f345 > -1:
            revert with 0, 17
        if sub_f4a8f345 < sub_f4a8f345:
            revert with 0, 'SafeMath: addition overflow'
    else:
        mem[0] = Mask(128, 128, arg1)
        mem[32] = sha3(address(msg.sender), 9)
        if stor9[address(msg.sender)][Mask(128, 128, arg1)]:
            if sub_f4a8f345 > -1:
                revert with 0, 17
            if sub_f4a8f345 < sub_f4a8f345:
                revert with 0, 'SafeMath: addition overflow'
        else:
            if ext_call.return_data[128] > 4:
                revert with 0, 33
            if ext_call.return_data[128] != 2:
                if sub_f4a8f345 > -1:
                    revert with 0, 17
                if sub_f4a8f345 < sub_f4a8f345:
                    revert with 0, 'SafeMath: addition overflow'
            else:
                if ext_call.return_data[192] >= sub_be647a94:
                    if sub_f4a8f345 > -1:
                        revert with 0, 17
                    if sub_f4a8f345 < sub_f4a8f345:
                        revert with 0, 'SafeMath: addition overflow'
                else:
                    if ext_call.return_data[192] > !ext_call.return_data[224]:
                        revert with 0, 17
                    if ext_call.return_data[192] + ext_call.return_data[224] < sub_be647a94:
                        if sub_f4a8f345 > -1:
                            revert with 0, 17
                        if sub_f4a8f345 < sub_f4a8f345:
                            revert with 0, 'SafeMath: addition overflow'
                    else:
                        mem[(2 * ceil32(return_data.size)) + 1632] = 17
                        mem[(2 * ceil32(return_data.size)) + 1664] = 'Stake is eligible' << 120
                        staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                                gas gas_remaining wei
                               args msg.sender, Mask(128, 128, arg1)
                        mem[(2 * ceil32(return_data.size)) + 1696 len 352] = ext_call.return_data[0 len 352]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 352
                        if not bool((4 * ceil32(return_data.size)) + 2048 <= test266151307()):
                            revert with 0, 65
                        require ext_call.return_data[0] == Mask(128, 128, ext_call.return_data[0])
                        mem[(4 * ceil32(return_data.size)) + 1696] = ext_call.return_data[0]
                        mem[(4 * ceil32(return_data.size)) + 1728] = ext_call.return_data[32]
                        mem[(4 * ceil32(return_data.size)) + 1760] = ext_call.return_data[64]
                        mem[(4 * ceil32(return_data.size)) + 1792] = ext_call.return_data[96]
                        require ext_call.return_data[128] < 5
                        mem[(4 * ceil32(return_data.size)) + 1824] = ext_call.return_data[128]
                        mem[(4 * ceil32(return_data.size)) + 1856] = ext_call.return_data[160]
                        mem[(4 * ceil32(return_data.size)) + 1888] = ext_call.return_data[192]
                        mem[(4 * ceil32(return_data.size)) + 1920] = ext_call.return_data[224]
                        mem[(4 * ceil32(return_data.size)) + 1952] = ext_call.return_data[256]
                        mem[(4 * ceil32(return_data.size)) + 1984] = ext_call.return_data[288]
                        mem[(4 * ceil32(return_data.size)) + 2016] = ext_call.return_data[320]
                        if Mask(128, 128, ext_call.return_data[0]) != Mask(128, 128, arg1):
                            revert with 0, 'Address does not contain stake with provided id'
                        if ext_call.return_data[128] > 4:
                            revert with 0, 33
                        if ext_call.return_data[128] == 3:
                            if sub_f4a8f345 > -1:
                                revert with 0, 17
                            if sub_f4a8f345 < sub_f4a8f345:
                                revert with 0, 'SafeMath: addition overflow'
                        else:
                            if ext_call.return_data[128] > 4:
                                revert with 0, 33
                            if ext_call.return_data[128] == 4:
                                if sub_f4a8f345 > -1:
                                    revert with 0, 17
                                if sub_f4a8f345 < sub_f4a8f345:
                                    revert with 0, 'SafeMath: addition overflow'
                            else:
                                if ext_call.return_data[128] > 4:
                                    revert with 0, 33
                                if ext_call.return_data[128] == 1:
                                    if sub_f4a8f345 > -1:
                                        revert with 0, 17
                                    if sub_f4a8f345 < sub_f4a8f345:
                                        revert with 0, 'SafeMath: addition overflow'
                                else:
                                    if ext_call.return_data[128] > 4:
                                        revert with 0, 33
                                    if not ext_call.return_data[128]:
                                        staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                                                gas gas_remaining wei
                                               args msg.sender, Mask(128, 128, ext_call.return_data[0])
                                        mem[(4 * ceil32(return_data.size)) + 2048 len 352] = ext_call.return_data[0 len 352]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 352
                                        if not bool((6 * ceil32(return_data.size)) + 2400 <= test266151307()):
                                            revert with 0, 65
                                        mem[64] = (6 * ceil32(return_data.size)) + 2400
                                        require ext_call.return_data[0] == Mask(128, 128, ext_call.return_data[0])
                                        mem[(6 * ceil32(return_data.size)) + 2048] = ext_call.return_data[0]
                                        mem[(6 * ceil32(return_data.size)) + 2080] = ext_call.return_data[32]
                                        mem[(6 * ceil32(return_data.size)) + 2112] = ext_call.return_data[64]
                                        mem[(6 * ceil32(return_data.size)) + 2144] = ext_call.return_data[96]
                                        require ext_call.return_data[128] < 5
                                        mem[(6 * ceil32(return_data.size)) + 2176] = ext_call.return_data[128]
                                        mem[(6 * ceil32(return_data.size)) + 2208] = ext_call.return_data[160]
                                        mem[(6 * ceil32(return_data.size)) + 2240] = ext_call.return_data[192]
                                        mem[(6 * ceil32(return_data.size)) + 2272] = ext_call.return_data[224]
                                        mem[(6 * ceil32(return_data.size)) + 2304] = ext_call.return_data[256]
                                        mem[(6 * ceil32(return_data.size)) + 2336] = ext_call.return_data[288]
                                        mem[(6 * ceil32(return_data.size)) + 2368] = ext_call.return_data[320]
                                        if Mask(128, 128, ext_call.return_data[0]) != Mask(128, 128, ext_call.return_data[0]):
                                            revert with 0, 'Address does not contain stake with provided id'
                                        idx = mem[(6 * ceil32(return_data.size)) + 2240]
                                        s = 0
                                        while idx < sub_ed73481d + 1:
                                            staticcall sub_413c05c6Address.0x8ce1d9e4 with:
                                                    gas gas_remaining wei
                                                   args idx
                                            mem[mem[64] len 160] = ext_call.return_data[0 len 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _686 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 160
                                            _697 = mem[64]
                                            if mem[64] + 160 > test266151307() or mem[64] + 160 < mem[64]:
                                                revert with 0, 65
                                            mem[64] = mem[64] + 160
                                            mem[_697] = mem[_686]
                                            mem[_697 + 32] = mem[_686 + 32]
                                            mem[_697 + 64] = mem[_686 + 64]
                                            mem[_697 + 96] = mem[_686 + 96]
                                            mem[_697 + 128] = mem[_686 + 128]
                                            _739 = mem[_697 + 64]
                                            _740 = mem[_697 + 32]
                                            _741 = mem[(6 * ceil32(return_data.size)) + 2112]
                                            _742 = mem[_697]
                                            _743 = mem[_697 + 128]
                                            _744 = mem[_697 + 96]
                                            if mem[_697 + 96] > !mem[_697 + 128]:
                                                revert with 0, 17
                                            if mem[_697 + 96] + mem[_697 + 128] < mem[_697 + 96]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not mem[_697 + 96] + mem[_697 + 128]:
                                                _808 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_808] = 26
                                                mem[_808 + 32] = 'SafeMath: division by zero'
                                                if not _740:
                                                    _819 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _819 + 68] = mem[_808 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_819 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _819 + -mem[64] + 100
                                                _891 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_891] = 26
                                                mem[_891 + 32] = 'SafeMath: division by zero'
                                                if _739:
                                                    if s > !(0 / _740 / _739):
                                                        revert with 0, 17
                                                    if s + (0 / _740 / _739) < s:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if idx == -1:
                                                        revert with 0, 17
                                                    idx = idx + 1
                                                    s = s + (0 / _740 / _739)
                                                    continue 
                                                _909 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _909 + 68] = mem[_891 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_909 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _909 + -mem[64] + 100
                                            if mem[_697 + 96] + mem[_697 + 128] and mem[_697] > -1 / mem[_697 + 96] + mem[_697 + 128]:
                                                revert with 0, 17
                                            if not mem[_697 + 96] + mem[_697 + 128]:
                                                revert with 0, 18
                                            if (mem[_697 + 96] * mem[_697]) + (mem[_697 + 128] * mem[_697]) / mem[_697 + 96] + mem[_697 + 128] != mem[_697]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if not (mem[_697 + 96] * mem[_697]) + (mem[_697 + 128] * mem[_697]):
                                                _848 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_848] = 26
                                                mem[_848 + 32] = 'SafeMath: division by zero'
                                                if not _740:
                                                    _890 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _890 + 68] = mem[_848 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_890 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _890 + -mem[64] + 100
                                                _950 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_950] = 26
                                                mem[_950 + 32] = 'SafeMath: division by zero'
                                                if _739:
                                                    if s > !(0 / _740 / _739):
                                                        revert with 0, 17
                                                    if s + (0 / _740 / _739) < s:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if idx == -1:
                                                        revert with 0, 17
                                                    idx = idx + 1
                                                    s = s + (0 / _740 / _739)
                                                    continue 
                                                _984 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _984 + 68] = mem[_950 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_984 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _984 + -mem[64] + 100
                                            if (mem[_697 + 96] * mem[_697]) + (mem[_697 + 128] * mem[_697]) and mem[(6 * ceil32(return_data.size)) + 2112] > -1 / (mem[_697 + 96] * mem[_697]) + (mem[_697 + 128] * mem[_697]):
                                                revert with 0, 17
                                            if not (mem[_697 + 96] * mem[_697]) + (mem[_697 + 128] * mem[_697]):
                                                revert with 0, 18
                                            if (mem[_697 + 96] * mem[_697] * mem[(6 * ceil32(return_data.size)) + 2112]) + (mem[_697 + 128] * mem[_697] * mem[(6 * ceil32(return_data.size)) + 2112]) / (mem[_697 + 96] * mem[_697]) + (mem[_697 + 128] * mem[_697]) != mem[(6 * ceil32(return_data.size)) + 2112]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _930 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_930] = 26
                                            mem[_930 + 32] = 'SafeMath: division by zero'
                                            if not _740:
                                                _949 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _949 + 68] = mem[_930 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_949 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _949 + -mem[64] + 100
                                            _1012 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_1012] = 26
                                            mem[_1012 + 32] = 'SafeMath: division by zero'
                                            if _739:
                                                if s > !((_744 * _742 * _741) + (_743 * _742 * _741) / _740 / _739):
                                                    revert with 0, 17
                                                if s + ((_744 * _742 * _741) + (_743 * _742 * _741) / _740 / _739) < s:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if idx == -1:
                                                    revert with 0, 17
                                                idx = idx + 1
                                                s = s + ((_744 * _742 * _741) + (_743 * _742 * _741) / _740 / _739)
                                                continue 
                                            _1029 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _1029 + 68] = mem[_1012 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_1029 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _1029 + -mem[64] + 100
                                        if mem[(4 * ceil32(return_data.size)) + 1856] > !s:
                                            revert with 0, 17
                                        if mem[(4 * ceil32(return_data.size)) + 1856] + s < mem[(4 * ceil32(return_data.size)) + 1856]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if mem[(4 * ceil32(return_data.size)) + 1728] > !(mem[(4 * ceil32(return_data.size)) + 1856] + s):
                                            revert with 0, 17
                                        if mem[(4 * ceil32(return_data.size)) + 1728] + mem[(4 * ceil32(return_data.size)) + 1856] + s < mem[(4 * ceil32(return_data.size)) + 1728]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if sub_f4a8f345 > !(mem[(4 * ceil32(return_data.size)) + 1728] + mem[(4 * ceil32(return_data.size)) + 1856] + s):
                                            revert with 0, 17
                                        if sub_f4a8f345 + mem[(4 * ceil32(return_data.size)) + 1728] + mem[(4 * ceil32(return_data.size)) + 1856] + s < sub_f4a8f345:
                                            revert with 0, 'SafeMath: addition overflow'
                                        sub_f4a8f345 = sub_f4a8f345 + mem[(4 * ceil32(return_data.size)) + 1728] + mem[(4 * ceil32(return_data.size)) + 1856] + s
                                    else:
                                        if ext_call.return_data[192] > !ext_call.return_data[224]:
                                            revert with 0, 17
                                        staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                                                gas gas_remaining wei
                                               args msg.sender, Mask(128, 128, ext_call.return_data[0])
                                        mem[(4 * ceil32(return_data.size)) + 2048 len 352] = ext_call.return_data[0 len 352]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 352
                                        if not bool((6 * ceil32(return_data.size)) + 2400 <= test266151307()):
                                            revert with 0, 65
                                        mem[64] = (6 * ceil32(return_data.size)) + 2400
                                        require ext_call.return_data[0] == Mask(128, 128, ext_call.return_data[0])
                                        mem[(6 * ceil32(return_data.size)) + 2048] = ext_call.return_data[0]
                                        mem[(6 * ceil32(return_data.size)) + 2080] = ext_call.return_data[32]
                                        mem[(6 * ceil32(return_data.size)) + 2112] = ext_call.return_data[64]
                                        mem[(6 * ceil32(return_data.size)) + 2144] = ext_call.return_data[96]
                                        require ext_call.return_data[128] < 5
                                        mem[(6 * ceil32(return_data.size)) + 2176] = ext_call.return_data[128]
                                        mem[(6 * ceil32(return_data.size)) + 2208] = ext_call.return_data[160]
                                        mem[(6 * ceil32(return_data.size)) + 2240] = ext_call.return_data[192]
                                        mem[(6 * ceil32(return_data.size)) + 2272] = ext_call.return_data[224]
                                        mem[(6 * ceil32(return_data.size)) + 2304] = ext_call.return_data[256]
                                        mem[(6 * ceil32(return_data.size)) + 2336] = ext_call.return_data[288]
                                        mem[(6 * ceil32(return_data.size)) + 2368] = ext_call.return_data[320]
                                        if Mask(128, 128, ext_call.return_data[0]) != Mask(128, 128, ext_call.return_data[0]):
                                            revert with 0, 'Address does not contain stake with provided id'
                                        if sub_ed73481d + 1 < ext_call.return_data[192] + ext_call.return_data[224]:
                                            idx = mem[(6 * ceil32(return_data.size)) + 2240]
                                            s = 0
                                            while idx < ext_call.return_data[192] + ext_call.return_data[224]:
                                                staticcall sub_413c05c6Address.0x8ce1d9e4 with:
                                                        gas gas_remaining wei
                                                       args idx
                                                mem[mem[64] len 160] = ext_call.return_data[0 len 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _681 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 160
                                                _693 = mem[64]
                                                if mem[64] + 160 > test266151307() or mem[64] + 160 < mem[64]:
                                                    revert with 0, 65
                                                mem[64] = mem[64] + 160
                                                mem[_693] = mem[_681]
                                                mem[_693 + 32] = mem[_681 + 32]
                                                mem[_693 + 64] = mem[_681 + 64]
                                                mem[_693 + 96] = mem[_681 + 96]
                                                mem[_693 + 128] = mem[_681 + 128]
                                                _725 = mem[_693 + 64]
                                                _726 = mem[_693 + 32]
                                                _727 = mem[(6 * ceil32(return_data.size)) + 2112]
                                                _728 = mem[_693]
                                                _729 = mem[_693 + 128]
                                                _730 = mem[_693 + 96]
                                                if mem[_693 + 96] > !mem[_693 + 128]:
                                                    revert with 0, 17
                                                if mem[_693 + 96] + mem[_693 + 128] < mem[_693 + 96]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not mem[_693 + 96] + mem[_693 + 128]:
                                                    _802 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_802] = 26
                                                    mem[_802 + 32] = 'SafeMath: division by zero'
                                                    if not _726:
                                                        _816 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _816 + 68] = mem[_802 + idx + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_816 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _816 + -mem[64] + 100
                                                    _880 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_880] = 26
                                                    mem[_880 + 32] = 'SafeMath: division by zero'
                                                    if _725:
                                                        if s > !(0 / _726 / _725):
                                                            revert with 0, 17
                                                        if s + (0 / _726 / _725) < s:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if idx == -1:
                                                            revert with 0, 17
                                                        idx = idx + 1
                                                        s = s + (0 / _726 / _725)
                                                        continue 
                                                    _901 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _901 + 68] = mem[_880 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_901 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _901 + -mem[64] + 100
                                                if mem[_693 + 96] + mem[_693 + 128] and mem[_693] > -1 / mem[_693 + 96] + mem[_693 + 128]:
                                                    revert with 0, 17
                                                if not mem[_693 + 96] + mem[_693 + 128]:
                                                    revert with 0, 18
                                                if (mem[_693 + 96] * mem[_693]) + (mem[_693 + 128] * mem[_693]) / mem[_693 + 96] + mem[_693 + 128] != mem[_693]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not (mem[_693 + 96] * mem[_693]) + (mem[_693 + 128] * mem[_693]):
                                                    _843 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_843] = 26
                                                    mem[_843 + 32] = 'SafeMath: division by zero'
                                                    if not _726:
                                                        _879 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _879 + 68] = mem[_843 + idx + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_879 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _879 + -mem[64] + 100
                                                    _941 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_941] = 26
                                                    mem[_941 + 32] = 'SafeMath: division by zero'
                                                    if _725:
                                                        if s > !(0 / _726 / _725):
                                                            revert with 0, 17
                                                        if s + (0 / _726 / _725) < s:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if idx == -1:
                                                            revert with 0, 17
                                                        idx = idx + 1
                                                        s = s + (0 / _726 / _725)
                                                        continue 
                                                    _972 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _972 + 68] = mem[_941 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_972 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _972 + -mem[64] + 100
                                                if (mem[_693 + 96] * mem[_693]) + (mem[_693 + 128] * mem[_693]) and mem[(6 * ceil32(return_data.size)) + 2112] > -1 / (mem[_693 + 96] * mem[_693]) + (mem[_693 + 128] * mem[_693]):
                                                    revert with 0, 17
                                                if not (mem[_693 + 96] * mem[_693]) + (mem[_693 + 128] * mem[_693]):
                                                    revert with 0, 18
                                                if (mem[_693 + 96] * mem[_693] * mem[(6 * ceil32(return_data.size)) + 2112]) + (mem[_693 + 128] * mem[_693] * mem[(6 * ceil32(return_data.size)) + 2112]) / (mem[_693 + 96] * mem[_693]) + (mem[_693 + 128] * mem[_693]) != mem[(6 * ceil32(return_data.size)) + 2112]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _922 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_922] = 26
                                                mem[_922 + 32] = 'SafeMath: division by zero'
                                                if not _726:
                                                    _940 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _940 + 68] = mem[_922 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_940 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _940 + -mem[64] + 100
                                                _1005 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_1005] = 26
                                                mem[_1005 + 32] = 'SafeMath: division by zero'
                                                if _725:
                                                    if s > !((_730 * _728 * _727) + (_729 * _728 * _727) / _726 / _725):
                                                        revert with 0, 17
                                                    if s + ((_730 * _728 * _727) + (_729 * _728 * _727) / _726 / _725) < s:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if idx == -1:
                                                        revert with 0, 17
                                                    idx = idx + 1
                                                    s = s + ((_730 * _728 * _727) + (_729 * _728 * _727) / _726 / _725)
                                                    continue 
                                                _1024 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _1024 + 68] = mem[_1005 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_1024 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _1024 + -mem[64] + 100
                                            if s >= mem[(4 * ceil32(return_data.size)) + 1856]:
                                                _687 = mem[(4 * ceil32(return_data.size)) + 1696]
                                                staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                                                        gas gas_remaining wei
                                                       args msg.sender, Mask(128, 128, mem[(4 * ceil32(return_data.size)) + 1696])
                                                mem[mem[64] len 352] = ext_call.return_data[0 len 352]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _745 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 352
                                                _751 = mem[64]
                                                if mem[64] + 352 < mem[64] or mem[64] + 352 > test266151307():
                                                    revert with 0, 65
                                                mem[64] = mem[64] + 352
                                                require mem[_745] == Mask(128, 128, mem[_745])
                                                mem[_751] = mem[_745]
                                                mem[_751 + 32] = mem[_745 + 32]
                                                mem[_751 + 64] = mem[_745 + 64]
                                                mem[_751 + 96] = mem[_745 + 96]
                                                require mem[_745 + 128] < 5
                                                mem[_751 + 128] = mem[_745 + 128]
                                                mem[_751 + 160] = mem[_745 + 160]
                                                mem[_751 + 192] = mem[_745 + 192]
                                                mem[_751 + 224] = mem[_745 + 224]
                                                mem[_751 + 256] = mem[_745 + 256]
                                                mem[_751 + 288] = mem[_745 + 288]
                                                mem[_751 + 320] = mem[_745 + 320]
                                                if Mask(128, 128, mem[_751]) != Mask(128, 128, _687):
                                                    revert with 0, 'Address does not contain stake with provided id'
                                                idx = mem[_751 + 192]
                                                s = 0
                                                while idx < sub_ed73481d + 1:
                                                    staticcall sub_413c05c6Address.0x8ce1d9e4 with:
                                                            gas gas_remaining wei
                                                           args idx
                                                    mem[mem[64] len 160] = ext_call.return_data[0 len 160]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _1282 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 160
                                                    _1289 = mem[64]
                                                    if mem[64] + 160 > test266151307() or mem[64] + 160 < mem[64]:
                                                        revert with 0, 65
                                                    mem[64] = mem[64] + 160
                                                    mem[_1289] = mem[_1282]
                                                    mem[_1289 + 32] = mem[_1282 + 32]
                                                    mem[_1289 + 64] = mem[_1282 + 64]
                                                    mem[_1289 + 96] = mem[_1282 + 96]
                                                    mem[_1289 + 128] = mem[_1282 + 128]
                                                    _1353 = mem[_1289 + 64]
                                                    _1354 = mem[_1289 + 32]
                                                    _1355 = mem[_751 + 64]
                                                    _1356 = mem[_1289]
                                                    _1357 = mem[_1289 + 128]
                                                    _1358 = mem[_1289 + 96]
                                                    if mem[_1289 + 96] > !mem[_1289 + 128]:
                                                        revert with 0, 17
                                                    if mem[_1289 + 96] + mem[_1289 + 128] < mem[_1289 + 96]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if not mem[_1289 + 96] + mem[_1289 + 128]:
                                                        _1402 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_1402] = 26
                                                        mem[_1402 + 32] = 'SafeMath: division by zero'
                                                        if not _1354:
                                                            _1413 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _1413 + 68] = mem[_1402 + idx + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_1413 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _1413 + -mem[64] + 100
                                                        _1434 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_1434] = 26
                                                        mem[_1434 + 32] = 'SafeMath: division by zero'
                                                        if _1353:
                                                            if s > !(0 / _1354 / _1353):
                                                                revert with 0, 17
                                                            if s + (0 / _1354 / _1353) < s:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            if idx == -1:
                                                                revert with 0, 17
                                                            idx = idx + 1
                                                            s = s + (0 / _1354 / _1353)
                                                            continue 
                                                        _1447 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _1447 + 68] = mem[_1434 + idx + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_1447 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _1447 + -mem[64] + 100
                                                    if mem[_1289 + 96] + mem[_1289 + 128] and mem[_1289] > -1 / mem[_1289 + 96] + mem[_1289 + 128]:
                                                        revert with 0, 17
                                                    if not mem[_1289 + 96] + mem[_1289 + 128]:
                                                        revert with 0, 18
                                                    if (mem[_1289 + 96] * mem[_1289]) + (mem[_1289 + 128] * mem[_1289]) / mem[_1289 + 96] + mem[_1289 + 128] != mem[_1289]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not (mem[_1289 + 96] * mem[_1289]) + (mem[_1289 + 128] * mem[_1289]):
                                                        _1425 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_1425] = 26
                                                        mem[_1425 + 32] = 'SafeMath: division by zero'
                                                        if not _1354:
                                                            _1433 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _1433 + 68] = mem[_1425 + idx + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_1433 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _1433 + -mem[64] + 100
                                                        _1478 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_1478] = 26
                                                        mem[_1478 + 32] = 'SafeMath: division by zero'
                                                        if _1353:
                                                            if s > !(0 / _1354 / _1353):
                                                                revert with 0, 17
                                                            if s + (0 / _1354 / _1353) < s:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            if idx == -1:
                                                                revert with 0, 17
                                                            idx = idx + 1
                                                            s = s + (0 / _1354 / _1353)
                                                            continue 
                                                        _1494 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _1494 + 68] = mem[_1478 + idx + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_1494 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _1494 + -mem[64] + 100
                                                    if (mem[_1289 + 96] * mem[_1289]) + (mem[_1289 + 128] * mem[_1289]) and mem[_751 + 64] > -1 / (mem[_1289 + 96] * mem[_1289]) + (mem[_1289 + 128] * mem[_1289]):
                                                        revert with 0, 17
                                                    if not (mem[_1289 + 96] * mem[_1289]) + (mem[_1289 + 128] * mem[_1289]):
                                                        revert with 0, 18
                                                    if (mem[_1289 + 96] * mem[_1289] * mem[_751 + 64]) + (mem[_1289 + 128] * mem[_1289] * mem[_751 + 64]) / (mem[_1289 + 96] * mem[_1289]) + (mem[_1289 + 128] * mem[_1289]) != mem[_751 + 64]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _1465 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_1465] = 26
                                                    mem[_1465 + 32] = 'SafeMath: division by zero'
                                                    if not _1354:
                                                        _1477 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _1477 + 68] = mem[_1465 + idx + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_1477 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _1477 + -mem[64] + 100
                                                    _1521 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_1521] = 26
                                                    mem[_1521 + 32] = 'SafeMath: division by zero'
                                                    if _1353:
                                                        if s > !((_1358 * _1356 * _1355) + (_1357 * _1356 * _1355) / _1354 / _1353):
                                                            revert with 0, 17
                                                        if s + ((_1358 * _1356 * _1355) + (_1357 * _1356 * _1355) / _1354 / _1353) < s:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if idx == -1:
                                                            revert with 0, 17
                                                        idx = idx + 1
                                                        s = s + ((_1358 * _1356 * _1355) + (_1357 * _1356 * _1355) / _1354 / _1353)
                                                        continue 
                                                    _1541 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _1541 + 68] = mem[_1521 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_1541 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _1541 + -mem[64] + 100
                                                if mem[(4 * ceil32(return_data.size)) + 1728] > !s:
                                                    revert with 0, 17
                                                if mem[(4 * ceil32(return_data.size)) + 1728] + s < mem[(4 * ceil32(return_data.size)) + 1728]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if sub_f4a8f345 > !(mem[(4 * ceil32(return_data.size)) + 1728] + s):
                                                    revert with 0, 17
                                                if sub_f4a8f345 + mem[(4 * ceil32(return_data.size)) + 1728] + s < sub_f4a8f345:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                sub_f4a8f345 = sub_f4a8f345 + mem[(4 * ceil32(return_data.size)) + 1728] + s
                                            else:
                                                _688 = mem[(4 * ceil32(return_data.size)) + 1856]
                                                _692 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_692] = 30
                                                mem[_692 + 32] = 'SafeMath: subtraction overflow'
                                                if s > _688:
                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                if _688 < s:
                                                    revert with 0, 17
                                                _755 = mem[(4 * ceil32(return_data.size)) + 1696]
                                                staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                                                        gas gas_remaining wei
                                                       args msg.sender, Mask(128, 128, mem[(4 * ceil32(return_data.size)) + 1696])
                                                mem[mem[64] len 352] = ext_call.return_data[0 len 352]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _773 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 352
                                                _783 = mem[64]
                                                if mem[64] + 352 < mem[64] or mem[64] + 352 > test266151307():
                                                    revert with 0, 65
                                                mem[64] = mem[64] + 352
                                                require mem[_773] == Mask(128, 128, mem[_773])
                                                mem[_783] = mem[_773]
                                                mem[_783 + 32] = mem[_773 + 32]
                                                mem[_783 + 64] = mem[_773 + 64]
                                                mem[_783 + 96] = mem[_773 + 96]
                                                require mem[_773 + 128] < 5
                                                mem[_783 + 128] = mem[_773 + 128]
                                                mem[_783 + 160] = mem[_773 + 160]
                                                mem[_783 + 192] = mem[_773 + 192]
                                                mem[_783 + 224] = mem[_773 + 224]
                                                mem[_783 + 256] = mem[_773 + 256]
                                                mem[_783 + 288] = mem[_773 + 288]
                                                mem[_783 + 320] = mem[_773 + 320]
                                                if Mask(128, 128, mem[_783]) != Mask(128, 128, _755):
                                                    revert with 0, 'Address does not contain stake with provided id'
                                                idx = mem[_783 + 192]
                                                t = 0
                                                while idx < sub_ed73481d + 1:
                                                    staticcall sub_413c05c6Address.0x8ce1d9e4 with:
                                                            gas gas_remaining wei
                                                           args idx
                                                    mem[mem[64] len 160] = ext_call.return_data[0 len 160]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _1284 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 160
                                                    _1290 = mem[64]
                                                    if mem[64] + 160 > test266151307() or mem[64] + 160 < mem[64]:
                                                        revert with 0, 65
                                                    mem[64] = mem[64] + 160
                                                    mem[_1290] = mem[_1284]
                                                    mem[_1290 + 32] = mem[_1284 + 32]
                                                    mem[_1290 + 64] = mem[_1284 + 64]
                                                    mem[_1290 + 96] = mem[_1284 + 96]
                                                    mem[_1290 + 128] = mem[_1284 + 128]
                                                    _1359 = mem[_1290 + 64]
                                                    _1360 = mem[_1290 + 32]
                                                    _1361 = mem[_783 + 64]
                                                    _1362 = mem[_1290]
                                                    _1363 = mem[_1290 + 128]
                                                    _1364 = mem[_1290 + 96]
                                                    if mem[_1290 + 96] > !mem[_1290 + 128]:
                                                        revert with 0, 17
                                                    if mem[_1290 + 96] + mem[_1290 + 128] < mem[_1290 + 96]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if not mem[_1290 + 96] + mem[_1290 + 128]:
                                                        _1404 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_1404] = 26
                                                        mem[_1404 + 32] = 'SafeMath: division by zero'
                                                        if not _1360:
                                                            _1415 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _1415 + 68] = mem[_1404 + idx + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_1415 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _1415 + -mem[64] + 100
                                                        _1436 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_1436] = 26
                                                        mem[_1436 + 32] = 'SafeMath: division by zero'
                                                        if _1359:
                                                            if t > !(0 / _1360 / _1359):
                                                                revert with 0, 17
                                                            if t + (0 / _1360 / _1359) < t:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            if idx == -1:
                                                                revert with 0, 17
                                                            idx = idx + 1
                                                            t = t + (0 / _1360 / _1359)
                                                            continue 
                                                        _1451 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _1451 + 68] = mem[_1436 + idx + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_1451 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _1451 + -mem[64] + 100
                                                    if mem[_1290 + 96] + mem[_1290 + 128] and mem[_1290] > -1 / mem[_1290 + 96] + mem[_1290 + 128]:
                                                        revert with 0, 17
                                                    if not mem[_1290 + 96] + mem[_1290 + 128]:
                                                        revert with 0, 18
                                                    if (mem[_1290 + 96] * mem[_1290]) + (mem[_1290 + 128] * mem[_1290]) / mem[_1290 + 96] + mem[_1290 + 128] != mem[_1290]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not (mem[_1290 + 96] * mem[_1290]) + (mem[_1290 + 128] * mem[_1290]):
                                                        _1427 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_1427] = 26
                                                        mem[_1427 + 32] = 'SafeMath: division by zero'
                                                        if not _1360:
                                                            _1435 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _1435 + 68] = mem[_1427 + idx + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_1435 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _1435 + -mem[64] + 100
                                                        _1481 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_1481] = 26
                                                        mem[_1481 + 32] = 'SafeMath: division by zero'
                                                        if _1359:
                                                            if t > !(0 / _1360 / _1359):
                                                                revert with 0, 17
                                                            if t + (0 / _1360 / _1359) < t:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            if idx == -1:
                                                                revert with 0, 17
                                                            idx = idx + 1
                                                            t = t + (0 / _1360 / _1359)
                                                            continue 
                                                        _1497 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _1497 + 68] = mem[_1481 + idx + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_1497 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _1497 + -mem[64] + 100
                                                    if (mem[_1290 + 96] * mem[_1290]) + (mem[_1290 + 128] * mem[_1290]) and mem[_783 + 64] > -1 / (mem[_1290 + 96] * mem[_1290]) + (mem[_1290 + 128] * mem[_1290]):
                                                        revert with 0, 17
                                                    if not (mem[_1290 + 96] * mem[_1290]) + (mem[_1290 + 128] * mem[_1290]):
                                                        revert with 0, 18
                                                    if (mem[_1290 + 96] * mem[_1290] * mem[_783 + 64]) + (mem[_1290 + 128] * mem[_1290] * mem[_783 + 64]) / (mem[_1290 + 96] * mem[_1290]) + (mem[_1290 + 128] * mem[_1290]) != mem[_783 + 64]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _1468 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_1468] = 26
                                                    mem[_1468 + 32] = 'SafeMath: division by zero'
                                                    if not _1360:
                                                        _1480 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _1480 + 68] = mem[_1468 + idx + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_1480 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _1480 + -mem[64] + 100
                                                    _1524 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_1524] = 26
                                                    mem[_1524 + 32] = 'SafeMath: division by zero'
                                                    if _1359:
                                                        if t > !((_1364 * _1362 * _1361) + (_1363 * _1362 * _1361) / _1360 / _1359):
                                                            revert with 0, 17
                                                        if t + ((_1364 * _1362 * _1361) + (_1363 * _1362 * _1361) / _1360 / _1359) < t:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if idx == -1:
                                                            revert with 0, 17
                                                        idx = idx + 1
                                                        t = t + ((_1364 * _1362 * _1361) + (_1363 * _1362 * _1361) / _1360 / _1359)
                                                        continue 
                                                    _1543 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _1543 + 68] = mem[_1524 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_1543 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _1543 + -mem[64] + 100
                                                if _688 - s > !t:
                                                    revert with 0, 17
                                                if t < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if mem[(4 * ceil32(return_data.size)) + 1728] > !(_688 - s + t):
                                                    revert with 0, 17
                                                if mem[(4 * ceil32(return_data.size)) + 1728] + _688 - s + t < mem[(4 * ceil32(return_data.size)) + 1728]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if sub_f4a8f345 > !(mem[(4 * ceil32(return_data.size)) + 1728] + _688 - s + t):
                                                    revert with 0, 17
                                                if sub_f4a8f345 + mem[(4 * ceil32(return_data.size)) + 1728] + _688 - s + t < sub_f4a8f345:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                sub_f4a8f345 = sub_f4a8f345 + mem[(4 * ceil32(return_data.size)) + 1728] + _688 - s + t
                                        else:
                                            idx = mem[(6 * ceil32(return_data.size)) + 2240]
                                            s = 0
                                            while idx < ext_call.return_data[192] + ext_call.return_data[224]:
                                                staticcall sub_413c05c6Address.0x8ce1d9e4 with:
                                                        gas gas_remaining wei
                                                       args idx
                                                mem[mem[64] len 160] = ext_call.return_data[0 len 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _683 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 160
                                                _696 = mem[64]
                                                if mem[64] + 160 > test266151307() or mem[64] + 160 < mem[64]:
                                                    revert with 0, 65
                                                mem[64] = mem[64] + 160
                                                mem[_696] = mem[_683]
                                                mem[_696 + 32] = mem[_683 + 32]
                                                mem[_696 + 64] = mem[_683 + 64]
                                                mem[_696 + 96] = mem[_683 + 96]
                                                mem[_696 + 128] = mem[_683 + 128]
                                                _733 = mem[_696 + 64]
                                                _734 = mem[_696 + 32]
                                                _735 = mem[(6 * ceil32(return_data.size)) + 2112]
                                                _736 = mem[_696]
                                                _737 = mem[_696 + 128]
                                                _738 = mem[_696 + 96]
                                                if mem[_696 + 96] > !mem[_696 + 128]:
                                                    revert with 0, 17
                                                if mem[_696 + 96] + mem[_696 + 128] < mem[_696 + 96]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not mem[_696 + 96] + mem[_696 + 128]:
                                                    _806 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_806] = 26
                                                    mem[_806 + 32] = 'SafeMath: division by zero'
                                                    if not _734:
                                                        _817 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _817 + 68] = mem[_806 + idx + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_817 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _817 + -mem[64] + 100
                                                    _889 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_889] = 26
                                                    mem[_889 + 32] = 'SafeMath: division by zero'
                                                    if _733:
                                                        if s > !(0 / _734 / _733):
                                                            revert with 0, 17
                                                        if s + (0 / _734 / _733) < s:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if idx == -1:
                                                            revert with 0, 17
                                                        idx = idx + 1
                                                        s = s + (0 / _734 / _733)
                                                        continue 
                                                    _905 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _905 + 68] = mem[_889 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_905 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _905 + -mem[64] + 100
                                                if mem[_696 + 96] + mem[_696 + 128] and mem[_696] > -1 / mem[_696 + 96] + mem[_696 + 128]:
                                                    revert with 0, 17
                                                if not mem[_696 + 96] + mem[_696 + 128]:
                                                    revert with 0, 18
                                                if (mem[_696 + 96] * mem[_696]) + (mem[_696 + 128] * mem[_696]) / mem[_696 + 96] + mem[_696 + 128] != mem[_696]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not (mem[_696 + 96] * mem[_696]) + (mem[_696 + 128] * mem[_696]):
                                                    _846 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_846] = 26
                                                    mem[_846 + 32] = 'SafeMath: division by zero'
                                                    if not _734:
                                                        _888 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _888 + 68] = mem[_846 + idx + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_888 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _888 + -mem[64] + 100
                                                    _947 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_947] = 26
                                                    mem[_947 + 32] = 'SafeMath: division by zero'
                                                    if _733:
                                                        if s > !(0 / _734 / _733):
                                                            revert with 0, 17
                                                        if s + (0 / _734 / _733) < s:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if idx == -1:
                                                            revert with 0, 17
                                                        idx = idx + 1
                                                        s = s + (0 / _734 / _733)
                                                        continue 
                                                    _981 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _981 + 68] = mem[_947 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_981 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _981 + -mem[64] + 100
                                                if (mem[_696 + 96] * mem[_696]) + (mem[_696 + 128] * mem[_696]) and mem[(6 * ceil32(return_data.size)) + 2112] > -1 / (mem[_696 + 96] * mem[_696]) + (mem[_696 + 128] * mem[_696]):
                                                    revert with 0, 17
                                                if not (mem[_696 + 96] * mem[_696]) + (mem[_696 + 128] * mem[_696]):
                                                    revert with 0, 18
                                                if (mem[_696 + 96] * mem[_696] * mem[(6 * ceil32(return_data.size)) + 2112]) + (mem[_696 + 128] * mem[_696] * mem[(6 * ceil32(return_data.size)) + 2112]) / (mem[_696 + 96] * mem[_696]) + (mem[_696 + 128] * mem[_696]) != mem[(6 * ceil32(return_data.size)) + 2112]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _927 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_927] = 26
                                                mem[_927 + 32] = 'SafeMath: division by zero'
                                                if not _734:
                                                    _946 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _946 + 68] = mem[_927 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_946 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _946 + -mem[64] + 100
                                                _1009 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_1009] = 26
                                                mem[_1009 + 32] = 'SafeMath: division by zero'
                                                if _733:
                                                    if s > !((_738 * _736 * _735) + (_737 * _736 * _735) / _734 / _733):
                                                        revert with 0, 17
                                                    if s + ((_738 * _736 * _735) + (_737 * _736 * _735) / _734 / _733) < s:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if idx == -1:
                                                        revert with 0, 17
                                                    idx = idx + 1
                                                    s = s + ((_738 * _736 * _735) + (_737 * _736 * _735) / _734 / _733)
                                                    continue 
                                                _1027 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _1027 + 68] = mem[_1009 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_1027 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _1027 + -mem[64] + 100
                                            if s >= mem[(4 * ceil32(return_data.size)) + 1856]:
                                                _689 = mem[(4 * ceil32(return_data.size)) + 1696]
                                                staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                                                        gas gas_remaining wei
                                                       args msg.sender, Mask(128, 128, mem[(4 * ceil32(return_data.size)) + 1696])
                                                mem[mem[64] len 352] = ext_call.return_data[0 len 352]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _746 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 352
                                                _753 = mem[64]
                                                if mem[64] + 352 < mem[64] or mem[64] + 352 > test266151307():
                                                    revert with 0, 65
                                                mem[64] = mem[64] + 352
                                                require mem[_746] == Mask(128, 128, mem[_746])
                                                mem[_753] = mem[_746]
                                                mem[_753 + 32] = mem[_746 + 32]
                                                mem[_753 + 64] = mem[_746 + 64]
                                                mem[_753 + 96] = mem[_746 + 96]
                                                require mem[_746 + 128] < 5
                                                mem[_753 + 128] = mem[_746 + 128]
                                                mem[_753 + 160] = mem[_746 + 160]
                                                mem[_753 + 192] = mem[_746 + 192]
                                                mem[_753 + 224] = mem[_746 + 224]
                                                mem[_753 + 256] = mem[_746 + 256]
                                                mem[_753 + 288] = mem[_746 + 288]
                                                mem[_753 + 320] = mem[_746 + 320]
                                                if Mask(128, 128, mem[_753]) != Mask(128, 128, _689):
                                                    revert with 0, 'Address does not contain stake with provided id'
                                                idx = mem[_753 + 192]
                                                s = 0
                                                while idx < ext_call.return_data[192] + ext_call.return_data[224]:
                                                    staticcall sub_413c05c6Address.0x8ce1d9e4 with:
                                                            gas gas_remaining wei
                                                           args idx
                                                    mem[mem[64] len 160] = ext_call.return_data[0 len 160]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _1286 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 160
                                                    _1298 = mem[64]
                                                    if mem[64] + 160 > test266151307() or mem[64] + 160 < mem[64]:
                                                        revert with 0, 65
                                                    mem[64] = mem[64] + 160
                                                    mem[_1298] = mem[_1286]
                                                    mem[_1298 + 32] = mem[_1286 + 32]
                                                    mem[_1298 + 64] = mem[_1286 + 64]
                                                    mem[_1298 + 96] = mem[_1286 + 96]
                                                    mem[_1298 + 128] = mem[_1286 + 128]
                                                    _1365 = mem[_1298 + 64]
                                                    _1366 = mem[_1298 + 32]
                                                    _1367 = mem[_753 + 64]
                                                    _1368 = mem[_1298]
                                                    _1369 = mem[_1298 + 128]
                                                    _1370 = mem[_1298 + 96]
                                                    if mem[_1298 + 96] > !mem[_1298 + 128]:
                                                        revert with 0, 17
                                                    if mem[_1298 + 96] + mem[_1298 + 128] < mem[_1298 + 96]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if not mem[_1298 + 96] + mem[_1298 + 128]:
                                                        _1406 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_1406] = 26
                                                        mem[_1406 + 32] = 'SafeMath: division by zero'
                                                        if not _1366:
                                                            _1416 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _1416 + 68] = mem[_1406 + idx + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_1416 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _1416 + -mem[64] + 100
                                                        _1438 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_1438] = 26
                                                        mem[_1438 + 32] = 'SafeMath: division by zero'
                                                        if _1365:
                                                            if s > !(0 / _1366 / _1365):
                                                                revert with 0, 17
                                                            if s + (0 / _1366 / _1365) < s:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            if idx == -1:
                                                                revert with 0, 17
                                                            idx = idx + 1
                                                            s = s + (0 / _1366 / _1365)
                                                            continue 
                                                        _1455 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _1455 + 68] = mem[_1438 + idx + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_1455 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _1455 + -mem[64] + 100
                                                    if mem[_1298 + 96] + mem[_1298 + 128] and mem[_1298] > -1 / mem[_1298 + 96] + mem[_1298 + 128]:
                                                        revert with 0, 17
                                                    if not mem[_1298 + 96] + mem[_1298 + 128]:
                                                        revert with 0, 18
                                                    if (mem[_1298 + 96] * mem[_1298]) + (mem[_1298 + 128] * mem[_1298]) / mem[_1298 + 96] + mem[_1298 + 128] != mem[_1298]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not (mem[_1298 + 96] * mem[_1298]) + (mem[_1298 + 128] * mem[_1298]):
                                                        _1429 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_1429] = 26
                                                        mem[_1429 + 32] = 'SafeMath: division by zero'
                                                        if not _1366:
                                                            _1437 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _1437 + 68] = mem[_1429 + idx + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_1437 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _1437 + -mem[64] + 100
                                                        _1484 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_1484] = 26
                                                        mem[_1484 + 32] = 'SafeMath: division by zero'
                                                        if _1365:
                                                            if s > !(0 / _1366 / _1365):
                                                                revert with 0, 17
                                                            if s + (0 / _1366 / _1365) < s:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            if idx == -1:
                                                                revert with 0, 17
                                                            idx = idx + 1
                                                            s = s + (0 / _1366 / _1365)
                                                            continue 
                                                        _1500 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _1500 + 68] = mem[_1484 + idx + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_1500 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _1500 + -mem[64] + 100
                                                    if (mem[_1298 + 96] * mem[_1298]) + (mem[_1298 + 128] * mem[_1298]) and mem[_753 + 64] > -1 / (mem[_1298 + 96] * mem[_1298]) + (mem[_1298 + 128] * mem[_1298]):
                                                        revert with 0, 17
                                                    if not (mem[_1298 + 96] * mem[_1298]) + (mem[_1298 + 128] * mem[_1298]):
                                                        revert with 0, 18
                                                    if (mem[_1298 + 96] * mem[_1298] * mem[_753 + 64]) + (mem[_1298 + 128] * mem[_1298] * mem[_753 + 64]) / (mem[_1298 + 96] * mem[_1298]) + (mem[_1298 + 128] * mem[_1298]) != mem[_753 + 64]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _1471 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_1471] = 26
                                                    mem[_1471 + 32] = 'SafeMath: division by zero'
                                                    if not _1366:
                                                        _1483 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _1483 + 68] = mem[_1471 + idx + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_1483 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _1483 + -mem[64] + 100
                                                    _1527 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_1527] = 26
                                                    mem[_1527 + 32] = 'SafeMath: division by zero'
                                                    if _1365:
                                                        if s > !((_1370 * _1368 * _1367) + (_1369 * _1368 * _1367) / _1366 / _1365):
                                                            revert with 0, 17
                                                        if s + ((_1370 * _1368 * _1367) + (_1369 * _1368 * _1367) / _1366 / _1365) < s:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if idx == -1:
                                                            revert with 0, 17
                                                        idx = idx + 1
                                                        s = s + ((_1370 * _1368 * _1367) + (_1369 * _1368 * _1367) / _1366 / _1365)
                                                        continue 
                                                    _1545 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _1545 + 68] = mem[_1527 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_1545 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _1545 + -mem[64] + 100
                                                if mem[(4 * ceil32(return_data.size)) + 1728] > !s:
                                                    revert with 0, 17
                                                if mem[(4 * ceil32(return_data.size)) + 1728] + s < mem[(4 * ceil32(return_data.size)) + 1728]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if sub_f4a8f345 > !(mem[(4 * ceil32(return_data.size)) + 1728] + s):
                                                    revert with 0, 17
                                                if sub_f4a8f345 + mem[(4 * ceil32(return_data.size)) + 1728] + s < sub_f4a8f345:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                sub_f4a8f345 = sub_f4a8f345 + mem[(4 * ceil32(return_data.size)) + 1728] + s
                                            else:
                                                _690 = mem[(4 * ceil32(return_data.size)) + 1856]
                                                _695 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_695] = 30
                                                mem[_695 + 32] = 'SafeMath: subtraction overflow'
                                                if s > _690:
                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                if _690 < s:
                                                    revert with 0, 17
                                                _757 = mem[(4 * ceil32(return_data.size)) + 1696]
                                                staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                                                        gas gas_remaining wei
                                                       args msg.sender, Mask(128, 128, mem[(4 * ceil32(return_data.size)) + 1696])
                                                mem[mem[64] len 352] = ext_call.return_data[0 len 352]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _774 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 352
                                                _785 = mem[64]
                                                if mem[64] + 352 < mem[64] or mem[64] + 352 > test266151307():
                                                    revert with 0, 65
                                                mem[64] = mem[64] + 352
                                                require mem[_774] == Mask(128, 128, mem[_774])
                                                mem[_785] = mem[_774]
                                                mem[_785 + 32] = mem[_774 + 32]
                                                mem[_785 + 64] = mem[_774 + 64]
                                                mem[_785 + 96] = mem[_774 + 96]
                                                require mem[_774 + 128] < 5
                                                mem[_785 + 128] = mem[_774 + 128]
                                                mem[_785 + 160] = mem[_774 + 160]
                                                mem[_785 + 192] = mem[_774 + 192]
                                                mem[_785 + 224] = mem[_774 + 224]
                                                mem[_785 + 256] = mem[_774 + 256]
                                                mem[_785 + 288] = mem[_774 + 288]
                                                mem[_785 + 320] = mem[_774 + 320]
                                                if Mask(128, 128, mem[_785]) != Mask(128, 128, _757):
                                                    revert with 0, 'Address does not contain stake with provided id'
                                                idx = mem[_785 + 192]
                                                t = 0
                                                while idx < ext_call.return_data[192] + ext_call.return_data[224]:
                                                    staticcall sub_413c05c6Address.0x8ce1d9e4 with:
                                                            gas gas_remaining wei
                                                           args idx
                                                    mem[mem[64] len 160] = ext_call.return_data[0 len 160]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _1288 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 160
                                                    _1299 = mem[64]
                                                    if mem[64] + 160 > test266151307() or mem[64] + 160 < mem[64]:
                                                        revert with 0, 65
                                                    mem[64] = mem[64] + 160
                                                    mem[_1299] = mem[_1288]
                                                    mem[_1299 + 32] = mem[_1288 + 32]
                                                    mem[_1299 + 64] = mem[_1288 + 64]
                                                    mem[_1299 + 96] = mem[_1288 + 96]
                                                    mem[_1299 + 128] = mem[_1288 + 128]
                                                    _1371 = mem[_1299 + 64]
                                                    _1372 = mem[_1299 + 32]
                                                    _1373 = mem[_785 + 64]
                                                    _1374 = mem[_1299]
                                                    _1375 = mem[_1299 + 128]
                                                    _1376 = mem[_1299 + 96]
                                                    if mem[_1299 + 96] > !mem[_1299 + 128]:
                                                        revert with 0, 17
                                                    if mem[_1299 + 96] + mem[_1299 + 128] < mem[_1299 + 96]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if not mem[_1299 + 96] + mem[_1299 + 128]:
                                                        _1408 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_1408] = 26
                                                        mem[_1408 + 32] = 'SafeMath: division by zero'
                                                        if not _1372:
                                                            _1418 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _1418 + 68] = mem[_1408 + idx + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_1418 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _1418 + -mem[64] + 100
                                                        _1440 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_1440] = 26
                                                        mem[_1440 + 32] = 'SafeMath: division by zero'
                                                        if _1371:
                                                            if t > !(0 / _1372 / _1371):
                                                                revert with 0, 17
                                                            if t + (0 / _1372 / _1371) < t:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            if idx == -1:
                                                                revert with 0, 17
                                                            idx = idx + 1
                                                            t = t + (0 / _1372 / _1371)
                                                            continue 
                                                        _1459 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _1459 + 68] = mem[_1440 + idx + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_1459 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _1459 + -mem[64] + 100
                                                    if mem[_1299 + 96] + mem[_1299 + 128] and mem[_1299] > -1 / mem[_1299 + 96] + mem[_1299 + 128]:
                                                        revert with 0, 17
                                                    if not mem[_1299 + 96] + mem[_1299 + 128]:
                                                        revert with 0, 18
                                                    if (mem[_1299 + 96] * mem[_1299]) + (mem[_1299 + 128] * mem[_1299]) / mem[_1299 + 96] + mem[_1299 + 128] != mem[_1299]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not (mem[_1299 + 96] * mem[_1299]) + (mem[_1299 + 128] * mem[_1299]):
                                                        _1431 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_1431] = 26
                                                        mem[_1431 + 32] = 'SafeMath: division by zero'
                                                        if not _1372:
                                                            _1439 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _1439 + 68] = mem[_1431 + idx + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_1439 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _1439 + -mem[64] + 100
                                                        _1487 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_1487] = 26
                                                        mem[_1487 + 32] = 'SafeMath: division by zero'
                                                        if _1371:
                                                            if t > !(0 / _1372 / _1371):
                                                                revert with 0, 17
                                                            if t + (0 / _1372 / _1371) < t:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            if idx == -1:
                                                                revert with 0, 17
                                                            idx = idx + 1
                                                            t = t + (0 / _1372 / _1371)
                                                            continue 
                                                        _1503 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _1503 + 68] = mem[_1487 + idx + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_1503 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _1503 + -mem[64] + 100
                                                    if (mem[_1299 + 96] * mem[_1299]) + (mem[_1299 + 128] * mem[_1299]) and mem[_785 + 64] > -1 / (mem[_1299 + 96] * mem[_1299]) + (mem[_1299 + 128] * mem[_1299]):
                                                        revert with 0, 17
                                                    if not (mem[_1299 + 96] * mem[_1299]) + (mem[_1299 + 128] * mem[_1299]):
                                                        revert with 0, 18
                                                    if (mem[_1299 + 96] * mem[_1299] * mem[_785 + 64]) + (mem[_1299 + 128] * mem[_1299] * mem[_785 + 64]) / (mem[_1299 + 96] * mem[_1299]) + (mem[_1299 + 128] * mem[_1299]) != mem[_785 + 64]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _1474 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_1474] = 26
                                                    mem[_1474 + 32] = 'SafeMath: division by zero'
                                                    if not _1372:
                                                        _1486 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _1486 + 68] = mem[_1474 + idx + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_1486 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _1486 + -mem[64] + 100
                                                    _1530 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_1530] = 26
                                                    mem[_1530 + 32] = 'SafeMath: division by zero'
                                                    if _1371:
                                                        if t > !((_1376 * _1374 * _1373) + (_1375 * _1374 * _1373) / _1372 / _1371):
                                                            revert with 0, 17
                                                        if t + ((_1376 * _1374 * _1373) + (_1375 * _1374 * _1373) / _1372 / _1371) < t:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if idx == -1:
                                                            revert with 0, 17
                                                        idx = idx + 1
                                                        t = t + ((_1376 * _1374 * _1373) + (_1375 * _1374 * _1373) / _1372 / _1371)
                                                        continue 
                                                    _1547 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _1547 + 68] = mem[_1530 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_1547 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _1547 + -mem[64] + 100
                                                if _690 - s > !t:
                                                    revert with 0, 17
                                                if t < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if mem[(4 * ceil32(return_data.size)) + 1728] > !(_690 - s + t):
                                                    revert with 0, 17
                                                if mem[(4 * ceil32(return_data.size)) + 1728] + _690 - s + t < mem[(4 * ceil32(return_data.size)) + 1728]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if sub_f4a8f345 > !(mem[(4 * ceil32(return_data.size)) + 1728] + _690 - s + t):
                                                    revert with 0, 17
                                                if sub_f4a8f345 + mem[(4 * ceil32(return_data.size)) + 1728] + _690 - s + t < sub_f4a8f345:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                sub_f4a8f345 = sub_f4a8f345 + mem[(4 * ceil32(return_data.size)) + 1728] + _690 - s + t
}

function sub_04e35cba(?) {
    require calldata.size - 4 >= 64
    require arg1 == address(arg1)
    require arg2 == Mask(128, 128, arg2)
    if TOKEN_DEFINERAddress != msg.sender:
        revert with 0, 'Wrong sender.'
    if not uint8(stor1.field_160):
        revert with 0, 'Register is disabled'
    mem[96] = 0
    mem[128] = 0
    mem[160] = 0
    mem[192] = 0
    mem[224] = 0
    mem[256] = 0
    mem[288] = 0
    mem[320] = 0
    mem[352] = 0
    mem[384] = 0
    mem[416] = 0
    staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
            gas gas_remaining wei
           args address(arg1), Mask(128, 128, arg2)
    mem[448 len 352] = ext_call.return_data[0 len 352]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 352
    if not bool(ceil32(return_data.size) + 800 <= test266151307()):
        revert with 0, 65
    require ext_call.return_data[0] == Mask(128, 128, ext_call.return_data[0])
    mem[ceil32(return_data.size) + 448] = ext_call.return_data[0]
    mem[ceil32(return_data.size) + 480] = ext_call.return_data[32]
    mem[ceil32(return_data.size) + 512] = ext_call.return_data[64]
    mem[ceil32(return_data.size) + 544] = ext_call.return_data[96]
    require ext_call.return_data[128] < 5
    mem[ceil32(return_data.size) + 576] = ext_call.return_data[128]
    mem[ceil32(return_data.size) + 608] = ext_call.return_data[160]
    mem[ceil32(return_data.size) + 640] = ext_call.return_data[192]
    mem[ceil32(return_data.size) + 672] = ext_call.return_data[224]
    mem[ceil32(return_data.size) + 704] = ext_call.return_data[256]
    mem[ceil32(return_data.size) + 736] = ext_call.return_data[288]
    mem[ceil32(return_data.size) + 768] = ext_call.return_data[320]
    if Mask(128, 128, ext_call.return_data[0]) != Mask(128, 128, arg2):
        revert with 0, 
                    32,
                    46,
                    0xfe53656e64657220646f6573206e6f7420636f6e7461696e207374616b6520776974682070726f76696465642069, mem[ceil32(return_data.size) + 878 len 18] >> 112,
                    0
    if stor9[address(arg1)][Mask(128, 128, arg2)]:
        revert with 0, 'Stake has already been converted'
    if ext_call.return_data[128] > 4:
        revert with 0, 33
    if ext_call.return_data[128] != 2:
        revert with 0, 
                    32,
                    44,
                    0x795374616b65206973206f6e6c7920656c696769626c6520696620697420686173206265656e20636c6f7365, mem[ceil32(return_data.size) + 876 len 20] >> 96,
                    0
    if ext_call.return_data[192] >= sub_be647a94:
        revert with 0, 
                    32,
                    65,
                    0x645374616b65206973206f6e6c7920656c696769626c65206966206974207761732063726561746564207072696f7220746f2074686520637574206f6666206461, mem[ceil32(return_data.size) + 897 len 31] >> 264,
                    0
    if ext_call.return_data[192] > !ext_call.return_data[224]:
        revert with 0, 17
    if ext_call.return_data[192] + ext_call.return_data[224] < sub_be647a94:
        revert with 0, 
                    32,
                    66,
                    0x645374616b65206973206f6e6c7920656c696769626c652069662069742077617320656e646564206f6e2074686520637574206f666620646179206f722061667465, mem[ceil32(return_data.size) + 898 len 30] >> 272,
                    0
    mem[ceil32(return_data.size) + 800] = 17
    mem[ceil32(return_data.size) + 832] = 'Stake is eligible' << 120
    if stor8[address(arg1)][Mask(128, 128, arg2)]:
        revert with 0, 'Stake has already been registered'
    stor8[address(arg1)][Mask(128, 128, arg2)] = 1
    mem[ceil32(return_data.size) + 864] = address(arg1)
    mem[ceil32(return_data.size) + 896] = Mask(128, 128, arg2)
    sub_4c86259e[stor10].field_0 = address(arg1)
    sub_4c86259e[stor10].field_256 = 0
    sub_4c86259e[stor10].field_512 = 0
    if sub_d3a8b1da == -1:
        revert with 0, 17
    sub_d3a8b1da++
    if 1 > !sub_2c8bff0e[address(arg1)]:
        revert with 0, 17
    sub_2c8bff0e[address(arg1)]++
    if 1 > !sub_ed73481d:
        revert with 0, 17
    mem[ceil32(return_data.size) + 928] = 0
    mem[ceil32(return_data.size) + 960] = 0
    mem[ceil32(return_data.size) + 992] = 0
    mem[ceil32(return_data.size) + 1024] = 0
    mem[ceil32(return_data.size) + 1056] = 0
    mem[ceil32(return_data.size) + 1088] = 0
    mem[ceil32(return_data.size) + 1120] = 0
    mem[ceil32(return_data.size) + 1152] = 0
    mem[ceil32(return_data.size) + 1184] = 0
    mem[ceil32(return_data.size) + 1216] = 0
    mem[ceil32(return_data.size) + 1248] = 0
    staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
            gas gas_remaining wei
           args address(arg1), Mask(128, 128, arg2)
    mem[ceil32(return_data.size) + 1280 len 352] = ext_call.return_data[0 len 352]
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 352
    if not bool((2 * ceil32(return_data.size)) + 1632 <= test266151307()):
        revert with 0, 65
    require ext_call.return_data[0] == Mask(128, 128, ext_call.return_data[0])
    mem[(2 * ceil32(return_data.size)) + 1280] = ext_call.return_data[0]
    mem[(2 * ceil32(return_data.size)) + 1312] = ext_call.return_data[32]
    mem[(2 * ceil32(return_data.size)) + 1344] = ext_call.return_data[64]
    mem[(2 * ceil32(return_data.size)) + 1376] = ext_call.return_data[96]
    require ext_call.return_data[128] < 5
    mem[(2 * ceil32(return_data.size)) + 1408] = ext_call.return_data[128]
    mem[(2 * ceil32(return_data.size)) + 1440] = ext_call.return_data[160]
    mem[(2 * ceil32(return_data.size)) + 1472] = ext_call.return_data[192]
    mem[(2 * ceil32(return_data.size)) + 1504] = ext_call.return_data[224]
    mem[(2 * ceil32(return_data.size)) + 1536] = ext_call.return_data[256]
    mem[(2 * ceil32(return_data.size)) + 1568] = ext_call.return_data[288]
    mem[(2 * ceil32(return_data.size)) + 1600] = ext_call.return_data[320]
    if Mask(128, 128, ext_call.return_data[0]) != Mask(128, 128, arg2):
        if sub_f4a8f345 > -1:
            revert with 0, 17
        if sub_f4a8f345 < sub_f4a8f345:
            revert with 0, 'SafeMath: addition overflow'
    else:
        mem[0] = Mask(128, 128, arg2)
        mem[32] = sha3(address(arg1), 9)
        if stor9[address(arg1)][Mask(128, 128, arg2)]:
            if sub_f4a8f345 > -1:
                revert with 0, 17
            if sub_f4a8f345 < sub_f4a8f345:
                revert with 0, 'SafeMath: addition overflow'
        else:
            if ext_call.return_data[128] > 4:
                revert with 0, 33
            if ext_call.return_data[128] != 2:
                if sub_f4a8f345 > -1:
                    revert with 0, 17
                if sub_f4a8f345 < sub_f4a8f345:
                    revert with 0, 'SafeMath: addition overflow'
            else:
                if ext_call.return_data[192] >= sub_be647a94:
                    if sub_f4a8f345 > -1:
                        revert with 0, 17
                    if sub_f4a8f345 < sub_f4a8f345:
                        revert with 0, 'SafeMath: addition overflow'
                else:
                    if ext_call.return_data[192] > !ext_call.return_data[224]:
                        revert with 0, 17
                    if ext_call.return_data[192] + ext_call.return_data[224] < sub_be647a94:
                        if sub_f4a8f345 > -1:
                            revert with 0, 17
                        if sub_f4a8f345 < sub_f4a8f345:
                            revert with 0, 'SafeMath: addition overflow'
                    else:
                        mem[(2 * ceil32(return_data.size)) + 1632] = 17
                        mem[(2 * ceil32(return_data.size)) + 1664] = 'Stake is eligible' << 120
                        staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                                gas gas_remaining wei
                               args address(arg1), Mask(128, 128, arg2)
                        mem[(2 * ceil32(return_data.size)) + 1696 len 352] = ext_call.return_data[0 len 352]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        require return_data.size >= 352
                        if not bool((4 * ceil32(return_data.size)) + 2048 <= test266151307()):
                            revert with 0, 65
                        require ext_call.return_data[0] == Mask(128, 128, ext_call.return_data[0])
                        mem[(4 * ceil32(return_data.size)) + 1696] = ext_call.return_data[0]
                        mem[(4 * ceil32(return_data.size)) + 1728] = ext_call.return_data[32]
                        mem[(4 * ceil32(return_data.size)) + 1760] = ext_call.return_data[64]
                        mem[(4 * ceil32(return_data.size)) + 1792] = ext_call.return_data[96]
                        require ext_call.return_data[128] < 5
                        mem[(4 * ceil32(return_data.size)) + 1824] = ext_call.return_data[128]
                        mem[(4 * ceil32(return_data.size)) + 1856] = ext_call.return_data[160]
                        mem[(4 * ceil32(return_data.size)) + 1888] = ext_call.return_data[192]
                        mem[(4 * ceil32(return_data.size)) + 1920] = ext_call.return_data[224]
                        mem[(4 * ceil32(return_data.size)) + 1952] = ext_call.return_data[256]
                        mem[(4 * ceil32(return_data.size)) + 1984] = ext_call.return_data[288]
                        mem[(4 * ceil32(return_data.size)) + 2016] = ext_call.return_data[320]
                        if Mask(128, 128, ext_call.return_data[0]) != Mask(128, 128, arg2):
                            revert with 0, 'Address does not contain stake with provided id'
                        if ext_call.return_data[128] > 4:
                            revert with 0, 33
                        if ext_call.return_data[128] == 3:
                            if sub_f4a8f345 > -1:
                                revert with 0, 17
                            if sub_f4a8f345 < sub_f4a8f345:
                                revert with 0, 'SafeMath: addition overflow'
                        else:
                            if ext_call.return_data[128] > 4:
                                revert with 0, 33
                            if ext_call.return_data[128] == 4:
                                if sub_f4a8f345 > -1:
                                    revert with 0, 17
                                if sub_f4a8f345 < sub_f4a8f345:
                                    revert with 0, 'SafeMath: addition overflow'
                            else:
                                if ext_call.return_data[128] > 4:
                                    revert with 0, 33
                                if ext_call.return_data[128] == 1:
                                    if sub_f4a8f345 > -1:
                                        revert with 0, 17
                                    if sub_f4a8f345 < sub_f4a8f345:
                                        revert with 0, 'SafeMath: addition overflow'
                                else:
                                    if ext_call.return_data[128] > 4:
                                        revert with 0, 33
                                    if not ext_call.return_data[128]:
                                        staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                                                gas gas_remaining wei
                                               args address(arg1), Mask(128, 128, ext_call.return_data[0])
                                        mem[(4 * ceil32(return_data.size)) + 2048 len 352] = ext_call.return_data[0 len 352]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 352
                                        if not bool((6 * ceil32(return_data.size)) + 2400 <= test266151307()):
                                            revert with 0, 65
                                        mem[64] = (6 * ceil32(return_data.size)) + 2400
                                        require ext_call.return_data[0] == Mask(128, 128, ext_call.return_data[0])
                                        mem[(6 * ceil32(return_data.size)) + 2048] = ext_call.return_data[0]
                                        mem[(6 * ceil32(return_data.size)) + 2080] = ext_call.return_data[32]
                                        mem[(6 * ceil32(return_data.size)) + 2112] = ext_call.return_data[64]
                                        mem[(6 * ceil32(return_data.size)) + 2144] = ext_call.return_data[96]
                                        require ext_call.return_data[128] < 5
                                        mem[(6 * ceil32(return_data.size)) + 2176] = ext_call.return_data[128]
                                        mem[(6 * ceil32(return_data.size)) + 2208] = ext_call.return_data[160]
                                        mem[(6 * ceil32(return_data.size)) + 2240] = ext_call.return_data[192]
                                        mem[(6 * ceil32(return_data.size)) + 2272] = ext_call.return_data[224]
                                        mem[(6 * ceil32(return_data.size)) + 2304] = ext_call.return_data[256]
                                        mem[(6 * ceil32(return_data.size)) + 2336] = ext_call.return_data[288]
                                        mem[(6 * ceil32(return_data.size)) + 2368] = ext_call.return_data[320]
                                        if Mask(128, 128, ext_call.return_data[0]) != Mask(128, 128, ext_call.return_data[0]):
                                            revert with 0, 'Address does not contain stake with provided id'
                                        idx = mem[(6 * ceil32(return_data.size)) + 2240]
                                        s = 0
                                        while idx < sub_ed73481d + 1:
                                            staticcall sub_413c05c6Address.0x8ce1d9e4 with:
                                                    gas gas_remaining wei
                                                   args idx
                                            mem[mem[64] len 160] = ext_call.return_data[0 len 160]
                                            if not ext_call.success:
                                                revert with ext_call.return_data[0 len return_data.size]
                                            _658 = mem[64]
                                            mem[64] = mem[64] + ceil32(return_data.size)
                                            require return_data.size >= 160
                                            _669 = mem[64]
                                            if mem[64] + 160 > test266151307() or mem[64] + 160 < mem[64]:
                                                revert with 0, 65
                                            mem[64] = mem[64] + 160
                                            mem[_669] = mem[_658]
                                            mem[_669 + 32] = mem[_658 + 32]
                                            mem[_669 + 64] = mem[_658 + 64]
                                            mem[_669 + 96] = mem[_658 + 96]
                                            mem[_669 + 128] = mem[_658 + 128]
                                            _711 = mem[_669 + 64]
                                            _712 = mem[_669 + 32]
                                            _713 = mem[(6 * ceil32(return_data.size)) + 2112]
                                            _714 = mem[_669]
                                            _715 = mem[_669 + 128]
                                            _716 = mem[_669 + 96]
                                            if mem[_669 + 96] > !mem[_669 + 128]:
                                                revert with 0, 17
                                            if mem[_669 + 96] + mem[_669 + 128] < mem[_669 + 96]:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if not mem[_669 + 96] + mem[_669 + 128]:
                                                _780 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_780] = 26
                                                mem[_780 + 32] = 'SafeMath: division by zero'
                                                if not _712:
                                                    _791 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _791 + 68] = mem[_780 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_791 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _791 + -mem[64] + 100
                                                _863 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_863] = 26
                                                mem[_863 + 32] = 'SafeMath: division by zero'
                                                if _711:
                                                    if s > !(0 / _712 / _711):
                                                        revert with 0, 17
                                                    if s + (0 / _712 / _711) < s:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if idx == -1:
                                                        revert with 0, 17
                                                    idx = idx + 1
                                                    s = s + (0 / _712 / _711)
                                                    continue 
                                                _881 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _881 + 68] = mem[_863 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_881 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _881 + -mem[64] + 100
                                            if mem[_669 + 96] + mem[_669 + 128] and mem[_669] > -1 / mem[_669 + 96] + mem[_669 + 128]:
                                                revert with 0, 17
                                            if not mem[_669 + 96] + mem[_669 + 128]:
                                                revert with 0, 18
                                            if (mem[_669 + 96] * mem[_669]) + (mem[_669 + 128] * mem[_669]) / mem[_669 + 96] + mem[_669 + 128] != mem[_669]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            if not (mem[_669 + 96] * mem[_669]) + (mem[_669 + 128] * mem[_669]):
                                                _820 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_820] = 26
                                                mem[_820 + 32] = 'SafeMath: division by zero'
                                                if not _712:
                                                    _862 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _862 + 68] = mem[_820 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_862 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _862 + -mem[64] + 100
                                                _922 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_922] = 26
                                                mem[_922 + 32] = 'SafeMath: division by zero'
                                                if _711:
                                                    if s > !(0 / _712 / _711):
                                                        revert with 0, 17
                                                    if s + (0 / _712 / _711) < s:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if idx == -1:
                                                        revert with 0, 17
                                                    idx = idx + 1
                                                    s = s + (0 / _712 / _711)
                                                    continue 
                                                _956 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _956 + 68] = mem[_922 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_956 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _956 + -mem[64] + 100
                                            if (mem[_669 + 96] * mem[_669]) + (mem[_669 + 128] * mem[_669]) and mem[(6 * ceil32(return_data.size)) + 2112] > -1 / (mem[_669 + 96] * mem[_669]) + (mem[_669 + 128] * mem[_669]):
                                                revert with 0, 17
                                            if not (mem[_669 + 96] * mem[_669]) + (mem[_669 + 128] * mem[_669]):
                                                revert with 0, 18
                                            if (mem[_669 + 96] * mem[_669] * mem[(6 * ceil32(return_data.size)) + 2112]) + (mem[_669 + 128] * mem[_669] * mem[(6 * ceil32(return_data.size)) + 2112]) / (mem[_669 + 96] * mem[_669]) + (mem[_669 + 128] * mem[_669]) != mem[(6 * ceil32(return_data.size)) + 2112]:
                                                revert with 0, 'SafeMath: multiplication overflow'
                                            _902 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_902] = 26
                                            mem[_902 + 32] = 'SafeMath: division by zero'
                                            if not _712:
                                                _921 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _921 + 68] = mem[_902 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_921 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _921 + -mem[64] + 100
                                            _984 = mem[64]
                                            mem[64] = mem[64] + 64
                                            mem[_984] = 26
                                            mem[_984 + 32] = 'SafeMath: division by zero'
                                            if _711:
                                                if s > !((_716 * _714 * _713) + (_715 * _714 * _713) / _712 / _711):
                                                    revert with 0, 17
                                                if s + ((_716 * _714 * _713) + (_715 * _714 * _713) / _712 / _711) < s:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if idx == -1:
                                                    revert with 0, 17
                                                idx = idx + 1
                                                s = s + ((_716 * _714 * _713) + (_715 * _714 * _713) / _712 / _711)
                                                continue 
                                            _1001 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _1001 + 68] = mem[_984 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_1001 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _1001 + -mem[64] + 100
                                        if mem[(4 * ceil32(return_data.size)) + 1856] > !s:
                                            revert with 0, 17
                                        if mem[(4 * ceil32(return_data.size)) + 1856] + s < mem[(4 * ceil32(return_data.size)) + 1856]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if mem[(4 * ceil32(return_data.size)) + 1728] > !(mem[(4 * ceil32(return_data.size)) + 1856] + s):
                                            revert with 0, 17
                                        if mem[(4 * ceil32(return_data.size)) + 1728] + mem[(4 * ceil32(return_data.size)) + 1856] + s < mem[(4 * ceil32(return_data.size)) + 1728]:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if sub_f4a8f345 > !(mem[(4 * ceil32(return_data.size)) + 1728] + mem[(4 * ceil32(return_data.size)) + 1856] + s):
                                            revert with 0, 17
                                        if sub_f4a8f345 + mem[(4 * ceil32(return_data.size)) + 1728] + mem[(4 * ceil32(return_data.size)) + 1856] + s < sub_f4a8f345:
                                            revert with 0, 'SafeMath: addition overflow'
                                        sub_f4a8f345 = sub_f4a8f345 + mem[(4 * ceil32(return_data.size)) + 1728] + mem[(4 * ceil32(return_data.size)) + 1856] + s
                                    else:
                                        if ext_call.return_data[192] > !ext_call.return_data[224]:
                                            revert with 0, 17
                                        staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                                                gas gas_remaining wei
                                               args address(arg1), Mask(128, 128, ext_call.return_data[0])
                                        mem[(4 * ceil32(return_data.size)) + 2048 len 352] = ext_call.return_data[0 len 352]
                                        if not ext_call.success:
                                            revert with ext_call.return_data[0 len return_data.size]
                                        require return_data.size >= 352
                                        if not bool((6 * ceil32(return_data.size)) + 2400 <= test266151307()):
                                            revert with 0, 65
                                        mem[64] = (6 * ceil32(return_data.size)) + 2400
                                        require ext_call.return_data[0] == Mask(128, 128, ext_call.return_data[0])
                                        mem[(6 * ceil32(return_data.size)) + 2048] = ext_call.return_data[0]
                                        mem[(6 * ceil32(return_data.size)) + 2080] = ext_call.return_data[32]
                                        mem[(6 * ceil32(return_data.size)) + 2112] = ext_call.return_data[64]
                                        mem[(6 * ceil32(return_data.size)) + 2144] = ext_call.return_data[96]
                                        require ext_call.return_data[128] < 5
                                        mem[(6 * ceil32(return_data.size)) + 2176] = ext_call.return_data[128]
                                        mem[(6 * ceil32(return_data.size)) + 2208] = ext_call.return_data[160]
                                        mem[(6 * ceil32(return_data.size)) + 2240] = ext_call.return_data[192]
                                        mem[(6 * ceil32(return_data.size)) + 2272] = ext_call.return_data[224]
                                        mem[(6 * ceil32(return_data.size)) + 2304] = ext_call.return_data[256]
                                        mem[(6 * ceil32(return_data.size)) + 2336] = ext_call.return_data[288]
                                        mem[(6 * ceil32(return_data.size)) + 2368] = ext_call.return_data[320]
                                        if Mask(128, 128, ext_call.return_data[0]) != Mask(128, 128, ext_call.return_data[0]):
                                            revert with 0, 'Address does not contain stake with provided id'
                                        if sub_ed73481d + 1 < ext_call.return_data[192] + ext_call.return_data[224]:
                                            idx = mem[(6 * ceil32(return_data.size)) + 2240]
                                            s = 0
                                            while idx < ext_call.return_data[192] + ext_call.return_data[224]:
                                                staticcall sub_413c05c6Address.0x8ce1d9e4 with:
                                                        gas gas_remaining wei
                                                       args idx
                                                mem[mem[64] len 160] = ext_call.return_data[0 len 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _653 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 160
                                                _665 = mem[64]
                                                if mem[64] + 160 > test266151307() or mem[64] + 160 < mem[64]:
                                                    revert with 0, 65
                                                mem[64] = mem[64] + 160
                                                mem[_665] = mem[_653]
                                                mem[_665 + 32] = mem[_653 + 32]
                                                mem[_665 + 64] = mem[_653 + 64]
                                                mem[_665 + 96] = mem[_653 + 96]
                                                mem[_665 + 128] = mem[_653 + 128]
                                                _697 = mem[_665 + 64]
                                                _698 = mem[_665 + 32]
                                                _699 = mem[(6 * ceil32(return_data.size)) + 2112]
                                                _700 = mem[_665]
                                                _701 = mem[_665 + 128]
                                                _702 = mem[_665 + 96]
                                                if mem[_665 + 96] > !mem[_665 + 128]:
                                                    revert with 0, 17
                                                if mem[_665 + 96] + mem[_665 + 128] < mem[_665 + 96]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not mem[_665 + 96] + mem[_665 + 128]:
                                                    _774 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_774] = 26
                                                    mem[_774 + 32] = 'SafeMath: division by zero'
                                                    if not _698:
                                                        _788 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _788 + 68] = mem[_774 + idx + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_788 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _788 + -mem[64] + 100
                                                    _852 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_852] = 26
                                                    mem[_852 + 32] = 'SafeMath: division by zero'
                                                    if _697:
                                                        if s > !(0 / _698 / _697):
                                                            revert with 0, 17
                                                        if s + (0 / _698 / _697) < s:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if idx == -1:
                                                            revert with 0, 17
                                                        idx = idx + 1
                                                        s = s + (0 / _698 / _697)
                                                        continue 
                                                    _873 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _873 + 68] = mem[_852 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_873 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _873 + -mem[64] + 100
                                                if mem[_665 + 96] + mem[_665 + 128] and mem[_665] > -1 / mem[_665 + 96] + mem[_665 + 128]:
                                                    revert with 0, 17
                                                if not mem[_665 + 96] + mem[_665 + 128]:
                                                    revert with 0, 18
                                                if (mem[_665 + 96] * mem[_665]) + (mem[_665 + 128] * mem[_665]) / mem[_665 + 96] + mem[_665 + 128] != mem[_665]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not (mem[_665 + 96] * mem[_665]) + (mem[_665 + 128] * mem[_665]):
                                                    _815 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_815] = 26
                                                    mem[_815 + 32] = 'SafeMath: division by zero'
                                                    if not _698:
                                                        _851 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _851 + 68] = mem[_815 + idx + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_851 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _851 + -mem[64] + 100
                                                    _913 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_913] = 26
                                                    mem[_913 + 32] = 'SafeMath: division by zero'
                                                    if _697:
                                                        if s > !(0 / _698 / _697):
                                                            revert with 0, 17
                                                        if s + (0 / _698 / _697) < s:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if idx == -1:
                                                            revert with 0, 17
                                                        idx = idx + 1
                                                        s = s + (0 / _698 / _697)
                                                        continue 
                                                    _944 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _944 + 68] = mem[_913 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_944 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _944 + -mem[64] + 100
                                                if (mem[_665 + 96] * mem[_665]) + (mem[_665 + 128] * mem[_665]) and mem[(6 * ceil32(return_data.size)) + 2112] > -1 / (mem[_665 + 96] * mem[_665]) + (mem[_665 + 128] * mem[_665]):
                                                    revert with 0, 17
                                                if not (mem[_665 + 96] * mem[_665]) + (mem[_665 + 128] * mem[_665]):
                                                    revert with 0, 18
                                                if (mem[_665 + 96] * mem[_665] * mem[(6 * ceil32(return_data.size)) + 2112]) + (mem[_665 + 128] * mem[_665] * mem[(6 * ceil32(return_data.size)) + 2112]) / (mem[_665 + 96] * mem[_665]) + (mem[_665 + 128] * mem[_665]) != mem[(6 * ceil32(return_data.size)) + 2112]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _894 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_894] = 26
                                                mem[_894 + 32] = 'SafeMath: division by zero'
                                                if not _698:
                                                    _912 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _912 + 68] = mem[_894 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_912 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _912 + -mem[64] + 100
                                                _977 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_977] = 26
                                                mem[_977 + 32] = 'SafeMath: division by zero'
                                                if _697:
                                                    if s > !((_702 * _700 * _699) + (_701 * _700 * _699) / _698 / _697):
                                                        revert with 0, 17
                                                    if s + ((_702 * _700 * _699) + (_701 * _700 * _699) / _698 / _697) < s:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if idx == -1:
                                                        revert with 0, 17
                                                    idx = idx + 1
                                                    s = s + ((_702 * _700 * _699) + (_701 * _700 * _699) / _698 / _697)
                                                    continue 
                                                _996 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _996 + 68] = mem[_977 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_996 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _996 + -mem[64] + 100
                                            if s >= mem[(4 * ceil32(return_data.size)) + 1856]:
                                                _659 = mem[(4 * ceil32(return_data.size)) + 1696]
                                                staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                                                        gas gas_remaining wei
                                                       args address(arg1), Mask(128, 128, mem[(4 * ceil32(return_data.size)) + 1696])
                                                mem[mem[64] len 352] = ext_call.return_data[0 len 352]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _717 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 352
                                                _723 = mem[64]
                                                if mem[64] + 352 < mem[64] or mem[64] + 352 > test266151307():
                                                    revert with 0, 65
                                                mem[64] = mem[64] + 352
                                                require mem[_717] == Mask(128, 128, mem[_717])
                                                mem[_723] = mem[_717]
                                                mem[_723 + 32] = mem[_717 + 32]
                                                mem[_723 + 64] = mem[_717 + 64]
                                                mem[_723 + 96] = mem[_717 + 96]
                                                require mem[_717 + 128] < 5
                                                mem[_723 + 128] = mem[_717 + 128]
                                                mem[_723 + 160] = mem[_717 + 160]
                                                mem[_723 + 192] = mem[_717 + 192]
                                                mem[_723 + 224] = mem[_717 + 224]
                                                mem[_723 + 256] = mem[_717 + 256]
                                                mem[_723 + 288] = mem[_717 + 288]
                                                mem[_723 + 320] = mem[_717 + 320]
                                                if Mask(128, 128, mem[_723]) != Mask(128, 128, _659):
                                                    revert with 0, 'Address does not contain stake with provided id'
                                                idx = mem[_723 + 192]
                                                s = 0
                                                while idx < sub_ed73481d + 1:
                                                    staticcall sub_413c05c6Address.0x8ce1d9e4 with:
                                                            gas gas_remaining wei
                                                           args idx
                                                    mem[mem[64] len 160] = ext_call.return_data[0 len 160]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _1254 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 160
                                                    _1261 = mem[64]
                                                    if mem[64] + 160 > test266151307() or mem[64] + 160 < mem[64]:
                                                        revert with 0, 65
                                                    mem[64] = mem[64] + 160
                                                    mem[_1261] = mem[_1254]
                                                    mem[_1261 + 32] = mem[_1254 + 32]
                                                    mem[_1261 + 64] = mem[_1254 + 64]
                                                    mem[_1261 + 96] = mem[_1254 + 96]
                                                    mem[_1261 + 128] = mem[_1254 + 128]
                                                    _1325 = mem[_1261 + 64]
                                                    _1326 = mem[_1261 + 32]
                                                    _1327 = mem[_723 + 64]
                                                    _1328 = mem[_1261]
                                                    _1329 = mem[_1261 + 128]
                                                    _1330 = mem[_1261 + 96]
                                                    if mem[_1261 + 96] > !mem[_1261 + 128]:
                                                        revert with 0, 17
                                                    if mem[_1261 + 96] + mem[_1261 + 128] < mem[_1261 + 96]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if not mem[_1261 + 96] + mem[_1261 + 128]:
                                                        _1374 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_1374] = 26
                                                        mem[_1374 + 32] = 'SafeMath: division by zero'
                                                        if not _1326:
                                                            _1385 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _1385 + 68] = mem[_1374 + idx + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_1385 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _1385 + -mem[64] + 100
                                                        _1406 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_1406] = 26
                                                        mem[_1406 + 32] = 'SafeMath: division by zero'
                                                        if _1325:
                                                            if s > !(0 / _1326 / _1325):
                                                                revert with 0, 17
                                                            if s + (0 / _1326 / _1325) < s:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            if idx == -1:
                                                                revert with 0, 17
                                                            idx = idx + 1
                                                            s = s + (0 / _1326 / _1325)
                                                            continue 
                                                        _1419 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _1419 + 68] = mem[_1406 + idx + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_1419 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _1419 + -mem[64] + 100
                                                    if mem[_1261 + 96] + mem[_1261 + 128] and mem[_1261] > -1 / mem[_1261 + 96] + mem[_1261 + 128]:
                                                        revert with 0, 17
                                                    if not mem[_1261 + 96] + mem[_1261 + 128]:
                                                        revert with 0, 18
                                                    if (mem[_1261 + 96] * mem[_1261]) + (mem[_1261 + 128] * mem[_1261]) / mem[_1261 + 96] + mem[_1261 + 128] != mem[_1261]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not (mem[_1261 + 96] * mem[_1261]) + (mem[_1261 + 128] * mem[_1261]):
                                                        _1397 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_1397] = 26
                                                        mem[_1397 + 32] = 'SafeMath: division by zero'
                                                        if not _1326:
                                                            _1405 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _1405 + 68] = mem[_1397 + idx + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_1405 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _1405 + -mem[64] + 100
                                                        _1450 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_1450] = 26
                                                        mem[_1450 + 32] = 'SafeMath: division by zero'
                                                        if _1325:
                                                            if s > !(0 / _1326 / _1325):
                                                                revert with 0, 17
                                                            if s + (0 / _1326 / _1325) < s:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            if idx == -1:
                                                                revert with 0, 17
                                                            idx = idx + 1
                                                            s = s + (0 / _1326 / _1325)
                                                            continue 
                                                        _1466 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _1466 + 68] = mem[_1450 + idx + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_1466 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _1466 + -mem[64] + 100
                                                    if (mem[_1261 + 96] * mem[_1261]) + (mem[_1261 + 128] * mem[_1261]) and mem[_723 + 64] > -1 / (mem[_1261 + 96] * mem[_1261]) + (mem[_1261 + 128] * mem[_1261]):
                                                        revert with 0, 17
                                                    if not (mem[_1261 + 96] * mem[_1261]) + (mem[_1261 + 128] * mem[_1261]):
                                                        revert with 0, 18
                                                    if (mem[_1261 + 96] * mem[_1261] * mem[_723 + 64]) + (mem[_1261 + 128] * mem[_1261] * mem[_723 + 64]) / (mem[_1261 + 96] * mem[_1261]) + (mem[_1261 + 128] * mem[_1261]) != mem[_723 + 64]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _1437 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_1437] = 26
                                                    mem[_1437 + 32] = 'SafeMath: division by zero'
                                                    if not _1326:
                                                        _1449 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _1449 + 68] = mem[_1437 + idx + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_1449 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _1449 + -mem[64] + 100
                                                    _1493 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_1493] = 26
                                                    mem[_1493 + 32] = 'SafeMath: division by zero'
                                                    if _1325:
                                                        if s > !((_1330 * _1328 * _1327) + (_1329 * _1328 * _1327) / _1326 / _1325):
                                                            revert with 0, 17
                                                        if s + ((_1330 * _1328 * _1327) + (_1329 * _1328 * _1327) / _1326 / _1325) < s:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if idx == -1:
                                                            revert with 0, 17
                                                        idx = idx + 1
                                                        s = s + ((_1330 * _1328 * _1327) + (_1329 * _1328 * _1327) / _1326 / _1325)
                                                        continue 
                                                    _1513 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _1513 + 68] = mem[_1493 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_1513 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _1513 + -mem[64] + 100
                                                if mem[(4 * ceil32(return_data.size)) + 1728] > !s:
                                                    revert with 0, 17
                                                if mem[(4 * ceil32(return_data.size)) + 1728] + s < mem[(4 * ceil32(return_data.size)) + 1728]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if sub_f4a8f345 > !(mem[(4 * ceil32(return_data.size)) + 1728] + s):
                                                    revert with 0, 17
                                                if sub_f4a8f345 + mem[(4 * ceil32(return_data.size)) + 1728] + s < sub_f4a8f345:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                sub_f4a8f345 = sub_f4a8f345 + mem[(4 * ceil32(return_data.size)) + 1728] + s
                                            else:
                                                _660 = mem[(4 * ceil32(return_data.size)) + 1856]
                                                _664 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_664] = 30
                                                mem[_664 + 32] = 'SafeMath: subtraction overflow'
                                                if s > _660:
                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                if _660 < s:
                                                    revert with 0, 17
                                                _727 = mem[(4 * ceil32(return_data.size)) + 1696]
                                                staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                                                        gas gas_remaining wei
                                                       args address(arg1), Mask(128, 128, mem[(4 * ceil32(return_data.size)) + 1696])
                                                mem[mem[64] len 352] = ext_call.return_data[0 len 352]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _745 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 352
                                                _755 = mem[64]
                                                if mem[64] + 352 < mem[64] or mem[64] + 352 > test266151307():
                                                    revert with 0, 65
                                                mem[64] = mem[64] + 352
                                                require mem[_745] == Mask(128, 128, mem[_745])
                                                mem[_755] = mem[_745]
                                                mem[_755 + 32] = mem[_745 + 32]
                                                mem[_755 + 64] = mem[_745 + 64]
                                                mem[_755 + 96] = mem[_745 + 96]
                                                require mem[_745 + 128] < 5
                                                mem[_755 + 128] = mem[_745 + 128]
                                                mem[_755 + 160] = mem[_745 + 160]
                                                mem[_755 + 192] = mem[_745 + 192]
                                                mem[_755 + 224] = mem[_745 + 224]
                                                mem[_755 + 256] = mem[_745 + 256]
                                                mem[_755 + 288] = mem[_745 + 288]
                                                mem[_755 + 320] = mem[_745 + 320]
                                                if Mask(128, 128, mem[_755]) != Mask(128, 128, _727):
                                                    revert with 0, 'Address does not contain stake with provided id'
                                                idx = mem[_755 + 192]
                                                t = 0
                                                while idx < sub_ed73481d + 1:
                                                    staticcall sub_413c05c6Address.0x8ce1d9e4 with:
                                                            gas gas_remaining wei
                                                           args idx
                                                    mem[mem[64] len 160] = ext_call.return_data[0 len 160]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _1256 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 160
                                                    _1262 = mem[64]
                                                    if mem[64] + 160 > test266151307() or mem[64] + 160 < mem[64]:
                                                        revert with 0, 65
                                                    mem[64] = mem[64] + 160
                                                    mem[_1262] = mem[_1256]
                                                    mem[_1262 + 32] = mem[_1256 + 32]
                                                    mem[_1262 + 64] = mem[_1256 + 64]
                                                    mem[_1262 + 96] = mem[_1256 + 96]
                                                    mem[_1262 + 128] = mem[_1256 + 128]
                                                    _1331 = mem[_1262 + 64]
                                                    _1332 = mem[_1262 + 32]
                                                    _1333 = mem[_755 + 64]
                                                    _1334 = mem[_1262]
                                                    _1335 = mem[_1262 + 128]
                                                    _1336 = mem[_1262 + 96]
                                                    if mem[_1262 + 96] > !mem[_1262 + 128]:
                                                        revert with 0, 17
                                                    if mem[_1262 + 96] + mem[_1262 + 128] < mem[_1262 + 96]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if not mem[_1262 + 96] + mem[_1262 + 128]:
                                                        _1376 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_1376] = 26
                                                        mem[_1376 + 32] = 'SafeMath: division by zero'
                                                        if not _1332:
                                                            _1387 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _1387 + 68] = mem[_1376 + idx + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_1387 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _1387 + -mem[64] + 100
                                                        _1408 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_1408] = 26
                                                        mem[_1408 + 32] = 'SafeMath: division by zero'
                                                        if _1331:
                                                            if t > !(0 / _1332 / _1331):
                                                                revert with 0, 17
                                                            if t + (0 / _1332 / _1331) < t:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            if idx == -1:
                                                                revert with 0, 17
                                                            idx = idx + 1
                                                            t = t + (0 / _1332 / _1331)
                                                            continue 
                                                        _1423 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _1423 + 68] = mem[_1408 + idx + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_1423 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _1423 + -mem[64] + 100
                                                    if mem[_1262 + 96] + mem[_1262 + 128] and mem[_1262] > -1 / mem[_1262 + 96] + mem[_1262 + 128]:
                                                        revert with 0, 17
                                                    if not mem[_1262 + 96] + mem[_1262 + 128]:
                                                        revert with 0, 18
                                                    if (mem[_1262 + 96] * mem[_1262]) + (mem[_1262 + 128] * mem[_1262]) / mem[_1262 + 96] + mem[_1262 + 128] != mem[_1262]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not (mem[_1262 + 96] * mem[_1262]) + (mem[_1262 + 128] * mem[_1262]):
                                                        _1399 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_1399] = 26
                                                        mem[_1399 + 32] = 'SafeMath: division by zero'
                                                        if not _1332:
                                                            _1407 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _1407 + 68] = mem[_1399 + idx + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_1407 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _1407 + -mem[64] + 100
                                                        _1453 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_1453] = 26
                                                        mem[_1453 + 32] = 'SafeMath: division by zero'
                                                        if _1331:
                                                            if t > !(0 / _1332 / _1331):
                                                                revert with 0, 17
                                                            if t + (0 / _1332 / _1331) < t:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            if idx == -1:
                                                                revert with 0, 17
                                                            idx = idx + 1
                                                            t = t + (0 / _1332 / _1331)
                                                            continue 
                                                        _1469 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _1469 + 68] = mem[_1453 + idx + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_1469 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _1469 + -mem[64] + 100
                                                    if (mem[_1262 + 96] * mem[_1262]) + (mem[_1262 + 128] * mem[_1262]) and mem[_755 + 64] > -1 / (mem[_1262 + 96] * mem[_1262]) + (mem[_1262 + 128] * mem[_1262]):
                                                        revert with 0, 17
                                                    if not (mem[_1262 + 96] * mem[_1262]) + (mem[_1262 + 128] * mem[_1262]):
                                                        revert with 0, 18
                                                    if (mem[_1262 + 96] * mem[_1262] * mem[_755 + 64]) + (mem[_1262 + 128] * mem[_1262] * mem[_755 + 64]) / (mem[_1262 + 96] * mem[_1262]) + (mem[_1262 + 128] * mem[_1262]) != mem[_755 + 64]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _1440 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_1440] = 26
                                                    mem[_1440 + 32] = 'SafeMath: division by zero'
                                                    if not _1332:
                                                        _1452 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _1452 + 68] = mem[_1440 + idx + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_1452 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _1452 + -mem[64] + 100
                                                    _1496 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_1496] = 26
                                                    mem[_1496 + 32] = 'SafeMath: division by zero'
                                                    if _1331:
                                                        if t > !((_1336 * _1334 * _1333) + (_1335 * _1334 * _1333) / _1332 / _1331):
                                                            revert with 0, 17
                                                        if t + ((_1336 * _1334 * _1333) + (_1335 * _1334 * _1333) / _1332 / _1331) < t:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if idx == -1:
                                                            revert with 0, 17
                                                        idx = idx + 1
                                                        t = t + ((_1336 * _1334 * _1333) + (_1335 * _1334 * _1333) / _1332 / _1331)
                                                        continue 
                                                    _1515 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _1515 + 68] = mem[_1496 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_1515 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _1515 + -mem[64] + 100
                                                if _660 - s > !t:
                                                    revert with 0, 17
                                                if t < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if mem[(4 * ceil32(return_data.size)) + 1728] > !(_660 - s + t):
                                                    revert with 0, 17
                                                if mem[(4 * ceil32(return_data.size)) + 1728] + _660 - s + t < mem[(4 * ceil32(return_data.size)) + 1728]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if sub_f4a8f345 > !(mem[(4 * ceil32(return_data.size)) + 1728] + _660 - s + t):
                                                    revert with 0, 17
                                                if sub_f4a8f345 + mem[(4 * ceil32(return_data.size)) + 1728] + _660 - s + t < sub_f4a8f345:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                sub_f4a8f345 = sub_f4a8f345 + mem[(4 * ceil32(return_data.size)) + 1728] + _660 - s + t
                                        else:
                                            idx = mem[(6 * ceil32(return_data.size)) + 2240]
                                            s = 0
                                            while idx < ext_call.return_data[192] + ext_call.return_data[224]:
                                                staticcall sub_413c05c6Address.0x8ce1d9e4 with:
                                                        gas gas_remaining wei
                                                       args idx
                                                mem[mem[64] len 160] = ext_call.return_data[0 len 160]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _655 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 160
                                                _668 = mem[64]
                                                if mem[64] + 160 > test266151307() or mem[64] + 160 < mem[64]:
                                                    revert with 0, 65
                                                mem[64] = mem[64] + 160
                                                mem[_668] = mem[_655]
                                                mem[_668 + 32] = mem[_655 + 32]
                                                mem[_668 + 64] = mem[_655 + 64]
                                                mem[_668 + 96] = mem[_655 + 96]
                                                mem[_668 + 128] = mem[_655 + 128]
                                                _705 = mem[_668 + 64]
                                                _706 = mem[_668 + 32]
                                                _707 = mem[(6 * ceil32(return_data.size)) + 2112]
                                                _708 = mem[_668]
                                                _709 = mem[_668 + 128]
                                                _710 = mem[_668 + 96]
                                                if mem[_668 + 96] > !mem[_668 + 128]:
                                                    revert with 0, 17
                                                if mem[_668 + 96] + mem[_668 + 128] < mem[_668 + 96]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if not mem[_668 + 96] + mem[_668 + 128]:
                                                    _778 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_778] = 26
                                                    mem[_778 + 32] = 'SafeMath: division by zero'
                                                    if not _706:
                                                        _789 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _789 + 68] = mem[_778 + idx + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_789 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _789 + -mem[64] + 100
                                                    _861 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_861] = 26
                                                    mem[_861 + 32] = 'SafeMath: division by zero'
                                                    if _705:
                                                        if s > !(0 / _706 / _705):
                                                            revert with 0, 17
                                                        if s + (0 / _706 / _705) < s:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if idx == -1:
                                                            revert with 0, 17
                                                        idx = idx + 1
                                                        s = s + (0 / _706 / _705)
                                                        continue 
                                                    _877 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _877 + 68] = mem[_861 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_877 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _877 + -mem[64] + 100
                                                if mem[_668 + 96] + mem[_668 + 128] and mem[_668] > -1 / mem[_668 + 96] + mem[_668 + 128]:
                                                    revert with 0, 17
                                                if not mem[_668 + 96] + mem[_668 + 128]:
                                                    revert with 0, 18
                                                if (mem[_668 + 96] * mem[_668]) + (mem[_668 + 128] * mem[_668]) / mem[_668 + 96] + mem[_668 + 128] != mem[_668]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                if not (mem[_668 + 96] * mem[_668]) + (mem[_668 + 128] * mem[_668]):
                                                    _818 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_818] = 26
                                                    mem[_818 + 32] = 'SafeMath: division by zero'
                                                    if not _706:
                                                        _860 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _860 + 68] = mem[_818 + idx + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_860 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _860 + -mem[64] + 100
                                                    _919 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_919] = 26
                                                    mem[_919 + 32] = 'SafeMath: division by zero'
                                                    if _705:
                                                        if s > !(0 / _706 / _705):
                                                            revert with 0, 17
                                                        if s + (0 / _706 / _705) < s:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if idx == -1:
                                                            revert with 0, 17
                                                        idx = idx + 1
                                                        s = s + (0 / _706 / _705)
                                                        continue 
                                                    _953 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _953 + 68] = mem[_919 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_953 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _953 + -mem[64] + 100
                                                if (mem[_668 + 96] * mem[_668]) + (mem[_668 + 128] * mem[_668]) and mem[(6 * ceil32(return_data.size)) + 2112] > -1 / (mem[_668 + 96] * mem[_668]) + (mem[_668 + 128] * mem[_668]):
                                                    revert with 0, 17
                                                if not (mem[_668 + 96] * mem[_668]) + (mem[_668 + 128] * mem[_668]):
                                                    revert with 0, 18
                                                if (mem[_668 + 96] * mem[_668] * mem[(6 * ceil32(return_data.size)) + 2112]) + (mem[_668 + 128] * mem[_668] * mem[(6 * ceil32(return_data.size)) + 2112]) / (mem[_668 + 96] * mem[_668]) + (mem[_668 + 128] * mem[_668]) != mem[(6 * ceil32(return_data.size)) + 2112]:
                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                _899 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_899] = 26
                                                mem[_899 + 32] = 'SafeMath: division by zero'
                                                if not _706:
                                                    _918 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _918 + 68] = mem[_899 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_918 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _918 + -mem[64] + 100
                                                _981 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_981] = 26
                                                mem[_981 + 32] = 'SafeMath: division by zero'
                                                if _705:
                                                    if s > !((_710 * _708 * _707) + (_709 * _708 * _707) / _706 / _705):
                                                        revert with 0, 17
                                                    if s + ((_710 * _708 * _707) + (_709 * _708 * _707) / _706 / _705) < s:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if idx == -1:
                                                        revert with 0, 17
                                                    idx = idx + 1
                                                    s = s + ((_710 * _708 * _707) + (_709 * _708 * _707) / _706 / _705)
                                                    continue 
                                                _999 = mem[64]
                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                mem[mem[64] + 4] = 32
                                                mem[mem[64] + 36] = 26
                                                idx = 0
                                                while idx < 26:
                                                    mem[idx + _999 + 68] = mem[_981 + idx + 32]
                                                    idx = idx + 32
                                                    continue 
                                                mem[_999 + 94] = 0
                                                revert with memory
                                                  from mem[64]
                                                   len _999 + -mem[64] + 100
                                            if s >= mem[(4 * ceil32(return_data.size)) + 1856]:
                                                _661 = mem[(4 * ceil32(return_data.size)) + 1696]
                                                staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                                                        gas gas_remaining wei
                                                       args address(arg1), Mask(128, 128, mem[(4 * ceil32(return_data.size)) + 1696])
                                                mem[mem[64] len 352] = ext_call.return_data[0 len 352]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _718 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 352
                                                _725 = mem[64]
                                                if mem[64] + 352 < mem[64] or mem[64] + 352 > test266151307():
                                                    revert with 0, 65
                                                mem[64] = mem[64] + 352
                                                require mem[_718] == Mask(128, 128, mem[_718])
                                                mem[_725] = mem[_718]
                                                mem[_725 + 32] = mem[_718 + 32]
                                                mem[_725 + 64] = mem[_718 + 64]
                                                mem[_725 + 96] = mem[_718 + 96]
                                                require mem[_718 + 128] < 5
                                                mem[_725 + 128] = mem[_718 + 128]
                                                mem[_725 + 160] = mem[_718 + 160]
                                                mem[_725 + 192] = mem[_718 + 192]
                                                mem[_725 + 224] = mem[_718 + 224]
                                                mem[_725 + 256] = mem[_718 + 256]
                                                mem[_725 + 288] = mem[_718 + 288]
                                                mem[_725 + 320] = mem[_718 + 320]
                                                if Mask(128, 128, mem[_725]) != Mask(128, 128, _661):
                                                    revert with 0, 'Address does not contain stake with provided id'
                                                idx = mem[_725 + 192]
                                                s = 0
                                                while idx < ext_call.return_data[192] + ext_call.return_data[224]:
                                                    staticcall sub_413c05c6Address.0x8ce1d9e4 with:
                                                            gas gas_remaining wei
                                                           args idx
                                                    mem[mem[64] len 160] = ext_call.return_data[0 len 160]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _1258 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 160
                                                    _1270 = mem[64]
                                                    if mem[64] + 160 > test266151307() or mem[64] + 160 < mem[64]:
                                                        revert with 0, 65
                                                    mem[64] = mem[64] + 160
                                                    mem[_1270] = mem[_1258]
                                                    mem[_1270 + 32] = mem[_1258 + 32]
                                                    mem[_1270 + 64] = mem[_1258 + 64]
                                                    mem[_1270 + 96] = mem[_1258 + 96]
                                                    mem[_1270 + 128] = mem[_1258 + 128]
                                                    _1337 = mem[_1270 + 64]
                                                    _1338 = mem[_1270 + 32]
                                                    _1339 = mem[_725 + 64]
                                                    _1340 = mem[_1270]
                                                    _1341 = mem[_1270 + 128]
                                                    _1342 = mem[_1270 + 96]
                                                    if mem[_1270 + 96] > !mem[_1270 + 128]:
                                                        revert with 0, 17
                                                    if mem[_1270 + 96] + mem[_1270 + 128] < mem[_1270 + 96]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if not mem[_1270 + 96] + mem[_1270 + 128]:
                                                        _1378 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_1378] = 26
                                                        mem[_1378 + 32] = 'SafeMath: division by zero'
                                                        if not _1338:
                                                            _1388 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _1388 + 68] = mem[_1378 + idx + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_1388 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _1388 + -mem[64] + 100
                                                        _1410 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_1410] = 26
                                                        mem[_1410 + 32] = 'SafeMath: division by zero'
                                                        if _1337:
                                                            if s > !(0 / _1338 / _1337):
                                                                revert with 0, 17
                                                            if s + (0 / _1338 / _1337) < s:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            if idx == -1:
                                                                revert with 0, 17
                                                            idx = idx + 1
                                                            s = s + (0 / _1338 / _1337)
                                                            continue 
                                                        _1427 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _1427 + 68] = mem[_1410 + idx + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_1427 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _1427 + -mem[64] + 100
                                                    if mem[_1270 + 96] + mem[_1270 + 128] and mem[_1270] > -1 / mem[_1270 + 96] + mem[_1270 + 128]:
                                                        revert with 0, 17
                                                    if not mem[_1270 + 96] + mem[_1270 + 128]:
                                                        revert with 0, 18
                                                    if (mem[_1270 + 96] * mem[_1270]) + (mem[_1270 + 128] * mem[_1270]) / mem[_1270 + 96] + mem[_1270 + 128] != mem[_1270]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not (mem[_1270 + 96] * mem[_1270]) + (mem[_1270 + 128] * mem[_1270]):
                                                        _1401 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_1401] = 26
                                                        mem[_1401 + 32] = 'SafeMath: division by zero'
                                                        if not _1338:
                                                            _1409 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _1409 + 68] = mem[_1401 + idx + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_1409 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _1409 + -mem[64] + 100
                                                        _1456 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_1456] = 26
                                                        mem[_1456 + 32] = 'SafeMath: division by zero'
                                                        if _1337:
                                                            if s > !(0 / _1338 / _1337):
                                                                revert with 0, 17
                                                            if s + (0 / _1338 / _1337) < s:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            if idx == -1:
                                                                revert with 0, 17
                                                            idx = idx + 1
                                                            s = s + (0 / _1338 / _1337)
                                                            continue 
                                                        _1472 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _1472 + 68] = mem[_1456 + idx + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_1472 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _1472 + -mem[64] + 100
                                                    if (mem[_1270 + 96] * mem[_1270]) + (mem[_1270 + 128] * mem[_1270]) and mem[_725 + 64] > -1 / (mem[_1270 + 96] * mem[_1270]) + (mem[_1270 + 128] * mem[_1270]):
                                                        revert with 0, 17
                                                    if not (mem[_1270 + 96] * mem[_1270]) + (mem[_1270 + 128] * mem[_1270]):
                                                        revert with 0, 18
                                                    if (mem[_1270 + 96] * mem[_1270] * mem[_725 + 64]) + (mem[_1270 + 128] * mem[_1270] * mem[_725 + 64]) / (mem[_1270 + 96] * mem[_1270]) + (mem[_1270 + 128] * mem[_1270]) != mem[_725 + 64]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _1443 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_1443] = 26
                                                    mem[_1443 + 32] = 'SafeMath: division by zero'
                                                    if not _1338:
                                                        _1455 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _1455 + 68] = mem[_1443 + idx + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_1455 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _1455 + -mem[64] + 100
                                                    _1499 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_1499] = 26
                                                    mem[_1499 + 32] = 'SafeMath: division by zero'
                                                    if _1337:
                                                        if s > !((_1342 * _1340 * _1339) + (_1341 * _1340 * _1339) / _1338 / _1337):
                                                            revert with 0, 17
                                                        if s + ((_1342 * _1340 * _1339) + (_1341 * _1340 * _1339) / _1338 / _1337) < s:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if idx == -1:
                                                            revert with 0, 17
                                                        idx = idx + 1
                                                        s = s + ((_1342 * _1340 * _1339) + (_1341 * _1340 * _1339) / _1338 / _1337)
                                                        continue 
                                                    _1517 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _1517 + 68] = mem[_1499 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_1517 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _1517 + -mem[64] + 100
                                                if mem[(4 * ceil32(return_data.size)) + 1728] > !s:
                                                    revert with 0, 17
                                                if mem[(4 * ceil32(return_data.size)) + 1728] + s < mem[(4 * ceil32(return_data.size)) + 1728]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if sub_f4a8f345 > !(mem[(4 * ceil32(return_data.size)) + 1728] + s):
                                                    revert with 0, 17
                                                if sub_f4a8f345 + mem[(4 * ceil32(return_data.size)) + 1728] + s < sub_f4a8f345:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                sub_f4a8f345 = sub_f4a8f345 + mem[(4 * ceil32(return_data.size)) + 1728] + s
                                            else:
                                                _662 = mem[(4 * ceil32(return_data.size)) + 1856]
                                                _667 = mem[64]
                                                mem[64] = mem[64] + 64
                                                mem[_667] = 30
                                                mem[_667 + 32] = 'SafeMath: subtraction overflow'
                                                if s > _662:
                                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                                if _662 < s:
                                                    revert with 0, 17
                                                _729 = mem[(4 * ceil32(return_data.size)) + 1696]
                                                staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                                                        gas gas_remaining wei
                                                       args address(arg1), Mask(128, 128, mem[(4 * ceil32(return_data.size)) + 1696])
                                                mem[mem[64] len 352] = ext_call.return_data[0 len 352]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                _746 = mem[64]
                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                require return_data.size >= 352
                                                _757 = mem[64]
                                                if mem[64] + 352 < mem[64] or mem[64] + 352 > test266151307():
                                                    revert with 0, 65
                                                mem[64] = mem[64] + 352
                                                require mem[_746] == Mask(128, 128, mem[_746])
                                                mem[_757] = mem[_746]
                                                mem[_757 + 32] = mem[_746 + 32]
                                                mem[_757 + 64] = mem[_746 + 64]
                                                mem[_757 + 96] = mem[_746 + 96]
                                                require mem[_746 + 128] < 5
                                                mem[_757 + 128] = mem[_746 + 128]
                                                mem[_757 + 160] = mem[_746 + 160]
                                                mem[_757 + 192] = mem[_746 + 192]
                                                mem[_757 + 224] = mem[_746 + 224]
                                                mem[_757 + 256] = mem[_746 + 256]
                                                mem[_757 + 288] = mem[_746 + 288]
                                                mem[_757 + 320] = mem[_746 + 320]
                                                if Mask(128, 128, mem[_757]) != Mask(128, 128, _729):
                                                    revert with 0, 'Address does not contain stake with provided id'
                                                idx = mem[_757 + 192]
                                                t = 0
                                                while idx < ext_call.return_data[192] + ext_call.return_data[224]:
                                                    staticcall sub_413c05c6Address.0x8ce1d9e4 with:
                                                            gas gas_remaining wei
                                                           args idx
                                                    mem[mem[64] len 160] = ext_call.return_data[0 len 160]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _1260 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 160
                                                    _1271 = mem[64]
                                                    if mem[64] + 160 > test266151307() or mem[64] + 160 < mem[64]:
                                                        revert with 0, 65
                                                    mem[64] = mem[64] + 160
                                                    mem[_1271] = mem[_1260]
                                                    mem[_1271 + 32] = mem[_1260 + 32]
                                                    mem[_1271 + 64] = mem[_1260 + 64]
                                                    mem[_1271 + 96] = mem[_1260 + 96]
                                                    mem[_1271 + 128] = mem[_1260 + 128]
                                                    _1343 = mem[_1271 + 64]
                                                    _1344 = mem[_1271 + 32]
                                                    _1345 = mem[_757 + 64]
                                                    _1346 = mem[_1271]
                                                    _1347 = mem[_1271 + 128]
                                                    _1348 = mem[_1271 + 96]
                                                    if mem[_1271 + 96] > !mem[_1271 + 128]:
                                                        revert with 0, 17
                                                    if mem[_1271 + 96] + mem[_1271 + 128] < mem[_1271 + 96]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if not mem[_1271 + 96] + mem[_1271 + 128]:
                                                        _1380 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_1380] = 26
                                                        mem[_1380 + 32] = 'SafeMath: division by zero'
                                                        if not _1344:
                                                            _1390 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _1390 + 68] = mem[_1380 + idx + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_1390 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _1390 + -mem[64] + 100
                                                        _1412 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_1412] = 26
                                                        mem[_1412 + 32] = 'SafeMath: division by zero'
                                                        if _1343:
                                                            if t > !(0 / _1344 / _1343):
                                                                revert with 0, 17
                                                            if t + (0 / _1344 / _1343) < t:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            if idx == -1:
                                                                revert with 0, 17
                                                            idx = idx + 1
                                                            t = t + (0 / _1344 / _1343)
                                                            continue 
                                                        _1431 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _1431 + 68] = mem[_1412 + idx + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_1431 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _1431 + -mem[64] + 100
                                                    if mem[_1271 + 96] + mem[_1271 + 128] and mem[_1271] > -1 / mem[_1271 + 96] + mem[_1271 + 128]:
                                                        revert with 0, 17
                                                    if not mem[_1271 + 96] + mem[_1271 + 128]:
                                                        revert with 0, 18
                                                    if (mem[_1271 + 96] * mem[_1271]) + (mem[_1271 + 128] * mem[_1271]) / mem[_1271 + 96] + mem[_1271 + 128] != mem[_1271]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not (mem[_1271 + 96] * mem[_1271]) + (mem[_1271 + 128] * mem[_1271]):
                                                        _1403 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_1403] = 26
                                                        mem[_1403 + 32] = 'SafeMath: division by zero'
                                                        if not _1344:
                                                            _1411 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _1411 + 68] = mem[_1403 + idx + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_1411 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _1411 + -mem[64] + 100
                                                        _1459 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_1459] = 26
                                                        mem[_1459 + 32] = 'SafeMath: division by zero'
                                                        if _1343:
                                                            if t > !(0 / _1344 / _1343):
                                                                revert with 0, 17
                                                            if t + (0 / _1344 / _1343) < t:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            if idx == -1:
                                                                revert with 0, 17
                                                            idx = idx + 1
                                                            t = t + (0 / _1344 / _1343)
                                                            continue 
                                                        _1475 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _1475 + 68] = mem[_1459 + idx + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_1475 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _1475 + -mem[64] + 100
                                                    if (mem[_1271 + 96] * mem[_1271]) + (mem[_1271 + 128] * mem[_1271]) and mem[_757 + 64] > -1 / (mem[_1271 + 96] * mem[_1271]) + (mem[_1271 + 128] * mem[_1271]):
                                                        revert with 0, 17
                                                    if not (mem[_1271 + 96] * mem[_1271]) + (mem[_1271 + 128] * mem[_1271]):
                                                        revert with 0, 18
                                                    if (mem[_1271 + 96] * mem[_1271] * mem[_757 + 64]) + (mem[_1271 + 128] * mem[_1271] * mem[_757 + 64]) / (mem[_1271 + 96] * mem[_1271]) + (mem[_1271 + 128] * mem[_1271]) != mem[_757 + 64]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _1446 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_1446] = 26
                                                    mem[_1446 + 32] = 'SafeMath: division by zero'
                                                    if not _1344:
                                                        _1458 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _1458 + 68] = mem[_1446 + idx + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_1458 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _1458 + -mem[64] + 100
                                                    _1502 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_1502] = 26
                                                    mem[_1502 + 32] = 'SafeMath: division by zero'
                                                    if _1343:
                                                        if t > !((_1348 * _1346 * _1345) + (_1347 * _1346 * _1345) / _1344 / _1343):
                                                            revert with 0, 17
                                                        if t + ((_1348 * _1346 * _1345) + (_1347 * _1346 * _1345) / _1344 / _1343) < t:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if idx == -1:
                                                            revert with 0, 17
                                                        idx = idx + 1
                                                        t = t + ((_1348 * _1346 * _1345) + (_1347 * _1346 * _1345) / _1344 / _1343)
                                                        continue 
                                                    _1519 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _1519 + 68] = mem[_1502 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_1519 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _1519 + -mem[64] + 100
                                                if _662 - s > !t:
                                                    revert with 0, 17
                                                if t < 0:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if mem[(4 * ceil32(return_data.size)) + 1728] > !(_662 - s + t):
                                                    revert with 0, 17
                                                if mem[(4 * ceil32(return_data.size)) + 1728] + _662 - s + t < mem[(4 * ceil32(return_data.size)) + 1728]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if sub_f4a8f345 > !(mem[(4 * ceil32(return_data.size)) + 1728] + _662 - s + t):
                                                    revert with 0, 17
                                                if sub_f4a8f345 + mem[(4 * ceil32(return_data.size)) + 1728] + _662 - s + t < sub_f4a8f345:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                sub_f4a8f345 = sub_f4a8f345 + mem[(4 * ceil32(return_data.size)) + 1728] + _662 - s + t
}

function sub_f19557d6(?) payable {
    mem[64] = 96
    require not msg.value
    require calldata.size - 4 >= 64
    if TOKEN_DEFINERAddress != msg.sender:
        revert with 0, 'Wrong sender.'
    if arg2 < sub_d3a8b1da:
        idx = arg1
        while idx < arg2:
            mem[0] = Mask(128, 128, sub_4c86259e[idx].field_256)
            mem[32] = sha3(sub_4c86259e[idx].field_0, 9)
            if not stor9[stor12[idx].field_0][Mask(128, 128, stor12[idx].field_256)]:
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            stor9[stor12[idx].field_0][Mask(128, 128, stor12[idx].field_256)] = 0
            if sub_1b385a01[stor12[idx].field_0] < 1:
                revert with 0, 17
            sub_1b385a01[stor12[idx].field_0]--
            if not sub_ab7789c0:
                revert with 0, 17
            sub_ab7789c0--
            mem[0] = idx
            mem[32] = 12
            if 1 > !sub_ed73481d:
                revert with 0, 17
            _1647 = mem[64]
            mem[64] = mem[64] + 352
            mem[_1647] = 0
            mem[_1647 + 32] = 0
            mem[_1647 + 64] = 0
            mem[_1647 + 96] = 0
            mem[_1647 + 128] = 0
            mem[_1647 + 160] = 0
            mem[_1647 + 192] = 0
            mem[_1647 + 224] = 0
            mem[_1647 + 256] = 0
            mem[_1647 + 288] = 0
            mem[_1647 + 320] = 0
            staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                    gas gas_remaining wei
                   args sub_4c86259e[idx].field_0, Mask(128, 128, sub_4c86259e[idx].field_256)
            mem[mem[64] len 352] = ext_call.return_data[0 len 352]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1653 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 352
            _1655 = mem[64]
            if mem[64] + 352 < mem[64] or mem[64] + 352 > test266151307():
                revert with 0, 65
            mem[64] = mem[64] + 352
            require mem[_1653] == Mask(128, 128, mem[_1653])
            mem[_1655] = mem[_1653]
            mem[_1655 + 32] = mem[_1653 + 32]
            mem[_1655 + 64] = mem[_1653 + 64]
            mem[_1655 + 96] = mem[_1653 + 96]
            require mem[_1653 + 128] < 5
            mem[_1655 + 128] = mem[_1653 + 128]
            mem[_1655 + 160] = mem[_1653 + 160]
            mem[_1655 + 192] = mem[_1653 + 192]
            mem[_1655 + 224] = mem[_1653 + 224]
            mem[_1655 + 256] = mem[_1653 + 256]
            mem[_1655 + 288] = mem[_1653 + 288]
            mem[_1655 + 320] = mem[_1653 + 320]
            if Mask(128, 128, mem[_1655]) != Mask(128, 128, sub_4c86259e[idx].field_256):
                _1683 = mem[64]
                mem[64] = mem[64] + 96
                mem[_1683] = 46
                mem[_1683 + 32 len 46] = 0xfe53656e64657220646f6573206e6f7420636f6e7461696e207374616b6520776974682070726f76696465642069
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            mem[0] = Mask(128, 128, sub_4c86259e[idx].field_256)
            mem[32] = sha3(sub_4c86259e[idx].field_0, 9)
            if stor9[stor12[idx].field_0][Mask(128, 128, stor12[idx].field_256)]:
                _1688 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1688] = 32
                mem[_1688 + 32] = 'Stake has already been converted'
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            if mem[_1655 + 128] > 4:
                revert with 0, 33
            if mem[_1655 + 128] != 2:
                _1692 = mem[64]
                mem[64] = mem[64] + 96
                mem[_1692] = 44
                mem[_1692 + 32 len 44] = 0x795374616b65206973206f6e6c7920656c696769626c6520696620697420686173206265656e20636c6f7365
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            if mem[_1655 + 192] >= sub_be647a94:
                _1697 = mem[64]
                mem[64] = mem[64] + 128
                mem[_1697] = 65
                mem[_1697 + 32 len 65] = 0x645374616b65206973206f6e6c7920656c696769626c65206966206974207761732063726561746564207072696f7220746f2074686520637574206f6666206461
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            if mem[_1655 + 192] > !mem[_1655 + 224]:
                revert with 0, 17
            if mem[_1655 + 192] + mem[_1655 + 224] < sub_be647a94:
                _1702 = mem[64]
                mem[64] = mem[64] + 128
                mem[_1702] = 66
                mem[_1702 + 32 len 66] = 0x645374616b65206973206f6e6c7920656c696769626c652069662069742077617320656e646564206f6e2074686520637574206f666620646179206f722061667465
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            _1701 = mem[64]
            mem[64] = mem[64] + 64
            mem[_1701] = 17
            mem[_1701 + 32] = 'Stake is eligible' << 120
            staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                    gas gas_remaining wei
                   args sub_4c86259e[idx].field_0, Mask(128, 128, sub_4c86259e[idx].field_256)
            mem[mem[64] len 352] = ext_call.return_data[0 len 352]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1709 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 352
            _1711 = mem[64]
            if mem[64] + 352 < mem[64] or mem[64] + 352 > test266151307():
                revert with 0, 65
            mem[64] = mem[64] + 352
            require mem[_1709] == Mask(128, 128, mem[_1709])
            mem[_1711] = mem[_1709]
            mem[_1711 + 32] = mem[_1709 + 32]
            mem[_1711 + 64] = mem[_1709 + 64]
            mem[_1711 + 96] = mem[_1709 + 96]
            require mem[_1709 + 128] < 5
            mem[_1711 + 128] = mem[_1709 + 128]
            mem[_1711 + 160] = mem[_1709 + 160]
            mem[_1711 + 192] = mem[_1709 + 192]
            mem[_1711 + 224] = mem[_1709 + 224]
            mem[_1711 + 256] = mem[_1709 + 256]
            mem[_1711 + 288] = mem[_1709 + 288]
            mem[_1711 + 320] = mem[_1709 + 320]
            if Mask(128, 128, mem[_1711]) != Mask(128, 128, sub_4c86259e[idx].field_256):
                revert with 0, 'Address does not contain stake with provided id'
            if mem[_1711 + 128] > 4:
                revert with 0, 33
            if mem[_1711 + 128] == 3:
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            if mem[_1711 + 128] > 4:
                revert with 0, 33
            if mem[_1711 + 128] == 4:
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            if mem[_1711 + 128] > 4:
                revert with 0, 33
            if mem[_1711 + 128] == 1:
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            if mem[_1711 + 128] > 4:
                revert with 0, 33
            if not mem[_1711 + 128]:
                _1751 = mem[_1711]
                staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                        gas gas_remaining wei
                       args sub_4c86259e[idx].field_0, Mask(128, 128, mem[_1711])
                mem[mem[64] len 352] = ext_call.return_data[0 len 352]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1759 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 352
                _1769 = mem[64]
                if mem[64] + 352 < mem[64] or mem[64] + 352 > test266151307():
                    revert with 0, 65
                mem[64] = mem[64] + 352
                require mem[_1759] == Mask(128, 128, mem[_1759])
                mem[_1769] = mem[_1759]
                mem[_1769 + 32] = mem[_1759 + 32]
                mem[_1769 + 64] = mem[_1759 + 64]
                mem[_1769 + 96] = mem[_1759 + 96]
                require mem[_1759 + 128] < 5
                mem[_1769 + 128] = mem[_1759 + 128]
                mem[_1769 + 160] = mem[_1759 + 160]
                mem[_1769 + 192] = mem[_1759 + 192]
                mem[_1769 + 224] = mem[_1759 + 224]
                mem[_1769 + 256] = mem[_1759 + 256]
                mem[_1769 + 288] = mem[_1759 + 288]
                mem[_1769 + 320] = mem[_1759 + 320]
                if Mask(128, 128, mem[_1769]) != Mask(128, 128, _1751):
                    revert with 0, 'Address does not contain stake with provided id'
                s = mem[_1769 + 192]
                t = 0
                while s < sub_ed73481d + 1:
                    staticcall sub_413c05c6Address.0x8ce1d9e4 with:
                            gas gas_remaining wei
                           args s
                    mem[mem[64] len 160] = ext_call.return_data[0 len 160]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3269 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 160
                    _3291 = mem[64]
                    if mem[64] + 160 > test266151307() or mem[64] + 160 < mem[64]:
                        revert with 0, 65
                    mem[64] = mem[64] + 160
                    mem[_3291] = mem[_3269]
                    mem[_3291 + 32] = mem[_3269 + 32]
                    mem[_3291 + 64] = mem[_3269 + 64]
                    mem[_3291 + 96] = mem[_3269 + 96]
                    mem[_3291 + 128] = mem[_3269 + 128]
                    _3345 = mem[_3291 + 64]
                    _3346 = mem[_3291 + 32]
                    _3347 = mem[_1769 + 64]
                    _3348 = mem[_3291]
                    _3349 = mem[_3291 + 128]
                    _3350 = mem[_3291 + 96]
                    if mem[_3291 + 96] > !mem[_3291 + 128]:
                        revert with 0, 17
                    if mem[_3291 + 96] + mem[_3291 + 128] < mem[_3291 + 96]:
                        revert with 0, 'SafeMath: addition overflow'
                    if not mem[_3291 + 96] + mem[_3291 + 128]:
                        _3490 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3490] = 26
                        mem[_3490 + 32] = 'SafeMath: division by zero'
                        if not _3346:
                            _3517 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _3517 + 68] = mem[_3490 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3517 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3517 + -mem[64] + 100
                        _3651 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3651] = 26
                        mem[_3651 + 32] = 'SafeMath: division by zero'
                        if _3345:
                            if t > !(0 / _3346 / _3345):
                                revert with 0, 17
                            if t + (0 / _3346 / _3345) < t:
                                revert with 0, 'SafeMath: addition overflow'
                            if s == -1:
                                revert with 0, 17
                            s = s + 1
                            t = t + (0 / _3346 / _3345)
                            continue 
                        _3701 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _3701 + 68] = mem[_3651 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3701 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3701 + -mem[64] + 100
                    if mem[_3291 + 96] + mem[_3291 + 128] and mem[_3291] > -1 / mem[_3291 + 96] + mem[_3291 + 128]:
                        revert with 0, 17
                    if not mem[_3291 + 96] + mem[_3291 + 128]:
                        revert with 0, 18
                    if (mem[_3291 + 96] * mem[_3291]) + (mem[_3291 + 128] * mem[_3291]) / mem[_3291 + 96] + mem[_3291 + 128] != mem[_3291]:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not (mem[_3291 + 96] * mem[_3291]) + (mem[_3291 + 128] * mem[_3291]):
                        _3573 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3573] = 26
                        mem[_3573 + 32] = 'SafeMath: division by zero'
                        if not _3346:
                            _3650 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _3650 + 68] = mem[_3573 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3650 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3650 + -mem[64] + 100
                        _3792 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3792] = 26
                        mem[_3792 + 32] = 'SafeMath: division by zero'
                        if _3345:
                            if t > !(0 / _3346 / _3345):
                                revert with 0, 17
                            if t + (0 / _3346 / _3345) < t:
                                revert with 0, 'SafeMath: addition overflow'
                            if s == -1:
                                revert with 0, 17
                            s = s + 1
                            t = t + (0 / _3346 / _3345)
                            continue 
                        _3858 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _3858 + 68] = mem[_3792 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3858 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3858 + -mem[64] + 100
                    if (mem[_3291 + 96] * mem[_3291]) + (mem[_3291 + 128] * mem[_3291]) and mem[_1769 + 64] > -1 / (mem[_3291 + 96] * mem[_3291]) + (mem[_3291 + 128] * mem[_3291]):
                        revert with 0, 17
                    if not (mem[_3291 + 96] * mem[_3291]) + (mem[_3291 + 128] * mem[_3291]):
                        revert with 0, 18
                    if (mem[_3291 + 96] * mem[_3291] * mem[_1769 + 64]) + (mem[_3291 + 128] * mem[_3291] * mem[_1769 + 64]) / (mem[_3291 + 96] * mem[_3291]) + (mem[_3291 + 128] * mem[_3291]) != mem[_1769 + 64]:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _3748 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3748] = 26
                    mem[_3748 + 32] = 'SafeMath: division by zero'
                    if not _3346:
                        _3791 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _3791 + 68] = mem[_3748 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3791 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3791 + -mem[64] + 100
                    _3932 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3932] = 26
                    mem[_3932 + 32] = 'SafeMath: division by zero'
                    if _3345:
                        if t > !((_3350 * _3348 * _3347) + (_3349 * _3348 * _3347) / _3346 / _3345):
                            revert with 0, 17
                        if t + ((_3350 * _3348 * _3347) + (_3349 * _3348 * _3347) / _3346 / _3345) < t:
                            revert with 0, 'SafeMath: addition overflow'
                        if s == -1:
                            revert with 0, 17
                        s = s + 1
                        t = t + ((_3350 * _3348 * _3347) + (_3349 * _3348 * _3347) / _3346 / _3345)
                        continue 
                    _3975 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _3975 + 68] = mem[_3932 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3975 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _3975 + -mem[64] + 100
                _3267 = mem[_1711 + 32]
                _3268 = mem[_1711 + 160]
                if mem[_1711 + 160] > !t:
                    revert with 0, 17
                if mem[_1711 + 160] + t < mem[_1711 + 160]:
                    revert with 0, 'SafeMath: addition overflow'
                if mem[_1711 + 32] > !(mem[_1711 + 160] + t):
                    revert with 0, 17
                if mem[_1711 + 32] + mem[_1711 + 160] + t < mem[_1711 + 32]:
                    revert with 0, 'SafeMath: addition overflow'
                if not mem[_1711 + 32] + mem[_1711 + 160] + t:
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                if not mem[_1711 + 32] + mem[_1711 + 160] + t:
                    _3527 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3527] = 26
                    mem[_3527 + 32] = 'SafeMath: division by zero'
                    if not DENOMINATOR:
                        _3563 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _3563 + 68] = mem[_3527 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3563 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3563 + -mem[64] + 100
                    _3724 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3724] = 30
                    mem[_3724 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / DENOMINATOR <= sub_04b4a313:
                        if sub_04b4a313 < 0 / DENOMINATOR:
                            revert with 0, 17
                        sub_04b4a313 -= 0 / DENOMINATOR
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                    _3770 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _3770 + 68] = mem[_3724 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3770 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _3770 + -mem[64] + 100
                if mem[_1711 + 32] + mem[_1711 + 160] + t and sub_d8830c7d > -1 / mem[_1711 + 32] + mem[_1711 + 160] + t:
                    revert with 0, 17
                if not mem[_1711 + 32] + mem[_1711 + 160] + t:
                    revert with 0, 18
                if (mem[_1711 + 32] * sub_d8830c7d) + (mem[_1711 + 160] * sub_d8830c7d) + (t * sub_d8830c7d) / mem[_1711 + 32] + mem[_1711 + 160] + t != sub_d8830c7d:
                    revert with 0, 'SafeMath: multiplication overflow'
                _3679 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3679] = 26
                mem[_3679 + 32] = 'SafeMath: division by zero'
                if not DENOMINATOR:
                    _3723 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _3723 + 68] = mem[_3679 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3723 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _3723 + -mem[64] + 100
                _3885 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3885] = 30
                mem[_3885 + 32] = 'SafeMath: subtraction overflow'
                if (_3267 * sub_d8830c7d) + (_3268 * sub_d8830c7d) + (t * sub_d8830c7d) / DENOMINATOR <= sub_04b4a313:
                    if sub_04b4a313 < (_3267 * sub_d8830c7d) + (_3268 * sub_d8830c7d) + (t * sub_d8830c7d) / DENOMINATOR:
                        revert with 0, 17
                    sub_04b4a313 -= (_3267 * sub_d8830c7d) + (_3268 * sub_d8830c7d) + (t * sub_d8830c7d) / DENOMINATOR
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                _3919 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _3919 + 68] = mem[_3885 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_3919 + 98] = 0
                revert with memory
                  from mem[64]
                   len _3919 + -mem[64] + 100
            _1749 = mem[_1711 + 224]
            _1750 = mem[_1711 + 192]
            if mem[_1711 + 192] > !mem[_1711 + 224]:
                revert with 0, 17
            if sub_ed73481d + 1 < mem[_1711 + 192] + mem[_1711 + 224]:
                _1761 = mem[_1711]
                staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                        gas gas_remaining wei
                       args sub_4c86259e[idx].field_0, Mask(128, 128, mem[_1711])
                mem[mem[64] len 352] = ext_call.return_data[0 len 352]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1775 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 352
                _1781 = mem[64]
                if mem[64] + 352 < mem[64] or mem[64] + 352 > test266151307():
                    revert with 0, 65
                mem[64] = mem[64] + 352
                require mem[_1775] == Mask(128, 128, mem[_1775])
                mem[_1781] = mem[_1775]
                mem[_1781 + 32] = mem[_1775 + 32]
                mem[_1781 + 64] = mem[_1775 + 64]
                mem[_1781 + 96] = mem[_1775 + 96]
                require mem[_1775 + 128] < 5
                mem[_1781 + 128] = mem[_1775 + 128]
                mem[_1781 + 160] = mem[_1775 + 160]
                mem[_1781 + 192] = mem[_1775 + 192]
                mem[_1781 + 224] = mem[_1775 + 224]
                mem[_1781 + 256] = mem[_1775 + 256]
                mem[_1781 + 288] = mem[_1775 + 288]
                mem[_1781 + 320] = mem[_1775 + 320]
                if Mask(128, 128, mem[_1781]) != Mask(128, 128, _1761):
                    revert with 0, 'Address does not contain stake with provided id'
                s = mem[_1781 + 192]
                t = 0
                while s < _1750 + _1749:
                    staticcall sub_413c05c6Address.0x8ce1d9e4 with:
                            gas gas_remaining wei
                           args s
                    mem[mem[64] len 160] = ext_call.return_data[0 len 160]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3264 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 160
                    _3287 = mem[64]
                    if mem[64] + 160 > test266151307() or mem[64] + 160 < mem[64]:
                        revert with 0, 65
                    mem[64] = mem[64] + 160
                    mem[_3287] = mem[_3264]
                    mem[_3287 + 32] = mem[_3264 + 32]
                    mem[_3287 + 64] = mem[_3264 + 64]
                    mem[_3287 + 96] = mem[_3264 + 96]
                    mem[_3287 + 128] = mem[_3264 + 128]
                    _3331 = mem[_3287 + 64]
                    _3332 = mem[_3287 + 32]
                    _3333 = mem[_1781 + 64]
                    _3334 = mem[_3287]
                    _3335 = mem[_3287 + 128]
                    _3336 = mem[_3287 + 96]
                    if mem[_3287 + 96] > !mem[_3287 + 128]:
                        revert with 0, 17
                    if mem[_3287 + 96] + mem[_3287 + 128] < mem[_3287 + 96]:
                        revert with 0, 'SafeMath: addition overflow'
                    if not mem[_3287 + 96] + mem[_3287 + 128]:
                        _3484 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3484] = 26
                        mem[_3484 + 32] = 'SafeMath: division by zero'
                        if not _3332:
                            _3515 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _3515 + 68] = mem[_3484 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3515 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3515 + -mem[64] + 100
                        _3639 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3639] = 26
                        mem[_3639 + 32] = 'SafeMath: division by zero'
                        if _3331:
                            if t > !(0 / _3332 / _3331):
                                revert with 0, 17
                            if t + (0 / _3332 / _3331) < t:
                                revert with 0, 'SafeMath: addition overflow'
                            if s == -1:
                                revert with 0, 17
                            s = s + 1
                            t = t + (0 / _3332 / _3331)
                            continue 
                        _3693 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _3693 + 68] = mem[_3639 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3693 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3693 + -mem[64] + 100
                    if mem[_3287 + 96] + mem[_3287 + 128] and mem[_3287] > -1 / mem[_3287 + 96] + mem[_3287 + 128]:
                        revert with 0, 17
                    if not mem[_3287 + 96] + mem[_3287 + 128]:
                        revert with 0, 18
                    if (mem[_3287 + 96] * mem[_3287]) + (mem[_3287 + 128] * mem[_3287]) / mem[_3287 + 96] + mem[_3287 + 128] != mem[_3287]:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not (mem[_3287 + 96] * mem[_3287]) + (mem[_3287 + 128] * mem[_3287]):
                        _3568 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3568] = 26
                        mem[_3568 + 32] = 'SafeMath: division by zero'
                        if not _3332:
                            _3638 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _3638 + 68] = mem[_3568 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3638 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3638 + -mem[64] + 100
                        _3783 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3783] = 26
                        mem[_3783 + 32] = 'SafeMath: division by zero'
                        if _3331:
                            if t > !(0 / _3332 / _3331):
                                revert with 0, 17
                            if t + (0 / _3332 / _3331) < t:
                                revert with 0, 'SafeMath: addition overflow'
                            if s == -1:
                                revert with 0, 17
                            s = s + 1
                            t = t + (0 / _3332 / _3331)
                            continue 
                        _3846 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _3846 + 68] = mem[_3783 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3846 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3846 + -mem[64] + 100
                    if (mem[_3287 + 96] * mem[_3287]) + (mem[_3287 + 128] * mem[_3287]) and mem[_1781 + 64] > -1 / (mem[_3287 + 96] * mem[_3287]) + (mem[_3287 + 128] * mem[_3287]):
                        revert with 0, 17
                    if not (mem[_3287 + 96] * mem[_3287]) + (mem[_3287 + 128] * mem[_3287]):
                        revert with 0, 18
                    if (mem[_3287 + 96] * mem[_3287] * mem[_1781 + 64]) + (mem[_3287 + 128] * mem[_3287] * mem[_1781 + 64]) / (mem[_3287 + 96] * mem[_3287]) + (mem[_3287 + 128] * mem[_3287]) != mem[_1781 + 64]:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _3739 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3739] = 26
                    mem[_3739 + 32] = 'SafeMath: division by zero'
                    if not _3332:
                        _3782 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _3782 + 68] = mem[_3739 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3782 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3782 + -mem[64] + 100
                    _3924 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3924] = 26
                    mem[_3924 + 32] = 'SafeMath: division by zero'
                    if _3331:
                        if t > !((_3336 * _3334 * _3333) + (_3335 * _3334 * _3333) / _3332 / _3331):
                            revert with 0, 17
                        if t + ((_3336 * _3334 * _3333) + (_3335 * _3334 * _3333) / _3332 / _3331) < t:
                            revert with 0, 'SafeMath: addition overflow'
                        if s == -1:
                            revert with 0, 17
                        s = s + 1
                        t = t + ((_3336 * _3334 * _3333) + (_3335 * _3334 * _3333) / _3332 / _3331)
                        continue 
                    _3969 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _3969 + 68] = mem[_3924 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3969 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _3969 + -mem[64] + 100
                if t >= mem[_1711 + 160]:
                    _3277 = mem[_1711]
                    staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                            gas gas_remaining wei
                           args sub_4c86259e[idx].field_0, Mask(128, 128, mem[_1711])
                    mem[mem[64] len 352] = ext_call.return_data[0 len 352]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3373 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 352
                    _3385 = mem[64]
                    if mem[64] + 352 < mem[64] or mem[64] + 352 > test266151307():
                        revert with 0, 65
                    mem[64] = mem[64] + 352
                    require mem[_3373] == Mask(128, 128, mem[_3373])
                    mem[_3385] = mem[_3373]
                    mem[_3385 + 32] = mem[_3373 + 32]
                    mem[_3385 + 64] = mem[_3373 + 64]
                    mem[_3385 + 96] = mem[_3373 + 96]
                    require mem[_3373 + 128] < 5
                    mem[_3385 + 128] = mem[_3373 + 128]
                    mem[_3385 + 160] = mem[_3373 + 160]
                    mem[_3385 + 192] = mem[_3373 + 192]
                    mem[_3385 + 224] = mem[_3373 + 224]
                    mem[_3385 + 256] = mem[_3373 + 256]
                    mem[_3385 + 288] = mem[_3373 + 288]
                    mem[_3385 + 320] = mem[_3373 + 320]
                    if Mask(128, 128, mem[_3385]) != Mask(128, 128, _3277):
                        revert with 0, 'Address does not contain stake with provided id'
                    s = mem[_3385 + 192]
                    t = 0
                    while s < sub_ed73481d + 1:
                        staticcall sub_413c05c6Address.0x8ce1d9e4 with:
                                gas gas_remaining wei
                               args s
                        mem[mem[64] len 160] = ext_call.return_data[0 len 160]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _4694 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 160
                        _4709 = mem[64]
                        if mem[64] + 160 > test266151307() or mem[64] + 160 < mem[64]:
                            revert with 0, 65
                        mem[64] = mem[64] + 160
                        mem[_4709] = mem[_4694]
                        mem[_4709 + 32] = mem[_4694 + 32]
                        mem[_4709 + 64] = mem[_4694 + 64]
                        mem[_4709 + 96] = mem[_4694 + 96]
                        mem[_4709 + 128] = mem[_4694 + 128]
                        _4853 = mem[_4709 + 64]
                        _4854 = mem[_4709 + 32]
                        _4855 = mem[_3385 + 64]
                        _4856 = mem[_4709]
                        _4857 = mem[_4709 + 128]
                        _4858 = mem[_4709 + 96]
                        if mem[_4709 + 96] > !mem[_4709 + 128]:
                            revert with 0, 17
                        if mem[_4709 + 96] + mem[_4709 + 128] < mem[_4709 + 96]:
                            revert with 0, 'SafeMath: addition overflow'
                        if not mem[_4709 + 96] + mem[_4709 + 128]:
                            _4950 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4950] = 26
                            mem[_4950 + 32] = 'SafeMath: division by zero'
                            if not _4854:
                                _4982 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _4982 + 68] = mem[_4950 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4982 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _4982 + -mem[64] + 100
                            _5066 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5066] = 26
                            mem[_5066 + 32] = 'SafeMath: division by zero'
                            if _4853:
                                if t > !(0 / _4854 / _4853):
                                    revert with 0, 17
                                if t + (0 / _4854 / _4853) < t:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s == -1:
                                    revert with 0, 17
                                s = s + 1
                                t = t + (0 / _4854 / _4853)
                                continue 
                            _5111 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _5111 + 68] = mem[_5066 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5111 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _5111 + -mem[64] + 100
                        if mem[_4709 + 96] + mem[_4709 + 128] and mem[_4709] > -1 / mem[_4709 + 96] + mem[_4709 + 128]:
                            revert with 0, 17
                        if not mem[_4709 + 96] + mem[_4709 + 128]:
                            revert with 0, 18
                        if (mem[_4709 + 96] * mem[_4709]) + (mem[_4709 + 128] * mem[_4709]) / mem[_4709 + 96] + mem[_4709 + 128] != mem[_4709]:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not (mem[_4709 + 96] * mem[_4709]) + (mem[_4709 + 128] * mem[_4709]):
                            _5026 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5026] = 26
                            mem[_5026 + 32] = 'SafeMath: division by zero'
                            if not _4854:
                                _5065 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _5065 + 68] = mem[_5026 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5065 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _5065 + -mem[64] + 100
                            _5219 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5219] = 26
                            mem[_5219 + 32] = 'SafeMath: division by zero'
                            if _4853:
                                if t > !(0 / _4854 / _4853):
                                    revert with 0, 17
                                if t + (0 / _4854 / _4853) < t:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s == -1:
                                    revert with 0, 17
                                s = s + 1
                                t = t + (0 / _4854 / _4853)
                                continue 
                            _5270 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _5270 + 68] = mem[_5219 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5270 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _5270 + -mem[64] + 100
                        if (mem[_4709 + 96] * mem[_4709]) + (mem[_4709 + 128] * mem[_4709]) and mem[_3385 + 64] > -1 / (mem[_4709 + 96] * mem[_4709]) + (mem[_4709 + 128] * mem[_4709]):
                            revert with 0, 17
                        if not (mem[_4709 + 96] * mem[_4709]) + (mem[_4709 + 128] * mem[_4709]):
                            revert with 0, 18
                        if (mem[_4709 + 96] * mem[_4709] * mem[_3385 + 64]) + (mem[_4709 + 128] * mem[_4709] * mem[_3385 + 64]) / (mem[_4709 + 96] * mem[_4709]) + (mem[_4709 + 128] * mem[_4709]) != mem[_3385 + 64]:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _5166 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5166] = 26
                        mem[_5166 + 32] = 'SafeMath: division by zero'
                        if not _4854:
                            _5218 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _5218 + 68] = mem[_5166 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5218 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _5218 + -mem[64] + 100
                        _5350 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5350] = 26
                        mem[_5350 + 32] = 'SafeMath: division by zero'
                        if _4853:
                            if t > !((_4858 * _4856 * _4855) + (_4857 * _4856 * _4855) / _4854 / _4853):
                                revert with 0, 17
                            if t + ((_4858 * _4856 * _4855) + (_4857 * _4856 * _4855) / _4854 / _4853) < t:
                                revert with 0, 'SafeMath: addition overflow'
                            if s == -1:
                                revert with 0, 17
                            s = s + 1
                            t = t + ((_4858 * _4856 * _4855) + (_4857 * _4856 * _4855) / _4854 / _4853)
                            continue 
                        _5409 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _5409 + 68] = mem[_5350 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_5409 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _5409 + -mem[64] + 100
                    _4693 = mem[_1711 + 32]
                    if mem[_1711 + 32] > !t:
                        revert with 0, 17
                    if mem[_1711 + 32] + t < mem[_1711 + 32]:
                        revert with 0, 'SafeMath: addition overflow'
                    if not mem[_1711 + 32] + t:
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                    if not mem[_1711 + 32] + t:
                        _4937 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4937] = 26
                        mem[_4937 + 32] = 'SafeMath: division by zero'
                        if not DENOMINATOR:
                            _4945 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _4945 + 68] = mem[_4937 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_4945 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _4945 + -mem[64] + 100
                        _5014 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5014] = 30
                        mem[_5014 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / DENOMINATOR <= sub_04b4a313:
                            if sub_04b4a313 < 0 / DENOMINATOR:
                                revert with 0, 17
                            sub_04b4a313 -= 0 / DENOMINATOR
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            continue 
                        _5046 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _5046 + 68] = mem[_5014 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_5046 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _5046 + -mem[64] + 100
                    if mem[_1711 + 32] + t and sub_d8830c7d > -1 / mem[_1711 + 32] + t:
                        revert with 0, 17
                    if not mem[_1711 + 32] + t:
                        revert with 0, 18
                    if (mem[_1711 + 32] * sub_d8830c7d) + (t * sub_d8830c7d) / mem[_1711 + 32] + t != sub_d8830c7d:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _4993 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4993] = 26
                    mem[_4993 + 32] = 'SafeMath: division by zero'
                    if not DENOMINATOR:
                        _5013 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _5013 + 68] = mem[_4993 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_5013 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _5013 + -mem[64] + 100
                    _5141 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5141] = 30
                    mem[_5141 + 32] = 'SafeMath: subtraction overflow'
                    if (_4693 * sub_d8830c7d) + (t * sub_d8830c7d) / DENOMINATOR <= sub_04b4a313:
                        if sub_04b4a313 < (_4693 * sub_d8830c7d) + (t * sub_d8830c7d) / DENOMINATOR:
                            revert with 0, 17
                        sub_04b4a313 -= (_4693 * sub_d8830c7d) + (t * sub_d8830c7d) / DENOMINATOR
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                    _5197 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _5197 + 68] = mem[_5141 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_5197 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _5197 + -mem[64] + 100
                _3278 = mem[_1711 + 160]
                _3286 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3286] = 30
                mem[_3286 + 32] = 'SafeMath: subtraction overflow'
                if t > _3278:
                    _3330 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _3330 + 68] = mem[_3286 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3330 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _3330 + -mem[64] + 100
                if _3278 < t:
                    revert with 0, 17
                _3393 = mem[_1711]
                staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                        gas gas_remaining wei
                       args sub_4c86259e[idx].field_0, Mask(128, 128, mem[_1711])
                mem[mem[64] len 352] = ext_call.return_data[0 len 352]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3429 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 352
                _3448 = mem[64]
                if mem[64] + 352 < mem[64] or mem[64] + 352 > test266151307():
                    revert with 0, 65
                mem[64] = mem[64] + 352
                require mem[_3429] == Mask(128, 128, mem[_3429])
                mem[_3448] = mem[_3429]
                mem[_3448 + 32] = mem[_3429 + 32]
                mem[_3448 + 64] = mem[_3429 + 64]
                mem[_3448 + 96] = mem[_3429 + 96]
                require mem[_3429 + 128] < 5
                mem[_3448 + 128] = mem[_3429 + 128]
                mem[_3448 + 160] = mem[_3429 + 160]
                mem[_3448 + 192] = mem[_3429 + 192]
                mem[_3448 + 224] = mem[_3429 + 224]
                mem[_3448 + 256] = mem[_3429 + 256]
                mem[_3448 + 288] = mem[_3429 + 288]
                mem[_3448 + 320] = mem[_3429 + 320]
                if Mask(128, 128, mem[_3448]) != Mask(128, 128, _3393):
                    revert with 0, 'Address does not contain stake with provided id'
                s = mem[_3448 + 192]
                u = 0
                while s < sub_ed73481d + 1:
                    staticcall sub_413c05c6Address.0x8ce1d9e4 with:
                            gas gas_remaining wei
                           args s
                    mem[mem[64] len 160] = ext_call.return_data[0 len 160]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _4696 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 160
                    _4710 = mem[64]
                    if mem[64] + 160 > test266151307() or mem[64] + 160 < mem[64]:
                        revert with 0, 65
                    mem[64] = mem[64] + 160
                    mem[_4710] = mem[_4696]
                    mem[_4710 + 32] = mem[_4696 + 32]
                    mem[_4710 + 64] = mem[_4696 + 64]
                    mem[_4710 + 96] = mem[_4696 + 96]
                    mem[_4710 + 128] = mem[_4696 + 128]
                    _4859 = mem[_4710 + 64]
                    _4860 = mem[_4710 + 32]
                    _4861 = mem[_3448 + 64]
                    _4862 = mem[_4710]
                    _4863 = mem[_4710 + 128]
                    _4864 = mem[_4710 + 96]
                    if mem[_4710 + 96] > !mem[_4710 + 128]:
                        revert with 0, 17
                    if mem[_4710 + 96] + mem[_4710 + 128] < mem[_4710 + 96]:
                        revert with 0, 'SafeMath: addition overflow'
                    if not mem[_4710 + 96] + mem[_4710 + 128]:
                        _4952 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4952] = 26
                        mem[_4952 + 32] = 'SafeMath: division by zero'
                        if not _4860:
                            _4983 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _4983 + 68] = mem[_4952 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_4983 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _4983 + -mem[64] + 100
                        _5069 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5069] = 26
                        mem[_5069 + 32] = 'SafeMath: division by zero'
                        if _4859:
                            if u > !(0 / _4860 / _4859):
                                revert with 0, 17
                            if u + (0 / _4860 / _4859) < u:
                                revert with 0, 'SafeMath: addition overflow'
                            if s == -1:
                                revert with 0, 17
                            s = s + 1
                            u = u + (0 / _4860 / _4859)
                            continue 
                        _5115 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _5115 + 68] = mem[_5069 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_5115 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _5115 + -mem[64] + 100
                    if mem[_4710 + 96] + mem[_4710 + 128] and mem[_4710] > -1 / mem[_4710 + 96] + mem[_4710 + 128]:
                        revert with 0, 17
                    if not mem[_4710 + 96] + mem[_4710 + 128]:
                        revert with 0, 18
                    if (mem[_4710 + 96] * mem[_4710]) + (mem[_4710 + 128] * mem[_4710]) / mem[_4710 + 96] + mem[_4710 + 128] != mem[_4710]:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not (mem[_4710 + 96] * mem[_4710]) + (mem[_4710 + 128] * mem[_4710]):
                        _5028 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5028] = 26
                        mem[_5028 + 32] = 'SafeMath: division by zero'
                        if not _4860:
                            _5068 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _5068 + 68] = mem[_5028 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5068 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _5068 + -mem[64] + 100
                        _5222 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5222] = 26
                        mem[_5222 + 32] = 'SafeMath: division by zero'
                        if _4859:
                            if u > !(0 / _4860 / _4859):
                                revert with 0, 17
                            if u + (0 / _4860 / _4859) < u:
                                revert with 0, 'SafeMath: addition overflow'
                            if s == -1:
                                revert with 0, 17
                            s = s + 1
                            u = u + (0 / _4860 / _4859)
                            continue 
                        _5273 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _5273 + 68] = mem[_5222 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_5273 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _5273 + -mem[64] + 100
                    if (mem[_4710 + 96] * mem[_4710]) + (mem[_4710 + 128] * mem[_4710]) and mem[_3448 + 64] > -1 / (mem[_4710 + 96] * mem[_4710]) + (mem[_4710 + 128] * mem[_4710]):
                        revert with 0, 17
                    if not (mem[_4710 + 96] * mem[_4710]) + (mem[_4710 + 128] * mem[_4710]):
                        revert with 0, 18
                    if (mem[_4710 + 96] * mem[_4710] * mem[_3448 + 64]) + (mem[_4710 + 128] * mem[_4710] * mem[_3448 + 64]) / (mem[_4710 + 96] * mem[_4710]) + (mem[_4710 + 128] * mem[_4710]) != mem[_3448 + 64]:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _5170 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5170] = 26
                    mem[_5170 + 32] = 'SafeMath: division by zero'
                    if not _4860:
                        _5221 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _5221 + 68] = mem[_5170 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_5221 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _5221 + -mem[64] + 100
                    _5354 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5354] = 26
                    mem[_5354 + 32] = 'SafeMath: division by zero'
                    if _4859:
                        if u > !((_4864 * _4862 * _4861) + (_4863 * _4862 * _4861) / _4860 / _4859):
                            revert with 0, 17
                        if u + ((_4864 * _4862 * _4861) + (_4863 * _4862 * _4861) / _4860 / _4859) < u:
                            revert with 0, 'SafeMath: addition overflow'
                        if s == -1:
                            revert with 0, 17
                        s = s + 1
                        u = u + ((_4864 * _4862 * _4861) + (_4863 * _4862 * _4861) / _4860 / _4859)
                        continue 
                    _5411 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5411 + 68] = mem[_5354 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_5411 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _5411 + -mem[64] + 100
                _4695 = mem[_1711 + 32]
                if _3278 - t > !u:
                    revert with 0, 17
                if u < 0:
                    revert with 0, 'SafeMath: addition overflow'
                if mem[_1711 + 32] > !(_3278 - t + u):
                    revert with 0, 17
                if mem[_1711 + 32] + _3278 - t + u < mem[_1711 + 32]:
                    revert with 0, 'SafeMath: addition overflow'
                if not mem[_1711 + 32] + _3278 - t + u:
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                if not mem[_1711 + 32] + _3278 - t + u:
                    _4995 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4995] = 26
                    mem[_4995 + 32] = 'SafeMath: division by zero'
                    if not DENOMINATOR:
                        _5015 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _5015 + 68] = mem[_4995 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_5015 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _5015 + -mem[64] + 100
                    _5145 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5145] = 30
                    mem[_5145 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / DENOMINATOR <= sub_04b4a313:
                        if sub_04b4a313 < 0 / DENOMINATOR:
                            revert with 0, 17
                        sub_04b4a313 -= 0 / DENOMINATOR
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                    _5200 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _5200 + 68] = mem[_5145 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_5200 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _5200 + -mem[64] + 100
                if mem[_1711 + 32] + _3278 - t + u and sub_d8830c7d > -1 / mem[_1711 + 32] + _3278 - t + u:
                    revert with 0, 17
                if not mem[_1711 + 32] + _3278 - t + u:
                    revert with 0, 18
                if (mem[_1711 + 32] * sub_d8830c7d) + (_3278 * sub_d8830c7d) - (t * sub_d8830c7d) + (u * sub_d8830c7d) / mem[_1711 + 32] + _3278 - t + u != sub_d8830c7d:
                    revert with 0, 'SafeMath: multiplication overflow'
                _5088 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5088] = 26
                mem[_5088 + 32] = 'SafeMath: division by zero'
                if not DENOMINATOR:
                    _5144 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5144 + 68] = mem[_5088 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_5144 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _5144 + -mem[64] + 100
                _5295 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5295] = 30
                mem[_5295 + 32] = 'SafeMath: subtraction overflow'
                if (_4695 * sub_d8830c7d) + (_3278 * sub_d8830c7d) - (t * sub_d8830c7d) + (u * sub_d8830c7d) / DENOMINATOR <= sub_04b4a313:
                    if sub_04b4a313 < (_4695 * sub_d8830c7d) + (_3278 * sub_d8830c7d) - (t * sub_d8830c7d) + (u * sub_d8830c7d) / DENOMINATOR:
                        revert with 0, 17
                    sub_04b4a313 -= (_4695 * sub_d8830c7d) + (_3278 * sub_d8830c7d) - (t * sub_d8830c7d) + (u * sub_d8830c7d) / DENOMINATOR
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                _5341 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _5341 + 68] = mem[_5295 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_5341 + 98] = 0
                revert with memory
                  from mem[64]
                   len _5341 + -mem[64] + 100
            _1762 = mem[_1711]
            staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                    gas gas_remaining wei
                   args sub_4c86259e[idx].field_0, Mask(128, 128, mem[_1711])
            mem[mem[64] len 352] = ext_call.return_data[0 len 352]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1776 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 352
            _1782 = mem[64]
            if mem[64] + 352 < mem[64] or mem[64] + 352 > test266151307():
                revert with 0, 65
            mem[64] = mem[64] + 352
            require mem[_1776] == Mask(128, 128, mem[_1776])
            mem[_1782] = mem[_1776]
            mem[_1782 + 32] = mem[_1776 + 32]
            mem[_1782 + 64] = mem[_1776 + 64]
            mem[_1782 + 96] = mem[_1776 + 96]
            require mem[_1776 + 128] < 5
            mem[_1782 + 128] = mem[_1776 + 128]
            mem[_1782 + 160] = mem[_1776 + 160]
            mem[_1782 + 192] = mem[_1776 + 192]
            mem[_1782 + 224] = mem[_1776 + 224]
            mem[_1782 + 256] = mem[_1776 + 256]
            mem[_1782 + 288] = mem[_1776 + 288]
            mem[_1782 + 320] = mem[_1776 + 320]
            if Mask(128, 128, mem[_1782]) != Mask(128, 128, _1762):
                revert with 0, 'Address does not contain stake with provided id'
            s = mem[_1782 + 192]
            t = 0
            while s < _1750 + _1749:
                staticcall sub_413c05c6Address.0x8ce1d9e4 with:
                        gas gas_remaining wei
                       args s
                mem[mem[64] len 160] = ext_call.return_data[0 len 160]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3266 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 160
                _3290 = mem[64]
                if mem[64] + 160 > test266151307() or mem[64] + 160 < mem[64]:
                    revert with 0, 65
                mem[64] = mem[64] + 160
                mem[_3290] = mem[_3266]
                mem[_3290 + 32] = mem[_3266 + 32]
                mem[_3290 + 64] = mem[_3266 + 64]
                mem[_3290 + 96] = mem[_3266 + 96]
                mem[_3290 + 128] = mem[_3266 + 128]
                _3339 = mem[_3290 + 64]
                _3340 = mem[_3290 + 32]
                _3341 = mem[_1782 + 64]
                _3342 = mem[_3290]
                _3343 = mem[_3290 + 128]
                _3344 = mem[_3290 + 96]
                if mem[_3290 + 96] > !mem[_3290 + 128]:
                    revert with 0, 17
                if mem[_3290 + 96] + mem[_3290 + 128] < mem[_3290 + 96]:
                    revert with 0, 'SafeMath: addition overflow'
                if not mem[_3290 + 96] + mem[_3290 + 128]:
                    _3488 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3488] = 26
                    mem[_3488 + 32] = 'SafeMath: division by zero'
                    if not _3340:
                        _3516 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _3516 + 68] = mem[_3488 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3516 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3516 + -mem[64] + 100
                    _3648 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3648] = 26
                    mem[_3648 + 32] = 'SafeMath: division by zero'
                    if _3339:
                        if t > !(0 / _3340 / _3339):
                            revert with 0, 17
                        if t + (0 / _3340 / _3339) < t:
                            revert with 0, 'SafeMath: addition overflow'
                        if s == -1:
                            revert with 0, 17
                        s = s + 1
                        t = t + (0 / _3340 / _3339)
                        continue 
                    _3697 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _3697 + 68] = mem[_3648 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3697 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _3697 + -mem[64] + 100
                if mem[_3290 + 96] + mem[_3290 + 128] and mem[_3290] > -1 / mem[_3290 + 96] + mem[_3290 + 128]:
                    revert with 0, 17
                if not mem[_3290 + 96] + mem[_3290 + 128]:
                    revert with 0, 18
                if (mem[_3290 + 96] * mem[_3290]) + (mem[_3290 + 128] * mem[_3290]) / mem[_3290 + 96] + mem[_3290 + 128] != mem[_3290]:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not (mem[_3290 + 96] * mem[_3290]) + (mem[_3290 + 128] * mem[_3290]):
                    _3571 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3571] = 26
                    mem[_3571 + 32] = 'SafeMath: division by zero'
                    if not _3340:
                        _3647 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _3647 + 68] = mem[_3571 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3647 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3647 + -mem[64] + 100
                    _3789 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3789] = 26
                    mem[_3789 + 32] = 'SafeMath: division by zero'
                    if _3339:
                        if t > !(0 / _3340 / _3339):
                            revert with 0, 17
                        if t + (0 / _3340 / _3339) < t:
                            revert with 0, 'SafeMath: addition overflow'
                        if s == -1:
                            revert with 0, 17
                        s = s + 1
                        t = t + (0 / _3340 / _3339)
                        continue 
                    _3855 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _3855 + 68] = mem[_3789 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3855 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _3855 + -mem[64] + 100
                if (mem[_3290 + 96] * mem[_3290]) + (mem[_3290 + 128] * mem[_3290]) and mem[_1782 + 64] > -1 / (mem[_3290 + 96] * mem[_3290]) + (mem[_3290 + 128] * mem[_3290]):
                    revert with 0, 17
                if not (mem[_3290 + 96] * mem[_3290]) + (mem[_3290 + 128] * mem[_3290]):
                    revert with 0, 18
                if (mem[_3290 + 96] * mem[_3290] * mem[_1782 + 64]) + (mem[_3290 + 128] * mem[_3290] * mem[_1782 + 64]) / (mem[_3290 + 96] * mem[_3290]) + (mem[_3290 + 128] * mem[_3290]) != mem[_1782 + 64]:
                    revert with 0, 'SafeMath: multiplication overflow'
                _3744 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3744] = 26
                mem[_3744 + 32] = 'SafeMath: division by zero'
                if not _3340:
                    _3788 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _3788 + 68] = mem[_3744 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3788 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _3788 + -mem[64] + 100
                _3928 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3928] = 26
                mem[_3928 + 32] = 'SafeMath: division by zero'
                if _3339:
                    if t > !((_3344 * _3342 * _3341) + (_3343 * _3342 * _3341) / _3340 / _3339):
                        revert with 0, 17
                    if t + ((_3344 * _3342 * _3341) + (_3343 * _3342 * _3341) / _3340 / _3339) < t:
                        revert with 0, 'SafeMath: addition overflow'
                    if s == -1:
                        revert with 0, 17
                    s = s + 1
                    t = t + ((_3344 * _3342 * _3341) + (_3343 * _3342 * _3341) / _3340 / _3339)
                    continue 
                _3973 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _3973 + 68] = mem[_3928 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_3973 + 94] = 0
                revert with memory
                  from mem[64]
                   len _3973 + -mem[64] + 100
            if t >= mem[_1711 + 160]:
                _3279 = mem[_1711]
                staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                        gas gas_remaining wei
                       args sub_4c86259e[idx].field_0, Mask(128, 128, mem[_1711])
                mem[mem[64] len 352] = ext_call.return_data[0 len 352]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3374 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 352
                _3387 = mem[64]
                if mem[64] + 352 < mem[64] or mem[64] + 352 > test266151307():
                    revert with 0, 65
                mem[64] = mem[64] + 352
                require mem[_3374] == Mask(128, 128, mem[_3374])
                mem[_3387] = mem[_3374]
                mem[_3387 + 32] = mem[_3374 + 32]
                mem[_3387 + 64] = mem[_3374 + 64]
                mem[_3387 + 96] = mem[_3374 + 96]
                require mem[_3374 + 128] < 5
                mem[_3387 + 128] = mem[_3374 + 128]
                mem[_3387 + 160] = mem[_3374 + 160]
                mem[_3387 + 192] = mem[_3374 + 192]
                mem[_3387 + 224] = mem[_3374 + 224]
                mem[_3387 + 256] = mem[_3374 + 256]
                mem[_3387 + 288] = mem[_3374 + 288]
                mem[_3387 + 320] = mem[_3374 + 320]
                if Mask(128, 128, mem[_3387]) != Mask(128, 128, _3279):
                    revert with 0, 'Address does not contain stake with provided id'
                s = mem[_3387 + 192]
                t = 0
                while s < _1750 + _1749:
                    staticcall sub_413c05c6Address.0x8ce1d9e4 with:
                            gas gas_remaining wei
                           args s
                    mem[mem[64] len 160] = ext_call.return_data[0 len 160]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _4698 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 160
                    _4718 = mem[64]
                    if mem[64] + 160 > test266151307() or mem[64] + 160 < mem[64]:
                        revert with 0, 65
                    mem[64] = mem[64] + 160
                    mem[_4718] = mem[_4698]
                    mem[_4718 + 32] = mem[_4698 + 32]
                    mem[_4718 + 64] = mem[_4698 + 64]
                    mem[_4718 + 96] = mem[_4698 + 96]
                    mem[_4718 + 128] = mem[_4698 + 128]
                    _4865 = mem[_4718 + 64]
                    _4866 = mem[_4718 + 32]
                    _4867 = mem[_3387 + 64]
                    _4868 = mem[_4718]
                    _4869 = mem[_4718 + 128]
                    _4870 = mem[_4718 + 96]
                    if mem[_4718 + 96] > !mem[_4718 + 128]:
                        revert with 0, 17
                    if mem[_4718 + 96] + mem[_4718 + 128] < mem[_4718 + 96]:
                        revert with 0, 'SafeMath: addition overflow'
                    if not mem[_4718 + 96] + mem[_4718 + 128]:
                        _4954 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4954] = 26
                        mem[_4954 + 32] = 'SafeMath: division by zero'
                        if not _4866:
                            _4985 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _4985 + 68] = mem[_4954 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_4985 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _4985 + -mem[64] + 100
                        _5071 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5071] = 26
                        mem[_5071 + 32] = 'SafeMath: division by zero'
                        if _4865:
                            if t > !(0 / _4866 / _4865):
                                revert with 0, 17
                            if t + (0 / _4866 / _4865) < t:
                                revert with 0, 'SafeMath: addition overflow'
                            if s == -1:
                                revert with 0, 17
                            s = s + 1
                            t = t + (0 / _4866 / _4865)
                            continue 
                        _5119 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _5119 + 68] = mem[_5071 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_5119 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _5119 + -mem[64] + 100
                    if mem[_4718 + 96] + mem[_4718 + 128] and mem[_4718] > -1 / mem[_4718 + 96] + mem[_4718 + 128]:
                        revert with 0, 17
                    if not mem[_4718 + 96] + mem[_4718 + 128]:
                        revert with 0, 18
                    if (mem[_4718 + 96] * mem[_4718]) + (mem[_4718 + 128] * mem[_4718]) / mem[_4718 + 96] + mem[_4718 + 128] != mem[_4718]:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not (mem[_4718 + 96] * mem[_4718]) + (mem[_4718 + 128] * mem[_4718]):
                        _5031 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5031] = 26
                        mem[_5031 + 32] = 'SafeMath: division by zero'
                        if not _4866:
                            _5070 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _5070 + 68] = mem[_5031 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5070 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _5070 + -mem[64] + 100
                        _5226 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5226] = 26
                        mem[_5226 + 32] = 'SafeMath: division by zero'
                        if _4865:
                            if t > !(0 / _4866 / _4865):
                                revert with 0, 17
                            if t + (0 / _4866 / _4865) < t:
                                revert with 0, 'SafeMath: addition overflow'
                            if s == -1:
                                revert with 0, 17
                            s = s + 1
                            t = t + (0 / _4866 / _4865)
                            continue 
                        _5276 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _5276 + 68] = mem[_5226 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_5276 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _5276 + -mem[64] + 100
                    if (mem[_4718 + 96] * mem[_4718]) + (mem[_4718 + 128] * mem[_4718]) and mem[_3387 + 64] > -1 / (mem[_4718 + 96] * mem[_4718]) + (mem[_4718 + 128] * mem[_4718]):
                        revert with 0, 17
                    if not (mem[_4718 + 96] * mem[_4718]) + (mem[_4718 + 128] * mem[_4718]):
                        revert with 0, 18
                    if (mem[_4718 + 96] * mem[_4718] * mem[_3387 + 64]) + (mem[_4718 + 128] * mem[_4718] * mem[_3387 + 64]) / (mem[_4718 + 96] * mem[_4718]) + (mem[_4718 + 128] * mem[_4718]) != mem[_3387 + 64]:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _5174 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5174] = 26
                    mem[_5174 + 32] = 'SafeMath: division by zero'
                    if not _4866:
                        _5225 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _5225 + 68] = mem[_5174 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_5225 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _5225 + -mem[64] + 100
                    _5358 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5358] = 26
                    mem[_5358 + 32] = 'SafeMath: division by zero'
                    if _4865:
                        if t > !((_4870 * _4868 * _4867) + (_4869 * _4868 * _4867) / _4866 / _4865):
                            revert with 0, 17
                        if t + ((_4870 * _4868 * _4867) + (_4869 * _4868 * _4867) / _4866 / _4865) < t:
                            revert with 0, 'SafeMath: addition overflow'
                        if s == -1:
                            revert with 0, 17
                        s = s + 1
                        t = t + ((_4870 * _4868 * _4867) + (_4869 * _4868 * _4867) / _4866 / _4865)
                        continue 
                    _5413 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5413 + 68] = mem[_5358 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_5413 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _5413 + -mem[64] + 100
                _4697 = mem[_1711 + 32]
                if mem[_1711 + 32] > !t:
                    revert with 0, 17
                if mem[_1711 + 32] + t < mem[_1711 + 32]:
                    revert with 0, 'SafeMath: addition overflow'
                if not mem[_1711 + 32] + t:
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                if not mem[_1711 + 32] + t:
                    _4939 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4939] = 26
                    mem[_4939 + 32] = 'SafeMath: division by zero'
                    if not DENOMINATOR:
                        _4946 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4946 + 68] = mem[_4939 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_4946 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _4946 + -mem[64] + 100
                    _5017 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5017] = 30
                    mem[_5017 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / DENOMINATOR <= sub_04b4a313:
                        if sub_04b4a313 < 0 / DENOMINATOR:
                            revert with 0, 17
                        sub_04b4a313 -= 0 / DENOMINATOR
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                    _5051 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _5051 + 68] = mem[_5017 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_5051 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _5051 + -mem[64] + 100
                if mem[_1711 + 32] + t and sub_d8830c7d > -1 / mem[_1711 + 32] + t:
                    revert with 0, 17
                if not mem[_1711 + 32] + t:
                    revert with 0, 18
                if (mem[_1711 + 32] * sub_d8830c7d) + (t * sub_d8830c7d) / mem[_1711 + 32] + t != sub_d8830c7d:
                    revert with 0, 'SafeMath: multiplication overflow'
                _4996 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4996] = 26
                mem[_4996 + 32] = 'SafeMath: division by zero'
                if not DENOMINATOR:
                    _5016 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5016 + 68] = mem[_4996 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_5016 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _5016 + -mem[64] + 100
                _5147 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5147] = 30
                mem[_5147 + 32] = 'SafeMath: subtraction overflow'
                if (_4697 * sub_d8830c7d) + (t * sub_d8830c7d) / DENOMINATOR <= sub_04b4a313:
                    if sub_04b4a313 < (_4697 * sub_d8830c7d) + (t * sub_d8830c7d) / DENOMINATOR:
                        revert with 0, 17
                    sub_04b4a313 -= (_4697 * sub_d8830c7d) + (t * sub_d8830c7d) / DENOMINATOR
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                _5202 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _5202 + 68] = mem[_5147 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_5202 + 98] = 0
                revert with memory
                  from mem[64]
                   len _5202 + -mem[64] + 100
            _3280 = mem[_1711 + 160]
            _3289 = mem[64]
            mem[64] = mem[64] + 64
            mem[_3289] = 30
            mem[_3289 + 32] = 'SafeMath: subtraction overflow'
            if t > _3280:
                _3338 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _3338 + 68] = mem[_3289 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_3338 + 98] = 0
                revert with memory
                  from mem[64]
                   len _3338 + -mem[64] + 100
            if _3280 < t:
                revert with 0, 17
            _3395 = mem[_1711]
            staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                    gas gas_remaining wei
                   args sub_4c86259e[idx].field_0, Mask(128, 128, mem[_1711])
            mem[mem[64] len 352] = ext_call.return_data[0 len 352]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3430 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 352
            _3450 = mem[64]
            if mem[64] + 352 < mem[64] or mem[64] + 352 > test266151307():
                revert with 0, 65
            mem[64] = mem[64] + 352
            require mem[_3430] == Mask(128, 128, mem[_3430])
            mem[_3450] = mem[_3430]
            mem[_3450 + 32] = mem[_3430 + 32]
            mem[_3450 + 64] = mem[_3430 + 64]
            mem[_3450 + 96] = mem[_3430 + 96]
            require mem[_3430 + 128] < 5
            mem[_3450 + 128] = mem[_3430 + 128]
            mem[_3450 + 160] = mem[_3430 + 160]
            mem[_3450 + 192] = mem[_3430 + 192]
            mem[_3450 + 224] = mem[_3430 + 224]
            mem[_3450 + 256] = mem[_3430 + 256]
            mem[_3450 + 288] = mem[_3430 + 288]
            mem[_3450 + 320] = mem[_3430 + 320]
            if Mask(128, 128, mem[_3450]) != Mask(128, 128, _3395):
                revert with 0, 'Address does not contain stake with provided id'
            s = mem[_3450 + 192]
            u = 0
            while s < _1750 + _1749:
                staticcall sub_413c05c6Address.0x8ce1d9e4 with:
                        gas gas_remaining wei
                       args s
                mem[mem[64] len 160] = ext_call.return_data[0 len 160]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _4700 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 160
                _4719 = mem[64]
                if mem[64] + 160 > test266151307() or mem[64] + 160 < mem[64]:
                    revert with 0, 65
                mem[64] = mem[64] + 160
                mem[_4719] = mem[_4700]
                mem[_4719 + 32] = mem[_4700 + 32]
                mem[_4719 + 64] = mem[_4700 + 64]
                mem[_4719 + 96] = mem[_4700 + 96]
                mem[_4719 + 128] = mem[_4700 + 128]
                _4871 = mem[_4719 + 64]
                _4872 = mem[_4719 + 32]
                _4873 = mem[_3450 + 64]
                _4874 = mem[_4719]
                _4875 = mem[_4719 + 128]
                _4876 = mem[_4719 + 96]
                if mem[_4719 + 96] > !mem[_4719 + 128]:
                    revert with 0, 17
                if mem[_4719 + 96] + mem[_4719 + 128] < mem[_4719 + 96]:
                    revert with 0, 'SafeMath: addition overflow'
                if not mem[_4719 + 96] + mem[_4719 + 128]:
                    _4956 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4956] = 26
                    mem[_4956 + 32] = 'SafeMath: division by zero'
                    if not _4872:
                        _4986 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4986 + 68] = mem[_4956 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_4986 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _4986 + -mem[64] + 100
                    _5074 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5074] = 26
                    mem[_5074 + 32] = 'SafeMath: division by zero'
                    if _4871:
                        if u > !(0 / _4872 / _4871):
                            revert with 0, 17
                        if u + (0 / _4872 / _4871) < u:
                            revert with 0, 'SafeMath: addition overflow'
                        if s == -1:
                            revert with 0, 17
                        s = s + 1
                        u = u + (0 / _4872 / _4871)
                        continue 
                    _5123 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5123 + 68] = mem[_5074 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_5123 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _5123 + -mem[64] + 100
                if mem[_4719 + 96] + mem[_4719 + 128] and mem[_4719] > -1 / mem[_4719 + 96] + mem[_4719 + 128]:
                    revert with 0, 17
                if not mem[_4719 + 96] + mem[_4719 + 128]:
                    revert with 0, 18
                if (mem[_4719 + 96] * mem[_4719]) + (mem[_4719 + 128] * mem[_4719]) / mem[_4719 + 96] + mem[_4719 + 128] != mem[_4719]:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not (mem[_4719 + 96] * mem[_4719]) + (mem[_4719 + 128] * mem[_4719]):
                    _5033 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5033] = 26
                    mem[_5033 + 32] = 'SafeMath: division by zero'
                    if not _4872:
                        _5073 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _5073 + 68] = mem[_5033 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_5073 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _5073 + -mem[64] + 100
                    _5229 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5229] = 26
                    mem[_5229 + 32] = 'SafeMath: division by zero'
                    if _4871:
                        if u > !(0 / _4872 / _4871):
                            revert with 0, 17
                        if u + (0 / _4872 / _4871) < u:
                            revert with 0, 'SafeMath: addition overflow'
                        if s == -1:
                            revert with 0, 17
                        s = s + 1
                        u = u + (0 / _4872 / _4871)
                        continue 
                    _5279 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5279 + 68] = mem[_5229 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_5279 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _5279 + -mem[64] + 100
                if (mem[_4719 + 96] * mem[_4719]) + (mem[_4719 + 128] * mem[_4719]) and mem[_3450 + 64] > -1 / (mem[_4719 + 96] * mem[_4719]) + (mem[_4719 + 128] * mem[_4719]):
                    revert with 0, 17
                if not (mem[_4719 + 96] * mem[_4719]) + (mem[_4719 + 128] * mem[_4719]):
                    revert with 0, 18
                if (mem[_4719 + 96] * mem[_4719] * mem[_3450 + 64]) + (mem[_4719 + 128] * mem[_4719] * mem[_3450 + 64]) / (mem[_4719 + 96] * mem[_4719]) + (mem[_4719 + 128] * mem[_4719]) != mem[_3450 + 64]:
                    revert with 0, 'SafeMath: multiplication overflow'
                _5178 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5178] = 26
                mem[_5178 + 32] = 'SafeMath: division by zero'
                if not _4872:
                    _5228 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5228 + 68] = mem[_5178 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_5228 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _5228 + -mem[64] + 100
                _5362 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5362] = 26
                mem[_5362 + 32] = 'SafeMath: division by zero'
                if _4871:
                    if u > !((_4876 * _4874 * _4873) + (_4875 * _4874 * _4873) / _4872 / _4871):
                        revert with 0, 17
                    if u + ((_4876 * _4874 * _4873) + (_4875 * _4874 * _4873) / _4872 / _4871) < u:
                        revert with 0, 'SafeMath: addition overflow'
                    if s == -1:
                        revert with 0, 17
                    s = s + 1
                    u = u + ((_4876 * _4874 * _4873) + (_4875 * _4874 * _4873) / _4872 / _4871)
                    continue 
                _5415 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _5415 + 68] = mem[_5362 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_5415 + 94] = 0
                revert with memory
                  from mem[64]
                   len _5415 + -mem[64] + 100
            _4699 = mem[_1711 + 32]
            if _3280 - t > !u:
                revert with 0, 17
            if u < 0:
                revert with 0, 'SafeMath: addition overflow'
            if mem[_1711 + 32] > !(_3280 - t + u):
                revert with 0, 17
            if mem[_1711 + 32] + _3280 - t + u < mem[_1711 + 32]:
                revert with 0, 'SafeMath: addition overflow'
            if not mem[_1711 + 32] + _3280 - t + u:
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            if not mem[_1711 + 32] + _3280 - t + u:
                _4998 = mem[64]
                mem[64] = mem[64] + 64
                mem[_4998] = 26
                mem[_4998 + 32] = 'SafeMath: division by zero'
                if not DENOMINATOR:
                    _5018 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5018 + 68] = mem[_4998 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_5018 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _5018 + -mem[64] + 100
                _5151 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5151] = 30
                mem[_5151 + 32] = 'SafeMath: subtraction overflow'
                if 0 / DENOMINATOR <= sub_04b4a313:
                    if sub_04b4a313 < 0 / DENOMINATOR:
                        revert with 0, 17
                    sub_04b4a313 -= 0 / DENOMINATOR
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                _5205 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _5205 + 68] = mem[_5151 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_5205 + 98] = 0
                revert with memory
                  from mem[64]
                   len _5205 + -mem[64] + 100
            if mem[_1711 + 32] + _3280 - t + u and sub_d8830c7d > -1 / mem[_1711 + 32] + _3280 - t + u:
                revert with 0, 17
            if not mem[_1711 + 32] + _3280 - t + u:
                revert with 0, 18
            if (mem[_1711 + 32] * sub_d8830c7d) + (_3280 * sub_d8830c7d) - (t * sub_d8830c7d) + (u * sub_d8830c7d) / mem[_1711 + 32] + _3280 - t + u != sub_d8830c7d:
                revert with 0, 'SafeMath: multiplication overflow'
            _5094 = mem[64]
            mem[64] = mem[64] + 64
            mem[_5094] = 26
            mem[_5094 + 32] = 'SafeMath: division by zero'
            if not DENOMINATOR:
                _5150 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _5150 + 68] = mem[_5094 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_5150 + 94] = 0
                revert with memory
                  from mem[64]
                   len _5150 + -mem[64] + 100
            _5300 = mem[64]
            mem[64] = mem[64] + 64
            mem[_5300] = 30
            mem[_5300 + 32] = 'SafeMath: subtraction overflow'
            if (_4699 * sub_d8830c7d) + (_3280 * sub_d8830c7d) - (t * sub_d8830c7d) + (u * sub_d8830c7d) / DENOMINATOR <= sub_04b4a313:
                if sub_04b4a313 < (_4699 * sub_d8830c7d) + (_3280 * sub_d8830c7d) - (t * sub_d8830c7d) + (u * sub_d8830c7d) / DENOMINATOR:
                    revert with 0, 17
                sub_04b4a313 -= (_4699 * sub_d8830c7d) + (_3280 * sub_d8830c7d) - (t * sub_d8830c7d) + (u * sub_d8830c7d) / DENOMINATOR
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            _5343 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[idx + _5343 + 68] = mem[_5300 + idx + 32]
                idx = idx + 32
                continue 
            mem[_5343 + 98] = 0
            revert with memory
              from mem[64]
               len _5343 + -mem[64] + 100
    else:
        idx = arg1
        while idx < sub_d3a8b1da:
            mem[0] = Mask(128, 128, sub_4c86259e[idx].field_256)
            mem[32] = sha3(sub_4c86259e[idx].field_0, 9)
            if not stor9[stor12[idx].field_0][Mask(128, 128, stor12[idx].field_256)]:
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            stor9[stor12[idx].field_0][Mask(128, 128, stor12[idx].field_256)] = 0
            if sub_1b385a01[stor12[idx].field_0] < 1:
                revert with 0, 17
            sub_1b385a01[stor12[idx].field_0]--
            if not sub_ab7789c0:
                revert with 0, 17
            sub_ab7789c0--
            mem[0] = idx
            mem[32] = 12
            if 1 > !sub_ed73481d:
                revert with 0, 17
            _1648 = mem[64]
            mem[64] = mem[64] + 352
            mem[_1648] = 0
            mem[_1648 + 32] = 0
            mem[_1648 + 64] = 0
            mem[_1648 + 96] = 0
            mem[_1648 + 128] = 0
            mem[_1648 + 160] = 0
            mem[_1648 + 192] = 0
            mem[_1648 + 224] = 0
            mem[_1648 + 256] = 0
            mem[_1648 + 288] = 0
            mem[_1648 + 320] = 0
            staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                    gas gas_remaining wei
                   args sub_4c86259e[idx].field_0, Mask(128, 128, sub_4c86259e[idx].field_256)
            mem[mem[64] len 352] = ext_call.return_data[0 len 352]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1654 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 352
            _1656 = mem[64]
            if mem[64] + 352 < mem[64] or mem[64] + 352 > test266151307():
                revert with 0, 65
            mem[64] = mem[64] + 352
            require mem[_1654] == Mask(128, 128, mem[_1654])
            mem[_1656] = mem[_1654]
            mem[_1656 + 32] = mem[_1654 + 32]
            mem[_1656 + 64] = mem[_1654 + 64]
            mem[_1656 + 96] = mem[_1654 + 96]
            require mem[_1654 + 128] < 5
            mem[_1656 + 128] = mem[_1654 + 128]
            mem[_1656 + 160] = mem[_1654 + 160]
            mem[_1656 + 192] = mem[_1654 + 192]
            mem[_1656 + 224] = mem[_1654 + 224]
            mem[_1656 + 256] = mem[_1654 + 256]
            mem[_1656 + 288] = mem[_1654 + 288]
            mem[_1656 + 320] = mem[_1654 + 320]
            if Mask(128, 128, mem[_1656]) != Mask(128, 128, sub_4c86259e[idx].field_256):
                _1686 = mem[64]
                mem[64] = mem[64] + 96
                mem[_1686] = 46
                mem[_1686 + 32 len 46] = 0xfe53656e64657220646f6573206e6f7420636f6e7461696e207374616b6520776974682070726f76696465642069
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            mem[0] = Mask(128, 128, sub_4c86259e[idx].field_256)
            mem[32] = sha3(sub_4c86259e[idx].field_0, 9)
            if stor9[stor12[idx].field_0][Mask(128, 128, stor12[idx].field_256)]:
                _1690 = mem[64]
                mem[64] = mem[64] + 64
                mem[_1690] = 32
                mem[_1690 + 32] = 'Stake has already been converted'
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            if mem[_1656 + 128] > 4:
                revert with 0, 33
            if mem[_1656 + 128] != 2:
                _1694 = mem[64]
                mem[64] = mem[64] + 96
                mem[_1694] = 44
                mem[_1694 + 32 len 44] = 0x795374616b65206973206f6e6c7920656c696769626c6520696620697420686173206265656e20636c6f7365
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            if mem[_1656 + 192] >= sub_be647a94:
                _1700 = mem[64]
                mem[64] = mem[64] + 128
                mem[_1700] = 65
                mem[_1700 + 32 len 65] = 0x645374616b65206973206f6e6c7920656c696769626c65206966206974207761732063726561746564207072696f7220746f2074686520637574206f6666206461
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            if mem[_1656 + 192] > !mem[_1656 + 224]:
                revert with 0, 17
            if mem[_1656 + 192] + mem[_1656 + 224] < sub_be647a94:
                _1704 = mem[64]
                mem[64] = mem[64] + 128
                mem[_1704] = 66
                mem[_1704 + 32 len 66] = 0x645374616b65206973206f6e6c7920656c696769626c652069662069742077617320656e646564206f6e2074686520637574206f666620646179206f722061667465
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            _1703 = mem[64]
            mem[64] = mem[64] + 64
            mem[_1703] = 17
            mem[_1703 + 32] = 'Stake is eligible' << 120
            staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                    gas gas_remaining wei
                   args sub_4c86259e[idx].field_0, Mask(128, 128, sub_4c86259e[idx].field_256)
            mem[mem[64] len 352] = ext_call.return_data[0 len 352]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1710 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 352
            _1712 = mem[64]
            if mem[64] + 352 < mem[64] or mem[64] + 352 > test266151307():
                revert with 0, 65
            mem[64] = mem[64] + 352
            require mem[_1710] == Mask(128, 128, mem[_1710])
            mem[_1712] = mem[_1710]
            mem[_1712 + 32] = mem[_1710 + 32]
            mem[_1712 + 64] = mem[_1710 + 64]
            mem[_1712 + 96] = mem[_1710 + 96]
            require mem[_1710 + 128] < 5
            mem[_1712 + 128] = mem[_1710 + 128]
            mem[_1712 + 160] = mem[_1710 + 160]
            mem[_1712 + 192] = mem[_1710 + 192]
            mem[_1712 + 224] = mem[_1710 + 224]
            mem[_1712 + 256] = mem[_1710 + 256]
            mem[_1712 + 288] = mem[_1710 + 288]
            mem[_1712 + 320] = mem[_1710 + 320]
            if Mask(128, 128, mem[_1712]) != Mask(128, 128, sub_4c86259e[idx].field_256):
                revert with 0, 'Address does not contain stake with provided id'
            if mem[_1712 + 128] > 4:
                revert with 0, 33
            if mem[_1712 + 128] == 3:
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            if mem[_1712 + 128] > 4:
                revert with 0, 33
            if mem[_1712 + 128] == 4:
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            if mem[_1712 + 128] > 4:
                revert with 0, 33
            if mem[_1712 + 128] == 1:
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            if mem[_1712 + 128] > 4:
                revert with 0, 33
            if not mem[_1712 + 128]:
                _1754 = mem[_1712]
                staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                        gas gas_remaining wei
                       args sub_4c86259e[idx].field_0, Mask(128, 128, mem[_1712])
                mem[mem[64] len 352] = ext_call.return_data[0 len 352]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1760 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 352
                _1770 = mem[64]
                if mem[64] + 352 < mem[64] or mem[64] + 352 > test266151307():
                    revert with 0, 65
                mem[64] = mem[64] + 352
                require mem[_1760] == Mask(128, 128, mem[_1760])
                mem[_1770] = mem[_1760]
                mem[_1770 + 32] = mem[_1760 + 32]
                mem[_1770 + 64] = mem[_1760 + 64]
                mem[_1770 + 96] = mem[_1760 + 96]
                require mem[_1760 + 128] < 5
                mem[_1770 + 128] = mem[_1760 + 128]
                mem[_1770 + 160] = mem[_1760 + 160]
                mem[_1770 + 192] = mem[_1760 + 192]
                mem[_1770 + 224] = mem[_1760 + 224]
                mem[_1770 + 256] = mem[_1760 + 256]
                mem[_1770 + 288] = mem[_1760 + 288]
                mem[_1770 + 320] = mem[_1760 + 320]
                if Mask(128, 128, mem[_1770]) != Mask(128, 128, _1754):
                    revert with 0, 'Address does not contain stake with provided id'
                s = mem[_1770 + 192]
                t = 0
                while s < sub_ed73481d + 1:
                    staticcall sub_413c05c6Address.0x8ce1d9e4 with:
                            gas gas_remaining wei
                           args s
                    mem[mem[64] len 160] = ext_call.return_data[0 len 160]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3276 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 160
                    _3298 = mem[64]
                    if mem[64] + 160 > test266151307() or mem[64] + 160 < mem[64]:
                        revert with 0, 65
                    mem[64] = mem[64] + 160
                    mem[_3298] = mem[_3276]
                    mem[_3298 + 32] = mem[_3276 + 32]
                    mem[_3298 + 64] = mem[_3276 + 64]
                    mem[_3298 + 96] = mem[_3276 + 96]
                    mem[_3298 + 128] = mem[_3276 + 128]
                    _3367 = mem[_3298 + 64]
                    _3368 = mem[_3298 + 32]
                    _3369 = mem[_1770 + 64]
                    _3370 = mem[_3298]
                    _3371 = mem[_3298 + 128]
                    _3372 = mem[_3298 + 96]
                    if mem[_3298 + 96] > !mem[_3298 + 128]:
                        revert with 0, 17
                    if mem[_3298 + 96] + mem[_3298 + 128] < mem[_3298 + 96]:
                        revert with 0, 'SafeMath: addition overflow'
                    if not mem[_3298 + 96] + mem[_3298 + 128]:
                        _3500 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3500] = 26
                        mem[_3500 + 32] = 'SafeMath: division by zero'
                        if not _3368:
                            _3520 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _3520 + 68] = mem[_3500 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3520 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3520 + -mem[64] + 100
                        _3672 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3672] = 26
                        mem[_3672 + 32] = 'SafeMath: division by zero'
                        if _3367:
                            if t > !(0 / _3368 / _3367):
                                revert with 0, 17
                            if t + (0 / _3368 / _3367) < t:
                                revert with 0, 'SafeMath: addition overflow'
                            if s == -1:
                                revert with 0, 17
                            s = s + 1
                            t = t + (0 / _3368 / _3367)
                            continue 
                        _3713 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _3713 + 68] = mem[_3672 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3713 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3713 + -mem[64] + 100
                    if mem[_3298 + 96] + mem[_3298 + 128] and mem[_3298] > -1 / mem[_3298 + 96] + mem[_3298 + 128]:
                        revert with 0, 17
                    if not mem[_3298 + 96] + mem[_3298 + 128]:
                        revert with 0, 18
                    if (mem[_3298 + 96] * mem[_3298]) + (mem[_3298 + 128] * mem[_3298]) / mem[_3298 + 96] + mem[_3298 + 128] != mem[_3298]:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not (mem[_3298 + 96] * mem[_3298]) + (mem[_3298 + 128] * mem[_3298]):
                        _3581 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3581] = 26
                        mem[_3581 + 32] = 'SafeMath: division by zero'
                        if not _3368:
                            _3671 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _3671 + 68] = mem[_3581 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3671 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3671 + -mem[64] + 100
                        _3807 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3807] = 26
                        mem[_3807 + 32] = 'SafeMath: division by zero'
                        if _3367:
                            if t > !(0 / _3368 / _3367):
                                revert with 0, 17
                            if t + (0 / _3368 / _3367) < t:
                                revert with 0, 'SafeMath: addition overflow'
                            if s == -1:
                                revert with 0, 17
                            s = s + 1
                            t = t + (0 / _3368 / _3367)
                            continue 
                        _3879 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _3879 + 68] = mem[_3807 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3879 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3879 + -mem[64] + 100
                    if (mem[_3298 + 96] * mem[_3298]) + (mem[_3298 + 128] * mem[_3298]) and mem[_1770 + 64] > -1 / (mem[_3298 + 96] * mem[_3298]) + (mem[_3298 + 128] * mem[_3298]):
                        revert with 0, 17
                    if not (mem[_3298 + 96] * mem[_3298]) + (mem[_3298 + 128] * mem[_3298]):
                        revert with 0, 18
                    if (mem[_3298 + 96] * mem[_3298] * mem[_1770 + 64]) + (mem[_3298 + 128] * mem[_3298] * mem[_1770 + 64]) / (mem[_3298 + 96] * mem[_3298]) + (mem[_3298 + 128] * mem[_3298]) != mem[_1770 + 64]:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _3762 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3762] = 26
                    mem[_3762 + 32] = 'SafeMath: division by zero'
                    if not _3368:
                        _3806 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _3806 + 68] = mem[_3762 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3806 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3806 + -mem[64] + 100
                    _3944 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3944] = 26
                    mem[_3944 + 32] = 'SafeMath: division by zero'
                    if _3367:
                        if t > !((_3372 * _3370 * _3369) + (_3371 * _3370 * _3369) / _3368 / _3367):
                            revert with 0, 17
                        if t + ((_3372 * _3370 * _3369) + (_3371 * _3370 * _3369) / _3368 / _3367) < t:
                            revert with 0, 'SafeMath: addition overflow'
                        if s == -1:
                            revert with 0, 17
                        s = s + 1
                        t = t + ((_3372 * _3370 * _3369) + (_3371 * _3370 * _3369) / _3368 / _3367)
                        continue 
                    _3985 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _3985 + 68] = mem[_3944 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3985 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _3985 + -mem[64] + 100
                _3274 = mem[_1712 + 32]
                _3275 = mem[_1712 + 160]
                if mem[_1712 + 160] > !t:
                    revert with 0, 17
                if mem[_1712 + 160] + t < mem[_1712 + 160]:
                    revert with 0, 'SafeMath: addition overflow'
                if mem[_1712 + 32] > !(mem[_1712 + 160] + t):
                    revert with 0, 17
                if mem[_1712 + 32] + mem[_1712 + 160] + t < mem[_1712 + 32]:
                    revert with 0, 'SafeMath: addition overflow'
                if not mem[_1712 + 32] + mem[_1712 + 160] + t:
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                if not mem[_1712 + 32] + mem[_1712 + 160] + t:
                    _3534 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3534] = 26
                    mem[_3534 + 32] = 'SafeMath: division by zero'
                    if not DENOMINATOR:
                        _3566 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _3566 + 68] = mem[_3534 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3566 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3566 + -mem[64] + 100
                    _3735 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3735] = 30
                    mem[_3735 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / DENOMINATOR <= sub_04b4a313:
                        if sub_04b4a313 < 0 / DENOMINATOR:
                            revert with 0, 17
                        sub_04b4a313 -= 0 / DENOMINATOR
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                    _3777 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _3777 + 68] = mem[_3735 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3777 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _3777 + -mem[64] + 100
                if mem[_1712 + 32] + mem[_1712 + 160] + t and sub_d8830c7d > -1 / mem[_1712 + 32] + mem[_1712 + 160] + t:
                    revert with 0, 17
                if not mem[_1712 + 32] + mem[_1712 + 160] + t:
                    revert with 0, 18
                if (mem[_1712 + 32] * sub_d8830c7d) + (mem[_1712 + 160] * sub_d8830c7d) + (t * sub_d8830c7d) / mem[_1712 + 32] + mem[_1712 + 160] + t != sub_d8830c7d:
                    revert with 0, 'SafeMath: multiplication overflow'
                _3688 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3688] = 26
                mem[_3688 + 32] = 'SafeMath: division by zero'
                if not DENOMINATOR:
                    _3734 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _3734 + 68] = mem[_3688 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3734 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _3734 + -mem[64] + 100
                _3892 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3892] = 30
                mem[_3892 + 32] = 'SafeMath: subtraction overflow'
                if (_3274 * sub_d8830c7d) + (_3275 * sub_d8830c7d) + (t * sub_d8830c7d) / DENOMINATOR <= sub_04b4a313:
                    if sub_04b4a313 < (_3274 * sub_d8830c7d) + (_3275 * sub_d8830c7d) + (t * sub_d8830c7d) / DENOMINATOR:
                        revert with 0, 17
                    sub_04b4a313 -= (_3274 * sub_d8830c7d) + (_3275 * sub_d8830c7d) + (t * sub_d8830c7d) / DENOMINATOR
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                _3921 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _3921 + 68] = mem[_3892 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_3921 + 98] = 0
                revert with memory
                  from mem[64]
                   len _3921 + -mem[64] + 100
            _1752 = mem[_1712 + 224]
            _1753 = mem[_1712 + 192]
            if mem[_1712 + 192] > !mem[_1712 + 224]:
                revert with 0, 17
            if sub_ed73481d + 1 < mem[_1712 + 192] + mem[_1712 + 224]:
                _1763 = mem[_1712]
                staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                        gas gas_remaining wei
                       args sub_4c86259e[idx].field_0, Mask(128, 128, mem[_1712])
                mem[mem[64] len 352] = ext_call.return_data[0 len 352]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _1777 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 352
                _1783 = mem[64]
                if mem[64] + 352 < mem[64] or mem[64] + 352 > test266151307():
                    revert with 0, 65
                mem[64] = mem[64] + 352
                require mem[_1777] == Mask(128, 128, mem[_1777])
                mem[_1783] = mem[_1777]
                mem[_1783 + 32] = mem[_1777 + 32]
                mem[_1783 + 64] = mem[_1777 + 64]
                mem[_1783 + 96] = mem[_1777 + 96]
                require mem[_1777 + 128] < 5
                mem[_1783 + 128] = mem[_1777 + 128]
                mem[_1783 + 160] = mem[_1777 + 160]
                mem[_1783 + 192] = mem[_1777 + 192]
                mem[_1783 + 224] = mem[_1777 + 224]
                mem[_1783 + 256] = mem[_1777 + 256]
                mem[_1783 + 288] = mem[_1777 + 288]
                mem[_1783 + 320] = mem[_1777 + 320]
                if Mask(128, 128, mem[_1783]) != Mask(128, 128, _1763):
                    revert with 0, 'Address does not contain stake with provided id'
                s = mem[_1783 + 192]
                t = 0
                while s < _1753 + _1752:
                    staticcall sub_413c05c6Address.0x8ce1d9e4 with:
                            gas gas_remaining wei
                           args s
                    mem[mem[64] len 160] = ext_call.return_data[0 len 160]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3271 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 160
                    _3294 = mem[64]
                    if mem[64] + 160 > test266151307() or mem[64] + 160 < mem[64]:
                        revert with 0, 65
                    mem[64] = mem[64] + 160
                    mem[_3294] = mem[_3271]
                    mem[_3294 + 32] = mem[_3271 + 32]
                    mem[_3294 + 64] = mem[_3271 + 64]
                    mem[_3294 + 96] = mem[_3271 + 96]
                    mem[_3294 + 128] = mem[_3271 + 128]
                    _3353 = mem[_3294 + 64]
                    _3354 = mem[_3294 + 32]
                    _3355 = mem[_1783 + 64]
                    _3356 = mem[_3294]
                    _3357 = mem[_3294 + 128]
                    _3358 = mem[_3294 + 96]
                    if mem[_3294 + 96] > !mem[_3294 + 128]:
                        revert with 0, 17
                    if mem[_3294 + 96] + mem[_3294 + 128] < mem[_3294 + 96]:
                        revert with 0, 'SafeMath: addition overflow'
                    if not mem[_3294 + 96] + mem[_3294 + 128]:
                        _3494 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3494] = 26
                        mem[_3494 + 32] = 'SafeMath: division by zero'
                        if not _3354:
                            _3518 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _3518 + 68] = mem[_3494 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3518 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3518 + -mem[64] + 100
                        _3660 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3660] = 26
                        mem[_3660 + 32] = 'SafeMath: division by zero'
                        if _3353:
                            if t > !(0 / _3354 / _3353):
                                revert with 0, 17
                            if t + (0 / _3354 / _3353) < t:
                                revert with 0, 'SafeMath: addition overflow'
                            if s == -1:
                                revert with 0, 17
                            s = s + 1
                            t = t + (0 / _3354 / _3353)
                            continue 
                        _3705 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _3705 + 68] = mem[_3660 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3705 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3705 + -mem[64] + 100
                    if mem[_3294 + 96] + mem[_3294 + 128] and mem[_3294] > -1 / mem[_3294 + 96] + mem[_3294 + 128]:
                        revert with 0, 17
                    if not mem[_3294 + 96] + mem[_3294 + 128]:
                        revert with 0, 18
                    if (mem[_3294 + 96] * mem[_3294]) + (mem[_3294 + 128] * mem[_3294]) / mem[_3294 + 96] + mem[_3294 + 128] != mem[_3294]:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not (mem[_3294 + 96] * mem[_3294]) + (mem[_3294 + 128] * mem[_3294]):
                        _3576 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3576] = 26
                        mem[_3576 + 32] = 'SafeMath: division by zero'
                        if not _3354:
                            _3659 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _3659 + 68] = mem[_3576 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_3659 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _3659 + -mem[64] + 100
                        _3798 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_3798] = 26
                        mem[_3798 + 32] = 'SafeMath: division by zero'
                        if _3353:
                            if t > !(0 / _3354 / _3353):
                                revert with 0, 17
                            if t + (0 / _3354 / _3353) < t:
                                revert with 0, 'SafeMath: addition overflow'
                            if s == -1:
                                revert with 0, 17
                            s = s + 1
                            t = t + (0 / _3354 / _3353)
                            continue 
                        _3867 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _3867 + 68] = mem[_3798 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3867 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3867 + -mem[64] + 100
                    if (mem[_3294 + 96] * mem[_3294]) + (mem[_3294 + 128] * mem[_3294]) and mem[_1783 + 64] > -1 / (mem[_3294 + 96] * mem[_3294]) + (mem[_3294 + 128] * mem[_3294]):
                        revert with 0, 17
                    if not (mem[_3294 + 96] * mem[_3294]) + (mem[_3294 + 128] * mem[_3294]):
                        revert with 0, 18
                    if (mem[_3294 + 96] * mem[_3294] * mem[_1783 + 64]) + (mem[_3294 + 128] * mem[_3294] * mem[_1783 + 64]) / (mem[_3294 + 96] * mem[_3294]) + (mem[_3294 + 128] * mem[_3294]) != mem[_1783 + 64]:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _3753 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3753] = 26
                    mem[_3753 + 32] = 'SafeMath: division by zero'
                    if not _3354:
                        _3797 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _3797 + 68] = mem[_3753 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3797 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3797 + -mem[64] + 100
                    _3936 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3936] = 26
                    mem[_3936 + 32] = 'SafeMath: division by zero'
                    if _3353:
                        if t > !((_3358 * _3356 * _3355) + (_3357 * _3356 * _3355) / _3354 / _3353):
                            revert with 0, 17
                        if t + ((_3358 * _3356 * _3355) + (_3357 * _3356 * _3355) / _3354 / _3353) < t:
                            revert with 0, 'SafeMath: addition overflow'
                        if s == -1:
                            revert with 0, 17
                        s = s + 1
                        t = t + ((_3358 * _3356 * _3355) + (_3357 * _3356 * _3355) / _3354 / _3353)
                        continue 
                    _3979 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _3979 + 68] = mem[_3936 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3979 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _3979 + -mem[64] + 100
                if t >= mem[_1712 + 160]:
                    _3281 = mem[_1712]
                    staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                            gas gas_remaining wei
                           args sub_4c86259e[idx].field_0, Mask(128, 128, mem[_1712])
                    mem[mem[64] len 352] = ext_call.return_data[0 len 352]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _3376 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 352
                    _3389 = mem[64]
                    if mem[64] + 352 < mem[64] or mem[64] + 352 > test266151307():
                        revert with 0, 65
                    mem[64] = mem[64] + 352
                    require mem[_3376] == Mask(128, 128, mem[_3376])
                    mem[_3389] = mem[_3376]
                    mem[_3389 + 32] = mem[_3376 + 32]
                    mem[_3389 + 64] = mem[_3376 + 64]
                    mem[_3389 + 96] = mem[_3376 + 96]
                    require mem[_3376 + 128] < 5
                    mem[_3389 + 128] = mem[_3376 + 128]
                    mem[_3389 + 160] = mem[_3376 + 160]
                    mem[_3389 + 192] = mem[_3376 + 192]
                    mem[_3389 + 224] = mem[_3376 + 224]
                    mem[_3389 + 256] = mem[_3376 + 256]
                    mem[_3389 + 288] = mem[_3376 + 288]
                    mem[_3389 + 320] = mem[_3376 + 320]
                    if Mask(128, 128, mem[_3389]) != Mask(128, 128, _3281):
                        revert with 0, 'Address does not contain stake with provided id'
                    s = mem[_3389 + 192]
                    t = 0
                    while s < sub_ed73481d + 1:
                        staticcall sub_413c05c6Address.0x8ce1d9e4 with:
                                gas gas_remaining wei
                               args s
                        mem[mem[64] len 160] = ext_call.return_data[0 len 160]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _4702 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 160
                        _4737 = mem[64]
                        if mem[64] + 160 > test266151307() or mem[64] + 160 < mem[64]:
                            revert with 0, 65
                        mem[64] = mem[64] + 160
                        mem[_4737] = mem[_4702]
                        mem[_4737 + 32] = mem[_4702 + 32]
                        mem[_4737 + 64] = mem[_4702 + 64]
                        mem[_4737 + 96] = mem[_4702 + 96]
                        mem[_4737 + 128] = mem[_4702 + 128]
                        _4877 = mem[_4737 + 64]
                        _4878 = mem[_4737 + 32]
                        _4879 = mem[_3389 + 64]
                        _4880 = mem[_4737]
                        _4881 = mem[_4737 + 128]
                        _4882 = mem[_4737 + 96]
                        if mem[_4737 + 96] > !mem[_4737 + 128]:
                            revert with 0, 17
                        if mem[_4737 + 96] + mem[_4737 + 128] < mem[_4737 + 96]:
                            revert with 0, 'SafeMath: addition overflow'
                        if not mem[_4737 + 96] + mem[_4737 + 128]:
                            _4958 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_4958] = 26
                            mem[_4958 + 32] = 'SafeMath: division by zero'
                            if not _4878:
                                _4988 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _4988 + 68] = mem[_4958 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_4988 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _4988 + -mem[64] + 100
                            _5076 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5076] = 26
                            mem[_5076 + 32] = 'SafeMath: division by zero'
                            if _4877:
                                if t > !(0 / _4878 / _4877):
                                    revert with 0, 17
                                if t + (0 / _4878 / _4877) < t:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s == -1:
                                    revert with 0, 17
                                s = s + 1
                                t = t + (0 / _4878 / _4877)
                                continue 
                            _5127 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _5127 + 68] = mem[_5076 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5127 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _5127 + -mem[64] + 100
                        if mem[_4737 + 96] + mem[_4737 + 128] and mem[_4737] > -1 / mem[_4737 + 96] + mem[_4737 + 128]:
                            revert with 0, 17
                        if not mem[_4737 + 96] + mem[_4737 + 128]:
                            revert with 0, 18
                        if (mem[_4737 + 96] * mem[_4737]) + (mem[_4737 + 128] * mem[_4737]) / mem[_4737 + 96] + mem[_4737 + 128] != mem[_4737]:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not (mem[_4737 + 96] * mem[_4737]) + (mem[_4737 + 128] * mem[_4737]):
                            _5036 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5036] = 26
                            mem[_5036 + 32] = 'SafeMath: division by zero'
                            if not _4878:
                                _5075 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _5075 + 68] = mem[_5036 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_5075 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _5075 + -mem[64] + 100
                            _5233 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_5233] = 26
                            mem[_5233 + 32] = 'SafeMath: division by zero'
                            if _4877:
                                if t > !(0 / _4878 / _4877):
                                    revert with 0, 17
                                if t + (0 / _4878 / _4877) < t:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s == -1:
                                    revert with 0, 17
                                s = s + 1
                                t = t + (0 / _4878 / _4877)
                                continue 
                            _5282 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _5282 + 68] = mem[_5233 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5282 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _5282 + -mem[64] + 100
                        if (mem[_4737 + 96] * mem[_4737]) + (mem[_4737 + 128] * mem[_4737]) and mem[_3389 + 64] > -1 / (mem[_4737 + 96] * mem[_4737]) + (mem[_4737 + 128] * mem[_4737]):
                            revert with 0, 17
                        if not (mem[_4737 + 96] * mem[_4737]) + (mem[_4737 + 128] * mem[_4737]):
                            revert with 0, 18
                        if (mem[_4737 + 96] * mem[_4737] * mem[_3389 + 64]) + (mem[_4737 + 128] * mem[_4737] * mem[_3389 + 64]) / (mem[_4737 + 96] * mem[_4737]) + (mem[_4737 + 128] * mem[_4737]) != mem[_3389 + 64]:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _5182 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5182] = 26
                        mem[_5182 + 32] = 'SafeMath: division by zero'
                        if not _4878:
                            _5232 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _5232 + 68] = mem[_5182 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5232 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _5232 + -mem[64] + 100
                        _5366 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5366] = 26
                        mem[_5366 + 32] = 'SafeMath: division by zero'
                        if _4877:
                            if t > !((_4882 * _4880 * _4879) + (_4881 * _4880 * _4879) / _4878 / _4877):
                                revert with 0, 17
                            if t + ((_4882 * _4880 * _4879) + (_4881 * _4880 * _4879) / _4878 / _4877) < t:
                                revert with 0, 'SafeMath: addition overflow'
                            if s == -1:
                                revert with 0, 17
                            s = s + 1
                            t = t + ((_4882 * _4880 * _4879) + (_4881 * _4880 * _4879) / _4878 / _4877)
                            continue 
                        _5417 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _5417 + 68] = mem[_5366 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_5417 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _5417 + -mem[64] + 100
                    _4701 = mem[_1712 + 32]
                    if mem[_1712 + 32] > !t:
                        revert with 0, 17
                    if mem[_1712 + 32] + t < mem[_1712 + 32]:
                        revert with 0, 'SafeMath: addition overflow'
                    if not mem[_1712 + 32] + t:
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                    if not mem[_1712 + 32] + t:
                        _4941 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4941] = 26
                        mem[_4941 + 32] = 'SafeMath: division by zero'
                        if not DENOMINATOR:
                            _4947 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _4947 + 68] = mem[_4941 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_4947 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _4947 + -mem[64] + 100
                        _5020 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5020] = 30
                        mem[_5020 + 32] = 'SafeMath: subtraction overflow'
                        if 0 / DENOMINATOR <= sub_04b4a313:
                            if sub_04b4a313 < 0 / DENOMINATOR:
                                revert with 0, 17
                            sub_04b4a313 -= 0 / DENOMINATOR
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            continue 
                        _5056 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _5056 + 68] = mem[_5020 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_5056 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _5056 + -mem[64] + 100
                    if mem[_1712 + 32] + t and sub_d8830c7d > -1 / mem[_1712 + 32] + t:
                        revert with 0, 17
                    if not mem[_1712 + 32] + t:
                        revert with 0, 18
                    if (mem[_1712 + 32] * sub_d8830c7d) + (t * sub_d8830c7d) / mem[_1712 + 32] + t != sub_d8830c7d:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _4999 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4999] = 26
                    mem[_4999 + 32] = 'SafeMath: division by zero'
                    if not DENOMINATOR:
                        _5019 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _5019 + 68] = mem[_4999 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_5019 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _5019 + -mem[64] + 100
                    _5153 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5153] = 30
                    mem[_5153 + 32] = 'SafeMath: subtraction overflow'
                    if (_4701 * sub_d8830c7d) + (t * sub_d8830c7d) / DENOMINATOR <= sub_04b4a313:
                        if sub_04b4a313 < (_4701 * sub_d8830c7d) + (t * sub_d8830c7d) / DENOMINATOR:
                            revert with 0, 17
                        sub_04b4a313 -= (_4701 * sub_d8830c7d) + (t * sub_d8830c7d) / DENOMINATOR
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                    _5207 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _5207 + 68] = mem[_5153 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_5207 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _5207 + -mem[64] + 100
                _3282 = mem[_1712 + 160]
                _3293 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3293] = 30
                mem[_3293 + 32] = 'SafeMath: subtraction overflow'
                if t > _3282:
                    _3352 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _3352 + 68] = mem[_3293 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3352 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _3352 + -mem[64] + 100
                if _3282 < t:
                    revert with 0, 17
                _3398 = mem[_1712]
                staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                        gas gas_remaining wei
                       args sub_4c86259e[idx].field_0, Mask(128, 128, mem[_1712])
                mem[mem[64] len 352] = ext_call.return_data[0 len 352]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3431 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 352
                _3453 = mem[64]
                if mem[64] + 352 < mem[64] or mem[64] + 352 > test266151307():
                    revert with 0, 65
                mem[64] = mem[64] + 352
                require mem[_3431] == Mask(128, 128, mem[_3431])
                mem[_3453] = mem[_3431]
                mem[_3453 + 32] = mem[_3431 + 32]
                mem[_3453 + 64] = mem[_3431 + 64]
                mem[_3453 + 96] = mem[_3431 + 96]
                require mem[_3431 + 128] < 5
                mem[_3453 + 128] = mem[_3431 + 128]
                mem[_3453 + 160] = mem[_3431 + 160]
                mem[_3453 + 192] = mem[_3431 + 192]
                mem[_3453 + 224] = mem[_3431 + 224]
                mem[_3453 + 256] = mem[_3431 + 256]
                mem[_3453 + 288] = mem[_3431 + 288]
                mem[_3453 + 320] = mem[_3431 + 320]
                if Mask(128, 128, mem[_3453]) != Mask(128, 128, _3398):
                    revert with 0, 'Address does not contain stake with provided id'
                s = mem[_3453 + 192]
                u = 0
                while s < sub_ed73481d + 1:
                    staticcall sub_413c05c6Address.0x8ce1d9e4 with:
                            gas gas_remaining wei
                           args s
                    mem[mem[64] len 160] = ext_call.return_data[0 len 160]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _4704 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 160
                    _4738 = mem[64]
                    if mem[64] + 160 > test266151307() or mem[64] + 160 < mem[64]:
                        revert with 0, 65
                    mem[64] = mem[64] + 160
                    mem[_4738] = mem[_4704]
                    mem[_4738 + 32] = mem[_4704 + 32]
                    mem[_4738 + 64] = mem[_4704 + 64]
                    mem[_4738 + 96] = mem[_4704 + 96]
                    mem[_4738 + 128] = mem[_4704 + 128]
                    _4883 = mem[_4738 + 64]
                    _4884 = mem[_4738 + 32]
                    _4885 = mem[_3453 + 64]
                    _4886 = mem[_4738]
                    _4887 = mem[_4738 + 128]
                    _4888 = mem[_4738 + 96]
                    if mem[_4738 + 96] > !mem[_4738 + 128]:
                        revert with 0, 17
                    if mem[_4738 + 96] + mem[_4738 + 128] < mem[_4738 + 96]:
                        revert with 0, 'SafeMath: addition overflow'
                    if not mem[_4738 + 96] + mem[_4738 + 128]:
                        _4960 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4960] = 26
                        mem[_4960 + 32] = 'SafeMath: division by zero'
                        if not _4884:
                            _4989 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _4989 + 68] = mem[_4960 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_4989 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _4989 + -mem[64] + 100
                        _5079 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5079] = 26
                        mem[_5079 + 32] = 'SafeMath: division by zero'
                        if _4883:
                            if u > !(0 / _4884 / _4883):
                                revert with 0, 17
                            if u + (0 / _4884 / _4883) < u:
                                revert with 0, 'SafeMath: addition overflow'
                            if s == -1:
                                revert with 0, 17
                            s = s + 1
                            u = u + (0 / _4884 / _4883)
                            continue 
                        _5131 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _5131 + 68] = mem[_5079 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_5131 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _5131 + -mem[64] + 100
                    if mem[_4738 + 96] + mem[_4738 + 128] and mem[_4738] > -1 / mem[_4738 + 96] + mem[_4738 + 128]:
                        revert with 0, 17
                    if not mem[_4738 + 96] + mem[_4738 + 128]:
                        revert with 0, 18
                    if (mem[_4738 + 96] * mem[_4738]) + (mem[_4738 + 128] * mem[_4738]) / mem[_4738 + 96] + mem[_4738 + 128] != mem[_4738]:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not (mem[_4738 + 96] * mem[_4738]) + (mem[_4738 + 128] * mem[_4738]):
                        _5038 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5038] = 26
                        mem[_5038 + 32] = 'SafeMath: division by zero'
                        if not _4884:
                            _5078 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _5078 + 68] = mem[_5038 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5078 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _5078 + -mem[64] + 100
                        _5236 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5236] = 26
                        mem[_5236 + 32] = 'SafeMath: division by zero'
                        if _4883:
                            if u > !(0 / _4884 / _4883):
                                revert with 0, 17
                            if u + (0 / _4884 / _4883) < u:
                                revert with 0, 'SafeMath: addition overflow'
                            if s == -1:
                                revert with 0, 17
                            s = s + 1
                            u = u + (0 / _4884 / _4883)
                            continue 
                        _5285 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _5285 + 68] = mem[_5236 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_5285 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _5285 + -mem[64] + 100
                    if (mem[_4738 + 96] * mem[_4738]) + (mem[_4738 + 128] * mem[_4738]) and mem[_3453 + 64] > -1 / (mem[_4738 + 96] * mem[_4738]) + (mem[_4738 + 128] * mem[_4738]):
                        revert with 0, 17
                    if not (mem[_4738 + 96] * mem[_4738]) + (mem[_4738 + 128] * mem[_4738]):
                        revert with 0, 18
                    if (mem[_4738 + 96] * mem[_4738] * mem[_3453 + 64]) + (mem[_4738 + 128] * mem[_4738] * mem[_3453 + 64]) / (mem[_4738 + 96] * mem[_4738]) + (mem[_4738 + 128] * mem[_4738]) != mem[_3453 + 64]:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _5186 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5186] = 26
                    mem[_5186 + 32] = 'SafeMath: division by zero'
                    if not _4884:
                        _5235 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _5235 + 68] = mem[_5186 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_5235 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _5235 + -mem[64] + 100
                    _5370 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5370] = 26
                    mem[_5370 + 32] = 'SafeMath: division by zero'
                    if _4883:
                        if u > !((_4888 * _4886 * _4885) + (_4887 * _4886 * _4885) / _4884 / _4883):
                            revert with 0, 17
                        if u + ((_4888 * _4886 * _4885) + (_4887 * _4886 * _4885) / _4884 / _4883) < u:
                            revert with 0, 'SafeMath: addition overflow'
                        if s == -1:
                            revert with 0, 17
                        s = s + 1
                        u = u + ((_4888 * _4886 * _4885) + (_4887 * _4886 * _4885) / _4884 / _4883)
                        continue 
                    _5419 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5419 + 68] = mem[_5370 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_5419 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _5419 + -mem[64] + 100
                _4703 = mem[_1712 + 32]
                if _3282 - t > !u:
                    revert with 0, 17
                if u < 0:
                    revert with 0, 'SafeMath: addition overflow'
                if mem[_1712 + 32] > !(_3282 - t + u):
                    revert with 0, 17
                if mem[_1712 + 32] + _3282 - t + u < mem[_1712 + 32]:
                    revert with 0, 'SafeMath: addition overflow'
                if not mem[_1712 + 32] + _3282 - t + u:
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                if not mem[_1712 + 32] + _3282 - t + u:
                    _5001 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5001] = 26
                    mem[_5001 + 32] = 'SafeMath: division by zero'
                    if not DENOMINATOR:
                        _5021 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _5021 + 68] = mem[_5001 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_5021 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _5021 + -mem[64] + 100
                    _5157 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5157] = 30
                    mem[_5157 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / DENOMINATOR <= sub_04b4a313:
                        if sub_04b4a313 < 0 / DENOMINATOR:
                            revert with 0, 17
                        sub_04b4a313 -= 0 / DENOMINATOR
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                    _5210 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _5210 + 68] = mem[_5157 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_5210 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _5210 + -mem[64] + 100
                if mem[_1712 + 32] + _3282 - t + u and sub_d8830c7d > -1 / mem[_1712 + 32] + _3282 - t + u:
                    revert with 0, 17
                if not mem[_1712 + 32] + _3282 - t + u:
                    revert with 0, 18
                if (mem[_1712 + 32] * sub_d8830c7d) + (_3282 * sub_d8830c7d) - (t * sub_d8830c7d) + (u * sub_d8830c7d) / mem[_1712 + 32] + _3282 - t + u != sub_d8830c7d:
                    revert with 0, 'SafeMath: multiplication overflow'
                _5100 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5100] = 26
                mem[_5100 + 32] = 'SafeMath: division by zero'
                if not DENOMINATOR:
                    _5156 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5156 + 68] = mem[_5100 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_5156 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _5156 + -mem[64] + 100
                _5305 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5305] = 30
                mem[_5305 + 32] = 'SafeMath: subtraction overflow'
                if (_4703 * sub_d8830c7d) + (_3282 * sub_d8830c7d) - (t * sub_d8830c7d) + (u * sub_d8830c7d) / DENOMINATOR <= sub_04b4a313:
                    if sub_04b4a313 < (_4703 * sub_d8830c7d) + (_3282 * sub_d8830c7d) - (t * sub_d8830c7d) + (u * sub_d8830c7d) / DENOMINATOR:
                        revert with 0, 17
                    sub_04b4a313 -= (_4703 * sub_d8830c7d) + (_3282 * sub_d8830c7d) - (t * sub_d8830c7d) + (u * sub_d8830c7d) / DENOMINATOR
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                _5345 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _5345 + 68] = mem[_5305 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_5345 + 98] = 0
                revert with memory
                  from mem[64]
                   len _5345 + -mem[64] + 100
            _1764 = mem[_1712]
            staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                    gas gas_remaining wei
                   args sub_4c86259e[idx].field_0, Mask(128, 128, mem[_1712])
            mem[mem[64] len 352] = ext_call.return_data[0 len 352]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _1778 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 352
            _1784 = mem[64]
            if mem[64] + 352 < mem[64] or mem[64] + 352 > test266151307():
                revert with 0, 65
            mem[64] = mem[64] + 352
            require mem[_1778] == Mask(128, 128, mem[_1778])
            mem[_1784] = mem[_1778]
            mem[_1784 + 32] = mem[_1778 + 32]
            mem[_1784 + 64] = mem[_1778 + 64]
            mem[_1784 + 96] = mem[_1778 + 96]
            require mem[_1778 + 128] < 5
            mem[_1784 + 128] = mem[_1778 + 128]
            mem[_1784 + 160] = mem[_1778 + 160]
            mem[_1784 + 192] = mem[_1778 + 192]
            mem[_1784 + 224] = mem[_1778 + 224]
            mem[_1784 + 256] = mem[_1778 + 256]
            mem[_1784 + 288] = mem[_1778 + 288]
            mem[_1784 + 320] = mem[_1778 + 320]
            if Mask(128, 128, mem[_1784]) != Mask(128, 128, _1764):
                revert with 0, 'Address does not contain stake with provided id'
            s = mem[_1784 + 192]
            t = 0
            while s < _1753 + _1752:
                staticcall sub_413c05c6Address.0x8ce1d9e4 with:
                        gas gas_remaining wei
                       args s
                mem[mem[64] len 160] = ext_call.return_data[0 len 160]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3273 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 160
                _3297 = mem[64]
                if mem[64] + 160 > test266151307() or mem[64] + 160 < mem[64]:
                    revert with 0, 65
                mem[64] = mem[64] + 160
                mem[_3297] = mem[_3273]
                mem[_3297 + 32] = mem[_3273 + 32]
                mem[_3297 + 64] = mem[_3273 + 64]
                mem[_3297 + 96] = mem[_3273 + 96]
                mem[_3297 + 128] = mem[_3273 + 128]
                _3361 = mem[_3297 + 64]
                _3362 = mem[_3297 + 32]
                _3363 = mem[_1784 + 64]
                _3364 = mem[_3297]
                _3365 = mem[_3297 + 128]
                _3366 = mem[_3297 + 96]
                if mem[_3297 + 96] > !mem[_3297 + 128]:
                    revert with 0, 17
                if mem[_3297 + 96] + mem[_3297 + 128] < mem[_3297 + 96]:
                    revert with 0, 'SafeMath: addition overflow'
                if not mem[_3297 + 96] + mem[_3297 + 128]:
                    _3498 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3498] = 26
                    mem[_3498 + 32] = 'SafeMath: division by zero'
                    if not _3362:
                        _3519 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _3519 + 68] = mem[_3498 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3519 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3519 + -mem[64] + 100
                    _3669 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3669] = 26
                    mem[_3669 + 32] = 'SafeMath: division by zero'
                    if _3361:
                        if t > !(0 / _3362 / _3361):
                            revert with 0, 17
                        if t + (0 / _3362 / _3361) < t:
                            revert with 0, 'SafeMath: addition overflow'
                        if s == -1:
                            revert with 0, 17
                        s = s + 1
                        t = t + (0 / _3362 / _3361)
                        continue 
                    _3709 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _3709 + 68] = mem[_3669 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3709 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _3709 + -mem[64] + 100
                if mem[_3297 + 96] + mem[_3297 + 128] and mem[_3297] > -1 / mem[_3297 + 96] + mem[_3297 + 128]:
                    revert with 0, 17
                if not mem[_3297 + 96] + mem[_3297 + 128]:
                    revert with 0, 18
                if (mem[_3297 + 96] * mem[_3297]) + (mem[_3297 + 128] * mem[_3297]) / mem[_3297 + 96] + mem[_3297 + 128] != mem[_3297]:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not (mem[_3297 + 96] * mem[_3297]) + (mem[_3297 + 128] * mem[_3297]):
                    _3579 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3579] = 26
                    mem[_3579 + 32] = 'SafeMath: division by zero'
                    if not _3362:
                        _3668 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _3668 + 68] = mem[_3579 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_3668 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _3668 + -mem[64] + 100
                    _3804 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_3804] = 26
                    mem[_3804 + 32] = 'SafeMath: division by zero'
                    if _3361:
                        if t > !(0 / _3362 / _3361):
                            revert with 0, 17
                        if t + (0 / _3362 / _3361) < t:
                            revert with 0, 'SafeMath: addition overflow'
                        if s == -1:
                            revert with 0, 17
                        s = s + 1
                        t = t + (0 / _3362 / _3361)
                        continue 
                    _3876 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _3876 + 68] = mem[_3804 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3876 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _3876 + -mem[64] + 100
                if (mem[_3297 + 96] * mem[_3297]) + (mem[_3297 + 128] * mem[_3297]) and mem[_1784 + 64] > -1 / (mem[_3297 + 96] * mem[_3297]) + (mem[_3297 + 128] * mem[_3297]):
                    revert with 0, 17
                if not (mem[_3297 + 96] * mem[_3297]) + (mem[_3297 + 128] * mem[_3297]):
                    revert with 0, 18
                if (mem[_3297 + 96] * mem[_3297] * mem[_1784 + 64]) + (mem[_3297 + 128] * mem[_3297] * mem[_1784 + 64]) / (mem[_3297 + 96] * mem[_3297]) + (mem[_3297 + 128] * mem[_3297]) != mem[_1784 + 64]:
                    revert with 0, 'SafeMath: multiplication overflow'
                _3758 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3758] = 26
                mem[_3758 + 32] = 'SafeMath: division by zero'
                if not _3362:
                    _3803 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _3803 + 68] = mem[_3758 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_3803 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _3803 + -mem[64] + 100
                _3940 = mem[64]
                mem[64] = mem[64] + 64
                mem[_3940] = 26
                mem[_3940 + 32] = 'SafeMath: division by zero'
                if _3361:
                    if t > !((_3366 * _3364 * _3363) + (_3365 * _3364 * _3363) / _3362 / _3361):
                        revert with 0, 17
                    if t + ((_3366 * _3364 * _3363) + (_3365 * _3364 * _3363) / _3362 / _3361) < t:
                        revert with 0, 'SafeMath: addition overflow'
                    if s == -1:
                        revert with 0, 17
                    s = s + 1
                    t = t + ((_3366 * _3364 * _3363) + (_3365 * _3364 * _3363) / _3362 / _3361)
                    continue 
                _3983 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _3983 + 68] = mem[_3940 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_3983 + 94] = 0
                revert with memory
                  from mem[64]
                   len _3983 + -mem[64] + 100
            if t >= mem[_1712 + 160]:
                _3283 = mem[_1712]
                staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                        gas gas_remaining wei
                       args sub_4c86259e[idx].field_0, Mask(128, 128, mem[_1712])
                mem[mem[64] len 352] = ext_call.return_data[0 len 352]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _3377 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 352
                _3391 = mem[64]
                if mem[64] + 352 < mem[64] or mem[64] + 352 > test266151307():
                    revert with 0, 65
                mem[64] = mem[64] + 352
                require mem[_3377] == Mask(128, 128, mem[_3377])
                mem[_3391] = mem[_3377]
                mem[_3391 + 32] = mem[_3377 + 32]
                mem[_3391 + 64] = mem[_3377 + 64]
                mem[_3391 + 96] = mem[_3377 + 96]
                require mem[_3377 + 128] < 5
                mem[_3391 + 128] = mem[_3377 + 128]
                mem[_3391 + 160] = mem[_3377 + 160]
                mem[_3391 + 192] = mem[_3377 + 192]
                mem[_3391 + 224] = mem[_3377 + 224]
                mem[_3391 + 256] = mem[_3377 + 256]
                mem[_3391 + 288] = mem[_3377 + 288]
                mem[_3391 + 320] = mem[_3377 + 320]
                if Mask(128, 128, mem[_3391]) != Mask(128, 128, _3283):
                    revert with 0, 'Address does not contain stake with provided id'
                s = mem[_3391 + 192]
                t = 0
                while s < _1753 + _1752:
                    staticcall sub_413c05c6Address.0x8ce1d9e4 with:
                            gas gas_remaining wei
                           args s
                    mem[mem[64] len 160] = ext_call.return_data[0 len 160]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _4706 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 160
                    _4746 = mem[64]
                    if mem[64] + 160 > test266151307() or mem[64] + 160 < mem[64]:
                        revert with 0, 65
                    mem[64] = mem[64] + 160
                    mem[_4746] = mem[_4706]
                    mem[_4746 + 32] = mem[_4706 + 32]
                    mem[_4746 + 64] = mem[_4706 + 64]
                    mem[_4746 + 96] = mem[_4706 + 96]
                    mem[_4746 + 128] = mem[_4706 + 128]
                    _4889 = mem[_4746 + 64]
                    _4890 = mem[_4746 + 32]
                    _4891 = mem[_3391 + 64]
                    _4892 = mem[_4746]
                    _4893 = mem[_4746 + 128]
                    _4894 = mem[_4746 + 96]
                    if mem[_4746 + 96] > !mem[_4746 + 128]:
                        revert with 0, 17
                    if mem[_4746 + 96] + mem[_4746 + 128] < mem[_4746 + 96]:
                        revert with 0, 'SafeMath: addition overflow'
                    if not mem[_4746 + 96] + mem[_4746 + 128]:
                        _4962 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_4962] = 26
                        mem[_4962 + 32] = 'SafeMath: division by zero'
                        if not _4890:
                            _4991 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _4991 + 68] = mem[_4962 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_4991 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _4991 + -mem[64] + 100
                        _5081 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5081] = 26
                        mem[_5081 + 32] = 'SafeMath: division by zero'
                        if _4889:
                            if t > !(0 / _4890 / _4889):
                                revert with 0, 17
                            if t + (0 / _4890 / _4889) < t:
                                revert with 0, 'SafeMath: addition overflow'
                            if s == -1:
                                revert with 0, 17
                            s = s + 1
                            t = t + (0 / _4890 / _4889)
                            continue 
                        _5135 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _5135 + 68] = mem[_5081 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_5135 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _5135 + -mem[64] + 100
                    if mem[_4746 + 96] + mem[_4746 + 128] and mem[_4746] > -1 / mem[_4746 + 96] + mem[_4746 + 128]:
                        revert with 0, 17
                    if not mem[_4746 + 96] + mem[_4746 + 128]:
                        revert with 0, 18
                    if (mem[_4746 + 96] * mem[_4746]) + (mem[_4746 + 128] * mem[_4746]) / mem[_4746 + 96] + mem[_4746 + 128] != mem[_4746]:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not (mem[_4746 + 96] * mem[_4746]) + (mem[_4746 + 128] * mem[_4746]):
                        _5041 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5041] = 26
                        mem[_5041 + 32] = 'SafeMath: division by zero'
                        if not _4890:
                            _5080 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _5080 + 68] = mem[_5041 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_5080 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _5080 + -mem[64] + 100
                        _5240 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_5240] = 26
                        mem[_5240 + 32] = 'SafeMath: division by zero'
                        if _4889:
                            if t > !(0 / _4890 / _4889):
                                revert with 0, 17
                            if t + (0 / _4890 / _4889) < t:
                                revert with 0, 'SafeMath: addition overflow'
                            if s == -1:
                                revert with 0, 17
                            s = s + 1
                            t = t + (0 / _4890 / _4889)
                            continue 
                        _5288 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _5288 + 68] = mem[_5240 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_5288 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _5288 + -mem[64] + 100
                    if (mem[_4746 + 96] * mem[_4746]) + (mem[_4746 + 128] * mem[_4746]) and mem[_3391 + 64] > -1 / (mem[_4746 + 96] * mem[_4746]) + (mem[_4746 + 128] * mem[_4746]):
                        revert with 0, 17
                    if not (mem[_4746 + 96] * mem[_4746]) + (mem[_4746 + 128] * mem[_4746]):
                        revert with 0, 18
                    if (mem[_4746 + 96] * mem[_4746] * mem[_3391 + 64]) + (mem[_4746 + 128] * mem[_4746] * mem[_3391 + 64]) / (mem[_4746 + 96] * mem[_4746]) + (mem[_4746 + 128] * mem[_4746]) != mem[_3391 + 64]:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _5190 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5190] = 26
                    mem[_5190 + 32] = 'SafeMath: division by zero'
                    if not _4890:
                        _5239 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _5239 + 68] = mem[_5190 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_5239 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _5239 + -mem[64] + 100
                    _5374 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5374] = 26
                    mem[_5374 + 32] = 'SafeMath: division by zero'
                    if _4889:
                        if t > !((_4894 * _4892 * _4891) + (_4893 * _4892 * _4891) / _4890 / _4889):
                            revert with 0, 17
                        if t + ((_4894 * _4892 * _4891) + (_4893 * _4892 * _4891) / _4890 / _4889) < t:
                            revert with 0, 'SafeMath: addition overflow'
                        if s == -1:
                            revert with 0, 17
                        s = s + 1
                        t = t + ((_4894 * _4892 * _4891) + (_4893 * _4892 * _4891) / _4890 / _4889)
                        continue 
                    _5421 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5421 + 68] = mem[_5374 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_5421 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _5421 + -mem[64] + 100
                _4705 = mem[_1712 + 32]
                if mem[_1712 + 32] > !t:
                    revert with 0, 17
                if mem[_1712 + 32] + t < mem[_1712 + 32]:
                    revert with 0, 'SafeMath: addition overflow'
                if not mem[_1712 + 32] + t:
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                if not mem[_1712 + 32] + t:
                    _4943 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4943] = 26
                    mem[_4943 + 32] = 'SafeMath: division by zero'
                    if not DENOMINATOR:
                        _4948 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4948 + 68] = mem[_4943 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_4948 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _4948 + -mem[64] + 100
                    _5023 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5023] = 30
                    mem[_5023 + 32] = 'SafeMath: subtraction overflow'
                    if 0 / DENOMINATOR <= sub_04b4a313:
                        if sub_04b4a313 < 0 / DENOMINATOR:
                            revert with 0, 17
                        sub_04b4a313 -= 0 / DENOMINATOR
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        continue 
                    _5061 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _5061 + 68] = mem[_5023 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_5061 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _5061 + -mem[64] + 100
                if mem[_1712 + 32] + t and sub_d8830c7d > -1 / mem[_1712 + 32] + t:
                    revert with 0, 17
                if not mem[_1712 + 32] + t:
                    revert with 0, 18
                if (mem[_1712 + 32] * sub_d8830c7d) + (t * sub_d8830c7d) / mem[_1712 + 32] + t != sub_d8830c7d:
                    revert with 0, 'SafeMath: multiplication overflow'
                _5002 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5002] = 26
                mem[_5002 + 32] = 'SafeMath: division by zero'
                if not DENOMINATOR:
                    _5022 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5022 + 68] = mem[_5002 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_5022 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _5022 + -mem[64] + 100
                _5159 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5159] = 30
                mem[_5159 + 32] = 'SafeMath: subtraction overflow'
                if (_4705 * sub_d8830c7d) + (t * sub_d8830c7d) / DENOMINATOR <= sub_04b4a313:
                    if sub_04b4a313 < (_4705 * sub_d8830c7d) + (t * sub_d8830c7d) / DENOMINATOR:
                        revert with 0, 17
                    sub_04b4a313 -= (_4705 * sub_d8830c7d) + (t * sub_d8830c7d) / DENOMINATOR
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                _5212 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _5212 + 68] = mem[_5159 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_5212 + 98] = 0
                revert with memory
                  from mem[64]
                   len _5212 + -mem[64] + 100
            _3284 = mem[_1712 + 160]
            _3296 = mem[64]
            mem[64] = mem[64] + 64
            mem[_3296] = 30
            mem[_3296 + 32] = 'SafeMath: subtraction overflow'
            if t > _3284:
                _3360 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _3360 + 68] = mem[_3296 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_3360 + 98] = 0
                revert with memory
                  from mem[64]
                   len _3360 + -mem[64] + 100
            if _3284 < t:
                revert with 0, 17
            _3400 = mem[_1712]
            staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                    gas gas_remaining wei
                   args sub_4c86259e[idx].field_0, Mask(128, 128, mem[_1712])
            mem[mem[64] len 352] = ext_call.return_data[0 len 352]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _3432 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 352
            _3455 = mem[64]
            if mem[64] + 352 < mem[64] or mem[64] + 352 > test266151307():
                revert with 0, 65
            mem[64] = mem[64] + 352
            require mem[_3432] == Mask(128, 128, mem[_3432])
            mem[_3455] = mem[_3432]
            mem[_3455 + 32] = mem[_3432 + 32]
            mem[_3455 + 64] = mem[_3432 + 64]
            mem[_3455 + 96] = mem[_3432 + 96]
            require mem[_3432 + 128] < 5
            mem[_3455 + 128] = mem[_3432 + 128]
            mem[_3455 + 160] = mem[_3432 + 160]
            mem[_3455 + 192] = mem[_3432 + 192]
            mem[_3455 + 224] = mem[_3432 + 224]
            mem[_3455 + 256] = mem[_3432 + 256]
            mem[_3455 + 288] = mem[_3432 + 288]
            mem[_3455 + 320] = mem[_3432 + 320]
            if Mask(128, 128, mem[_3455]) != Mask(128, 128, _3400):
                revert with 0, 'Address does not contain stake with provided id'
            s = mem[_3455 + 192]
            u = 0
            while s < _1753 + _1752:
                staticcall sub_413c05c6Address.0x8ce1d9e4 with:
                        gas gas_remaining wei
                       args s
                mem[mem[64] len 160] = ext_call.return_data[0 len 160]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _4708 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 160
                _4747 = mem[64]
                if mem[64] + 160 > test266151307() or mem[64] + 160 < mem[64]:
                    revert with 0, 65
                mem[64] = mem[64] + 160
                mem[_4747] = mem[_4708]
                mem[_4747 + 32] = mem[_4708 + 32]
                mem[_4747 + 64] = mem[_4708 + 64]
                mem[_4747 + 96] = mem[_4708 + 96]
                mem[_4747 + 128] = mem[_4708 + 128]
                _4895 = mem[_4747 + 64]
                _4896 = mem[_4747 + 32]
                _4897 = mem[_3455 + 64]
                _4898 = mem[_4747]
                _4899 = mem[_4747 + 128]
                _4900 = mem[_4747 + 96]
                if mem[_4747 + 96] > !mem[_4747 + 128]:
                    revert with 0, 17
                if mem[_4747 + 96] + mem[_4747 + 128] < mem[_4747 + 96]:
                    revert with 0, 'SafeMath: addition overflow'
                if not mem[_4747 + 96] + mem[_4747 + 128]:
                    _4964 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_4964] = 26
                    mem[_4964 + 32] = 'SafeMath: division by zero'
                    if not _4896:
                        _4992 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _4992 + 68] = mem[_4964 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_4992 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _4992 + -mem[64] + 100
                    _5084 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5084] = 26
                    mem[_5084 + 32] = 'SafeMath: division by zero'
                    if _4895:
                        if u > !(0 / _4896 / _4895):
                            revert with 0, 17
                        if u + (0 / _4896 / _4895) < u:
                            revert with 0, 'SafeMath: addition overflow'
                        if s == -1:
                            revert with 0, 17
                        s = s + 1
                        u = u + (0 / _4896 / _4895)
                        continue 
                    _5139 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5139 + 68] = mem[_5084 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_5139 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _5139 + -mem[64] + 100
                if mem[_4747 + 96] + mem[_4747 + 128] and mem[_4747] > -1 / mem[_4747 + 96] + mem[_4747 + 128]:
                    revert with 0, 17
                if not mem[_4747 + 96] + mem[_4747 + 128]:
                    revert with 0, 18
                if (mem[_4747 + 96] * mem[_4747]) + (mem[_4747 + 128] * mem[_4747]) / mem[_4747 + 96] + mem[_4747 + 128] != mem[_4747]:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not (mem[_4747 + 96] * mem[_4747]) + (mem[_4747 + 128] * mem[_4747]):
                    _5043 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5043] = 26
                    mem[_5043 + 32] = 'SafeMath: division by zero'
                    if not _4896:
                        _5083 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _5083 + 68] = mem[_5043 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_5083 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _5083 + -mem[64] + 100
                    _5243 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_5243] = 26
                    mem[_5243 + 32] = 'SafeMath: division by zero'
                    if _4895:
                        if u > !(0 / _4896 / _4895):
                            revert with 0, 17
                        if u + (0 / _4896 / _4895) < u:
                            revert with 0, 'SafeMath: addition overflow'
                        if s == -1:
                            revert with 0, 17
                        s = s + 1
                        u = u + (0 / _4896 / _4895)
                        continue 
                    _5291 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5291 + 68] = mem[_5243 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_5291 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _5291 + -mem[64] + 100
                if (mem[_4747 + 96] * mem[_4747]) + (mem[_4747 + 128] * mem[_4747]) and mem[_3455 + 64] > -1 / (mem[_4747 + 96] * mem[_4747]) + (mem[_4747 + 128] * mem[_4747]):
                    revert with 0, 17
                if not (mem[_4747 + 96] * mem[_4747]) + (mem[_4747 + 128] * mem[_4747]):
                    revert with 0, 18
                if (mem[_4747 + 96] * mem[_4747] * mem[_3455 + 64]) + (mem[_4747 + 128] * mem[_4747] * mem[_3455 + 64]) / (mem[_4747 + 96] * mem[_4747]) + (mem[_4747 + 128] * mem[_4747]) != mem[_3455 + 64]:
                    revert with 0, 'SafeMath: multiplication overflow'
                _5194 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5194] = 26
                mem[_5194 + 32] = 'SafeMath: division by zero'
                if not _4896:
                    _5242 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5242 + 68] = mem[_5194 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_5242 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _5242 + -mem[64] + 100
                _5378 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5378] = 26
                mem[_5378 + 32] = 'SafeMath: division by zero'
                if _4895:
                    if u > !((_4900 * _4898 * _4897) + (_4899 * _4898 * _4897) / _4896 / _4895):
                        revert with 0, 17
                    if u + ((_4900 * _4898 * _4897) + (_4899 * _4898 * _4897) / _4896 / _4895) < u:
                        revert with 0, 'SafeMath: addition overflow'
                    if s == -1:
                        revert with 0, 17
                    s = s + 1
                    u = u + ((_4900 * _4898 * _4897) + (_4899 * _4898 * _4897) / _4896 / _4895)
                    continue 
                _5423 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _5423 + 68] = mem[_5378 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_5423 + 94] = 0
                revert with memory
                  from mem[64]
                   len _5423 + -mem[64] + 100
            _4707 = mem[_1712 + 32]
            if _3284 - t > !u:
                revert with 0, 17
            if u < 0:
                revert with 0, 'SafeMath: addition overflow'
            if mem[_1712 + 32] > !(_3284 - t + u):
                revert with 0, 17
            if mem[_1712 + 32] + _3284 - t + u < mem[_1712 + 32]:
                revert with 0, 'SafeMath: addition overflow'
            if not mem[_1712 + 32] + _3284 - t + u:
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            if not mem[_1712 + 32] + _3284 - t + u:
                _5004 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5004] = 26
                mem[_5004 + 32] = 'SafeMath: division by zero'
                if not DENOMINATOR:
                    _5024 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _5024 + 68] = mem[_5004 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_5024 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _5024 + -mem[64] + 100
                _5163 = mem[64]
                mem[64] = mem[64] + 64
                mem[_5163] = 30
                mem[_5163 + 32] = 'SafeMath: subtraction overflow'
                if 0 / DENOMINATOR <= sub_04b4a313:
                    if sub_04b4a313 < 0 / DENOMINATOR:
                        revert with 0, 17
                    sub_04b4a313 -= 0 / DENOMINATOR
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    continue 
                _5215 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _5215 + 68] = mem[_5163 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_5215 + 98] = 0
                revert with memory
                  from mem[64]
                   len _5215 + -mem[64] + 100
            if mem[_1712 + 32] + _3284 - t + u and sub_d8830c7d > -1 / mem[_1712 + 32] + _3284 - t + u:
                revert with 0, 17
            if not mem[_1712 + 32] + _3284 - t + u:
                revert with 0, 18
            if (mem[_1712 + 32] * sub_d8830c7d) + (_3284 * sub_d8830c7d) - (t * sub_d8830c7d) + (u * sub_d8830c7d) / mem[_1712 + 32] + _3284 - t + u != sub_d8830c7d:
                revert with 0, 'SafeMath: multiplication overflow'
            _5106 = mem[64]
            mem[64] = mem[64] + 64
            mem[_5106] = 26
            mem[_5106 + 32] = 'SafeMath: division by zero'
            if not DENOMINATOR:
                _5162 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _5162 + 68] = mem[_5106 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_5162 + 94] = 0
                revert with memory
                  from mem[64]
                   len _5162 + -mem[64] + 100
            _5310 = mem[64]
            mem[64] = mem[64] + 64
            mem[_5310] = 30
            mem[_5310 + 32] = 'SafeMath: subtraction overflow'
            if (_4707 * sub_d8830c7d) + (_3284 * sub_d8830c7d) - (t * sub_d8830c7d) + (u * sub_d8830c7d) / DENOMINATOR <= sub_04b4a313:
                if sub_04b4a313 < (_4707 * sub_d8830c7d) + (_3284 * sub_d8830c7d) - (t * sub_d8830c7d) + (u * sub_d8830c7d) / DENOMINATOR:
                    revert with 0, 17
                sub_04b4a313 -= (_4707 * sub_d8830c7d) + (_3284 * sub_d8830c7d) - (t * sub_d8830c7d) + (u * sub_d8830c7d) / DENOMINATOR
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                continue 
            _5347 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[idx + _5347 + 68] = mem[_5310 + idx + 32]
                idx = idx + 32
                continue 
            mem[_5347 + 98] = 0
            revert with memory
              from mem[64]
               len _5347 + -mem[64] + 100
}

function _fallback() payable {
    mem[64] = 128
    require calldata.size >= 4
    if unknown_0x918f8674(?????) <= uint32(call.func_hash) >> 224:
        if unknown_0xdb45a4ec(?????) > uint32(call.func_hash) >> 224:
            if unknown_0xbe647a94(?????) > uint32(call.func_hash) >> 224:
                if unknown_0x918f8674(?????) == uint32(call.func_hash) >> 224:
                    require not msg.value
                    return DENOMINATOR
                if unknown_0x9caa9dae(?????) == uint32(call.func_hash) >> 224:
                    require not msg.value
                    require calldata.size - 4 >= 64
                    if TOKEN_DEFINERAddress != msg.sender:
                        revert with 0, 'Wrong sender.'
                    if arg2 < sub_d3a8b1da:
                        idx = arg1
                        while idx < arg2:
                            mem[0] = Mask(128, 128, sub_4c86259e[idx].field_256)
                            mem[32] = sha3(sub_4c86259e[idx].field_0, 9)
                            if not stor9[stor12[idx].field_0][Mask(128, 128, stor12[idx].field_256)]:
                                mem[0] = idx
                                mem[32] = 12
                                if 1 > !sub_ed73481d:
                                    revert with 0, 17
                                _6812 = mem[64]
                                mem[64] = mem[64] + 352
                                mem[_6812] = 0
                                mem[_6812 + 32] = 0
                                mem[_6812 + 64] = 0
                                mem[_6812 + 96] = 0
                                mem[_6812 + 128] = 0
                                mem[_6812 + 160] = 0
                                mem[_6812 + 192] = 0
                                mem[_6812 + 224] = 0
                                mem[_6812 + 256] = 0
                                mem[_6812 + 288] = 0
                                mem[_6812 + 320] = 0
                                staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                                        gas gas_remaining wei
                                       args sub_4c86259e[idx].field_0, Mask(128, 128, sub_4c86259e[idx].field_256)
                                mem[mem[64] len 352] = ext_call.return_data[0 len 352]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _6876 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 352
                                _6946 = mem[64]
                                if mem[64] + 352 < mem[64] or mem[64] + 352 > test266151307():
                                    revert with 0, 65
                                mem[64] = mem[64] + 352
                                require mem[_6876] == Mask(128, 128, mem[_6876])
                                mem[_6946] = mem[_6876]
                                mem[_6946 + 32] = mem[_6876 + 32]
                                mem[_6946 + 64] = mem[_6876 + 64]
                                mem[_6946 + 96] = mem[_6876 + 96]
                                require mem[_6876 + 128] < 5
                                mem[_6946 + 128] = mem[_6876 + 128]
                                mem[_6946 + 160] = mem[_6876 + 160]
                                mem[_6946 + 192] = mem[_6876 + 192]
                                mem[_6946 + 224] = mem[_6876 + 224]
                                mem[_6946 + 256] = mem[_6876 + 256]
                                mem[_6946 + 288] = mem[_6876 + 288]
                                mem[_6946 + 320] = mem[_6876 + 320]
                                if Mask(128, 128, mem[_6946]) != Mask(128, 128, sub_4c86259e[idx].field_256):
                                    _7261 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_7261] = 46
                                    mem[_7261 + 32 len 46] = 0xfe53656e64657220646f6573206e6f7420636f6e7461696e207374616b6520776974682070726f76696465642069
                                    stor9[stor12[idx].field_0][Mask(128, 128, stor12[idx].field_256)] = 1
                                    mem[0] = idx
                                    mem[32] = 12
                                else:
                                    mem[0] = Mask(128, 128, sub_4c86259e[idx].field_256)
                                    mem[32] = sha3(sub_4c86259e[idx].field_0, 9)
                                    if stor9[stor12[idx].field_0][Mask(128, 128, stor12[idx].field_256)]:
                                        _7288 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7288] = 32
                                        mem[_7288 + 32] = 'Stake has already been converted'
                                        stor9[stor12[idx].field_0][Mask(128, 128, stor12[idx].field_256)] = 1
                                        mem[0] = idx
                                        mem[32] = 12
                                    else:
                                        if mem[_6946 + 128] > 4:
                                            revert with 0, 33
                                        if mem[_6946 + 128] != 2:
                                            _7450 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_7450] = 44
                                            mem[_7450 + 32 len 44] = 0x795374616b65206973206f6e6c7920656c696769626c6520696620697420686173206265656e20636c6f7365
                                            stor9[stor12[idx].field_0][Mask(128, 128, stor12[idx].field_256)] = 1
                                            mem[0] = idx
                                            mem[32] = 12
                                        else:
                                            if mem[_6946 + 192] >= sub_be647a94:
                                                _7512 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_7512] = 65
                                                mem[_7512 + 32 len 65] = 0x645374616b65206973206f6e6c7920656c696769626c65206966206974207761732063726561746564207072696f7220746f2074686520637574206f6666206461
                                                stor9[stor12[idx].field_0][Mask(128, 128, stor12[idx].field_256)] = 1
                                                mem[0] = idx
                                                mem[32] = 12
                                            else:
                                                if mem[_6946 + 192] > !mem[_6946 + 224]:
                                                    revert with 0, 17
                                                if mem[_6946 + 192] + mem[_6946 + 224] < sub_be647a94:
                                                    _7721 = mem[64]
                                                    mem[64] = mem[64] + 128
                                                    mem[_7721] = 66
                                                    mem[_7721 + 32 len 66] = 0x645374616b65206973206f6e6c7920656c696769626c652069662069742077617320656e646564206f6e2074686520637574206f666620646179206f722061667465
                                                    stor9[stor12[idx].field_0][Mask(128, 128, stor12[idx].field_256)] = 1
                                                    mem[0] = idx
                                                    mem[32] = 12
                                                else:
                                                    _7720 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_7720] = 17
                                                    mem[_7720 + 32] = 'Stake is eligible' << 120
                                                    staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                                                            gas gas_remaining wei
                                                           args sub_4c86259e[idx].field_0, Mask(128, 128, sub_4c86259e[idx].field_256)
                                                    mem[mem[64] len 352] = ext_call.return_data[0 len 352]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _8060 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 352
                                                    _8169 = mem[64]
                                                    if mem[64] + 352 < mem[64] or mem[64] + 352 > test266151307():
                                                        revert with 0, 65
                                                    mem[64] = mem[64] + 352
                                                    require mem[_8060] == Mask(128, 128, mem[_8060])
                                                    mem[_8169] = mem[_8060]
                                                    mem[_8169 + 32] = mem[_8060 + 32]
                                                    mem[_8169 + 64] = mem[_8060 + 64]
                                                    mem[_8169 + 96] = mem[_8060 + 96]
                                                    require mem[_8060 + 128] < 5
                                                    mem[_8169 + 128] = mem[_8060 + 128]
                                                    mem[_8169 + 160] = mem[_8060 + 160]
                                                    mem[_8169 + 192] = mem[_8060 + 192]
                                                    mem[_8169 + 224] = mem[_8060 + 224]
                                                    mem[_8169 + 256] = mem[_8060 + 256]
                                                    mem[_8169 + 288] = mem[_8060 + 288]
                                                    mem[_8169 + 320] = mem[_8060 + 320]
                                                    if Mask(128, 128, mem[_8169]) != Mask(128, 128, sub_4c86259e[idx].field_256):
                                                        revert with 0, 'Address does not contain stake with provided id'
                                                    if mem[_8169 + 128] > 4:
                                                        revert with 0, 33
                                                    if mem[_8169 + 128] == 3:
                                                        stor9[stor12[idx].field_0][Mask(128, 128, stor12[idx].field_256)] = 1
                                                        mem[0] = idx
                                                        mem[32] = 12
                                                    else:
                                                        if mem[_8169 + 128] > 4:
                                                            revert with 0, 33
                                                        if mem[_8169 + 128] == 4:
                                                            stor9[stor12[idx].field_0][Mask(128, 128, stor12[idx].field_256)] = 1
                                                            mem[0] = idx
                                                            mem[32] = 12
                                                        else:
                                                            if mem[_8169 + 128] > 4:
                                                                revert with 0, 33
                                                            if mem[_8169 + 128] == 1:
                                                                stor9[stor12[idx].field_0][Mask(128, 128, stor12[idx].field_256)] = 1
                                                                mem[0] = idx
                                                                mem[32] = 12
                                                            else:
                                                                if mem[_8169 + 128] > 4:
                                                                    revert with 0, 33
                                                                if not mem[_8169 + 128]:
                                                                    _8827 = mem[_8169]
                                                                    staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                                                                            gas gas_remaining wei
                                                                           args sub_4c86259e[idx].field_0, Mask(128, 128, mem[_8169])
                                                                    mem[mem[64] len 352] = ext_call.return_data[0 len 352]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    _8950 = mem[64]
                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                    require return_data.size >= 352
                                                                    _9032 = mem[64]
                                                                    if mem[64] + 352 < mem[64] or mem[64] + 352 > test266151307():
                                                                        revert with 0, 65
                                                                    mem[64] = mem[64] + 352
                                                                    require mem[_8950] == Mask(128, 128, mem[_8950])
                                                                    mem[_9032] = mem[_8950]
                                                                    mem[_9032 + 32] = mem[_8950 + 32]
                                                                    mem[_9032 + 64] = mem[_8950 + 64]
                                                                    mem[_9032 + 96] = mem[_8950 + 96]
                                                                    require mem[_8950 + 128] < 5
                                                                    mem[_9032 + 128] = mem[_8950 + 128]
                                                                    mem[_9032 + 160] = mem[_8950 + 160]
                                                                    mem[_9032 + 192] = mem[_8950 + 192]
                                                                    mem[_9032 + 224] = mem[_8950 + 224]
                                                                    mem[_9032 + 256] = mem[_8950 + 256]
                                                                    mem[_9032 + 288] = mem[_8950 + 288]
                                                                    mem[_9032 + 320] = mem[_8950 + 320]
                                                                    if Mask(128, 128, mem[_9032]) != Mask(128, 128, _8827):
                                                                        revert with 0, 'Address does not contain stake with provided id'
                                                                    s = mem[_9032 + 192]
                                                                    t = 0
                                                                    while s < sub_ed73481d + 1:
                                                                        staticcall sub_413c05c6Address.0x8ce1d9e4 with:
                                                                                gas gas_remaining wei
                                                                               args s
                                                                        mem[mem[64] len 160] = ext_call.return_data[0 len 160]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        _12624 = mem[64]
                                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                                        require return_data.size >= 160
                                                                        _12748 = mem[64]
                                                                        if mem[64] + 160 > test266151307() or mem[64] + 160 < mem[64]:
                                                                            revert with 0, 65
                                                                        mem[64] = mem[64] + 160
                                                                        mem[_12748] = mem[_12624]
                                                                        mem[_12748 + 32] = mem[_12624 + 32]
                                                                        mem[_12748 + 64] = mem[_12624 + 64]
                                                                        mem[_12748 + 96] = mem[_12624 + 96]
                                                                        mem[_12748 + 128] = mem[_12624 + 128]
                                                                        _13118 = mem[_12748 + 64]
                                                                        _13119 = mem[_12748 + 32]
                                                                        _13120 = mem[_9032 + 64]
                                                                        _13121 = mem[_12748]
                                                                        _13122 = mem[_12748 + 128]
                                                                        _13123 = mem[_12748 + 96]
                                                                        if mem[_12748 + 96] > !mem[_12748 + 128]:
                                                                            revert with 0, 17
                                                                        if mem[_12748 + 96] + mem[_12748 + 128] < mem[_12748 + 96]:
                                                                            revert with 0, 'SafeMath: addition overflow'
                                                                        if not mem[_12748 + 96] + mem[_12748 + 128]:
                                                                            _13571 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_13571] = 26
                                                                            mem[_13571 + 32] = 'SafeMath: division by zero'
                                                                            if not _13119:
                                                                                _13676 = mem[64]
                                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                mem[mem[64] + 4] = 32
                                                                                mem[mem[64] + 36] = 26
                                                                                idx = 0
                                                                                while idx < 26:
                                                                                    mem[idx + _13676 + 68] = mem[_13571 + idx + 32]
                                                                                    idx = idx + 32
                                                                                    continue 
                                                                                mem[_13676 + 94] = 0
                                                                                revert with memory
                                                                                  from mem[64]
                                                                                   len _13676 + -mem[64] + 100
                                                                            _14005 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_14005] = 26
                                                                            mem[_14005 + 32] = 'SafeMath: division by zero'
                                                                            if _13118:
                                                                                if t > !(0 / _13119 / _13118):
                                                                                    revert with 0, 17
                                                                                if t + (0 / _13119 / _13118) < t:
                                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                                if s == -1:
                                                                                    revert with 0, 17
                                                                                s = s + 1
                                                                                t = t + (0 / _13119 / _13118)
                                                                                continue 
                                                                            _14186 = mem[64]
                                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                            mem[mem[64] + 4] = 32
                                                                            mem[mem[64] + 36] = 26
                                                                            idx = 0
                                                                            while idx < 26:
                                                                                mem[idx + _14186 + 68] = mem[_14005 + idx + 32]
                                                                                idx = idx + 32
                                                                                continue 
                                                                            mem[_14186 + 94] = 0
                                                                            revert with memory
                                                                              from mem[64]
                                                                               len _14186 + -mem[64] + 100
                                                                        if mem[_12748 + 96] + mem[_12748 + 128] and mem[_12748] > -1 / mem[_12748 + 96] + mem[_12748 + 128]:
                                                                            revert with 0, 17
                                                                        if not mem[_12748 + 96] + mem[_12748 + 128]:
                                                                            revert with 0, 18
                                                                        if (mem[_12748 + 96] * mem[_12748]) + (mem[_12748 + 128] * mem[_12748]) / mem[_12748 + 96] + mem[_12748 + 128] != mem[_12748]:
                                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                                        if not (mem[_12748 + 96] * mem[_12748]) + (mem[_12748 + 128] * mem[_12748]):
                                                                            _13827 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_13827] = 26
                                                                            mem[_13827 + 32] = 'SafeMath: division by zero'
                                                                            if not _13119:
                                                                                _14004 = mem[64]
                                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                mem[mem[64] + 4] = 32
                                                                                mem[mem[64] + 36] = 26
                                                                                idx = 0
                                                                                while idx < 26:
                                                                                    mem[idx + _14004 + 68] = mem[_13827 + idx + 32]
                                                                                    idx = idx + 32
                                                                                    continue 
                                                                                mem[_14004 + 94] = 0
                                                                                revert with memory
                                                                                  from mem[64]
                                                                                   len _14004 + -mem[64] + 100
                                                                            _14485 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_14485] = 26
                                                                            mem[_14485 + 32] = 'SafeMath: division by zero'
                                                                            if _13118:
                                                                                if t > !(0 / _13119 / _13118):
                                                                                    revert with 0, 17
                                                                                if t + (0 / _13119 / _13118) < t:
                                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                                if s == -1:
                                                                                    revert with 0, 17
                                                                                s = s + 1
                                                                                t = t + (0 / _13119 / _13118)
                                                                                continue 
                                                                            _14683 = mem[64]
                                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                            mem[mem[64] + 4] = 32
                                                                            mem[mem[64] + 36] = 26
                                                                            idx = 0
                                                                            while idx < 26:
                                                                                mem[idx + _14683 + 68] = mem[_14485 + idx + 32]
                                                                                idx = idx + 32
                                                                                continue 
                                                                            mem[_14683 + 94] = 0
                                                                            revert with memory
                                                                              from mem[64]
                                                                               len _14683 + -mem[64] + 100
                                                                        if (mem[_12748 + 96] * mem[_12748]) + (mem[_12748 + 128] * mem[_12748]) and mem[_9032 + 64] > -1 / (mem[_12748 + 96] * mem[_12748]) + (mem[_12748 + 128] * mem[_12748]):
                                                                            revert with 0, 17
                                                                        if not (mem[_12748 + 96] * mem[_12748]) + (mem[_12748 + 128] * mem[_12748]):
                                                                            revert with 0, 18
                                                                        if (mem[_12748 + 96] * mem[_12748] * mem[_9032 + 64]) + (mem[_12748 + 128] * mem[_12748] * mem[_9032 + 64]) / (mem[_12748 + 96] * mem[_12748]) + (mem[_12748 + 128] * mem[_12748]) != mem[_9032 + 64]:
                                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                                        _14353 = mem[64]
                                                                        mem[64] = mem[64] + 64
                                                                        mem[_14353] = 26
                                                                        mem[_14353 + 32] = 'SafeMath: division by zero'
                                                                        if not _13119:
                                                                            _14484 = mem[64]
                                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                            mem[mem[64] + 4] = 32
                                                                            mem[mem[64] + 36] = 26
                                                                            idx = 0
                                                                            while idx < 26:
                                                                                mem[idx + _14484 + 68] = mem[_14353 + idx + 32]
                                                                                idx = idx + 32
                                                                                continue 
                                                                            mem[_14484 + 94] = 0
                                                                            revert with memory
                                                                              from mem[64]
                                                                               len _14484 + -mem[64] + 100
                                                                        _14955 = mem[64]
                                                                        mem[64] = mem[64] + 64
                                                                        mem[_14955] = 26
                                                                        mem[_14955 + 32] = 'SafeMath: division by zero'
                                                                        if _13118:
                                                                            if t > !((_13123 * _13121 * _13120) + (_13122 * _13121 * _13120) / _13119 / _13118):
                                                                                revert with 0, 17
                                                                            if t + ((_13123 * _13121 * _13120) + (_13122 * _13121 * _13120) / _13119 / _13118) < t:
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            if s == -1:
                                                                                revert with 0, 17
                                                                            s = s + 1
                                                                            t = t + ((_13123 * _13121 * _13120) + (_13122 * _13121 * _13120) / _13119 / _13118)
                                                                            continue 
                                                                        _15121 = mem[64]
                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[mem[64] + 4] = 32
                                                                        mem[mem[64] + 36] = 26
                                                                        idx = 0
                                                                        while idx < 26:
                                                                            mem[idx + _15121 + 68] = mem[_14955 + idx + 32]
                                                                            idx = idx + 32
                                                                            continue 
                                                                        mem[_15121 + 94] = 0
                                                                        revert with memory
                                                                          from mem[64]
                                                                           len _15121 + -mem[64] + 100
                                                                    _12622 = mem[_8169 + 32]
                                                                    _12623 = mem[_8169 + 160]
                                                                    if mem[_8169 + 160] > !t:
                                                                        revert with 0, 17
                                                                    if mem[_8169 + 160] + t < mem[_8169 + 160]:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    stor9[stor12[idx].field_0][Mask(128, 128, stor12[idx].field_256)] = 1
                                                                    mem[0] = idx
                                                                    mem[32] = 12
                                                                    if _12622 > !(_12623 + t):
                                                                        revert with 0, 17
                                                                    if _12622 + _12623 + t < _12622:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    if _12622 + _12623 + t:
                                                                        if not _12622 + _12623 + t:
                                                                            _13744 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_13744] = 26
                                                                            mem[_13744 + 32] = 'SafeMath: division by zero'
                                                                            if not DENOMINATOR:
                                                                                _13826 = mem[64]
                                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                mem[mem[64] + 4] = 32
                                                                                mem[mem[64] + 36] = 26
                                                                                idx = 0
                                                                                while idx < 26:
                                                                                    mem[idx + _13826 + 68] = mem[_13744 + idx + 32]
                                                                                    idx = idx + 32
                                                                                    continue 
                                                                                mem[_13826 + 94] = 0
                                                                                revert with memory
                                                                                  from mem[64]
                                                                                   len _13826 + -mem[64] + 100
                                                                            mem[mem[64] + 36] = 0 / DENOMINATOR
                                                                            require ext_code.size(sub_76089ab4Address)
                                                                            call sub_76089ab4Address.mintSupply(address arg1, uint256 arg2) with:
                                                                                 gas gas_remaining wei
                                                                                args this.address, 0 / DENOMINATOR
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            require ext_code.size(sub_76089ab4Address)
                                                                            call sub_76089ab4Address.createStake(uint256 arg1) with:
                                                                                 gas gas_remaining wei
                                                                                args (0 / DENOMINATOR)
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            mem[mem[64] + 4] = this.address
                                                                            staticcall sub_76089ab4Address.stakeCount(address arg1) with:
                                                                                    gas gas_remaining wei
                                                                                   args this.address
                                                                            mem[mem[64]] = ext_call.return_data[0]
                                                                            _14681 = mem[64]
                                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                                            require return_data.size >= 32
                                                                            _14850 = mem[_14681]
                                                                            if mem[_14681] < 1:
                                                                                revert with 0, 17
                                                                            _15190 = mem[64]
                                                                            mem[mem[64] + 32] = address(this.address)
                                                                            mem[mem[64] + 52] = _14850 - 1
                                                                            mem[mem[64] + 84] = 0x100000000000000000000000000000000000000000000000000000000000000
                                                                            _15191 = mem[64]
                                                                            mem[mem[64]] = 53
                                                                            mem[64] = mem[64] + 85
                                                                            _15193 = sha3(mem[_15191 + 32 len mem[_15191]])
                                                                            mem[_15190 + 89] = Mask(128, 128, sha3(mem[_15191 + 32 len mem[_15191]]))
                                                                            mem[_15190 + 121] = sub_4c86259e[idx].field_0
                                                                            require ext_code.size(sub_76089ab4Address)
                                                                            call sub_76089ab4Address.moveStake(bytes16 arg1, address arg2) with:
                                                                                 gas gas_remaining wei
                                                                                args Mask(128, 128, _15193), sub_4c86259e[idx].field_0
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            if sub_ab7789c0 == -1:
                                                                                revert with 0, 17
                                                                            sub_ab7789c0++
                                                                            if 1 > !sub_1b385a01[stor12[idx].field_0]:
                                                                                revert with 0, 17
                                                                            mem[0] = sub_4c86259e[idx].field_0
                                                                            mem[32] = 7
                                                                            sub_1b385a01[stor12[idx].field_0]++
                                                                            if sub_04b4a313 > !(0 / DENOMINATOR):
                                                                                revert with 0, 17
                                                                            if sub_04b4a313 + (0 / DENOMINATOR) < sub_04b4a313:
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            sub_04b4a313 += 0 / DENOMINATOR
                                                                            mem[_15190 + 85] = 0 / DENOMINATOR
                                                                            emit 0xdbcd8131: (0 / DENOMINATOR), sub_4c86259e[idx].field_0, Mask(128, 128, sub_4c86259e[idx].field_256), Mask(128, 128, _15193)
                                                                        else:
                                                                            if _12622 + _12623 + t and sub_d8830c7d > -1 / _12622 + _12623 + t:
                                                                                revert with 0, 17
                                                                            if not _12622 + _12623 + t:
                                                                                revert with 0, 18
                                                                            if (_12622 * sub_d8830c7d) + (_12623 * sub_d8830c7d) + (t * sub_d8830c7d) / _12622 + _12623 + t != sub_d8830c7d:
                                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                                            _14182 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_14182] = 26
                                                                            mem[_14182 + 32] = 'SafeMath: division by zero'
                                                                            if not DENOMINATOR:
                                                                                _14352 = mem[64]
                                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                mem[mem[64] + 4] = 32
                                                                                mem[mem[64] + 36] = 26
                                                                                idx = 0
                                                                                while idx < 26:
                                                                                    mem[idx + _14352 + 68] = mem[_14182 + idx + 32]
                                                                                    idx = idx + 32
                                                                                    continue 
                                                                                mem[_14352 + 94] = 0
                                                                                revert with memory
                                                                                  from mem[64]
                                                                                   len _14352 + -mem[64] + 100
                                                                            mem[mem[64] + 36] = (_12622 * sub_d8830c7d) + (_12623 * sub_d8830c7d) + (t * sub_d8830c7d) / DENOMINATOR
                                                                            require ext_code.size(sub_76089ab4Address)
                                                                            call sub_76089ab4Address.mintSupply(address arg1, uint256 arg2) with:
                                                                                 gas gas_remaining wei
                                                                                args this.address, (_12622 * sub_d8830c7d) + (_12623 * sub_d8830c7d) + (t * sub_d8830c7d) / DENOMINATOR
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            require ext_code.size(sub_76089ab4Address)
                                                                            call sub_76089ab4Address.createStake(uint256 arg1) with:
                                                                                 gas gas_remaining wei
                                                                                args ((_12622 * sub_d8830c7d) + (_12623 * sub_d8830c7d) + (t * sub_d8830c7d) / DENOMINATOR)
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            mem[mem[64] + 4] = this.address
                                                                            staticcall sub_76089ab4Address.stakeCount(address arg1) with:
                                                                                    gas gas_remaining wei
                                                                                   args this.address
                                                                            mem[mem[64]] = ext_call.return_data[0]
                                                                            _15120 = mem[64]
                                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                                            require return_data.size >= 32
                                                                            _15254 = mem[_15120]
                                                                            if mem[_15120] < 1:
                                                                                revert with 0, 17
                                                                            _15492 = mem[64]
                                                                            mem[mem[64] + 32] = address(this.address)
                                                                            mem[mem[64] + 52] = _15254 - 1
                                                                            mem[mem[64] + 84] = 0x100000000000000000000000000000000000000000000000000000000000000
                                                                            _15493 = mem[64]
                                                                            mem[mem[64]] = 53
                                                                            mem[64] = mem[64] + 85
                                                                            _15495 = sha3(mem[_15493 + 32 len mem[_15493]])
                                                                            mem[_15492 + 89] = Mask(128, 128, sha3(mem[_15493 + 32 len mem[_15493]]))
                                                                            mem[_15492 + 121] = sub_4c86259e[idx].field_0
                                                                            require ext_code.size(sub_76089ab4Address)
                                                                            call sub_76089ab4Address.moveStake(bytes16 arg1, address arg2) with:
                                                                                 gas gas_remaining wei
                                                                                args Mask(128, 128, _15495), sub_4c86259e[idx].field_0
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            if sub_ab7789c0 == -1:
                                                                                revert with 0, 17
                                                                            sub_ab7789c0++
                                                                            if 1 > !sub_1b385a01[stor12[idx].field_0]:
                                                                                revert with 0, 17
                                                                            mem[0] = sub_4c86259e[idx].field_0
                                                                            mem[32] = 7
                                                                            sub_1b385a01[stor12[idx].field_0]++
                                                                            if sub_04b4a313 > !((_12622 * sub_d8830c7d) + (_12623 * sub_d8830c7d) + (t * sub_d8830c7d) / DENOMINATOR):
                                                                                revert with 0, 17
                                                                            if sub_04b4a313 + ((_12622 * sub_d8830c7d) + (_12623 * sub_d8830c7d) + (t * sub_d8830c7d) / DENOMINATOR) < sub_04b4a313:
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            sub_04b4a313 += (_12622 * sub_d8830c7d) + (_12623 * sub_d8830c7d) + (t * sub_d8830c7d) / DENOMINATOR
                                                                            mem[_15492 + 85] = (_12622 * sub_d8830c7d) + (_12623 * sub_d8830c7d) + (t * sub_d8830c7d) / DENOMINATOR
                                                                            emit 0xdbcd8131: ((_12622 * sub_d8830c7d) + (_12623 * sub_d8830c7d) + (t * sub_d8830c7d) / DENOMINATOR), sub_4c86259e[idx].field_0, Mask(128, 128, sub_4c86259e[idx].field_256), Mask(128, 128, _15495)
                                                                else:
                                                                    _8825 = mem[_8169 + 224]
                                                                    _8826 = mem[_8169 + 192]
                                                                    if mem[_8169 + 192] > !mem[_8169 + 224]:
                                                                        revert with 0, 17
                                                                    if sub_ed73481d + 1 < mem[_8169 + 192] + mem[_8169 + 224]:
                                                                        _8978 = mem[_8169]
                                                                        staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                                                                                gas gas_remaining wei
                                                                               args sub_4c86259e[idx].field_0, Mask(128, 128, mem[_8169])
                                                                        mem[mem[64] len 352] = ext_call.return_data[0 len 352]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        _9080 = mem[64]
                                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                                        require return_data.size >= 352
                                                                        _9138 = mem[64]
                                                                        if mem[64] + 352 < mem[64] or mem[64] + 352 > test266151307():
                                                                            revert with 0, 65
                                                                        mem[64] = mem[64] + 352
                                                                        require mem[_9080] == Mask(128, 128, mem[_9080])
                                                                        mem[_9138] = mem[_9080]
                                                                        mem[_9138 + 32] = mem[_9080 + 32]
                                                                        mem[_9138 + 64] = mem[_9080 + 64]
                                                                        mem[_9138 + 96] = mem[_9080 + 96]
                                                                        require mem[_9080 + 128] < 5
                                                                        mem[_9138 + 128] = mem[_9080 + 128]
                                                                        mem[_9138 + 160] = mem[_9080 + 160]
                                                                        mem[_9138 + 192] = mem[_9080 + 192]
                                                                        mem[_9138 + 224] = mem[_9080 + 224]
                                                                        mem[_9138 + 256] = mem[_9080 + 256]
                                                                        mem[_9138 + 288] = mem[_9080 + 288]
                                                                        mem[_9138 + 320] = mem[_9080 + 320]
                                                                        if Mask(128, 128, mem[_9138]) != Mask(128, 128, _8978):
                                                                            revert with 0, 'Address does not contain stake with provided id'
                                                                        s = mem[_9138 + 192]
                                                                        t = 0
                                                                        while s < _8826 + _8825:
                                                                            staticcall sub_413c05c6Address.0x8ce1d9e4 with:
                                                                                    gas gas_remaining wei
                                                                                   args s
                                                                            mem[mem[64] len 160] = ext_call.return_data[0 len 160]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            _12619 = mem[64]
                                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                                            require return_data.size >= 160
                                                                            _12744 = mem[64]
                                                                            if mem[64] + 160 > test266151307() or mem[64] + 160 < mem[64]:
                                                                                revert with 0, 65
                                                                            mem[64] = mem[64] + 160
                                                                            mem[_12744] = mem[_12619]
                                                                            mem[_12744 + 32] = mem[_12619 + 32]
                                                                            mem[_12744 + 64] = mem[_12619 + 64]
                                                                            mem[_12744 + 96] = mem[_12619 + 96]
                                                                            mem[_12744 + 128] = mem[_12619 + 128]
                                                                            _13104 = mem[_12744 + 64]
                                                                            _13105 = mem[_12744 + 32]
                                                                            _13106 = mem[_9138 + 64]
                                                                            _13107 = mem[_12744]
                                                                            _13108 = mem[_12744 + 128]
                                                                            _13109 = mem[_12744 + 96]
                                                                            if mem[_12744 + 96] > !mem[_12744 + 128]:
                                                                                revert with 0, 17
                                                                            if mem[_12744 + 96] + mem[_12744 + 128] < mem[_12744 + 96]:
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            if not mem[_12744 + 96] + mem[_12744 + 128]:
                                                                                _13565 = mem[64]
                                                                                mem[64] = mem[64] + 64
                                                                                mem[_13565] = 26
                                                                                mem[_13565 + 32] = 'SafeMath: division by zero'
                                                                                if not _13105:
                                                                                    _13674 = mem[64]
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 26
                                                                                    idx = 0
                                                                                    while idx < 26:
                                                                                        mem[idx + _13674 + 68] = mem[_13565 + idx + 32]
                                                                                        idx = idx + 32
                                                                                        continue 
                                                                                    mem[_13674 + 94] = 0
                                                                                    revert with memory
                                                                                      from mem[64]
                                                                                       len _13674 + -mem[64] + 100
                                                                                _13989 = mem[64]
                                                                                mem[64] = mem[64] + 64
                                                                                mem[_13989] = 26
                                                                                mem[_13989 + 32] = 'SafeMath: division by zero'
                                                                                if _13104:
                                                                                    if t > !(0 / _13105 / _13104):
                                                                                        revert with 0, 17
                                                                                    if t + (0 / _13105 / _13104) < t:
                                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                                    if s == -1:
                                                                                        revert with 0, 17
                                                                                    s = s + 1
                                                                                    t = t + (0 / _13105 / _13104)
                                                                                    continue 
                                                                                _14176 = mem[64]
                                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                mem[mem[64] + 4] = 32
                                                                                mem[mem[64] + 36] = 26
                                                                                idx = 0
                                                                                while idx < 26:
                                                                                    mem[idx + _14176 + 68] = mem[_13989 + idx + 32]
                                                                                    idx = idx + 32
                                                                                    continue 
                                                                                mem[_14176 + 94] = 0
                                                                                revert with memory
                                                                                  from mem[64]
                                                                                   len _14176 + -mem[64] + 100
                                                                            if mem[_12744 + 96] + mem[_12744 + 128] and mem[_12744] > -1 / mem[_12744 + 96] + mem[_12744 + 128]:
                                                                                revert with 0, 17
                                                                            if not mem[_12744 + 96] + mem[_12744 + 128]:
                                                                                revert with 0, 18
                                                                            if (mem[_12744 + 96] * mem[_12744]) + (mem[_12744 + 128] * mem[_12744]) / mem[_12744 + 96] + mem[_12744 + 128] != mem[_12744]:
                                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                                            if not (mem[_12744 + 96] * mem[_12744]) + (mem[_12744 + 128] * mem[_12744]):
                                                                                _13821 = mem[64]
                                                                                mem[64] = mem[64] + 64
                                                                                mem[_13821] = 26
                                                                                mem[_13821 + 32] = 'SafeMath: division by zero'
                                                                                if not _13105:
                                                                                    _13988 = mem[64]
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 26
                                                                                    idx = 0
                                                                                    while idx < 26:
                                                                                        mem[idx + _13988 + 68] = mem[_13821 + idx + 32]
                                                                                        idx = idx + 32
                                                                                        continue 
                                                                                    mem[_13988 + 94] = 0
                                                                                    revert with memory
                                                                                      from mem[64]
                                                                                       len _13988 + -mem[64] + 100
                                                                                _14474 = mem[64]
                                                                                mem[64] = mem[64] + 64
                                                                                mem[_14474] = 26
                                                                                mem[_14474 + 32] = 'SafeMath: division by zero'
                                                                                if _13104:
                                                                                    if t > !(0 / _13105 / _13104):
                                                                                        revert with 0, 17
                                                                                    if t + (0 / _13105 / _13104) < t:
                                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                                    if s == -1:
                                                                                        revert with 0, 17
                                                                                    s = s + 1
                                                                                    t = t + (0 / _13105 / _13104)
                                                                                    continue 
                                                                                _14669 = mem[64]
                                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                mem[mem[64] + 4] = 32
                                                                                mem[mem[64] + 36] = 26
                                                                                idx = 0
                                                                                while idx < 26:
                                                                                    mem[idx + _14669 + 68] = mem[_14474 + idx + 32]
                                                                                    idx = idx + 32
                                                                                    continue 
                                                                                mem[_14669 + 94] = 0
                                                                                revert with memory
                                                                                  from mem[64]
                                                                                   len _14669 + -mem[64] + 100
                                                                            if (mem[_12744 + 96] * mem[_12744]) + (mem[_12744 + 128] * mem[_12744]) and mem[_9138 + 64] > -1 / (mem[_12744 + 96] * mem[_12744]) + (mem[_12744 + 128] * mem[_12744]):
                                                                                revert with 0, 17
                                                                            if not (mem[_12744 + 96] * mem[_12744]) + (mem[_12744 + 128] * mem[_12744]):
                                                                                revert with 0, 18
                                                                            if (mem[_12744 + 96] * mem[_12744] * mem[_9138 + 64]) + (mem[_12744 + 128] * mem[_12744] * mem[_9138 + 64]) / (mem[_12744 + 96] * mem[_12744]) + (mem[_12744 + 128] * mem[_12744]) != mem[_9138 + 64]:
                                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                                            _14344 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_14344] = 26
                                                                            mem[_14344 + 32] = 'SafeMath: division by zero'
                                                                            if not _13105:
                                                                                _14473 = mem[64]
                                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                mem[mem[64] + 4] = 32
                                                                                mem[mem[64] + 36] = 26
                                                                                idx = 0
                                                                                while idx < 26:
                                                                                    mem[idx + _14473 + 68] = mem[_14344 + idx + 32]
                                                                                    idx = idx + 32
                                                                                    continue 
                                                                                mem[_14473 + 94] = 0
                                                                                revert with memory
                                                                                  from mem[64]
                                                                                   len _14473 + -mem[64] + 100
                                                                            _14948 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_14948] = 26
                                                                            mem[_14948 + 32] = 'SafeMath: division by zero'
                                                                            if _13104:
                                                                                if t > !((_13109 * _13107 * _13106) + (_13108 * _13107 * _13106) / _13105 / _13104):
                                                                                    revert with 0, 17
                                                                                if t + ((_13109 * _13107 * _13106) + (_13108 * _13107 * _13106) / _13105 / _13104) < t:
                                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                                if s == -1:
                                                                                    revert with 0, 17
                                                                                s = s + 1
                                                                                t = t + ((_13109 * _13107 * _13106) + (_13108 * _13107 * _13106) / _13105 / _13104)
                                                                                continue 
                                                                            _15112 = mem[64]
                                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                            mem[mem[64] + 4] = 32
                                                                            mem[mem[64] + 36] = 26
                                                                            idx = 0
                                                                            while idx < 26:
                                                                                mem[idx + _15112 + 68] = mem[_14948 + idx + 32]
                                                                                idx = idx + 32
                                                                                continue 
                                                                            mem[_15112 + 94] = 0
                                                                            revert with memory
                                                                              from mem[64]
                                                                               len _15112 + -mem[64] + 100
                                                                        if t >= mem[_8169 + 160]:
                                                                            _12664 = mem[_8169]
                                                                            staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                                                                                    gas gas_remaining wei
                                                                                   args sub_4c86259e[idx].field_0, Mask(128, 128, mem[_8169])
                                                                            mem[mem[64] len 352] = ext_call.return_data[0 len 352]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            _13246 = mem[64]
                                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                                            require return_data.size >= 352
                                                                            _13284 = mem[64]
                                                                            if mem[64] + 352 < mem[64] or mem[64] + 352 > test266151307():
                                                                                revert with 0, 65
                                                                            mem[64] = mem[64] + 352
                                                                            require mem[_13246] == Mask(128, 128, mem[_13246])
                                                                            mem[_13284] = mem[_13246]
                                                                            mem[_13284 + 32] = mem[_13246 + 32]
                                                                            mem[_13284 + 64] = mem[_13246 + 64]
                                                                            mem[_13284 + 96] = mem[_13246 + 96]
                                                                            require mem[_13246 + 128] < 5
                                                                            mem[_13284 + 128] = mem[_13246 + 128]
                                                                            mem[_13284 + 160] = mem[_13246 + 160]
                                                                            mem[_13284 + 192] = mem[_13246 + 192]
                                                                            mem[_13284 + 224] = mem[_13246 + 224]
                                                                            mem[_13284 + 256] = mem[_13246 + 256]
                                                                            mem[_13284 + 288] = mem[_13246 + 288]
                                                                            mem[_13284 + 320] = mem[_13246 + 320]
                                                                            if Mask(128, 128, mem[_13284]) != Mask(128, 128, _12664):
                                                                                revert with 0, 'Address does not contain stake with provided id'
                                                                            s = mem[_13284 + 192]
                                                                            t = 0
                                                                            while s < sub_ed73481d + 1:
                                                                                staticcall sub_413c05c6Address.0x8ce1d9e4 with:
                                                                                        gas gas_remaining wei
                                                                                       args s
                                                                                mem[mem[64] len 160] = ext_call.return_data[0 len 160]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                _17119 = mem[64]
                                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                                require return_data.size >= 160
                                                                                _17198 = mem[64]
                                                                                if mem[64] + 160 > test266151307() or mem[64] + 160 < mem[64]:
                                                                                    revert with 0, 65
                                                                                mem[64] = mem[64] + 160
                                                                                mem[_17198] = mem[_17119]
                                                                                mem[_17198 + 32] = mem[_17119 + 32]
                                                                                mem[_17198 + 64] = mem[_17119 + 64]
                                                                                mem[_17198 + 96] = mem[_17119 + 96]
                                                                                mem[_17198 + 128] = mem[_17119 + 128]
                                                                                _17625 = mem[_17198 + 64]
                                                                                _17626 = mem[_17198 + 32]
                                                                                _17627 = mem[_13284 + 64]
                                                                                _17628 = mem[_17198]
                                                                                _17629 = mem[_17198 + 128]
                                                                                _17630 = mem[_17198 + 96]
                                                                                if mem[_17198 + 96] > !mem[_17198 + 128]:
                                                                                    revert with 0, 17
                                                                                if mem[_17198 + 96] + mem[_17198 + 128] < mem[_17198 + 96]:
                                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                                if not mem[_17198 + 96] + mem[_17198 + 128]:
                                                                                    _17836 = mem[64]
                                                                                    mem[64] = mem[64] + 64
                                                                                    mem[_17836] = 26
                                                                                    mem[_17836 + 32] = 'SafeMath: division by zero'
                                                                                    if not _17626:
                                                                                        _17896 = mem[64]
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 26
                                                                                        idx = 0
                                                                                        while idx < 26:
                                                                                            mem[idx + _17896 + 68] = mem[_17836 + idx + 32]
                                                                                            idx = idx + 32
                                                                                            continue 
                                                                                        mem[_17896 + 94] = 0
                                                                                        revert with memory
                                                                                          from mem[64]
                                                                                           len _17896 + -mem[64] + 100
                                                                                    _18065 = mem[64]
                                                                                    mem[64] = mem[64] + 64
                                                                                    mem[_18065] = 26
                                                                                    mem[_18065 + 32] = 'SafeMath: division by zero'
                                                                                    if _17625:
                                                                                        if t > !(0 / _17626 / _17625):
                                                                                            revert with 0, 17
                                                                                        if t + (0 / _17626 / _17625) < t:
                                                                                            revert with 0, 'SafeMath: addition overflow'
                                                                                        if s == -1:
                                                                                            revert with 0, 17
                                                                                        s = s + 1
                                                                                        t = t + (0 / _17626 / _17625)
                                                                                        continue 
                                                                                    _18162 = mem[64]
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 26
                                                                                    idx = 0
                                                                                    while idx < 26:
                                                                                        mem[idx + _18162 + 68] = mem[_18065 + idx + 32]
                                                                                        idx = idx + 32
                                                                                        continue 
                                                                                    mem[_18162 + 94] = 0
                                                                                    revert with memory
                                                                                      from mem[64]
                                                                                       len _18162 + -mem[64] + 100
                                                                                if mem[_17198 + 96] + mem[_17198 + 128] and mem[_17198] > -1 / mem[_17198 + 96] + mem[_17198 + 128]:
                                                                                    revert with 0, 17
                                                                                if not mem[_17198 + 96] + mem[_17198 + 128]:
                                                                                    revert with 0, 18
                                                                                if (mem[_17198 + 96] * mem[_17198]) + (mem[_17198 + 128] * mem[_17198]) / mem[_17198 + 96] + mem[_17198 + 128] != mem[_17198]:
                                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                                if not (mem[_17198 + 96] * mem[_17198]) + (mem[_17198 + 128] * mem[_17198]):
                                                                                    _17987 = mem[64]
                                                                                    mem[64] = mem[64] + 64
                                                                                    mem[_17987] = 26
                                                                                    mem[_17987 + 32] = 'SafeMath: division by zero'
                                                                                    if not _17626:
                                                                                        _18064 = mem[64]
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 26
                                                                                        idx = 0
                                                                                        while idx < 26:
                                                                                            mem[idx + _18064 + 68] = mem[_17987 + idx + 32]
                                                                                            idx = idx + 32
                                                                                            continue 
                                                                                        mem[_18064 + 94] = 0
                                                                                        revert with memory
                                                                                          from mem[64]
                                                                                           len _18064 + -mem[64] + 100
                                                                                    _18396 = mem[64]
                                                                                    mem[64] = mem[64] + 64
                                                                                    mem[_18396] = 26
                                                                                    mem[_18396 + 32] = 'SafeMath: division by zero'
                                                                                    if _17625:
                                                                                        if t > !(0 / _17626 / _17625):
                                                                                            revert with 0, 17
                                                                                        if t + (0 / _17626 / _17625) < t:
                                                                                            revert with 0, 'SafeMath: addition overflow'
                                                                                        if s == -1:
                                                                                            revert with 0, 17
                                                                                        s = s + 1
                                                                                        t = t + (0 / _17626 / _17625)
                                                                                        continue 
                                                                                    _18508 = mem[64]
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 26
                                                                                    idx = 0
                                                                                    while idx < 26:
                                                                                        mem[idx + _18508 + 68] = mem[_18396 + idx + 32]
                                                                                        idx = idx + 32
                                                                                        continue 
                                                                                    mem[_18508 + 94] = 0
                                                                                    revert with memory
                                                                                      from mem[64]
                                                                                       len _18508 + -mem[64] + 100
                                                                                if (mem[_17198 + 96] * mem[_17198]) + (mem[_17198 + 128] * mem[_17198]) and mem[_13284 + 64] > -1 / (mem[_17198 + 96] * mem[_17198]) + (mem[_17198 + 128] * mem[_17198]):
                                                                                    revert with 0, 17
                                                                                if not (mem[_17198 + 96] * mem[_17198]) + (mem[_17198 + 128] * mem[_17198]):
                                                                                    revert with 0, 18
                                                                                if (mem[_17198 + 96] * mem[_17198] * mem[_13284 + 64]) + (mem[_17198 + 128] * mem[_17198] * mem[_13284 + 64]) / (mem[_17198 + 96] * mem[_17198]) + (mem[_17198 + 128] * mem[_17198]) != mem[_13284 + 64]:
                                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                                _18287 = mem[64]
                                                                                mem[64] = mem[64] + 64
                                                                                mem[_18287] = 26
                                                                                mem[_18287 + 32] = 'SafeMath: division by zero'
                                                                                if not _17626:
                                                                                    _18395 = mem[64]
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 26
                                                                                    idx = 0
                                                                                    while idx < 26:
                                                                                        mem[idx + _18395 + 68] = mem[_18287 + idx + 32]
                                                                                        idx = idx + 32
                                                                                        continue 
                                                                                    mem[_18395 + 94] = 0
                                                                                    revert with memory
                                                                                      from mem[64]
                                                                                       len _18395 + -mem[64] + 100
                                                                                _18706 = mem[64]
                                                                                mem[64] = mem[64] + 64
                                                                                mem[_18706] = 26
                                                                                mem[_18706 + 32] = 'SafeMath: division by zero'
                                                                                if _17625:
                                                                                    if t > !((_17630 * _17628 * _17627) + (_17629 * _17628 * _17627) / _17626 / _17625):
                                                                                        revert with 0, 17
                                                                                    if t + ((_17630 * _17628 * _17627) + (_17629 * _17628 * _17627) / _17626 / _17625) < t:
                                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                                    if s == -1:
                                                                                        revert with 0, 17
                                                                                    s = s + 1
                                                                                    t = t + ((_17630 * _17628 * _17627) + (_17629 * _17628 * _17627) / _17626 / _17625)
                                                                                    continue 
                                                                                _18818 = mem[64]
                                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                mem[mem[64] + 4] = 32
                                                                                mem[mem[64] + 36] = 26
                                                                                idx = 0
                                                                                while idx < 26:
                                                                                    mem[idx + _18818 + 68] = mem[_18706 + idx + 32]
                                                                                    idx = idx + 32
                                                                                    continue 
                                                                                mem[_18818 + 94] = 0
                                                                                revert with memory
                                                                                  from mem[64]
                                                                                   len _18818 + -mem[64] + 100
                                                                            _17118 = mem[_8169 + 32]
                                                                            stor9[stor12[idx].field_0][Mask(128, 128, stor12[idx].field_256)] = 1
                                                                            mem[0] = idx
                                                                            mem[32] = 12
                                                                            if _17118 > !t:
                                                                                revert with 0, 17
                                                                            if _17118 + t < _17118:
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            if _17118 + t:
                                                                                if not _17118 + t:
                                                                                    _17822 = mem[64]
                                                                                    mem[64] = mem[64] + 64
                                                                                    mem[_17822] = 26
                                                                                    mem[_17822 + 32] = 'SafeMath: division by zero'
                                                                                    if not DENOMINATOR:
                                                                                        _17834 = mem[64]
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 26
                                                                                        idx = 0
                                                                                        while idx < 26:
                                                                                            mem[idx + _17834 + 68] = mem[_17822 + idx + 32]
                                                                                            idx = idx + 32
                                                                                            continue 
                                                                                        mem[_17834 + 94] = 0
                                                                                        revert with memory
                                                                                          from mem[64]
                                                                                           len _17834 + -mem[64] + 100
                                                                                    mem[mem[64] + 36] = 0 / DENOMINATOR
                                                                                    require ext_code.size(sub_76089ab4Address)
                                                                                    call sub_76089ab4Address.mintSupply(address arg1, uint256 arg2) with:
                                                                                         gas gas_remaining wei
                                                                                        args this.address, 0 / DENOMINATOR
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    require ext_code.size(sub_76089ab4Address)
                                                                                    call sub_76089ab4Address.createStake(uint256 arg1) with:
                                                                                         gas gas_remaining wei
                                                                                        args (0 / DENOMINATOR)
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    mem[mem[64] + 4] = this.address
                                                                                    staticcall sub_76089ab4Address.stakeCount(address arg1) with:
                                                                                            gas gas_remaining wei
                                                                                           args this.address
                                                                                    mem[mem[64]] = ext_call.return_data[0]
                                                                                    _18159 = mem[64]
                                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                                    require return_data.size >= 32
                                                                                    _18286 = mem[_18159]
                                                                                    if mem[_18159] < 1:
                                                                                        revert with 0, 17
                                                                                    _18566 = mem[64]
                                                                                    mem[mem[64] + 32] = address(this.address)
                                                                                    mem[mem[64] + 52] = _18286 - 1
                                                                                    mem[mem[64] + 84] = 0x100000000000000000000000000000000000000000000000000000000000000
                                                                                    _18567 = mem[64]
                                                                                    mem[mem[64]] = 53
                                                                                    mem[64] = mem[64] + 85
                                                                                    _18569 = sha3(mem[_18567 + 32 len mem[_18567]])
                                                                                    mem[_18566 + 89] = Mask(128, 128, sha3(mem[_18567 + 32 len mem[_18567]]))
                                                                                    mem[_18566 + 121] = sub_4c86259e[idx].field_0
                                                                                    require ext_code.size(sub_76089ab4Address)
                                                                                    call sub_76089ab4Address.moveStake(bytes16 arg1, address arg2) with:
                                                                                         gas gas_remaining wei
                                                                                        args Mask(128, 128, _18569), sub_4c86259e[idx].field_0
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    if sub_ab7789c0 == -1:
                                                                                        revert with 0, 17
                                                                                    sub_ab7789c0++
                                                                                    if 1 > !sub_1b385a01[stor12[idx].field_0]:
                                                                                        revert with 0, 17
                                                                                    mem[0] = sub_4c86259e[idx].field_0
                                                                                    mem[32] = 7
                                                                                    sub_1b385a01[stor12[idx].field_0]++
                                                                                    if sub_04b4a313 > !(0 / DENOMINATOR):
                                                                                        revert with 0, 17
                                                                                    if sub_04b4a313 + (0 / DENOMINATOR) < sub_04b4a313:
                                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                                    sub_04b4a313 += 0 / DENOMINATOR
                                                                                    mem[_18566 + 85] = 0 / DENOMINATOR
                                                                                    emit 0xdbcd8131: (0 / DENOMINATOR), sub_4c86259e[idx].field_0, Mask(128, 128, sub_4c86259e[idx].field_256), Mask(128, 128, _18569)
                                                                                else:
                                                                                    if _17118 + t and sub_d8830c7d > -1 / _17118 + t:
                                                                                        revert with 0, 17
                                                                                    if not _17118 + t:
                                                                                        revert with 0, 18
                                                                                    if (_17118 * sub_d8830c7d) + (t * sub_d8830c7d) / _17118 + t != sub_d8830c7d:
                                                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                                                    _17938 = mem[64]
                                                                                    mem[64] = mem[64] + 64
                                                                                    mem[_17938] = 26
                                                                                    mem[_17938 + 32] = 'SafeMath: division by zero'
                                                                                    if not DENOMINATOR:
                                                                                        _17986 = mem[64]
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 26
                                                                                        idx = 0
                                                                                        while idx < 26:
                                                                                            mem[idx + _17986 + 68] = mem[_17938 + idx + 32]
                                                                                            idx = idx + 32
                                                                                            continue 
                                                                                        mem[_17986 + 94] = 0
                                                                                        revert with memory
                                                                                          from mem[64]
                                                                                           len _17986 + -mem[64] + 100
                                                                                    mem[mem[64] + 36] = (_17118 * sub_d8830c7d) + (t * sub_d8830c7d) / DENOMINATOR
                                                                                    require ext_code.size(sub_76089ab4Address)
                                                                                    call sub_76089ab4Address.mintSupply(address arg1, uint256 arg2) with:
                                                                                         gas gas_remaining wei
                                                                                        args this.address, (_17118 * sub_d8830c7d) + (t * sub_d8830c7d) / DENOMINATOR
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    require ext_code.size(sub_76089ab4Address)
                                                                                    call sub_76089ab4Address.createStake(uint256 arg1) with:
                                                                                         gas gas_remaining wei
                                                                                        args ((_17118 * sub_d8830c7d) + (t * sub_d8830c7d) / DENOMINATOR)
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    mem[mem[64] + 4] = this.address
                                                                                    staticcall sub_76089ab4Address.stakeCount(address arg1) with:
                                                                                            gas gas_remaining wei
                                                                                           args this.address
                                                                                    mem[mem[64]] = ext_call.return_data[0]
                                                                                    _18506 = mem[64]
                                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                                    require return_data.size >= 32
                                                                                    _18618 = mem[_18506]
                                                                                    if mem[_18506] < 1:
                                                                                        revert with 0, 17
                                                                                    _18854 = mem[64]
                                                                                    mem[mem[64] + 32] = address(this.address)
                                                                                    mem[mem[64] + 52] = _18618 - 1
                                                                                    mem[mem[64] + 84] = 0x100000000000000000000000000000000000000000000000000000000000000
                                                                                    _18855 = mem[64]
                                                                                    mem[mem[64]] = 53
                                                                                    mem[64] = mem[64] + 85
                                                                                    _18857 = sha3(mem[_18855 + 32 len mem[_18855]])
                                                                                    mem[_18854 + 89] = Mask(128, 128, sha3(mem[_18855 + 32 len mem[_18855]]))
                                                                                    mem[_18854 + 121] = sub_4c86259e[idx].field_0
                                                                                    require ext_code.size(sub_76089ab4Address)
                                                                                    call sub_76089ab4Address.moveStake(bytes16 arg1, address arg2) with:
                                                                                         gas gas_remaining wei
                                                                                        args Mask(128, 128, _18857), sub_4c86259e[idx].field_0
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    if sub_ab7789c0 == -1:
                                                                                        revert with 0, 17
                                                                                    sub_ab7789c0++
                                                                                    if 1 > !sub_1b385a01[stor12[idx].field_0]:
                                                                                        revert with 0, 17
                                                                                    mem[0] = sub_4c86259e[idx].field_0
                                                                                    mem[32] = 7
                                                                                    sub_1b385a01[stor12[idx].field_0]++
                                                                                    if sub_04b4a313 > !((_17118 * sub_d8830c7d) + (t * sub_d8830c7d) / DENOMINATOR):
                                                                                        revert with 0, 17
                                                                                    if sub_04b4a313 + ((_17118 * sub_d8830c7d) + (t * sub_d8830c7d) / DENOMINATOR) < sub_04b4a313:
                                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                                    sub_04b4a313 += (_17118 * sub_d8830c7d) + (t * sub_d8830c7d) / DENOMINATOR
                                                                                    mem[_18854 + 85] = (_17118 * sub_d8830c7d) + (t * sub_d8830c7d) / DENOMINATOR
                                                                                    emit 0xdbcd8131: ((_17118 * sub_d8830c7d) + (t * sub_d8830c7d) / DENOMINATOR), sub_4c86259e[idx].field_0, Mask(128, 128, sub_4c86259e[idx].field_256), Mask(128, 128, _18857)
                                                                        else:
                                                                            _12665 = mem[_8169 + 160]
                                                                            _12743 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_12743] = 30
                                                                            mem[_12743 + 32] = 'SafeMath: subtraction overflow'
                                                                            if t > _12665:
                                                                                _13103 = mem[64]
                                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                mem[mem[64] + 4] = 32
                                                                                mem[mem[64] + 36] = 30
                                                                                idx = 0
                                                                                while idx < 30:
                                                                                    mem[idx + _13103 + 68] = mem[_12743 + idx + 32]
                                                                                    idx = idx + 32
                                                                                    continue 
                                                                                mem[_13103 + 98] = 0
                                                                                revert with memory
                                                                                  from mem[64]
                                                                                   len _13103 + -mem[64] + 100
                                                                            if _12665 < t:
                                                                                revert with 0, 17
                                                                            _13314 = mem[_8169]
                                                                            staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                                                                                    gas gas_remaining wei
                                                                                   args sub_4c86259e[idx].field_0, Mask(128, 128, mem[_8169])
                                                                            mem[mem[64] len 352] = ext_call.return_data[0 len 352]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            _13426 = mem[64]
                                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                                            require return_data.size >= 352
                                                                            _13477 = mem[64]
                                                                            if mem[64] + 352 < mem[64] or mem[64] + 352 > test266151307():
                                                                                revert with 0, 65
                                                                            mem[64] = mem[64] + 352
                                                                            require mem[_13426] == Mask(128, 128, mem[_13426])
                                                                            mem[_13477] = mem[_13426]
                                                                            mem[_13477 + 32] = mem[_13426 + 32]
                                                                            mem[_13477 + 64] = mem[_13426 + 64]
                                                                            mem[_13477 + 96] = mem[_13426 + 96]
                                                                            require mem[_13426 + 128] < 5
                                                                            mem[_13477 + 128] = mem[_13426 + 128]
                                                                            mem[_13477 + 160] = mem[_13426 + 160]
                                                                            mem[_13477 + 192] = mem[_13426 + 192]
                                                                            mem[_13477 + 224] = mem[_13426 + 224]
                                                                            mem[_13477 + 256] = mem[_13426 + 256]
                                                                            mem[_13477 + 288] = mem[_13426 + 288]
                                                                            mem[_13477 + 320] = mem[_13426 + 320]
                                                                            if Mask(128, 128, mem[_13477]) != Mask(128, 128, _13314):
                                                                                revert with 0, 'Address does not contain stake with provided id'
                                                                            s = mem[_13477 + 192]
                                                                            u = 0
                                                                            while s < sub_ed73481d + 1:
                                                                                staticcall sub_413c05c6Address.0x8ce1d9e4 with:
                                                                                        gas gas_remaining wei
                                                                                       args s
                                                                                mem[mem[64] len 160] = ext_call.return_data[0 len 160]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                _17121 = mem[64]
                                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                                require return_data.size >= 160
                                                                                _17199 = mem[64]
                                                                                if mem[64] + 160 > test266151307() or mem[64] + 160 < mem[64]:
                                                                                    revert with 0, 65
                                                                                mem[64] = mem[64] + 160
                                                                                mem[_17199] = mem[_17121]
                                                                                mem[_17199 + 32] = mem[_17121 + 32]
                                                                                mem[_17199 + 64] = mem[_17121 + 64]
                                                                                mem[_17199 + 96] = mem[_17121 + 96]
                                                                                mem[_17199 + 128] = mem[_17121 + 128]
                                                                                _17631 = mem[_17199 + 64]
                                                                                _17632 = mem[_17199 + 32]
                                                                                _17633 = mem[_13477 + 64]
                                                                                _17634 = mem[_17199]
                                                                                _17635 = mem[_17199 + 128]
                                                                                _17636 = mem[_17199 + 96]
                                                                                if mem[_17199 + 96] > !mem[_17199 + 128]:
                                                                                    revert with 0, 17
                                                                                if mem[_17199 + 96] + mem[_17199 + 128] < mem[_17199 + 96]:
                                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                                if not mem[_17199 + 96] + mem[_17199 + 128]:
                                                                                    _17838 = mem[64]
                                                                                    mem[64] = mem[64] + 64
                                                                                    mem[_17838] = 26
                                                                                    mem[_17838 + 32] = 'SafeMath: division by zero'
                                                                                    if not _17632:
                                                                                        _17897 = mem[64]
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 26
                                                                                        idx = 0
                                                                                        while idx < 26:
                                                                                            mem[idx + _17897 + 68] = mem[_17838 + idx + 32]
                                                                                            idx = idx + 32
                                                                                            continue 
                                                                                        mem[_17897 + 94] = 0
                                                                                        revert with memory
                                                                                          from mem[64]
                                                                                           len _17897 + -mem[64] + 100
                                                                                    _18069 = mem[64]
                                                                                    mem[64] = mem[64] + 64
                                                                                    mem[_18069] = 26
                                                                                    mem[_18069 + 32] = 'SafeMath: division by zero'
                                                                                    if _17631:
                                                                                        if u > !(0 / _17632 / _17631):
                                                                                            revert with 0, 17
                                                                                        if u + (0 / _17632 / _17631) < u:
                                                                                            revert with 0, 'SafeMath: addition overflow'
                                                                                        if s == -1:
                                                                                            revert with 0, 17
                                                                                        s = s + 1
                                                                                        u = u + (0 / _17632 / _17631)
                                                                                        continue 
                                                                                    _18168 = mem[64]
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 26
                                                                                    idx = 0
                                                                                    while idx < 26:
                                                                                        mem[idx + _18168 + 68] = mem[_18069 + idx + 32]
                                                                                        idx = idx + 32
                                                                                        continue 
                                                                                    mem[_18168 + 94] = 0
                                                                                    revert with memory
                                                                                      from mem[64]
                                                                                       len _18168 + -mem[64] + 100
                                                                                if mem[_17199 + 96] + mem[_17199 + 128] and mem[_17199] > -1 / mem[_17199 + 96] + mem[_17199 + 128]:
                                                                                    revert with 0, 17
                                                                                if not mem[_17199 + 96] + mem[_17199 + 128]:
                                                                                    revert with 0, 18
                                                                                if (mem[_17199 + 96] * mem[_17199]) + (mem[_17199 + 128] * mem[_17199]) / mem[_17199 + 96] + mem[_17199 + 128] != mem[_17199]:
                                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                                if not (mem[_17199 + 96] * mem[_17199]) + (mem[_17199 + 128] * mem[_17199]):
                                                                                    _17990 = mem[64]
                                                                                    mem[64] = mem[64] + 64
                                                                                    mem[_17990] = 26
                                                                                    mem[_17990 + 32] = 'SafeMath: division by zero'
                                                                                    if not _17632:
                                                                                        _18068 = mem[64]
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 26
                                                                                        idx = 0
                                                                                        while idx < 26:
                                                                                            mem[idx + _18068 + 68] = mem[_17990 + idx + 32]
                                                                                            idx = idx + 32
                                                                                            continue 
                                                                                        mem[_18068 + 94] = 0
                                                                                        revert with memory
                                                                                          from mem[64]
                                                                                           len _18068 + -mem[64] + 100
                                                                                    _18401 = mem[64]
                                                                                    mem[64] = mem[64] + 64
                                                                                    mem[_18401] = 26
                                                                                    mem[_18401 + 32] = 'SafeMath: division by zero'
                                                                                    if _17631:
                                                                                        if u > !(0 / _17632 / _17631):
                                                                                            revert with 0, 17
                                                                                        if u + (0 / _17632 / _17631) < u:
                                                                                            revert with 0, 'SafeMath: addition overflow'
                                                                                        if s == -1:
                                                                                            revert with 0, 17
                                                                                        s = s + 1
                                                                                        u = u + (0 / _17632 / _17631)
                                                                                        continue 
                                                                                    _18513 = mem[64]
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 26
                                                                                    idx = 0
                                                                                    while idx < 26:
                                                                                        mem[idx + _18513 + 68] = mem[_18401 + idx + 32]
                                                                                        idx = idx + 32
                                                                                        continue 
                                                                                    mem[_18513 + 94] = 0
                                                                                    revert with memory
                                                                                      from mem[64]
                                                                                       len _18513 + -mem[64] + 100
                                                                                if (mem[_17199 + 96] * mem[_17199]) + (mem[_17199 + 128] * mem[_17199]) and mem[_13477 + 64] > -1 / (mem[_17199 + 96] * mem[_17199]) + (mem[_17199 + 128] * mem[_17199]):
                                                                                    revert with 0, 17
                                                                                if not (mem[_17199 + 96] * mem[_17199]) + (mem[_17199 + 128] * mem[_17199]):
                                                                                    revert with 0, 18
                                                                                if (mem[_17199 + 96] * mem[_17199] * mem[_13477 + 64]) + (mem[_17199 + 128] * mem[_17199] * mem[_13477 + 64]) / (mem[_17199 + 96] * mem[_17199]) + (mem[_17199 + 128] * mem[_17199]) != mem[_13477 + 64]:
                                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                                _18291 = mem[64]
                                                                                mem[64] = mem[64] + 64
                                                                                mem[_18291] = 26
                                                                                mem[_18291 + 32] = 'SafeMath: division by zero'
                                                                                if not _17632:
                                                                                    _18400 = mem[64]
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 26
                                                                                    idx = 0
                                                                                    while idx < 26:
                                                                                        mem[idx + _18400 + 68] = mem[_18291 + idx + 32]
                                                                                        idx = idx + 32
                                                                                        continue 
                                                                                    mem[_18400 + 94] = 0
                                                                                    revert with memory
                                                                                      from mem[64]
                                                                                       len _18400 + -mem[64] + 100
                                                                                _18710 = mem[64]
                                                                                mem[64] = mem[64] + 64
                                                                                mem[_18710] = 26
                                                                                mem[_18710 + 32] = 'SafeMath: division by zero'
                                                                                if _17631:
                                                                                    if u > !((_17636 * _17634 * _17633) + (_17635 * _17634 * _17633) / _17632 / _17631):
                                                                                        revert with 0, 17
                                                                                    if u + ((_17636 * _17634 * _17633) + (_17635 * _17634 * _17633) / _17632 / _17631) < u:
                                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                                    if s == -1:
                                                                                        revert with 0, 17
                                                                                    s = s + 1
                                                                                    u = u + ((_17636 * _17634 * _17633) + (_17635 * _17634 * _17633) / _17632 / _17631)
                                                                                    continue 
                                                                                _18821 = mem[64]
                                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                mem[mem[64] + 4] = 32
                                                                                mem[mem[64] + 36] = 26
                                                                                idx = 0
                                                                                while idx < 26:
                                                                                    mem[idx + _18821 + 68] = mem[_18710 + idx + 32]
                                                                                    idx = idx + 32
                                                                                    continue 
                                                                                mem[_18821 + 94] = 0
                                                                                revert with memory
                                                                                  from mem[64]
                                                                                   len _18821 + -mem[64] + 100
                                                                            _17120 = mem[_8169 + 32]
                                                                            if _12665 - t > !u:
                                                                                revert with 0, 17
                                                                            if u < 0:
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            stor9[stor12[idx].field_0][Mask(128, 128, stor12[idx].field_256)] = 1
                                                                            mem[0] = idx
                                                                            mem[32] = 12
                                                                            if _17120 > !(_12665 - t + u):
                                                                                revert with 0, 17
                                                                            if _17120 + _12665 - t + u < _17120:
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            if _17120 + _12665 - t + u:
                                                                                if not _17120 + _12665 - t + u:
                                                                                    _17941 = mem[64]
                                                                                    mem[64] = mem[64] + 64
                                                                                    mem[_17941] = 26
                                                                                    mem[_17941 + 32] = 'SafeMath: division by zero'
                                                                                    if not DENOMINATOR:
                                                                                        _17989 = mem[64]
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 26
                                                                                        idx = 0
                                                                                        while idx < 26:
                                                                                            mem[idx + _17989 + 68] = mem[_17941 + idx + 32]
                                                                                            idx = idx + 32
                                                                                            continue 
                                                                                        mem[_17989 + 94] = 0
                                                                                        revert with memory
                                                                                          from mem[64]
                                                                                           len _17989 + -mem[64] + 100
                                                                                    mem[mem[64] + 36] = 0 / DENOMINATOR
                                                                                    require ext_code.size(sub_76089ab4Address)
                                                                                    call sub_76089ab4Address.mintSupply(address arg1, uint256 arg2) with:
                                                                                         gas gas_remaining wei
                                                                                        args this.address, 0 / DENOMINATOR
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    require ext_code.size(sub_76089ab4Address)
                                                                                    call sub_76089ab4Address.createStake(uint256 arg1) with:
                                                                                         gas gas_remaining wei
                                                                                        args (0 / DENOMINATOR)
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    mem[mem[64] + 4] = this.address
                                                                                    staticcall sub_76089ab4Address.stakeCount(address arg1) with:
                                                                                            gas gas_remaining wei
                                                                                           args this.address
                                                                                    mem[mem[64]] = ext_call.return_data[0]
                                                                                    _18511 = mem[64]
                                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                                    require return_data.size >= 32
                                                                                    _18622 = mem[_18511]
                                                                                    if mem[_18511] < 1:
                                                                                        revert with 0, 17
                                                                                    _18859 = mem[64]
                                                                                    mem[mem[64] + 32] = address(this.address)
                                                                                    mem[mem[64] + 52] = _18622 - 1
                                                                                    mem[mem[64] + 84] = 0x100000000000000000000000000000000000000000000000000000000000000
                                                                                    _18860 = mem[64]
                                                                                    mem[mem[64]] = 53
                                                                                    mem[64] = mem[64] + 85
                                                                                    _18862 = sha3(mem[_18860 + 32 len mem[_18860]])
                                                                                    mem[_18859 + 89] = Mask(128, 128, sha3(mem[_18860 + 32 len mem[_18860]]))
                                                                                    mem[_18859 + 121] = sub_4c86259e[idx].field_0
                                                                                    require ext_code.size(sub_76089ab4Address)
                                                                                    call sub_76089ab4Address.moveStake(bytes16 arg1, address arg2) with:
                                                                                         gas gas_remaining wei
                                                                                        args Mask(128, 128, _18862), sub_4c86259e[idx].field_0
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    if sub_ab7789c0 == -1:
                                                                                        revert with 0, 17
                                                                                    sub_ab7789c0++
                                                                                    if 1 > !sub_1b385a01[stor12[idx].field_0]:
                                                                                        revert with 0, 17
                                                                                    mem[0] = sub_4c86259e[idx].field_0
                                                                                    mem[32] = 7
                                                                                    sub_1b385a01[stor12[idx].field_0]++
                                                                                    if sub_04b4a313 > !(0 / DENOMINATOR):
                                                                                        revert with 0, 17
                                                                                    if sub_04b4a313 + (0 / DENOMINATOR) < sub_04b4a313:
                                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                                    sub_04b4a313 += 0 / DENOMINATOR
                                                                                    mem[_18859 + 85] = 0 / DENOMINATOR
                                                                                    emit 0xdbcd8131: (0 / DENOMINATOR), sub_4c86259e[idx].field_0, Mask(128, 128, sub_4c86259e[idx].field_256), Mask(128, 128, _18862)
                                                                                else:
                                                                                    if _17120 + _12665 - t + u and sub_d8830c7d > -1 / _17120 + _12665 - t + u:
                                                                                        revert with 0, 17
                                                                                    if not _17120 + _12665 - t + u:
                                                                                        revert with 0, 18
                                                                                    if (_17120 * sub_d8830c7d) + (_12665 * sub_d8830c7d) - (t * sub_d8830c7d) + (u * sub_d8830c7d) / _17120 + _12665 - t + u != sub_d8830c7d:
                                                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                                                    _18164 = mem[64]
                                                                                    mem[64] = mem[64] + 64
                                                                                    mem[_18164] = 26
                                                                                    mem[_18164 + 32] = 'SafeMath: division by zero'
                                                                                    if not DENOMINATOR:
                                                                                        _18290 = mem[64]
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 26
                                                                                        idx = 0
                                                                                        while idx < 26:
                                                                                            mem[idx + _18290 + 68] = mem[_18164 + idx + 32]
                                                                                            idx = idx + 32
                                                                                            continue 
                                                                                        mem[_18290 + 94] = 0
                                                                                        revert with memory
                                                                                          from mem[64]
                                                                                           len _18290 + -mem[64] + 100
                                                                                    mem[mem[64] + 36] = (_17120 * sub_d8830c7d) + (_12665 * sub_d8830c7d) - (t * sub_d8830c7d) + (u * sub_d8830c7d) / DENOMINATOR
                                                                                    require ext_code.size(sub_76089ab4Address)
                                                                                    call sub_76089ab4Address.mintSupply(address arg1, uint256 arg2) with:
                                                                                         gas gas_remaining wei
                                                                                        args this.address, (_17120 * sub_d8830c7d) + (_12665 * sub_d8830c7d) - (t * sub_d8830c7d) + (u * sub_d8830c7d) / DENOMINATOR
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    require ext_code.size(sub_76089ab4Address)
                                                                                    call sub_76089ab4Address.createStake(uint256 arg1) with:
                                                                                         gas gas_remaining wei
                                                                                        args ((_17120 * sub_d8830c7d) + (_12665 * sub_d8830c7d) - (t * sub_d8830c7d) + (u * sub_d8830c7d) / DENOMINATOR)
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    mem[mem[64] + 4] = this.address
                                                                                    staticcall sub_76089ab4Address.stakeCount(address arg1) with:
                                                                                            gas gas_remaining wei
                                                                                           args this.address
                                                                                    mem[mem[64]] = ext_call.return_data[0]
                                                                                    _18820 = mem[64]
                                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                                    require return_data.size >= 32
                                                                                    _18909 = mem[_18820]
                                                                                    if mem[_18820] < 1:
                                                                                        revert with 0, 17
                                                                                    _19023 = mem[64]
                                                                                    mem[mem[64] + 32] = address(this.address)
                                                                                    mem[mem[64] + 52] = _18909 - 1
                                                                                    mem[mem[64] + 84] = 0x100000000000000000000000000000000000000000000000000000000000000
                                                                                    _19024 = mem[64]
                                                                                    mem[mem[64]] = 53
                                                                                    mem[64] = mem[64] + 85
                                                                                    _19026 = sha3(mem[_19024 + 32 len mem[_19024]])
                                                                                    mem[_19023 + 89] = Mask(128, 128, sha3(mem[_19024 + 32 len mem[_19024]]))
                                                                                    mem[_19023 + 121] = sub_4c86259e[idx].field_0
                                                                                    require ext_code.size(sub_76089ab4Address)
                                                                                    call sub_76089ab4Address.moveStake(bytes16 arg1, address arg2) with:
                                                                                         gas gas_remaining wei
                                                                                        args Mask(128, 128, _19026), sub_4c86259e[idx].field_0
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    if sub_ab7789c0 == -1:
                                                                                        revert with 0, 17
                                                                                    sub_ab7789c0++
                                                                                    if 1 > !sub_1b385a01[stor12[idx].field_0]:
                                                                                        revert with 0, 17
                                                                                    mem[0] = sub_4c86259e[idx].field_0
                                                                                    mem[32] = 7
                                                                                    sub_1b385a01[stor12[idx].field_0]++
                                                                                    if sub_04b4a313 > !((_17120 * sub_d8830c7d) + (_12665 * sub_d8830c7d) - (t * sub_d8830c7d) + (u * sub_d8830c7d) / DENOMINATOR):
                                                                                        revert with 0, 17
                                                                                    if sub_04b4a313 + ((_17120 * sub_d8830c7d) + (_12665 * sub_d8830c7d) - (t * sub_d8830c7d) + (u * sub_d8830c7d) / DENOMINATOR) < sub_04b4a313:
                                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                                    sub_04b4a313 += (_17120 * sub_d8830c7d) + (_12665 * sub_d8830c7d) - (t * sub_d8830c7d) + (u * sub_d8830c7d) / DENOMINATOR
                                                                                    mem[_19023 + 85] = (_17120 * sub_d8830c7d) + (_12665 * sub_d8830c7d) - (t * sub_d8830c7d) + (u * sub_d8830c7d) / DENOMINATOR
                                                                                    emit 0xdbcd8131: ((_17120 * sub_d8830c7d) + (_12665 * sub_d8830c7d) - (t * sub_d8830c7d) + (u * sub_d8830c7d) / DENOMINATOR), sub_4c86259e[idx].field_0, Mask(128, 128, sub_4c86259e[idx].field_256), Mask(128, 128, _19026)
                                                                    else:
                                                                        _8979 = mem[_8169]
                                                                        staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                                                                                gas gas_remaining wei
                                                                               args sub_4c86259e[idx].field_0, Mask(128, 128, mem[_8169])
                                                                        mem[mem[64] len 352] = ext_call.return_data[0 len 352]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        _9081 = mem[64]
                                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                                        require return_data.size >= 352
                                                                        _9139 = mem[64]
                                                                        if mem[64] + 352 < mem[64] or mem[64] + 352 > test266151307():
                                                                            revert with 0, 65
                                                                        mem[64] = mem[64] + 352
                                                                        require mem[_9081] == Mask(128, 128, mem[_9081])
                                                                        mem[_9139] = mem[_9081]
                                                                        mem[_9139 + 32] = mem[_9081 + 32]
                                                                        mem[_9139 + 64] = mem[_9081 + 64]
                                                                        mem[_9139 + 96] = mem[_9081 + 96]
                                                                        require mem[_9081 + 128] < 5
                                                                        mem[_9139 + 128] = mem[_9081 + 128]
                                                                        mem[_9139 + 160] = mem[_9081 + 160]
                                                                        mem[_9139 + 192] = mem[_9081 + 192]
                                                                        mem[_9139 + 224] = mem[_9081 + 224]
                                                                        mem[_9139 + 256] = mem[_9081 + 256]
                                                                        mem[_9139 + 288] = mem[_9081 + 288]
                                                                        mem[_9139 + 320] = mem[_9081 + 320]
                                                                        if Mask(128, 128, mem[_9139]) != Mask(128, 128, _8979):
                                                                            revert with 0, 'Address does not contain stake with provided id'
                                                                        s = mem[_9139 + 192]
                                                                        t = 0
                                                                        while s < _8826 + _8825:
                                                                            staticcall sub_413c05c6Address.0x8ce1d9e4 with:
                                                                                    gas gas_remaining wei
                                                                                   args s
                                                                            mem[mem[64] len 160] = ext_call.return_data[0 len 160]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            _12621 = mem[64]
                                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                                            require return_data.size >= 160
                                                                            _12747 = mem[64]
                                                                            if mem[64] + 160 > test266151307() or mem[64] + 160 < mem[64]:
                                                                                revert with 0, 65
                                                                            mem[64] = mem[64] + 160
                                                                            mem[_12747] = mem[_12621]
                                                                            mem[_12747 + 32] = mem[_12621 + 32]
                                                                            mem[_12747 + 64] = mem[_12621 + 64]
                                                                            mem[_12747 + 96] = mem[_12621 + 96]
                                                                            mem[_12747 + 128] = mem[_12621 + 128]
                                                                            _13112 = mem[_12747 + 64]
                                                                            _13113 = mem[_12747 + 32]
                                                                            _13114 = mem[_9139 + 64]
                                                                            _13115 = mem[_12747]
                                                                            _13116 = mem[_12747 + 128]
                                                                            _13117 = mem[_12747 + 96]
                                                                            if mem[_12747 + 96] > !mem[_12747 + 128]:
                                                                                revert with 0, 17
                                                                            if mem[_12747 + 96] + mem[_12747 + 128] < mem[_12747 + 96]:
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            if not mem[_12747 + 96] + mem[_12747 + 128]:
                                                                                _13569 = mem[64]
                                                                                mem[64] = mem[64] + 64
                                                                                mem[_13569] = 26
                                                                                mem[_13569 + 32] = 'SafeMath: division by zero'
                                                                                if not _13113:
                                                                                    _13675 = mem[64]
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 26
                                                                                    idx = 0
                                                                                    while idx < 26:
                                                                                        mem[idx + _13675 + 68] = mem[_13569 + idx + 32]
                                                                                        idx = idx + 32
                                                                                        continue 
                                                                                    mem[_13675 + 94] = 0
                                                                                    revert with memory
                                                                                      from mem[64]
                                                                                       len _13675 + -mem[64] + 100
                                                                                _14001 = mem[64]
                                                                                mem[64] = mem[64] + 64
                                                                                mem[_14001] = 26
                                                                                mem[_14001 + 32] = 'SafeMath: division by zero'
                                                                                if _13112:
                                                                                    if t > !(0 / _13113 / _13112):
                                                                                        revert with 0, 17
                                                                                    if t + (0 / _13113 / _13112) < t:
                                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                                    if s == -1:
                                                                                        revert with 0, 17
                                                                                    s = s + 1
                                                                                    t = t + (0 / _13113 / _13112)
                                                                                    continue 
                                                                                _14180 = mem[64]
                                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                mem[mem[64] + 4] = 32
                                                                                mem[mem[64] + 36] = 26
                                                                                idx = 0
                                                                                while idx < 26:
                                                                                    mem[idx + _14180 + 68] = mem[_14001 + idx + 32]
                                                                                    idx = idx + 32
                                                                                    continue 
                                                                                mem[_14180 + 94] = 0
                                                                                revert with memory
                                                                                  from mem[64]
                                                                                   len _14180 + -mem[64] + 100
                                                                            if mem[_12747 + 96] + mem[_12747 + 128] and mem[_12747] > -1 / mem[_12747 + 96] + mem[_12747 + 128]:
                                                                                revert with 0, 17
                                                                            if not mem[_12747 + 96] + mem[_12747 + 128]:
                                                                                revert with 0, 18
                                                                            if (mem[_12747 + 96] * mem[_12747]) + (mem[_12747 + 128] * mem[_12747]) / mem[_12747 + 96] + mem[_12747 + 128] != mem[_12747]:
                                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                                            if not (mem[_12747 + 96] * mem[_12747]) + (mem[_12747 + 128] * mem[_12747]):
                                                                                _13824 = mem[64]
                                                                                mem[64] = mem[64] + 64
                                                                                mem[_13824] = 26
                                                                                mem[_13824 + 32] = 'SafeMath: division by zero'
                                                                                if not _13113:
                                                                                    _14000 = mem[64]
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 26
                                                                                    idx = 0
                                                                                    while idx < 26:
                                                                                        mem[idx + _14000 + 68] = mem[_13824 + idx + 32]
                                                                                        idx = idx + 32
                                                                                        continue 
                                                                                    mem[_14000 + 94] = 0
                                                                                    revert with memory
                                                                                      from mem[64]
                                                                                       len _14000 + -mem[64] + 100
                                                                                _14480 = mem[64]
                                                                                mem[64] = mem[64] + 64
                                                                                mem[_14480] = 26
                                                                                mem[_14480 + 32] = 'SafeMath: division by zero'
                                                                                if _13112:
                                                                                    if t > !(0 / _13113 / _13112):
                                                                                        revert with 0, 17
                                                                                    if t + (0 / _13113 / _13112) < t:
                                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                                    if s == -1:
                                                                                        revert with 0, 17
                                                                                    s = s + 1
                                                                                    t = t + (0 / _13113 / _13112)
                                                                                    continue 
                                                                                _14678 = mem[64]
                                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                mem[mem[64] + 4] = 32
                                                                                mem[mem[64] + 36] = 26
                                                                                idx = 0
                                                                                while idx < 26:
                                                                                    mem[idx + _14678 + 68] = mem[_14480 + idx + 32]
                                                                                    idx = idx + 32
                                                                                    continue 
                                                                                mem[_14678 + 94] = 0
                                                                                revert with memory
                                                                                  from mem[64]
                                                                                   len _14678 + -mem[64] + 100
                                                                            if (mem[_12747 + 96] * mem[_12747]) + (mem[_12747 + 128] * mem[_12747]) and mem[_9139 + 64] > -1 / (mem[_12747 + 96] * mem[_12747]) + (mem[_12747 + 128] * mem[_12747]):
                                                                                revert with 0, 17
                                                                            if not (mem[_12747 + 96] * mem[_12747]) + (mem[_12747 + 128] * mem[_12747]):
                                                                                revert with 0, 18
                                                                            if (mem[_12747 + 96] * mem[_12747] * mem[_9139 + 64]) + (mem[_12747 + 128] * mem[_12747] * mem[_9139 + 64]) / (mem[_12747 + 96] * mem[_12747]) + (mem[_12747 + 128] * mem[_12747]) != mem[_9139 + 64]:
                                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                                            _14349 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_14349] = 26
                                                                            mem[_14349 + 32] = 'SafeMath: division by zero'
                                                                            if not _13113:
                                                                                _14479 = mem[64]
                                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                mem[mem[64] + 4] = 32
                                                                                mem[mem[64] + 36] = 26
                                                                                idx = 0
                                                                                while idx < 26:
                                                                                    mem[idx + _14479 + 68] = mem[_14349 + idx + 32]
                                                                                    idx = idx + 32
                                                                                    continue 
                                                                                mem[_14479 + 94] = 0
                                                                                revert with memory
                                                                                  from mem[64]
                                                                                   len _14479 + -mem[64] + 100
                                                                            _14951 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_14951] = 26
                                                                            mem[_14951 + 32] = 'SafeMath: division by zero'
                                                                            if _13112:
                                                                                if t > !((_13117 * _13115 * _13114) + (_13116 * _13115 * _13114) / _13113 / _13112):
                                                                                    revert with 0, 17
                                                                                if t + ((_13117 * _13115 * _13114) + (_13116 * _13115 * _13114) / _13113 / _13112) < t:
                                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                                if s == -1:
                                                                                    revert with 0, 17
                                                                                s = s + 1
                                                                                t = t + ((_13117 * _13115 * _13114) + (_13116 * _13115 * _13114) / _13113 / _13112)
                                                                                continue 
                                                                            _15118 = mem[64]
                                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                            mem[mem[64] + 4] = 32
                                                                            mem[mem[64] + 36] = 26
                                                                            idx = 0
                                                                            while idx < 26:
                                                                                mem[idx + _15118 + 68] = mem[_14951 + idx + 32]
                                                                                idx = idx + 32
                                                                                continue 
                                                                            mem[_15118 + 94] = 0
                                                                            revert with memory
                                                                              from mem[64]
                                                                               len _15118 + -mem[64] + 100
                                                                        if t >= mem[_8169 + 160]:
                                                                            _12666 = mem[_8169]
                                                                            staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                                                                                    gas gas_remaining wei
                                                                                   args sub_4c86259e[idx].field_0, Mask(128, 128, mem[_8169])
                                                                            mem[mem[64] len 352] = ext_call.return_data[0 len 352]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            _13247 = mem[64]
                                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                                            require return_data.size >= 352
                                                                            _13286 = mem[64]
                                                                            if mem[64] + 352 < mem[64] or mem[64] + 352 > test266151307():
                                                                                revert with 0, 65
                                                                            mem[64] = mem[64] + 352
                                                                            require mem[_13247] == Mask(128, 128, mem[_13247])
                                                                            mem[_13286] = mem[_13247]
                                                                            mem[_13286 + 32] = mem[_13247 + 32]
                                                                            mem[_13286 + 64] = mem[_13247 + 64]
                                                                            mem[_13286 + 96] = mem[_13247 + 96]
                                                                            require mem[_13247 + 128] < 5
                                                                            mem[_13286 + 128] = mem[_13247 + 128]
                                                                            mem[_13286 + 160] = mem[_13247 + 160]
                                                                            mem[_13286 + 192] = mem[_13247 + 192]
                                                                            mem[_13286 + 224] = mem[_13247 + 224]
                                                                            mem[_13286 + 256] = mem[_13247 + 256]
                                                                            mem[_13286 + 288] = mem[_13247 + 288]
                                                                            mem[_13286 + 320] = mem[_13247 + 320]
                                                                            if Mask(128, 128, mem[_13286]) != Mask(128, 128, _12666):
                                                                                revert with 0, 'Address does not contain stake with provided id'
                                                                            s = mem[_13286 + 192]
                                                                            t = 0
                                                                            while s < _8826 + _8825:
                                                                                staticcall sub_413c05c6Address.0x8ce1d9e4 with:
                                                                                        gas gas_remaining wei
                                                                                       args s
                                                                                mem[mem[64] len 160] = ext_call.return_data[0 len 160]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                _17123 = mem[64]
                                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                                require return_data.size >= 160
                                                                                _17207 = mem[64]
                                                                                if mem[64] + 160 > test266151307() or mem[64] + 160 < mem[64]:
                                                                                    revert with 0, 65
                                                                                mem[64] = mem[64] + 160
                                                                                mem[_17207] = mem[_17123]
                                                                                mem[_17207 + 32] = mem[_17123 + 32]
                                                                                mem[_17207 + 64] = mem[_17123 + 64]
                                                                                mem[_17207 + 96] = mem[_17123 + 96]
                                                                                mem[_17207 + 128] = mem[_17123 + 128]
                                                                                _17640 = mem[_17207 + 64]
                                                                                _17641 = mem[_17207 + 32]
                                                                                _17642 = mem[_13286 + 64]
                                                                                _17643 = mem[_17207]
                                                                                _17644 = mem[_17207 + 128]
                                                                                _17645 = mem[_17207 + 96]
                                                                                if mem[_17207 + 96] > !mem[_17207 + 128]:
                                                                                    revert with 0, 17
                                                                                if mem[_17207 + 96] + mem[_17207 + 128] < mem[_17207 + 96]:
                                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                                if not mem[_17207 + 96] + mem[_17207 + 128]:
                                                                                    _17841 = mem[64]
                                                                                    mem[64] = mem[64] + 64
                                                                                    mem[_17841] = 26
                                                                                    mem[_17841 + 32] = 'SafeMath: division by zero'
                                                                                    if not _17641:
                                                                                        _17900 = mem[64]
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 26
                                                                                        idx = 0
                                                                                        while idx < 26:
                                                                                            mem[idx + _17900 + 68] = mem[_17841 + idx + 32]
                                                                                            idx = idx + 32
                                                                                            continue 
                                                                                        mem[_17900 + 94] = 0
                                                                                        revert with memory
                                                                                          from mem[64]
                                                                                           len _17900 + -mem[64] + 100
                                                                                    _18073 = mem[64]
                                                                                    mem[64] = mem[64] + 64
                                                                                    mem[_18073] = 26
                                                                                    mem[_18073 + 32] = 'SafeMath: division by zero'
                                                                                    if _17640:
                                                                                        if t > !(0 / _17641 / _17640):
                                                                                            revert with 0, 17
                                                                                        if t + (0 / _17641 / _17640) < t:
                                                                                            revert with 0, 'SafeMath: addition overflow'
                                                                                        if s == -1:
                                                                                            revert with 0, 17
                                                                                        s = s + 1
                                                                                        t = t + (0 / _17641 / _17640)
                                                                                        continue 
                                                                                    _18174 = mem[64]
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 26
                                                                                    idx = 0
                                                                                    while idx < 26:
                                                                                        mem[idx + _18174 + 68] = mem[_18073 + idx + 32]
                                                                                        idx = idx + 32
                                                                                        continue 
                                                                                    mem[_18174 + 94] = 0
                                                                                    revert with memory
                                                                                      from mem[64]
                                                                                       len _18174 + -mem[64] + 100
                                                                                if mem[_17207 + 96] + mem[_17207 + 128] and mem[_17207] > -1 / mem[_17207 + 96] + mem[_17207 + 128]:
                                                                                    revert with 0, 17
                                                                                if not mem[_17207 + 96] + mem[_17207 + 128]:
                                                                                    revert with 0, 18
                                                                                if (mem[_17207 + 96] * mem[_17207]) + (mem[_17207 + 128] * mem[_17207]) / mem[_17207 + 96] + mem[_17207 + 128] != mem[_17207]:
                                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                                if not (mem[_17207 + 96] * mem[_17207]) + (mem[_17207 + 128] * mem[_17207]):
                                                                                    _17993 = mem[64]
                                                                                    mem[64] = mem[64] + 64
                                                                                    mem[_17993] = 26
                                                                                    mem[_17993 + 32] = 'SafeMath: division by zero'
                                                                                    if not _17641:
                                                                                        _18072 = mem[64]
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 26
                                                                                        idx = 0
                                                                                        while idx < 26:
                                                                                            mem[idx + _18072 + 68] = mem[_17993 + idx + 32]
                                                                                            idx = idx + 32
                                                                                            continue 
                                                                                        mem[_18072 + 94] = 0
                                                                                        revert with memory
                                                                                          from mem[64]
                                                                                           len _18072 + -mem[64] + 100
                                                                                    _18405 = mem[64]
                                                                                    mem[64] = mem[64] + 64
                                                                                    mem[_18405] = 26
                                                                                    mem[_18405 + 32] = 'SafeMath: division by zero'
                                                                                    if _17640:
                                                                                        if t > !(0 / _17641 / _17640):
                                                                                            revert with 0, 17
                                                                                        if t + (0 / _17641 / _17640) < t:
                                                                                            revert with 0, 'SafeMath: addition overflow'
                                                                                        if s == -1:
                                                                                            revert with 0, 17
                                                                                        s = s + 1
                                                                                        t = t + (0 / _17641 / _17640)
                                                                                        continue 
                                                                                    _18517 = mem[64]
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 26
                                                                                    idx = 0
                                                                                    while idx < 26:
                                                                                        mem[idx + _18517 + 68] = mem[_18405 + idx + 32]
                                                                                        idx = idx + 32
                                                                                        continue 
                                                                                    mem[_18517 + 94] = 0
                                                                                    revert with memory
                                                                                      from mem[64]
                                                                                       len _18517 + -mem[64] + 100
                                                                                if (mem[_17207 + 96] * mem[_17207]) + (mem[_17207 + 128] * mem[_17207]) and mem[_13286 + 64] > -1 / (mem[_17207 + 96] * mem[_17207]) + (mem[_17207 + 128] * mem[_17207]):
                                                                                    revert with 0, 17
                                                                                if not (mem[_17207 + 96] * mem[_17207]) + (mem[_17207 + 128] * mem[_17207]):
                                                                                    revert with 0, 18
                                                                                if (mem[_17207 + 96] * mem[_17207] * mem[_13286 + 64]) + (mem[_17207 + 128] * mem[_17207] * mem[_13286 + 64]) / (mem[_17207 + 96] * mem[_17207]) + (mem[_17207 + 128] * mem[_17207]) != mem[_13286 + 64]:
                                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                                _18295 = mem[64]
                                                                                mem[64] = mem[64] + 64
                                                                                mem[_18295] = 26
                                                                                mem[_18295 + 32] = 'SafeMath: division by zero'
                                                                                if not _17641:
                                                                                    _18404 = mem[64]
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 26
                                                                                    idx = 0
                                                                                    while idx < 26:
                                                                                        mem[idx + _18404 + 68] = mem[_18295 + idx + 32]
                                                                                        idx = idx + 32
                                                                                        continue 
                                                                                    mem[_18404 + 94] = 0
                                                                                    revert with memory
                                                                                      from mem[64]
                                                                                       len _18404 + -mem[64] + 100
                                                                                _18713 = mem[64]
                                                                                mem[64] = mem[64] + 64
                                                                                mem[_18713] = 26
                                                                                mem[_18713 + 32] = 'SafeMath: division by zero'
                                                                                if _17640:
                                                                                    if t > !((_17645 * _17643 * _17642) + (_17644 * _17643 * _17642) / _17641 / _17640):
                                                                                        revert with 0, 17
                                                                                    if t + ((_17645 * _17643 * _17642) + (_17644 * _17643 * _17642) / _17641 / _17640) < t:
                                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                                    if s == -1:
                                                                                        revert with 0, 17
                                                                                    s = s + 1
                                                                                    t = t + ((_17645 * _17643 * _17642) + (_17644 * _17643 * _17642) / _17641 / _17640)
                                                                                    continue 
                                                                                _18823 = mem[64]
                                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                mem[mem[64] + 4] = 32
                                                                                mem[mem[64] + 36] = 26
                                                                                idx = 0
                                                                                while idx < 26:
                                                                                    mem[idx + _18823 + 68] = mem[_18713 + idx + 32]
                                                                                    idx = idx + 32
                                                                                    continue 
                                                                                mem[_18823 + 94] = 0
                                                                                revert with memory
                                                                                  from mem[64]
                                                                                   len _18823 + -mem[64] + 100
                                                                            _17122 = mem[_8169 + 32]
                                                                            stor9[stor12[idx].field_0][Mask(128, 128, stor12[idx].field_256)] = 1
                                                                            mem[0] = idx
                                                                            mem[32] = 12
                                                                            if _17122 > !t:
                                                                                revert with 0, 17
                                                                            if _17122 + t < _17122:
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            if _17122 + t:
                                                                                if not _17122 + t:
                                                                                    _17824 = mem[64]
                                                                                    mem[64] = mem[64] + 64
                                                                                    mem[_17824] = 26
                                                                                    mem[_17824 + 32] = 'SafeMath: division by zero'
                                                                                    if not DENOMINATOR:
                                                                                        _17839 = mem[64]
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 26
                                                                                        idx = 0
                                                                                        while idx < 26:
                                                                                            mem[idx + _17839 + 68] = mem[_17824 + idx + 32]
                                                                                            idx = idx + 32
                                                                                            continue 
                                                                                        mem[_17839 + 94] = 0
                                                                                        revert with memory
                                                                                          from mem[64]
                                                                                           len _17839 + -mem[64] + 100
                                                                                    mem[mem[64] + 36] = 0 / DENOMINATOR
                                                                                    require ext_code.size(sub_76089ab4Address)
                                                                                    call sub_76089ab4Address.mintSupply(address arg1, uint256 arg2) with:
                                                                                         gas gas_remaining wei
                                                                                        args this.address, 0 / DENOMINATOR
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    require ext_code.size(sub_76089ab4Address)
                                                                                    call sub_76089ab4Address.createStake(uint256 arg1) with:
                                                                                         gas gas_remaining wei
                                                                                        args (0 / DENOMINATOR)
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    mem[mem[64] + 4] = this.address
                                                                                    staticcall sub_76089ab4Address.stakeCount(address arg1) with:
                                                                                            gas gas_remaining wei
                                                                                           args this.address
                                                                                    mem[mem[64]] = ext_call.return_data[0]
                                                                                    _18171 = mem[64]
                                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                                    require return_data.size >= 32
                                                                                    _18294 = mem[_18171]
                                                                                    if mem[_18171] < 1:
                                                                                        revert with 0, 17
                                                                                    _18574 = mem[64]
                                                                                    mem[mem[64] + 32] = address(this.address)
                                                                                    mem[mem[64] + 52] = _18294 - 1
                                                                                    mem[mem[64] + 84] = 0x100000000000000000000000000000000000000000000000000000000000000
                                                                                    _18575 = mem[64]
                                                                                    mem[mem[64]] = 53
                                                                                    mem[64] = mem[64] + 85
                                                                                    _18577 = sha3(mem[_18575 + 32 len mem[_18575]])
                                                                                    mem[_18574 + 89] = Mask(128, 128, sha3(mem[_18575 + 32 len mem[_18575]]))
                                                                                    mem[_18574 + 121] = sub_4c86259e[idx].field_0
                                                                                    require ext_code.size(sub_76089ab4Address)
                                                                                    call sub_76089ab4Address.moveStake(bytes16 arg1, address arg2) with:
                                                                                         gas gas_remaining wei
                                                                                        args Mask(128, 128, _18577), sub_4c86259e[idx].field_0
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    if sub_ab7789c0 == -1:
                                                                                        revert with 0, 17
                                                                                    sub_ab7789c0++
                                                                                    if 1 > !sub_1b385a01[stor12[idx].field_0]:
                                                                                        revert with 0, 17
                                                                                    mem[0] = sub_4c86259e[idx].field_0
                                                                                    mem[32] = 7
                                                                                    sub_1b385a01[stor12[idx].field_0]++
                                                                                    if sub_04b4a313 > !(0 / DENOMINATOR):
                                                                                        revert with 0, 17
                                                                                    if sub_04b4a313 + (0 / DENOMINATOR) < sub_04b4a313:
                                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                                    sub_04b4a313 += 0 / DENOMINATOR
                                                                                    mem[_18574 + 85] = 0 / DENOMINATOR
                                                                                    emit 0xdbcd8131: (0 / DENOMINATOR), sub_4c86259e[idx].field_0, Mask(128, 128, sub_4c86259e[idx].field_256), Mask(128, 128, _18577)
                                                                                else:
                                                                                    if _17122 + t and sub_d8830c7d > -1 / _17122 + t:
                                                                                        revert with 0, 17
                                                                                    if not _17122 + t:
                                                                                        revert with 0, 18
                                                                                    if (_17122 * sub_d8830c7d) + (t * sub_d8830c7d) / _17122 + t != sub_d8830c7d:
                                                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                                                    _17943 = mem[64]
                                                                                    mem[64] = mem[64] + 64
                                                                                    mem[_17943] = 26
                                                                                    mem[_17943 + 32] = 'SafeMath: division by zero'
                                                                                    if not DENOMINATOR:
                                                                                        _17992 = mem[64]
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 26
                                                                                        idx = 0
                                                                                        while idx < 26:
                                                                                            mem[idx + _17992 + 68] = mem[_17943 + idx + 32]
                                                                                            idx = idx + 32
                                                                                            continue 
                                                                                        mem[_17992 + 94] = 0
                                                                                        revert with memory
                                                                                          from mem[64]
                                                                                           len _17992 + -mem[64] + 100
                                                                                    mem[mem[64] + 36] = (_17122 * sub_d8830c7d) + (t * sub_d8830c7d) / DENOMINATOR
                                                                                    require ext_code.size(sub_76089ab4Address)
                                                                                    call sub_76089ab4Address.mintSupply(address arg1, uint256 arg2) with:
                                                                                         gas gas_remaining wei
                                                                                        args this.address, (_17122 * sub_d8830c7d) + (t * sub_d8830c7d) / DENOMINATOR
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    require ext_code.size(sub_76089ab4Address)
                                                                                    call sub_76089ab4Address.createStake(uint256 arg1) with:
                                                                                         gas gas_remaining wei
                                                                                        args ((_17122 * sub_d8830c7d) + (t * sub_d8830c7d) / DENOMINATOR)
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    mem[mem[64] + 4] = this.address
                                                                                    staticcall sub_76089ab4Address.stakeCount(address arg1) with:
                                                                                            gas gas_remaining wei
                                                                                           args this.address
                                                                                    mem[mem[64]] = ext_call.return_data[0]
                                                                                    _18515 = mem[64]
                                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                                    require return_data.size >= 32
                                                                                    _18626 = mem[_18515]
                                                                                    if mem[_18515] < 1:
                                                                                        revert with 0, 17
                                                                                    _18864 = mem[64]
                                                                                    mem[mem[64] + 32] = address(this.address)
                                                                                    mem[mem[64] + 52] = _18626 - 1
                                                                                    mem[mem[64] + 84] = 0x100000000000000000000000000000000000000000000000000000000000000
                                                                                    _18865 = mem[64]
                                                                                    mem[mem[64]] = 53
                                                                                    mem[64] = mem[64] + 85
                                                                                    _18867 = sha3(mem[_18865 + 32 len mem[_18865]])
                                                                                    mem[_18864 + 89] = Mask(128, 128, sha3(mem[_18865 + 32 len mem[_18865]]))
                                                                                    mem[_18864 + 121] = sub_4c86259e[idx].field_0
                                                                                    require ext_code.size(sub_76089ab4Address)
                                                                                    call sub_76089ab4Address.moveStake(bytes16 arg1, address arg2) with:
                                                                                         gas gas_remaining wei
                                                                                        args Mask(128, 128, _18867), sub_4c86259e[idx].field_0
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    if sub_ab7789c0 == -1:
                                                                                        revert with 0, 17
                                                                                    sub_ab7789c0++
                                                                                    if 1 > !sub_1b385a01[stor12[idx].field_0]:
                                                                                        revert with 0, 17
                                                                                    mem[0] = sub_4c86259e[idx].field_0
                                                                                    mem[32] = 7
                                                                                    sub_1b385a01[stor12[idx].field_0]++
                                                                                    if sub_04b4a313 > !((_17122 * sub_d8830c7d) + (t * sub_d8830c7d) / DENOMINATOR):
                                                                                        revert with 0, 17
                                                                                    if sub_04b4a313 + ((_17122 * sub_d8830c7d) + (t * sub_d8830c7d) / DENOMINATOR) < sub_04b4a313:
                                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                                    sub_04b4a313 += (_17122 * sub_d8830c7d) + (t * sub_d8830c7d) / DENOMINATOR
                                                                                    mem[_18864 + 85] = (_17122 * sub_d8830c7d) + (t * sub_d8830c7d) / DENOMINATOR
                                                                                    emit 0xdbcd8131: ((_17122 * sub_d8830c7d) + (t * sub_d8830c7d) / DENOMINATOR), sub_4c86259e[idx].field_0, Mask(128, 128, sub_4c86259e[idx].field_256), Mask(128, 128, _18867)
                                                                        else:
                                                                            _12667 = mem[_8169 + 160]
                                                                            _12746 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_12746] = 30
                                                                            mem[_12746 + 32] = 'SafeMath: subtraction overflow'
                                                                            if t > _12667:
                                                                                _13111 = mem[64]
                                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                mem[mem[64] + 4] = 32
                                                                                mem[mem[64] + 36] = 30
                                                                                idx = 0
                                                                                while idx < 30:
                                                                                    mem[idx + _13111 + 68] = mem[_12746 + idx + 32]
                                                                                    idx = idx + 32
                                                                                    continue 
                                                                                mem[_13111 + 98] = 0
                                                                                revert with memory
                                                                                  from mem[64]
                                                                                   len _13111 + -mem[64] + 100
                                                                            if _12667 < t:
                                                                                revert with 0, 17
                                                                            _13316 = mem[_8169]
                                                                            staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                                                                                    gas gas_remaining wei
                                                                                   args sub_4c86259e[idx].field_0, Mask(128, 128, mem[_8169])
                                                                            mem[mem[64] len 352] = ext_call.return_data[0 len 352]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            _13427 = mem[64]
                                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                                            require return_data.size >= 352
                                                                            _13479 = mem[64]
                                                                            if mem[64] + 352 < mem[64] or mem[64] + 352 > test266151307():
                                                                                revert with 0, 65
                                                                            mem[64] = mem[64] + 352
                                                                            require mem[_13427] == Mask(128, 128, mem[_13427])
                                                                            mem[_13479] = mem[_13427]
                                                                            mem[_13479 + 32] = mem[_13427 + 32]
                                                                            mem[_13479 + 64] = mem[_13427 + 64]
                                                                            mem[_13479 + 96] = mem[_13427 + 96]
                                                                            require mem[_13427 + 128] < 5
                                                                            mem[_13479 + 128] = mem[_13427 + 128]
                                                                            mem[_13479 + 160] = mem[_13427 + 160]
                                                                            mem[_13479 + 192] = mem[_13427 + 192]
                                                                            mem[_13479 + 224] = mem[_13427 + 224]
                                                                            mem[_13479 + 256] = mem[_13427 + 256]
                                                                            mem[_13479 + 288] = mem[_13427 + 288]
                                                                            mem[_13479 + 320] = mem[_13427 + 320]
                                                                            if Mask(128, 128, mem[_13479]) != Mask(128, 128, _13316):
                                                                                revert with 0, 'Address does not contain stake with provided id'
                                                                            s = mem[_13479 + 192]
                                                                            u = 0
                                                                            while s < _8826 + _8825:
                                                                                staticcall sub_413c05c6Address.0x8ce1d9e4 with:
                                                                                        gas gas_remaining wei
                                                                                       args s
                                                                                mem[mem[64] len 160] = ext_call.return_data[0 len 160]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                _17125 = mem[64]
                                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                                require return_data.size >= 160
                                                                                _17208 = mem[64]
                                                                                if mem[64] + 160 > test266151307() or mem[64] + 160 < mem[64]:
                                                                                    revert with 0, 65
                                                                                mem[64] = mem[64] + 160
                                                                                mem[_17208] = mem[_17125]
                                                                                mem[_17208 + 32] = mem[_17125 + 32]
                                                                                mem[_17208 + 64] = mem[_17125 + 64]
                                                                                mem[_17208 + 96] = mem[_17125 + 96]
                                                                                mem[_17208 + 128] = mem[_17125 + 128]
                                                                                _17646 = mem[_17208 + 64]
                                                                                _17647 = mem[_17208 + 32]
                                                                                _17648 = mem[_13479 + 64]
                                                                                _17649 = mem[_17208]
                                                                                _17650 = mem[_17208 + 128]
                                                                                _17651 = mem[_17208 + 96]
                                                                                if mem[_17208 + 96] > !mem[_17208 + 128]:
                                                                                    revert with 0, 17
                                                                                if mem[_17208 + 96] + mem[_17208 + 128] < mem[_17208 + 96]:
                                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                                if not mem[_17208 + 96] + mem[_17208 + 128]:
                                                                                    _17843 = mem[64]
                                                                                    mem[64] = mem[64] + 64
                                                                                    mem[_17843] = 26
                                                                                    mem[_17843 + 32] = 'SafeMath: division by zero'
                                                                                    if not _17647:
                                                                                        _17901 = mem[64]
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 26
                                                                                        idx = 0
                                                                                        while idx < 26:
                                                                                            mem[idx + _17901 + 68] = mem[_17843 + idx + 32]
                                                                                            idx = idx + 32
                                                                                            continue 
                                                                                        mem[_17901 + 94] = 0
                                                                                        revert with memory
                                                                                          from mem[64]
                                                                                           len _17901 + -mem[64] + 100
                                                                                    _18077 = mem[64]
                                                                                    mem[64] = mem[64] + 64
                                                                                    mem[_18077] = 26
                                                                                    mem[_18077 + 32] = 'SafeMath: division by zero'
                                                                                    if _17646:
                                                                                        if u > !(0 / _17647 / _17646):
                                                                                            revert with 0, 17
                                                                                        if u + (0 / _17647 / _17646) < u:
                                                                                            revert with 0, 'SafeMath: addition overflow'
                                                                                        if s == -1:
                                                                                            revert with 0, 17
                                                                                        s = s + 1
                                                                                        u = u + (0 / _17647 / _17646)
                                                                                        continue 
                                                                                    _18180 = mem[64]
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 26
                                                                                    idx = 0
                                                                                    while idx < 26:
                                                                                        mem[idx + _18180 + 68] = mem[_18077 + idx + 32]
                                                                                        idx = idx + 32
                                                                                        continue 
                                                                                    mem[_18180 + 94] = 0
                                                                                    revert with memory
                                                                                      from mem[64]
                                                                                       len _18180 + -mem[64] + 100
                                                                                if mem[_17208 + 96] + mem[_17208 + 128] and mem[_17208] > -1 / mem[_17208 + 96] + mem[_17208 + 128]:
                                                                                    revert with 0, 17
                                                                                if not mem[_17208 + 96] + mem[_17208 + 128]:
                                                                                    revert with 0, 18
                                                                                if (mem[_17208 + 96] * mem[_17208]) + (mem[_17208 + 128] * mem[_17208]) / mem[_17208 + 96] + mem[_17208 + 128] != mem[_17208]:
                                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                                if not (mem[_17208 + 96] * mem[_17208]) + (mem[_17208 + 128] * mem[_17208]):
                                                                                    _17996 = mem[64]
                                                                                    mem[64] = mem[64] + 64
                                                                                    mem[_17996] = 26
                                                                                    mem[_17996 + 32] = 'SafeMath: division by zero'
                                                                                    if not _17647:
                                                                                        _18076 = mem[64]
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 26
                                                                                        idx = 0
                                                                                        while idx < 26:
                                                                                            mem[idx + _18076 + 68] = mem[_17996 + idx + 32]
                                                                                            idx = idx + 32
                                                                                            continue 
                                                                                        mem[_18076 + 94] = 0
                                                                                        revert with memory
                                                                                          from mem[64]
                                                                                           len _18076 + -mem[64] + 100
                                                                                    _18410 = mem[64]
                                                                                    mem[64] = mem[64] + 64
                                                                                    mem[_18410] = 26
                                                                                    mem[_18410 + 32] = 'SafeMath: division by zero'
                                                                                    if _17646:
                                                                                        if u > !(0 / _17647 / _17646):
                                                                                            revert with 0, 17
                                                                                        if u + (0 / _17647 / _17646) < u:
                                                                                            revert with 0, 'SafeMath: addition overflow'
                                                                                        if s == -1:
                                                                                            revert with 0, 17
                                                                                        s = s + 1
                                                                                        u = u + (0 / _17647 / _17646)
                                                                                        continue 
                                                                                    _18522 = mem[64]
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 26
                                                                                    idx = 0
                                                                                    while idx < 26:
                                                                                        mem[idx + _18522 + 68] = mem[_18410 + idx + 32]
                                                                                        idx = idx + 32
                                                                                        continue 
                                                                                    mem[_18522 + 94] = 0
                                                                                    revert with memory
                                                                                      from mem[64]
                                                                                       len _18522 + -mem[64] + 100
                                                                                if (mem[_17208 + 96] * mem[_17208]) + (mem[_17208 + 128] * mem[_17208]) and mem[_13479 + 64] > -1 / (mem[_17208 + 96] * mem[_17208]) + (mem[_17208 + 128] * mem[_17208]):
                                                                                    revert with 0, 17
                                                                                if not (mem[_17208 + 96] * mem[_17208]) + (mem[_17208 + 128] * mem[_17208]):
                                                                                    revert with 0, 18
                                                                                if (mem[_17208 + 96] * mem[_17208] * mem[_13479 + 64]) + (mem[_17208 + 128] * mem[_17208] * mem[_13479 + 64]) / (mem[_17208 + 96] * mem[_17208]) + (mem[_17208 + 128] * mem[_17208]) != mem[_13479 + 64]:
                                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                                _18299 = mem[64]
                                                                                mem[64] = mem[64] + 64
                                                                                mem[_18299] = 26
                                                                                mem[_18299 + 32] = 'SafeMath: division by zero'
                                                                                if not _17647:
                                                                                    _18409 = mem[64]
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 26
                                                                                    idx = 0
                                                                                    while idx < 26:
                                                                                        mem[idx + _18409 + 68] = mem[_18299 + idx + 32]
                                                                                        idx = idx + 32
                                                                                        continue 
                                                                                    mem[_18409 + 94] = 0
                                                                                    revert with memory
                                                                                      from mem[64]
                                                                                       len _18409 + -mem[64] + 100
                                                                                _18717 = mem[64]
                                                                                mem[64] = mem[64] + 64
                                                                                mem[_18717] = 26
                                                                                mem[_18717 + 32] = 'SafeMath: division by zero'
                                                                                if _17646:
                                                                                    if u > !((_17651 * _17649 * _17648) + (_17650 * _17649 * _17648) / _17647 / _17646):
                                                                                        revert with 0, 17
                                                                                    if u + ((_17651 * _17649 * _17648) + (_17650 * _17649 * _17648) / _17647 / _17646) < u:
                                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                                    if s == -1:
                                                                                        revert with 0, 17
                                                                                    s = s + 1
                                                                                    u = u + ((_17651 * _17649 * _17648) + (_17650 * _17649 * _17648) / _17647 / _17646)
                                                                                    continue 
                                                                                _18826 = mem[64]
                                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                mem[mem[64] + 4] = 32
                                                                                mem[mem[64] + 36] = 26
                                                                                idx = 0
                                                                                while idx < 26:
                                                                                    mem[idx + _18826 + 68] = mem[_18717 + idx + 32]
                                                                                    idx = idx + 32
                                                                                    continue 
                                                                                mem[_18826 + 94] = 0
                                                                                revert with memory
                                                                                  from mem[64]
                                                                                   len _18826 + -mem[64] + 100
                                                                            _17124 = mem[_8169 + 32]
                                                                            if _12667 - t > !u:
                                                                                revert with 0, 17
                                                                            if u < 0:
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            stor9[stor12[idx].field_0][Mask(128, 128, stor12[idx].field_256)] = 1
                                                                            mem[0] = idx
                                                                            mem[32] = 12
                                                                            if _17124 > !(_12667 - t + u):
                                                                                revert with 0, 17
                                                                            if _17124 + _12667 - t + u < _17124:
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            if _17124 + _12667 - t + u:
                                                                                if not _17124 + _12667 - t + u:
                                                                                    _17946 = mem[64]
                                                                                    mem[64] = mem[64] + 64
                                                                                    mem[_17946] = 26
                                                                                    mem[_17946 + 32] = 'SafeMath: division by zero'
                                                                                    if not DENOMINATOR:
                                                                                        _17995 = mem[64]
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 26
                                                                                        idx = 0
                                                                                        while idx < 26:
                                                                                            mem[idx + _17995 + 68] = mem[_17946 + idx + 32]
                                                                                            idx = idx + 32
                                                                                            continue 
                                                                                        mem[_17995 + 94] = 0
                                                                                        revert with memory
                                                                                          from mem[64]
                                                                                           len _17995 + -mem[64] + 100
                                                                                    mem[mem[64] + 36] = 0 / DENOMINATOR
                                                                                    require ext_code.size(sub_76089ab4Address)
                                                                                    call sub_76089ab4Address.mintSupply(address arg1, uint256 arg2) with:
                                                                                         gas gas_remaining wei
                                                                                        args this.address, 0 / DENOMINATOR
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    require ext_code.size(sub_76089ab4Address)
                                                                                    call sub_76089ab4Address.createStake(uint256 arg1) with:
                                                                                         gas gas_remaining wei
                                                                                        args (0 / DENOMINATOR)
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    mem[mem[64] + 4] = this.address
                                                                                    staticcall sub_76089ab4Address.stakeCount(address arg1) with:
                                                                                            gas gas_remaining wei
                                                                                           args this.address
                                                                                    mem[mem[64]] = ext_call.return_data[0]
                                                                                    _18520 = mem[64]
                                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                                    require return_data.size >= 32
                                                                                    _18630 = mem[_18520]
                                                                                    if mem[_18520] < 1:
                                                                                        revert with 0, 17
                                                                                    _18869 = mem[64]
                                                                                    mem[mem[64] + 32] = address(this.address)
                                                                                    mem[mem[64] + 52] = _18630 - 1
                                                                                    mem[mem[64] + 84] = 0x100000000000000000000000000000000000000000000000000000000000000
                                                                                    _18870 = mem[64]
                                                                                    mem[mem[64]] = 53
                                                                                    mem[64] = mem[64] + 85
                                                                                    _18872 = sha3(mem[_18870 + 32 len mem[_18870]])
                                                                                    mem[_18869 + 89] = Mask(128, 128, sha3(mem[_18870 + 32 len mem[_18870]]))
                                                                                    mem[_18869 + 121] = sub_4c86259e[idx].field_0
                                                                                    require ext_code.size(sub_76089ab4Address)
                                                                                    call sub_76089ab4Address.moveStake(bytes16 arg1, address arg2) with:
                                                                                         gas gas_remaining wei
                                                                                        args Mask(128, 128, _18872), sub_4c86259e[idx].field_0
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    if sub_ab7789c0 == -1:
                                                                                        revert with 0, 17
                                                                                    sub_ab7789c0++
                                                                                    if 1 > !sub_1b385a01[stor12[idx].field_0]:
                                                                                        revert with 0, 17
                                                                                    mem[0] = sub_4c86259e[idx].field_0
                                                                                    mem[32] = 7
                                                                                    sub_1b385a01[stor12[idx].field_0]++
                                                                                    if sub_04b4a313 > !(0 / DENOMINATOR):
                                                                                        revert with 0, 17
                                                                                    if sub_04b4a313 + (0 / DENOMINATOR) < sub_04b4a313:
                                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                                    sub_04b4a313 += 0 / DENOMINATOR
                                                                                    mem[_18869 + 85] = 0 / DENOMINATOR
                                                                                    emit 0xdbcd8131: (0 / DENOMINATOR), sub_4c86259e[idx].field_0, Mask(128, 128, sub_4c86259e[idx].field_256), Mask(128, 128, _18872)
                                                                                else:
                                                                                    if _17124 + _12667 - t + u and sub_d8830c7d > -1 / _17124 + _12667 - t + u:
                                                                                        revert with 0, 17
                                                                                    if not _17124 + _12667 - t + u:
                                                                                        revert with 0, 18
                                                                                    if (_17124 * sub_d8830c7d) + (_12667 * sub_d8830c7d) - (t * sub_d8830c7d) + (u * sub_d8830c7d) / _17124 + _12667 - t + u != sub_d8830c7d:
                                                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                                                    _18176 = mem[64]
                                                                                    mem[64] = mem[64] + 64
                                                                                    mem[_18176] = 26
                                                                                    mem[_18176 + 32] = 'SafeMath: division by zero'
                                                                                    if not DENOMINATOR:
                                                                                        _18298 = mem[64]
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 26
                                                                                        idx = 0
                                                                                        while idx < 26:
                                                                                            mem[idx + _18298 + 68] = mem[_18176 + idx + 32]
                                                                                            idx = idx + 32
                                                                                            continue 
                                                                                        mem[_18298 + 94] = 0
                                                                                        revert with memory
                                                                                          from mem[64]
                                                                                           len _18298 + -mem[64] + 100
                                                                                    mem[mem[64] + 36] = (_17124 * sub_d8830c7d) + (_12667 * sub_d8830c7d) - (t * sub_d8830c7d) + (u * sub_d8830c7d) / DENOMINATOR
                                                                                    require ext_code.size(sub_76089ab4Address)
                                                                                    call sub_76089ab4Address.mintSupply(address arg1, uint256 arg2) with:
                                                                                         gas gas_remaining wei
                                                                                        args this.address, (_17124 * sub_d8830c7d) + (_12667 * sub_d8830c7d) - (t * sub_d8830c7d) + (u * sub_d8830c7d) / DENOMINATOR
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    require ext_code.size(sub_76089ab4Address)
                                                                                    call sub_76089ab4Address.createStake(uint256 arg1) with:
                                                                                         gas gas_remaining wei
                                                                                        args ((_17124 * sub_d8830c7d) + (_12667 * sub_d8830c7d) - (t * sub_d8830c7d) + (u * sub_d8830c7d) / DENOMINATOR)
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    mem[mem[64] + 4] = this.address
                                                                                    staticcall sub_76089ab4Address.stakeCount(address arg1) with:
                                                                                            gas gas_remaining wei
                                                                                           args this.address
                                                                                    mem[mem[64]] = ext_call.return_data[0]
                                                                                    _18825 = mem[64]
                                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                                    require return_data.size >= 32
                                                                                    _18915 = mem[_18825]
                                                                                    if mem[_18825] < 1:
                                                                                        revert with 0, 17
                                                                                    _19029 = mem[64]
                                                                                    mem[mem[64] + 32] = address(this.address)
                                                                                    mem[mem[64] + 52] = _18915 - 1
                                                                                    mem[mem[64] + 84] = 0x100000000000000000000000000000000000000000000000000000000000000
                                                                                    _19030 = mem[64]
                                                                                    mem[mem[64]] = 53
                                                                                    mem[64] = mem[64] + 85
                                                                                    _19032 = sha3(mem[_19030 + 32 len mem[_19030]])
                                                                                    mem[_19029 + 89] = Mask(128, 128, sha3(mem[_19030 + 32 len mem[_19030]]))
                                                                                    mem[_19029 + 121] = sub_4c86259e[idx].field_0
                                                                                    require ext_code.size(sub_76089ab4Address)
                                                                                    call sub_76089ab4Address.moveStake(bytes16 arg1, address arg2) with:
                                                                                         gas gas_remaining wei
                                                                                        args Mask(128, 128, _19032), sub_4c86259e[idx].field_0
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    if sub_ab7789c0 == -1:
                                                                                        revert with 0, 17
                                                                                    sub_ab7789c0++
                                                                                    if 1 > !sub_1b385a01[stor12[idx].field_0]:
                                                                                        revert with 0, 17
                                                                                    mem[0] = sub_4c86259e[idx].field_0
                                                                                    mem[32] = 7
                                                                                    sub_1b385a01[stor12[idx].field_0]++
                                                                                    if sub_04b4a313 > !((_17124 * sub_d8830c7d) + (_12667 * sub_d8830c7d) - (t * sub_d8830c7d) + (u * sub_d8830c7d) / DENOMINATOR):
                                                                                        revert with 0, 17
                                                                                    if sub_04b4a313 + ((_17124 * sub_d8830c7d) + (_12667 * sub_d8830c7d) - (t * sub_d8830c7d) + (u * sub_d8830c7d) / DENOMINATOR) < sub_04b4a313:
                                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                                    sub_04b4a313 += (_17124 * sub_d8830c7d) + (_12667 * sub_d8830c7d) - (t * sub_d8830c7d) + (u * sub_d8830c7d) / DENOMINATOR
                                                                                    mem[_19029 + 85] = (_17124 * sub_d8830c7d) + (_12667 * sub_d8830c7d) - (t * sub_d8830c7d) + (u * sub_d8830c7d) / DENOMINATOR
                                                                                    emit 0xdbcd8131: ((_17124 * sub_d8830c7d) + (_12667 * sub_d8830c7d) - (t * sub_d8830c7d) + (u * sub_d8830c7d) / DENOMINATOR), sub_4c86259e[idx].field_0, Mask(128, 128, sub_4c86259e[idx].field_256), Mask(128, 128, _19032)
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            continue 
                    else:
                        idx = arg1
                        while idx < sub_d3a8b1da:
                            mem[0] = Mask(128, 128, sub_4c86259e[idx].field_256)
                            mem[32] = sha3(sub_4c86259e[idx].field_0, 9)
                            if not stor9[stor12[idx].field_0][Mask(128, 128, stor12[idx].field_256)]:
                                mem[0] = idx
                                mem[32] = 12
                                if 1 > !sub_ed73481d:
                                    revert with 0, 17
                                _6813 = mem[64]
                                mem[64] = mem[64] + 352
                                mem[_6813] = 0
                                mem[_6813 + 32] = 0
                                mem[_6813 + 64] = 0
                                mem[_6813 + 96] = 0
                                mem[_6813 + 128] = 0
                                mem[_6813 + 160] = 0
                                mem[_6813 + 192] = 0
                                mem[_6813 + 224] = 0
                                mem[_6813 + 256] = 0
                                mem[_6813 + 288] = 0
                                mem[_6813 + 320] = 0
                                staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                                        gas gas_remaining wei
                                       args sub_4c86259e[idx].field_0, Mask(128, 128, sub_4c86259e[idx].field_256)
                                mem[mem[64] len 352] = ext_call.return_data[0 len 352]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _6877 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 352
                                _6947 = mem[64]
                                if mem[64] + 352 < mem[64] or mem[64] + 352 > test266151307():
                                    revert with 0, 65
                                mem[64] = mem[64] + 352
                                require mem[_6877] == Mask(128, 128, mem[_6877])
                                mem[_6947] = mem[_6877]
                                mem[_6947 + 32] = mem[_6877 + 32]
                                mem[_6947 + 64] = mem[_6877 + 64]
                                mem[_6947 + 96] = mem[_6877 + 96]
                                require mem[_6877 + 128] < 5
                                mem[_6947 + 128] = mem[_6877 + 128]
                                mem[_6947 + 160] = mem[_6877 + 160]
                                mem[_6947 + 192] = mem[_6877 + 192]
                                mem[_6947 + 224] = mem[_6877 + 224]
                                mem[_6947 + 256] = mem[_6877 + 256]
                                mem[_6947 + 288] = mem[_6877 + 288]
                                mem[_6947 + 320] = mem[_6877 + 320]
                                if Mask(128, 128, mem[_6947]) != Mask(128, 128, sub_4c86259e[idx].field_256):
                                    _7264 = mem[64]
                                    mem[64] = mem[64] + 96
                                    mem[_7264] = 46
                                    mem[_7264 + 32 len 46] = 0xfe53656e64657220646f6573206e6f7420636f6e7461696e207374616b6520776974682070726f76696465642069
                                    stor9[stor12[idx].field_0][Mask(128, 128, stor12[idx].field_256)] = 1
                                    mem[0] = idx
                                    mem[32] = 12
                                else:
                                    mem[0] = Mask(128, 128, sub_4c86259e[idx].field_256)
                                    mem[32] = sha3(sub_4c86259e[idx].field_0, 9)
                                    if stor9[stor12[idx].field_0][Mask(128, 128, stor12[idx].field_256)]:
                                        _7290 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_7290] = 32
                                        mem[_7290 + 32] = 'Stake has already been converted'
                                        stor9[stor12[idx].field_0][Mask(128, 128, stor12[idx].field_256)] = 1
                                        mem[0] = idx
                                        mem[32] = 12
                                    else:
                                        if mem[_6947 + 128] > 4:
                                            revert with 0, 33
                                        if mem[_6947 + 128] != 2:
                                            _7452 = mem[64]
                                            mem[64] = mem[64] + 96
                                            mem[_7452] = 44
                                            mem[_7452 + 32 len 44] = 0x795374616b65206973206f6e6c7920656c696769626c6520696620697420686173206265656e20636c6f7365
                                            stor9[stor12[idx].field_0][Mask(128, 128, stor12[idx].field_256)] = 1
                                            mem[0] = idx
                                            mem[32] = 12
                                        else:
                                            if mem[_6947 + 192] >= sub_be647a94:
                                                _7515 = mem[64]
                                                mem[64] = mem[64] + 128
                                                mem[_7515] = 65
                                                mem[_7515 + 32 len 65] = 0x645374616b65206973206f6e6c7920656c696769626c65206966206974207761732063726561746564207072696f7220746f2074686520637574206f6666206461
                                                stor9[stor12[idx].field_0][Mask(128, 128, stor12[idx].field_256)] = 1
                                                mem[0] = idx
                                                mem[32] = 12
                                            else:
                                                if mem[_6947 + 192] > !mem[_6947 + 224]:
                                                    revert with 0, 17
                                                if mem[_6947 + 192] + mem[_6947 + 224] < sub_be647a94:
                                                    _7726 = mem[64]
                                                    mem[64] = mem[64] + 128
                                                    mem[_7726] = 66
                                                    mem[_7726 + 32 len 66] = 0x645374616b65206973206f6e6c7920656c696769626c652069662069742077617320656e646564206f6e2074686520637574206f666620646179206f722061667465
                                                    stor9[stor12[idx].field_0][Mask(128, 128, stor12[idx].field_256)] = 1
                                                    mem[0] = idx
                                                    mem[32] = 12
                                                else:
                                                    _7725 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_7725] = 17
                                                    mem[_7725 + 32] = 'Stake is eligible' << 120
                                                    staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                                                            gas gas_remaining wei
                                                           args sub_4c86259e[idx].field_0, Mask(128, 128, sub_4c86259e[idx].field_256)
                                                    mem[mem[64] len 352] = ext_call.return_data[0 len 352]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _8061 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 352
                                                    _8170 = mem[64]
                                                    if mem[64] + 352 < mem[64] or mem[64] + 352 > test266151307():
                                                        revert with 0, 65
                                                    mem[64] = mem[64] + 352
                                                    require mem[_8061] == Mask(128, 128, mem[_8061])
                                                    mem[_8170] = mem[_8061]
                                                    mem[_8170 + 32] = mem[_8061 + 32]
                                                    mem[_8170 + 64] = mem[_8061 + 64]
                                                    mem[_8170 + 96] = mem[_8061 + 96]
                                                    require mem[_8061 + 128] < 5
                                                    mem[_8170 + 128] = mem[_8061 + 128]
                                                    mem[_8170 + 160] = mem[_8061 + 160]
                                                    mem[_8170 + 192] = mem[_8061 + 192]
                                                    mem[_8170 + 224] = mem[_8061 + 224]
                                                    mem[_8170 + 256] = mem[_8061 + 256]
                                                    mem[_8170 + 288] = mem[_8061 + 288]
                                                    mem[_8170 + 320] = mem[_8061 + 320]
                                                    if Mask(128, 128, mem[_8170]) != Mask(128, 128, sub_4c86259e[idx].field_256):
                                                        revert with 0, 'Address does not contain stake with provided id'
                                                    if mem[_8170 + 128] > 4:
                                                        revert with 0, 33
                                                    if mem[_8170 + 128] == 3:
                                                        stor9[stor12[idx].field_0][Mask(128, 128, stor12[idx].field_256)] = 1
                                                        mem[0] = idx
                                                        mem[32] = 12
                                                    else:
                                                        if mem[_8170 + 128] > 4:
                                                            revert with 0, 33
                                                        if mem[_8170 + 128] == 4:
                                                            stor9[stor12[idx].field_0][Mask(128, 128, stor12[idx].field_256)] = 1
                                                            mem[0] = idx
                                                            mem[32] = 12
                                                        else:
                                                            if mem[_8170 + 128] > 4:
                                                                revert with 0, 33
                                                            if mem[_8170 + 128] == 1:
                                                                stor9[stor12[idx].field_0][Mask(128, 128, stor12[idx].field_256)] = 1
                                                                mem[0] = idx
                                                                mem[32] = 12
                                                            else:
                                                                if mem[_8170 + 128] > 4:
                                                                    revert with 0, 33
                                                                if not mem[_8170 + 128]:
                                                                    _8833 = mem[_8170]
                                                                    staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                                                                            gas gas_remaining wei
                                                                           args sub_4c86259e[idx].field_0, Mask(128, 128, mem[_8170])
                                                                    mem[mem[64] len 352] = ext_call.return_data[0 len 352]
                                                                    if not ext_call.success:
                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                    _8951 = mem[64]
                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                    require return_data.size >= 352
                                                                    _9033 = mem[64]
                                                                    if mem[64] + 352 < mem[64] or mem[64] + 352 > test266151307():
                                                                        revert with 0, 65
                                                                    mem[64] = mem[64] + 352
                                                                    require mem[_8951] == Mask(128, 128, mem[_8951])
                                                                    mem[_9033] = mem[_8951]
                                                                    mem[_9033 + 32] = mem[_8951 + 32]
                                                                    mem[_9033 + 64] = mem[_8951 + 64]
                                                                    mem[_9033 + 96] = mem[_8951 + 96]
                                                                    require mem[_8951 + 128] < 5
                                                                    mem[_9033 + 128] = mem[_8951 + 128]
                                                                    mem[_9033 + 160] = mem[_8951 + 160]
                                                                    mem[_9033 + 192] = mem[_8951 + 192]
                                                                    mem[_9033 + 224] = mem[_8951 + 224]
                                                                    mem[_9033 + 256] = mem[_8951 + 256]
                                                                    mem[_9033 + 288] = mem[_8951 + 288]
                                                                    mem[_9033 + 320] = mem[_8951 + 320]
                                                                    if Mask(128, 128, mem[_9033]) != Mask(128, 128, _8833):
                                                                        revert with 0, 'Address does not contain stake with provided id'
                                                                    s = mem[_9033 + 192]
                                                                    t = 0
                                                                    while s < sub_ed73481d + 1:
                                                                        staticcall sub_413c05c6Address.0x8ce1d9e4 with:
                                                                                gas gas_remaining wei
                                                                               args s
                                                                        mem[mem[64] len 160] = ext_call.return_data[0 len 160]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        _12631 = mem[64]
                                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                                        require return_data.size >= 160
                                                                        _12755 = mem[64]
                                                                        if mem[64] + 160 > test266151307() or mem[64] + 160 < mem[64]:
                                                                            revert with 0, 65
                                                                        mem[64] = mem[64] + 160
                                                                        mem[_12755] = mem[_12631]
                                                                        mem[_12755 + 32] = mem[_12631 + 32]
                                                                        mem[_12755 + 64] = mem[_12631 + 64]
                                                                        mem[_12755 + 96] = mem[_12631 + 96]
                                                                        mem[_12755 + 128] = mem[_12631 + 128]
                                                                        _13140 = mem[_12755 + 64]
                                                                        _13141 = mem[_12755 + 32]
                                                                        _13142 = mem[_9033 + 64]
                                                                        _13143 = mem[_12755]
                                                                        _13144 = mem[_12755 + 128]
                                                                        _13145 = mem[_12755 + 96]
                                                                        if mem[_12755 + 96] > !mem[_12755 + 128]:
                                                                            revert with 0, 17
                                                                        if mem[_12755 + 96] + mem[_12755 + 128] < mem[_12755 + 96]:
                                                                            revert with 0, 'SafeMath: addition overflow'
                                                                        if not mem[_12755 + 96] + mem[_12755 + 128]:
                                                                            _13581 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_13581] = 26
                                                                            mem[_13581 + 32] = 'SafeMath: division by zero'
                                                                            if not _13141:
                                                                                _13679 = mem[64]
                                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                mem[mem[64] + 4] = 32
                                                                                mem[mem[64] + 36] = 26
                                                                                idx = 0
                                                                                while idx < 26:
                                                                                    mem[idx + _13679 + 68] = mem[_13581 + idx + 32]
                                                                                    idx = idx + 32
                                                                                    continue 
                                                                                mem[_13679 + 94] = 0
                                                                                revert with memory
                                                                                  from mem[64]
                                                                                   len _13679 + -mem[64] + 100
                                                                            _14033 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_14033] = 26
                                                                            mem[_14033 + 32] = 'SafeMath: division by zero'
                                                                            if _13140:
                                                                                if t > !(0 / _13141 / _13140):
                                                                                    revert with 0, 17
                                                                                if t + (0 / _13141 / _13140) < t:
                                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                                if s == -1:
                                                                                    revert with 0, 17
                                                                                s = s + 1
                                                                                t = t + (0 / _13141 / _13140)
                                                                                continue 
                                                                            _14200 = mem[64]
                                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                            mem[mem[64] + 4] = 32
                                                                            mem[mem[64] + 36] = 26
                                                                            idx = 0
                                                                            while idx < 26:
                                                                                mem[idx + _14200 + 68] = mem[_14033 + idx + 32]
                                                                                idx = idx + 32
                                                                                continue 
                                                                            mem[_14200 + 94] = 0
                                                                            revert with memory
                                                                              from mem[64]
                                                                               len _14200 + -mem[64] + 100
                                                                        if mem[_12755 + 96] + mem[_12755 + 128] and mem[_12755] > -1 / mem[_12755 + 96] + mem[_12755 + 128]:
                                                                            revert with 0, 17
                                                                        if not mem[_12755 + 96] + mem[_12755 + 128]:
                                                                            revert with 0, 18
                                                                        if (mem[_12755 + 96] * mem[_12755]) + (mem[_12755 + 128] * mem[_12755]) / mem[_12755 + 96] + mem[_12755 + 128] != mem[_12755]:
                                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                                        if not (mem[_12755 + 96] * mem[_12755]) + (mem[_12755 + 128] * mem[_12755]):
                                                                            _13836 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_13836] = 26
                                                                            mem[_13836 + 32] = 'SafeMath: division by zero'
                                                                            if not _13141:
                                                                                _14032 = mem[64]
                                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                mem[mem[64] + 4] = 32
                                                                                mem[mem[64] + 36] = 26
                                                                                idx = 0
                                                                                while idx < 26:
                                                                                    mem[idx + _14032 + 68] = mem[_13836 + idx + 32]
                                                                                    idx = idx + 32
                                                                                    continue 
                                                                                mem[_14032 + 94] = 0
                                                                                revert with memory
                                                                                  from mem[64]
                                                                                   len _14032 + -mem[64] + 100
                                                                            _14502 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_14502] = 26
                                                                            mem[_14502 + 32] = 'SafeMath: division by zero'
                                                                            if _13140:
                                                                                if t > !(0 / _13141 / _13140):
                                                                                    revert with 0, 17
                                                                                if t + (0 / _13141 / _13140) < t:
                                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                                if s == -1:
                                                                                    revert with 0, 17
                                                                                s = s + 1
                                                                                t = t + (0 / _13141 / _13140)
                                                                                continue 
                                                                            _14706 = mem[64]
                                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                            mem[mem[64] + 4] = 32
                                                                            mem[mem[64] + 36] = 26
                                                                            idx = 0
                                                                            while idx < 26:
                                                                                mem[idx + _14706 + 68] = mem[_14502 + idx + 32]
                                                                                idx = idx + 32
                                                                                continue 
                                                                            mem[_14706 + 94] = 0
                                                                            revert with memory
                                                                              from mem[64]
                                                                               len _14706 + -mem[64] + 100
                                                                        if (mem[_12755 + 96] * mem[_12755]) + (mem[_12755 + 128] * mem[_12755]) and mem[_9033 + 64] > -1 / (mem[_12755 + 96] * mem[_12755]) + (mem[_12755 + 128] * mem[_12755]):
                                                                            revert with 0, 17
                                                                        if not (mem[_12755 + 96] * mem[_12755]) + (mem[_12755 + 128] * mem[_12755]):
                                                                            revert with 0, 18
                                                                        if (mem[_12755 + 96] * mem[_12755] * mem[_9033 + 64]) + (mem[_12755 + 128] * mem[_12755] * mem[_9033 + 64]) / (mem[_12755 + 96] * mem[_12755]) + (mem[_12755 + 128] * mem[_12755]) != mem[_9033 + 64]:
                                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                                        _14367 = mem[64]
                                                                        mem[64] = mem[64] + 64
                                                                        mem[_14367] = 26
                                                                        mem[_14367 + 32] = 'SafeMath: division by zero'
                                                                        if not _13141:
                                                                            _14501 = mem[64]
                                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                            mem[mem[64] + 4] = 32
                                                                            mem[mem[64] + 36] = 26
                                                                            idx = 0
                                                                            while idx < 26:
                                                                                mem[idx + _14501 + 68] = mem[_14367 + idx + 32]
                                                                                idx = idx + 32
                                                                                continue 
                                                                            mem[_14501 + 94] = 0
                                                                            revert with memory
                                                                              from mem[64]
                                                                               len _14501 + -mem[64] + 100
                                                                        _14965 = mem[64]
                                                                        mem[64] = mem[64] + 64
                                                                        mem[_14965] = 26
                                                                        mem[_14965 + 32] = 'SafeMath: division by zero'
                                                                        if _13140:
                                                                            if t > !((_13145 * _13143 * _13142) + (_13144 * _13143 * _13142) / _13141 / _13140):
                                                                                revert with 0, 17
                                                                            if t + ((_13145 * _13143 * _13142) + (_13144 * _13143 * _13142) / _13141 / _13140) < t:
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            if s == -1:
                                                                                revert with 0, 17
                                                                            s = s + 1
                                                                            t = t + ((_13145 * _13143 * _13142) + (_13144 * _13143 * _13142) / _13141 / _13140)
                                                                            continue 
                                                                        _15136 = mem[64]
                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                        mem[mem[64] + 4] = 32
                                                                        mem[mem[64] + 36] = 26
                                                                        idx = 0
                                                                        while idx < 26:
                                                                            mem[idx + _15136 + 68] = mem[_14965 + idx + 32]
                                                                            idx = idx + 32
                                                                            continue 
                                                                        mem[_15136 + 94] = 0
                                                                        revert with memory
                                                                          from mem[64]
                                                                           len _15136 + -mem[64] + 100
                                                                    _12629 = mem[_8170 + 32]
                                                                    _12630 = mem[_8170 + 160]
                                                                    if mem[_8170 + 160] > !t:
                                                                        revert with 0, 17
                                                                    if mem[_8170 + 160] + t < mem[_8170 + 160]:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    stor9[stor12[idx].field_0][Mask(128, 128, stor12[idx].field_256)] = 1
                                                                    mem[0] = idx
                                                                    mem[32] = 12
                                                                    if _12629 > !(_12630 + t):
                                                                        revert with 0, 17
                                                                    if _12629 + _12630 + t < _12629:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    if _12629 + _12630 + t:
                                                                        if not _12629 + _12630 + t:
                                                                            _13758 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_13758] = 26
                                                                            mem[_13758 + 32] = 'SafeMath: division by zero'
                                                                            if not DENOMINATOR:
                                                                                _13835 = mem[64]
                                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                mem[mem[64] + 4] = 32
                                                                                mem[mem[64] + 36] = 26
                                                                                idx = 0
                                                                                while idx < 26:
                                                                                    mem[idx + _13835 + 68] = mem[_13758 + idx + 32]
                                                                                    idx = idx + 32
                                                                                    continue 
                                                                                mem[_13835 + 94] = 0
                                                                                revert with memory
                                                                                  from mem[64]
                                                                                   len _13835 + -mem[64] + 100
                                                                            mem[mem[64] + 36] = 0 / DENOMINATOR
                                                                            require ext_code.size(sub_76089ab4Address)
                                                                            call sub_76089ab4Address.mintSupply(address arg1, uint256 arg2) with:
                                                                                 gas gas_remaining wei
                                                                                args this.address, 0 / DENOMINATOR
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            require ext_code.size(sub_76089ab4Address)
                                                                            call sub_76089ab4Address.createStake(uint256 arg1) with:
                                                                                 gas gas_remaining wei
                                                                                args (0 / DENOMINATOR)
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            mem[mem[64] + 4] = this.address
                                                                            staticcall sub_76089ab4Address.stakeCount(address arg1) with:
                                                                                    gas gas_remaining wei
                                                                                   args this.address
                                                                            mem[mem[64]] = ext_call.return_data[0]
                                                                            _14704 = mem[64]
                                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                                            require return_data.size >= 32
                                                                            _14862 = mem[_14704]
                                                                            if mem[_14704] < 1:
                                                                                revert with 0, 17
                                                                            _15203 = mem[64]
                                                                            mem[mem[64] + 32] = address(this.address)
                                                                            mem[mem[64] + 52] = _14862 - 1
                                                                            mem[mem[64] + 84] = 0x100000000000000000000000000000000000000000000000000000000000000
                                                                            _15204 = mem[64]
                                                                            mem[mem[64]] = 53
                                                                            mem[64] = mem[64] + 85
                                                                            _15206 = sha3(mem[_15204 + 32 len mem[_15204]])
                                                                            mem[_15203 + 89] = Mask(128, 128, sha3(mem[_15204 + 32 len mem[_15204]]))
                                                                            mem[_15203 + 121] = sub_4c86259e[idx].field_0
                                                                            require ext_code.size(sub_76089ab4Address)
                                                                            call sub_76089ab4Address.moveStake(bytes16 arg1, address arg2) with:
                                                                                 gas gas_remaining wei
                                                                                args Mask(128, 128, _15206), sub_4c86259e[idx].field_0
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            if sub_ab7789c0 == -1:
                                                                                revert with 0, 17
                                                                            sub_ab7789c0++
                                                                            if 1 > !sub_1b385a01[stor12[idx].field_0]:
                                                                                revert with 0, 17
                                                                            mem[0] = sub_4c86259e[idx].field_0
                                                                            mem[32] = 7
                                                                            sub_1b385a01[stor12[idx].field_0]++
                                                                            if sub_04b4a313 > !(0 / DENOMINATOR):
                                                                                revert with 0, 17
                                                                            if sub_04b4a313 + (0 / DENOMINATOR) < sub_04b4a313:
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            sub_04b4a313 += 0 / DENOMINATOR
                                                                            mem[_15203 + 85] = 0 / DENOMINATOR
                                                                            emit 0xdbcd8131: (0 / DENOMINATOR), sub_4c86259e[idx].field_0, Mask(128, 128, sub_4c86259e[idx].field_256), Mask(128, 128, _15206)
                                                                        else:
                                                                            if _12629 + _12630 + t and sub_d8830c7d > -1 / _12629 + _12630 + t:
                                                                                revert with 0, 17
                                                                            if not _12629 + _12630 + t:
                                                                                revert with 0, 18
                                                                            if (_12629 * sub_d8830c7d) + (_12630 * sub_d8830c7d) + (t * sub_d8830c7d) / _12629 + _12630 + t != sub_d8830c7d:
                                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                                            _14196 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_14196] = 26
                                                                            mem[_14196 + 32] = 'SafeMath: division by zero'
                                                                            if not DENOMINATOR:
                                                                                _14366 = mem[64]
                                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                mem[mem[64] + 4] = 32
                                                                                mem[mem[64] + 36] = 26
                                                                                idx = 0
                                                                                while idx < 26:
                                                                                    mem[idx + _14366 + 68] = mem[_14196 + idx + 32]
                                                                                    idx = idx + 32
                                                                                    continue 
                                                                                mem[_14366 + 94] = 0
                                                                                revert with memory
                                                                                  from mem[64]
                                                                                   len _14366 + -mem[64] + 100
                                                                            mem[mem[64] + 36] = (_12629 * sub_d8830c7d) + (_12630 * sub_d8830c7d) + (t * sub_d8830c7d) / DENOMINATOR
                                                                            require ext_code.size(sub_76089ab4Address)
                                                                            call sub_76089ab4Address.mintSupply(address arg1, uint256 arg2) with:
                                                                                 gas gas_remaining wei
                                                                                args this.address, (_12629 * sub_d8830c7d) + (_12630 * sub_d8830c7d) + (t * sub_d8830c7d) / DENOMINATOR
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            require ext_code.size(sub_76089ab4Address)
                                                                            call sub_76089ab4Address.createStake(uint256 arg1) with:
                                                                                 gas gas_remaining wei
                                                                                args ((_12629 * sub_d8830c7d) + (_12630 * sub_d8830c7d) + (t * sub_d8830c7d) / DENOMINATOR)
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            mem[mem[64] + 4] = this.address
                                                                            staticcall sub_76089ab4Address.stakeCount(address arg1) with:
                                                                                    gas gas_remaining wei
                                                                                   args this.address
                                                                            mem[mem[64]] = ext_call.return_data[0]
                                                                            _15135 = mem[64]
                                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                                            require return_data.size >= 32
                                                                            _15263 = mem[_15135]
                                                                            if mem[_15135] < 1:
                                                                                revert with 0, 17
                                                                            _15507 = mem[64]
                                                                            mem[mem[64] + 32] = address(this.address)
                                                                            mem[mem[64] + 52] = _15263 - 1
                                                                            mem[mem[64] + 84] = 0x100000000000000000000000000000000000000000000000000000000000000
                                                                            _15508 = mem[64]
                                                                            mem[mem[64]] = 53
                                                                            mem[64] = mem[64] + 85
                                                                            _15510 = sha3(mem[_15508 + 32 len mem[_15508]])
                                                                            mem[_15507 + 89] = Mask(128, 128, sha3(mem[_15508 + 32 len mem[_15508]]))
                                                                            mem[_15507 + 121] = sub_4c86259e[idx].field_0
                                                                            require ext_code.size(sub_76089ab4Address)
                                                                            call sub_76089ab4Address.moveStake(bytes16 arg1, address arg2) with:
                                                                                 gas gas_remaining wei
                                                                                args Mask(128, 128, _15510), sub_4c86259e[idx].field_0
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            if sub_ab7789c0 == -1:
                                                                                revert with 0, 17
                                                                            sub_ab7789c0++
                                                                            if 1 > !sub_1b385a01[stor12[idx].field_0]:
                                                                                revert with 0, 17
                                                                            mem[0] = sub_4c86259e[idx].field_0
                                                                            mem[32] = 7
                                                                            sub_1b385a01[stor12[idx].field_0]++
                                                                            if sub_04b4a313 > !((_12629 * sub_d8830c7d) + (_12630 * sub_d8830c7d) + (t * sub_d8830c7d) / DENOMINATOR):
                                                                                revert with 0, 17
                                                                            if sub_04b4a313 + ((_12629 * sub_d8830c7d) + (_12630 * sub_d8830c7d) + (t * sub_d8830c7d) / DENOMINATOR) < sub_04b4a313:
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            sub_04b4a313 += (_12629 * sub_d8830c7d) + (_12630 * sub_d8830c7d) + (t * sub_d8830c7d) / DENOMINATOR
                                                                            mem[_15507 + 85] = (_12629 * sub_d8830c7d) + (_12630 * sub_d8830c7d) + (t * sub_d8830c7d) / DENOMINATOR
                                                                            emit 0xdbcd8131: ((_12629 * sub_d8830c7d) + (_12630 * sub_d8830c7d) + (t * sub_d8830c7d) / DENOMINATOR), sub_4c86259e[idx].field_0, Mask(128, 128, sub_4c86259e[idx].field_256), Mask(128, 128, _15510)
                                                                else:
                                                                    _8831 = mem[_8170 + 224]
                                                                    _8832 = mem[_8170 + 192]
                                                                    if mem[_8170 + 192] > !mem[_8170 + 224]:
                                                                        revert with 0, 17
                                                                    if sub_ed73481d + 1 < mem[_8170 + 192] + mem[_8170 + 224]:
                                                                        _8980 = mem[_8170]
                                                                        staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                                                                                gas gas_remaining wei
                                                                               args sub_4c86259e[idx].field_0, Mask(128, 128, mem[_8170])
                                                                        mem[mem[64] len 352] = ext_call.return_data[0 len 352]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        _9082 = mem[64]
                                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                                        require return_data.size >= 352
                                                                        _9140 = mem[64]
                                                                        if mem[64] + 352 < mem[64] or mem[64] + 352 > test266151307():
                                                                            revert with 0, 65
                                                                        mem[64] = mem[64] + 352
                                                                        require mem[_9082] == Mask(128, 128, mem[_9082])
                                                                        mem[_9140] = mem[_9082]
                                                                        mem[_9140 + 32] = mem[_9082 + 32]
                                                                        mem[_9140 + 64] = mem[_9082 + 64]
                                                                        mem[_9140 + 96] = mem[_9082 + 96]
                                                                        require mem[_9082 + 128] < 5
                                                                        mem[_9140 + 128] = mem[_9082 + 128]
                                                                        mem[_9140 + 160] = mem[_9082 + 160]
                                                                        mem[_9140 + 192] = mem[_9082 + 192]
                                                                        mem[_9140 + 224] = mem[_9082 + 224]
                                                                        mem[_9140 + 256] = mem[_9082 + 256]
                                                                        mem[_9140 + 288] = mem[_9082 + 288]
                                                                        mem[_9140 + 320] = mem[_9082 + 320]
                                                                        if Mask(128, 128, mem[_9140]) != Mask(128, 128, _8980):
                                                                            revert with 0, 'Address does not contain stake with provided id'
                                                                        s = mem[_9140 + 192]
                                                                        t = 0
                                                                        while s < _8832 + _8831:
                                                                            staticcall sub_413c05c6Address.0x8ce1d9e4 with:
                                                                                    gas gas_remaining wei
                                                                                   args s
                                                                            mem[mem[64] len 160] = ext_call.return_data[0 len 160]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            _12626 = mem[64]
                                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                                            require return_data.size >= 160
                                                                            _12751 = mem[64]
                                                                            if mem[64] + 160 > test266151307() or mem[64] + 160 < mem[64]:
                                                                                revert with 0, 65
                                                                            mem[64] = mem[64] + 160
                                                                            mem[_12751] = mem[_12626]
                                                                            mem[_12751 + 32] = mem[_12626 + 32]
                                                                            mem[_12751 + 64] = mem[_12626 + 64]
                                                                            mem[_12751 + 96] = mem[_12626 + 96]
                                                                            mem[_12751 + 128] = mem[_12626 + 128]
                                                                            _13126 = mem[_12751 + 64]
                                                                            _13127 = mem[_12751 + 32]
                                                                            _13128 = mem[_9140 + 64]
                                                                            _13129 = mem[_12751]
                                                                            _13130 = mem[_12751 + 128]
                                                                            _13131 = mem[_12751 + 96]
                                                                            if mem[_12751 + 96] > !mem[_12751 + 128]:
                                                                                revert with 0, 17
                                                                            if mem[_12751 + 96] + mem[_12751 + 128] < mem[_12751 + 96]:
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            if not mem[_12751 + 96] + mem[_12751 + 128]:
                                                                                _13575 = mem[64]
                                                                                mem[64] = mem[64] + 64
                                                                                mem[_13575] = 26
                                                                                mem[_13575 + 32] = 'SafeMath: division by zero'
                                                                                if not _13127:
                                                                                    _13677 = mem[64]
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 26
                                                                                    idx = 0
                                                                                    while idx < 26:
                                                                                        mem[idx + _13677 + 68] = mem[_13575 + idx + 32]
                                                                                        idx = idx + 32
                                                                                        continue 
                                                                                    mem[_13677 + 94] = 0
                                                                                    revert with memory
                                                                                      from mem[64]
                                                                                       len _13677 + -mem[64] + 100
                                                                                _14017 = mem[64]
                                                                                mem[64] = mem[64] + 64
                                                                                mem[_14017] = 26
                                                                                mem[_14017 + 32] = 'SafeMath: division by zero'
                                                                                if _13126:
                                                                                    if t > !(0 / _13127 / _13126):
                                                                                        revert with 0, 17
                                                                                    if t + (0 / _13127 / _13126) < t:
                                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                                    if s == -1:
                                                                                        revert with 0, 17
                                                                                    s = s + 1
                                                                                    t = t + (0 / _13127 / _13126)
                                                                                    continue 
                                                                                _14190 = mem[64]
                                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                mem[mem[64] + 4] = 32
                                                                                mem[mem[64] + 36] = 26
                                                                                idx = 0
                                                                                while idx < 26:
                                                                                    mem[idx + _14190 + 68] = mem[_14017 + idx + 32]
                                                                                    idx = idx + 32
                                                                                    continue 
                                                                                mem[_14190 + 94] = 0
                                                                                revert with memory
                                                                                  from mem[64]
                                                                                   len _14190 + -mem[64] + 100
                                                                            if mem[_12751 + 96] + mem[_12751 + 128] and mem[_12751] > -1 / mem[_12751 + 96] + mem[_12751 + 128]:
                                                                                revert with 0, 17
                                                                            if not mem[_12751 + 96] + mem[_12751 + 128]:
                                                                                revert with 0, 18
                                                                            if (mem[_12751 + 96] * mem[_12751]) + (mem[_12751 + 128] * mem[_12751]) / mem[_12751 + 96] + mem[_12751 + 128] != mem[_12751]:
                                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                                            if not (mem[_12751 + 96] * mem[_12751]) + (mem[_12751 + 128] * mem[_12751]):
                                                                                _13830 = mem[64]
                                                                                mem[64] = mem[64] + 64
                                                                                mem[_13830] = 26
                                                                                mem[_13830 + 32] = 'SafeMath: division by zero'
                                                                                if not _13127:
                                                                                    _14016 = mem[64]
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 26
                                                                                    idx = 0
                                                                                    while idx < 26:
                                                                                        mem[idx + _14016 + 68] = mem[_13830 + idx + 32]
                                                                                        idx = idx + 32
                                                                                        continue 
                                                                                    mem[_14016 + 94] = 0
                                                                                    revert with memory
                                                                                      from mem[64]
                                                                                       len _14016 + -mem[64] + 100
                                                                                _14491 = mem[64]
                                                                                mem[64] = mem[64] + 64
                                                                                mem[_14491] = 26
                                                                                mem[_14491 + 32] = 'SafeMath: division by zero'
                                                                                if _13126:
                                                                                    if t > !(0 / _13127 / _13126):
                                                                                        revert with 0, 17
                                                                                    if t + (0 / _13127 / _13126) < t:
                                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                                    if s == -1:
                                                                                        revert with 0, 17
                                                                                    s = s + 1
                                                                                    t = t + (0 / _13127 / _13126)
                                                                                    continue 
                                                                                _14692 = mem[64]
                                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                mem[mem[64] + 4] = 32
                                                                                mem[mem[64] + 36] = 26
                                                                                idx = 0
                                                                                while idx < 26:
                                                                                    mem[idx + _14692 + 68] = mem[_14491 + idx + 32]
                                                                                    idx = idx + 32
                                                                                    continue 
                                                                                mem[_14692 + 94] = 0
                                                                                revert with memory
                                                                                  from mem[64]
                                                                                   len _14692 + -mem[64] + 100
                                                                            if (mem[_12751 + 96] * mem[_12751]) + (mem[_12751 + 128] * mem[_12751]) and mem[_9140 + 64] > -1 / (mem[_12751 + 96] * mem[_12751]) + (mem[_12751 + 128] * mem[_12751]):
                                                                                revert with 0, 17
                                                                            if not (mem[_12751 + 96] * mem[_12751]) + (mem[_12751 + 128] * mem[_12751]):
                                                                                revert with 0, 18
                                                                            if (mem[_12751 + 96] * mem[_12751] * mem[_9140 + 64]) + (mem[_12751 + 128] * mem[_12751] * mem[_9140 + 64]) / (mem[_12751 + 96] * mem[_12751]) + (mem[_12751 + 128] * mem[_12751]) != mem[_9140 + 64]:
                                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                                            _14358 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_14358] = 26
                                                                            mem[_14358 + 32] = 'SafeMath: division by zero'
                                                                            if not _13127:
                                                                                _14490 = mem[64]
                                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                mem[mem[64] + 4] = 32
                                                                                mem[mem[64] + 36] = 26
                                                                                idx = 0
                                                                                while idx < 26:
                                                                                    mem[idx + _14490 + 68] = mem[_14358 + idx + 32]
                                                                                    idx = idx + 32
                                                                                    continue 
                                                                                mem[_14490 + 94] = 0
                                                                                revert with memory
                                                                                  from mem[64]
                                                                                   len _14490 + -mem[64] + 100
                                                                            _14958 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_14958] = 26
                                                                            mem[_14958 + 32] = 'SafeMath: division by zero'
                                                                            if _13126:
                                                                                if t > !((_13131 * _13129 * _13128) + (_13130 * _13129 * _13128) / _13127 / _13126):
                                                                                    revert with 0, 17
                                                                                if t + ((_13131 * _13129 * _13128) + (_13130 * _13129 * _13128) / _13127 / _13126) < t:
                                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                                if s == -1:
                                                                                    revert with 0, 17
                                                                                s = s + 1
                                                                                t = t + ((_13131 * _13129 * _13128) + (_13130 * _13129 * _13128) / _13127 / _13126)
                                                                                continue 
                                                                            _15127 = mem[64]
                                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                            mem[mem[64] + 4] = 32
                                                                            mem[mem[64] + 36] = 26
                                                                            idx = 0
                                                                            while idx < 26:
                                                                                mem[idx + _15127 + 68] = mem[_14958 + idx + 32]
                                                                                idx = idx + 32
                                                                                continue 
                                                                            mem[_15127 + 94] = 0
                                                                            revert with memory
                                                                              from mem[64]
                                                                               len _15127 + -mem[64] + 100
                                                                        if t >= mem[_8170 + 160]:
                                                                            _12668 = mem[_8170]
                                                                            staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                                                                                    gas gas_remaining wei
                                                                                   args sub_4c86259e[idx].field_0, Mask(128, 128, mem[_8170])
                                                                            mem[mem[64] len 352] = ext_call.return_data[0 len 352]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            _13249 = mem[64]
                                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                                            require return_data.size >= 352
                                                                            _13288 = mem[64]
                                                                            if mem[64] + 352 < mem[64] or mem[64] + 352 > test266151307():
                                                                                revert with 0, 65
                                                                            mem[64] = mem[64] + 352
                                                                            require mem[_13249] == Mask(128, 128, mem[_13249])
                                                                            mem[_13288] = mem[_13249]
                                                                            mem[_13288 + 32] = mem[_13249 + 32]
                                                                            mem[_13288 + 64] = mem[_13249 + 64]
                                                                            mem[_13288 + 96] = mem[_13249 + 96]
                                                                            require mem[_13249 + 128] < 5
                                                                            mem[_13288 + 128] = mem[_13249 + 128]
                                                                            mem[_13288 + 160] = mem[_13249 + 160]
                                                                            mem[_13288 + 192] = mem[_13249 + 192]
                                                                            mem[_13288 + 224] = mem[_13249 + 224]
                                                                            mem[_13288 + 256] = mem[_13249 + 256]
                                                                            mem[_13288 + 288] = mem[_13249 + 288]
                                                                            mem[_13288 + 320] = mem[_13249 + 320]
                                                                            if Mask(128, 128, mem[_13288]) != Mask(128, 128, _12668):
                                                                                revert with 0, 'Address does not contain stake with provided id'
                                                                            s = mem[_13288 + 192]
                                                                            t = 0
                                                                            while s < sub_ed73481d + 1:
                                                                                staticcall sub_413c05c6Address.0x8ce1d9e4 with:
                                                                                        gas gas_remaining wei
                                                                                       args s
                                                                                mem[mem[64] len 160] = ext_call.return_data[0 len 160]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                _17127 = mem[64]
                                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                                require return_data.size >= 160
                                                                                _17224 = mem[64]
                                                                                if mem[64] + 160 > test266151307() or mem[64] + 160 < mem[64]:
                                                                                    revert with 0, 65
                                                                                mem[64] = mem[64] + 160
                                                                                mem[_17224] = mem[_17127]
                                                                                mem[_17224 + 32] = mem[_17127 + 32]
                                                                                mem[_17224 + 64] = mem[_17127 + 64]
                                                                                mem[_17224 + 96] = mem[_17127 + 96]
                                                                                mem[_17224 + 128] = mem[_17127 + 128]
                                                                                _17655 = mem[_17224 + 64]
                                                                                _17656 = mem[_17224 + 32]
                                                                                _17657 = mem[_13288 + 64]
                                                                                _17658 = mem[_17224]
                                                                                _17659 = mem[_17224 + 128]
                                                                                _17660 = mem[_17224 + 96]
                                                                                if mem[_17224 + 96] > !mem[_17224 + 128]:
                                                                                    revert with 0, 17
                                                                                if mem[_17224 + 96] + mem[_17224 + 128] < mem[_17224 + 96]:
                                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                                if not mem[_17224 + 96] + mem[_17224 + 128]:
                                                                                    _17846 = mem[64]
                                                                                    mem[64] = mem[64] + 64
                                                                                    mem[_17846] = 26
                                                                                    mem[_17846 + 32] = 'SafeMath: division by zero'
                                                                                    if not _17656:
                                                                                        _17904 = mem[64]
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 26
                                                                                        idx = 0
                                                                                        while idx < 26:
                                                                                            mem[idx + _17904 + 68] = mem[_17846 + idx + 32]
                                                                                            idx = idx + 32
                                                                                            continue 
                                                                                        mem[_17904 + 94] = 0
                                                                                        revert with memory
                                                                                          from mem[64]
                                                                                           len _17904 + -mem[64] + 100
                                                                                    _18081 = mem[64]
                                                                                    mem[64] = mem[64] + 64
                                                                                    mem[_18081] = 26
                                                                                    mem[_18081 + 32] = 'SafeMath: division by zero'
                                                                                    if _17655:
                                                                                        if t > !(0 / _17656 / _17655):
                                                                                            revert with 0, 17
                                                                                        if t + (0 / _17656 / _17655) < t:
                                                                                            revert with 0, 'SafeMath: addition overflow'
                                                                                        if s == -1:
                                                                                            revert with 0, 17
                                                                                        s = s + 1
                                                                                        t = t + (0 / _17656 / _17655)
                                                                                        continue 
                                                                                    _18186 = mem[64]
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 26
                                                                                    idx = 0
                                                                                    while idx < 26:
                                                                                        mem[idx + _18186 + 68] = mem[_18081 + idx + 32]
                                                                                        idx = idx + 32
                                                                                        continue 
                                                                                    mem[_18186 + 94] = 0
                                                                                    revert with memory
                                                                                      from mem[64]
                                                                                       len _18186 + -mem[64] + 100
                                                                                if mem[_17224 + 96] + mem[_17224 + 128] and mem[_17224] > -1 / mem[_17224 + 96] + mem[_17224 + 128]:
                                                                                    revert with 0, 17
                                                                                if not mem[_17224 + 96] + mem[_17224 + 128]:
                                                                                    revert with 0, 18
                                                                                if (mem[_17224 + 96] * mem[_17224]) + (mem[_17224 + 128] * mem[_17224]) / mem[_17224 + 96] + mem[_17224 + 128] != mem[_17224]:
                                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                                if not (mem[_17224 + 96] * mem[_17224]) + (mem[_17224 + 128] * mem[_17224]):
                                                                                    _17999 = mem[64]
                                                                                    mem[64] = mem[64] + 64
                                                                                    mem[_17999] = 26
                                                                                    mem[_17999 + 32] = 'SafeMath: division by zero'
                                                                                    if not _17656:
                                                                                        _18080 = mem[64]
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 26
                                                                                        idx = 0
                                                                                        while idx < 26:
                                                                                            mem[idx + _18080 + 68] = mem[_17999 + idx + 32]
                                                                                            idx = idx + 32
                                                                                            continue 
                                                                                        mem[_18080 + 94] = 0
                                                                                        revert with memory
                                                                                          from mem[64]
                                                                                           len _18080 + -mem[64] + 100
                                                                                    _18414 = mem[64]
                                                                                    mem[64] = mem[64] + 64
                                                                                    mem[_18414] = 26
                                                                                    mem[_18414 + 32] = 'SafeMath: division by zero'
                                                                                    if _17655:
                                                                                        if t > !(0 / _17656 / _17655):
                                                                                            revert with 0, 17
                                                                                        if t + (0 / _17656 / _17655) < t:
                                                                                            revert with 0, 'SafeMath: addition overflow'
                                                                                        if s == -1:
                                                                                            revert with 0, 17
                                                                                        s = s + 1
                                                                                        t = t + (0 / _17656 / _17655)
                                                                                        continue 
                                                                                    _18526 = mem[64]
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 26
                                                                                    idx = 0
                                                                                    while idx < 26:
                                                                                        mem[idx + _18526 + 68] = mem[_18414 + idx + 32]
                                                                                        idx = idx + 32
                                                                                        continue 
                                                                                    mem[_18526 + 94] = 0
                                                                                    revert with memory
                                                                                      from mem[64]
                                                                                       len _18526 + -mem[64] + 100
                                                                                if (mem[_17224 + 96] * mem[_17224]) + (mem[_17224 + 128] * mem[_17224]) and mem[_13288 + 64] > -1 / (mem[_17224 + 96] * mem[_17224]) + (mem[_17224 + 128] * mem[_17224]):
                                                                                    revert with 0, 17
                                                                                if not (mem[_17224 + 96] * mem[_17224]) + (mem[_17224 + 128] * mem[_17224]):
                                                                                    revert with 0, 18
                                                                                if (mem[_17224 + 96] * mem[_17224] * mem[_13288 + 64]) + (mem[_17224 + 128] * mem[_17224] * mem[_13288 + 64]) / (mem[_17224 + 96] * mem[_17224]) + (mem[_17224 + 128] * mem[_17224]) != mem[_13288 + 64]:
                                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                                _18303 = mem[64]
                                                                                mem[64] = mem[64] + 64
                                                                                mem[_18303] = 26
                                                                                mem[_18303 + 32] = 'SafeMath: division by zero'
                                                                                if not _17656:
                                                                                    _18413 = mem[64]
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 26
                                                                                    idx = 0
                                                                                    while idx < 26:
                                                                                        mem[idx + _18413 + 68] = mem[_18303 + idx + 32]
                                                                                        idx = idx + 32
                                                                                        continue 
                                                                                    mem[_18413 + 94] = 0
                                                                                    revert with memory
                                                                                      from mem[64]
                                                                                       len _18413 + -mem[64] + 100
                                                                                _18720 = mem[64]
                                                                                mem[64] = mem[64] + 64
                                                                                mem[_18720] = 26
                                                                                mem[_18720 + 32] = 'SafeMath: division by zero'
                                                                                if _17655:
                                                                                    if t > !((_17660 * _17658 * _17657) + (_17659 * _17658 * _17657) / _17656 / _17655):
                                                                                        revert with 0, 17
                                                                                    if t + ((_17660 * _17658 * _17657) + (_17659 * _17658 * _17657) / _17656 / _17655) < t:
                                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                                    if s == -1:
                                                                                        revert with 0, 17
                                                                                    s = s + 1
                                                                                    t = t + ((_17660 * _17658 * _17657) + (_17659 * _17658 * _17657) / _17656 / _17655)
                                                                                    continue 
                                                                                _18828 = mem[64]
                                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                mem[mem[64] + 4] = 32
                                                                                mem[mem[64] + 36] = 26
                                                                                idx = 0
                                                                                while idx < 26:
                                                                                    mem[idx + _18828 + 68] = mem[_18720 + idx + 32]
                                                                                    idx = idx + 32
                                                                                    continue 
                                                                                mem[_18828 + 94] = 0
                                                                                revert with memory
                                                                                  from mem[64]
                                                                                   len _18828 + -mem[64] + 100
                                                                            _17126 = mem[_8170 + 32]
                                                                            stor9[stor12[idx].field_0][Mask(128, 128, stor12[idx].field_256)] = 1
                                                                            mem[0] = idx
                                                                            mem[32] = 12
                                                                            if _17126 > !t:
                                                                                revert with 0, 17
                                                                            if _17126 + t < _17126:
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            if _17126 + t:
                                                                                if not _17126 + t:
                                                                                    _17826 = mem[64]
                                                                                    mem[64] = mem[64] + 64
                                                                                    mem[_17826] = 26
                                                                                    mem[_17826 + 32] = 'SafeMath: division by zero'
                                                                                    if not DENOMINATOR:
                                                                                        _17844 = mem[64]
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 26
                                                                                        idx = 0
                                                                                        while idx < 26:
                                                                                            mem[idx + _17844 + 68] = mem[_17826 + idx + 32]
                                                                                            idx = idx + 32
                                                                                            continue 
                                                                                        mem[_17844 + 94] = 0
                                                                                        revert with memory
                                                                                          from mem[64]
                                                                                           len _17844 + -mem[64] + 100
                                                                                    mem[mem[64] + 36] = 0 / DENOMINATOR
                                                                                    require ext_code.size(sub_76089ab4Address)
                                                                                    call sub_76089ab4Address.mintSupply(address arg1, uint256 arg2) with:
                                                                                         gas gas_remaining wei
                                                                                        args this.address, 0 / DENOMINATOR
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    require ext_code.size(sub_76089ab4Address)
                                                                                    call sub_76089ab4Address.createStake(uint256 arg1) with:
                                                                                         gas gas_remaining wei
                                                                                        args (0 / DENOMINATOR)
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    mem[mem[64] + 4] = this.address
                                                                                    staticcall sub_76089ab4Address.stakeCount(address arg1) with:
                                                                                            gas gas_remaining wei
                                                                                           args this.address
                                                                                    mem[mem[64]] = ext_call.return_data[0]
                                                                                    _18183 = mem[64]
                                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                                    require return_data.size >= 32
                                                                                    _18302 = mem[_18183]
                                                                                    if mem[_18183] < 1:
                                                                                        revert with 0, 17
                                                                                    _18582 = mem[64]
                                                                                    mem[mem[64] + 32] = address(this.address)
                                                                                    mem[mem[64] + 52] = _18302 - 1
                                                                                    mem[mem[64] + 84] = 0x100000000000000000000000000000000000000000000000000000000000000
                                                                                    _18583 = mem[64]
                                                                                    mem[mem[64]] = 53
                                                                                    mem[64] = mem[64] + 85
                                                                                    _18585 = sha3(mem[_18583 + 32 len mem[_18583]])
                                                                                    mem[_18582 + 89] = Mask(128, 128, sha3(mem[_18583 + 32 len mem[_18583]]))
                                                                                    mem[_18582 + 121] = sub_4c86259e[idx].field_0
                                                                                    require ext_code.size(sub_76089ab4Address)
                                                                                    call sub_76089ab4Address.moveStake(bytes16 arg1, address arg2) with:
                                                                                         gas gas_remaining wei
                                                                                        args Mask(128, 128, _18585), sub_4c86259e[idx].field_0
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    if sub_ab7789c0 == -1:
                                                                                        revert with 0, 17
                                                                                    sub_ab7789c0++
                                                                                    if 1 > !sub_1b385a01[stor12[idx].field_0]:
                                                                                        revert with 0, 17
                                                                                    mem[0] = sub_4c86259e[idx].field_0
                                                                                    mem[32] = 7
                                                                                    sub_1b385a01[stor12[idx].field_0]++
                                                                                    if sub_04b4a313 > !(0 / DENOMINATOR):
                                                                                        revert with 0, 17
                                                                                    if sub_04b4a313 + (0 / DENOMINATOR) < sub_04b4a313:
                                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                                    sub_04b4a313 += 0 / DENOMINATOR
                                                                                    mem[_18582 + 85] = 0 / DENOMINATOR
                                                                                    emit 0xdbcd8131: (0 / DENOMINATOR), sub_4c86259e[idx].field_0, Mask(128, 128, sub_4c86259e[idx].field_256), Mask(128, 128, _18585)
                                                                                else:
                                                                                    if _17126 + t and sub_d8830c7d > -1 / _17126 + t:
                                                                                        revert with 0, 17
                                                                                    if not _17126 + t:
                                                                                        revert with 0, 18
                                                                                    if (_17126 * sub_d8830c7d) + (t * sub_d8830c7d) / _17126 + t != sub_d8830c7d:
                                                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                                                    _17948 = mem[64]
                                                                                    mem[64] = mem[64] + 64
                                                                                    mem[_17948] = 26
                                                                                    mem[_17948 + 32] = 'SafeMath: division by zero'
                                                                                    if not DENOMINATOR:
                                                                                        _17998 = mem[64]
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 26
                                                                                        idx = 0
                                                                                        while idx < 26:
                                                                                            mem[idx + _17998 + 68] = mem[_17948 + idx + 32]
                                                                                            idx = idx + 32
                                                                                            continue 
                                                                                        mem[_17998 + 94] = 0
                                                                                        revert with memory
                                                                                          from mem[64]
                                                                                           len _17998 + -mem[64] + 100
                                                                                    mem[mem[64] + 36] = (_17126 * sub_d8830c7d) + (t * sub_d8830c7d) / DENOMINATOR
                                                                                    require ext_code.size(sub_76089ab4Address)
                                                                                    call sub_76089ab4Address.mintSupply(address arg1, uint256 arg2) with:
                                                                                         gas gas_remaining wei
                                                                                        args this.address, (_17126 * sub_d8830c7d) + (t * sub_d8830c7d) / DENOMINATOR
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    require ext_code.size(sub_76089ab4Address)
                                                                                    call sub_76089ab4Address.createStake(uint256 arg1) with:
                                                                                         gas gas_remaining wei
                                                                                        args ((_17126 * sub_d8830c7d) + (t * sub_d8830c7d) / DENOMINATOR)
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    mem[mem[64] + 4] = this.address
                                                                                    staticcall sub_76089ab4Address.stakeCount(address arg1) with:
                                                                                            gas gas_remaining wei
                                                                                           args this.address
                                                                                    mem[mem[64]] = ext_call.return_data[0]
                                                                                    _18524 = mem[64]
                                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                                    require return_data.size >= 32
                                                                                    _18634 = mem[_18524]
                                                                                    if mem[_18524] < 1:
                                                                                        revert with 0, 17
                                                                                    _18874 = mem[64]
                                                                                    mem[mem[64] + 32] = address(this.address)
                                                                                    mem[mem[64] + 52] = _18634 - 1
                                                                                    mem[mem[64] + 84] = 0x100000000000000000000000000000000000000000000000000000000000000
                                                                                    _18875 = mem[64]
                                                                                    mem[mem[64]] = 53
                                                                                    mem[64] = mem[64] + 85
                                                                                    _18877 = sha3(mem[_18875 + 32 len mem[_18875]])
                                                                                    mem[_18874 + 89] = Mask(128, 128, sha3(mem[_18875 + 32 len mem[_18875]]))
                                                                                    mem[_18874 + 121] = sub_4c86259e[idx].field_0
                                                                                    require ext_code.size(sub_76089ab4Address)
                                                                                    call sub_76089ab4Address.moveStake(bytes16 arg1, address arg2) with:
                                                                                         gas gas_remaining wei
                                                                                        args Mask(128, 128, _18877), sub_4c86259e[idx].field_0
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    if sub_ab7789c0 == -1:
                                                                                        revert with 0, 17
                                                                                    sub_ab7789c0++
                                                                                    if 1 > !sub_1b385a01[stor12[idx].field_0]:
                                                                                        revert with 0, 17
                                                                                    mem[0] = sub_4c86259e[idx].field_0
                                                                                    mem[32] = 7
                                                                                    sub_1b385a01[stor12[idx].field_0]++
                                                                                    if sub_04b4a313 > !((_17126 * sub_d8830c7d) + (t * sub_d8830c7d) / DENOMINATOR):
                                                                                        revert with 0, 17
                                                                                    if sub_04b4a313 + ((_17126 * sub_d8830c7d) + (t * sub_d8830c7d) / DENOMINATOR) < sub_04b4a313:
                                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                                    sub_04b4a313 += (_17126 * sub_d8830c7d) + (t * sub_d8830c7d) / DENOMINATOR
                                                                                    mem[_18874 + 85] = (_17126 * sub_d8830c7d) + (t * sub_d8830c7d) / DENOMINATOR
                                                                                    emit 0xdbcd8131: ((_17126 * sub_d8830c7d) + (t * sub_d8830c7d) / DENOMINATOR), sub_4c86259e[idx].field_0, Mask(128, 128, sub_4c86259e[idx].field_256), Mask(128, 128, _18877)
                                                                        else:
                                                                            _12669 = mem[_8170 + 160]
                                                                            _12750 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_12750] = 30
                                                                            mem[_12750 + 32] = 'SafeMath: subtraction overflow'
                                                                            if t > _12669:
                                                                                _13125 = mem[64]
                                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                mem[mem[64] + 4] = 32
                                                                                mem[mem[64] + 36] = 30
                                                                                idx = 0
                                                                                while idx < 30:
                                                                                    mem[idx + _13125 + 68] = mem[_12750 + idx + 32]
                                                                                    idx = idx + 32
                                                                                    continue 
                                                                                mem[_13125 + 98] = 0
                                                                                revert with memory
                                                                                  from mem[64]
                                                                                   len _13125 + -mem[64] + 100
                                                                            if _12669 < t:
                                                                                revert with 0, 17
                                                                            _13319 = mem[_8170]
                                                                            staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                                                                                    gas gas_remaining wei
                                                                                   args sub_4c86259e[idx].field_0, Mask(128, 128, mem[_8170])
                                                                            mem[mem[64] len 352] = ext_call.return_data[0 len 352]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            _13428 = mem[64]
                                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                                            require return_data.size >= 352
                                                                            _13482 = mem[64]
                                                                            if mem[64] + 352 < mem[64] or mem[64] + 352 > test266151307():
                                                                                revert with 0, 65
                                                                            mem[64] = mem[64] + 352
                                                                            require mem[_13428] == Mask(128, 128, mem[_13428])
                                                                            mem[_13482] = mem[_13428]
                                                                            mem[_13482 + 32] = mem[_13428 + 32]
                                                                            mem[_13482 + 64] = mem[_13428 + 64]
                                                                            mem[_13482 + 96] = mem[_13428 + 96]
                                                                            require mem[_13428 + 128] < 5
                                                                            mem[_13482 + 128] = mem[_13428 + 128]
                                                                            mem[_13482 + 160] = mem[_13428 + 160]
                                                                            mem[_13482 + 192] = mem[_13428 + 192]
                                                                            mem[_13482 + 224] = mem[_13428 + 224]
                                                                            mem[_13482 + 256] = mem[_13428 + 256]
                                                                            mem[_13482 + 288] = mem[_13428 + 288]
                                                                            mem[_13482 + 320] = mem[_13428 + 320]
                                                                            if Mask(128, 128, mem[_13482]) != Mask(128, 128, _13319):
                                                                                revert with 0, 'Address does not contain stake with provided id'
                                                                            s = mem[_13482 + 192]
                                                                            u = 0
                                                                            while s < sub_ed73481d + 1:
                                                                                staticcall sub_413c05c6Address.0x8ce1d9e4 with:
                                                                                        gas gas_remaining wei
                                                                                       args s
                                                                                mem[mem[64] len 160] = ext_call.return_data[0 len 160]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                _17129 = mem[64]
                                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                                require return_data.size >= 160
                                                                                _17225 = mem[64]
                                                                                if mem[64] + 160 > test266151307() or mem[64] + 160 < mem[64]:
                                                                                    revert with 0, 65
                                                                                mem[64] = mem[64] + 160
                                                                                mem[_17225] = mem[_17129]
                                                                                mem[_17225 + 32] = mem[_17129 + 32]
                                                                                mem[_17225 + 64] = mem[_17129 + 64]
                                                                                mem[_17225 + 96] = mem[_17129 + 96]
                                                                                mem[_17225 + 128] = mem[_17129 + 128]
                                                                                _17661 = mem[_17225 + 64]
                                                                                _17662 = mem[_17225 + 32]
                                                                                _17663 = mem[_13482 + 64]
                                                                                _17664 = mem[_17225]
                                                                                _17665 = mem[_17225 + 128]
                                                                                _17666 = mem[_17225 + 96]
                                                                                if mem[_17225 + 96] > !mem[_17225 + 128]:
                                                                                    revert with 0, 17
                                                                                if mem[_17225 + 96] + mem[_17225 + 128] < mem[_17225 + 96]:
                                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                                if not mem[_17225 + 96] + mem[_17225 + 128]:
                                                                                    _17848 = mem[64]
                                                                                    mem[64] = mem[64] + 64
                                                                                    mem[_17848] = 26
                                                                                    mem[_17848 + 32] = 'SafeMath: division by zero'
                                                                                    if not _17662:
                                                                                        _17905 = mem[64]
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 26
                                                                                        idx = 0
                                                                                        while idx < 26:
                                                                                            mem[idx + _17905 + 68] = mem[_17848 + idx + 32]
                                                                                            idx = idx + 32
                                                                                            continue 
                                                                                        mem[_17905 + 94] = 0
                                                                                        revert with memory
                                                                                          from mem[64]
                                                                                           len _17905 + -mem[64] + 100
                                                                                    _18085 = mem[64]
                                                                                    mem[64] = mem[64] + 64
                                                                                    mem[_18085] = 26
                                                                                    mem[_18085 + 32] = 'SafeMath: division by zero'
                                                                                    if _17661:
                                                                                        if u > !(0 / _17662 / _17661):
                                                                                            revert with 0, 17
                                                                                        if u + (0 / _17662 / _17661) < u:
                                                                                            revert with 0, 'SafeMath: addition overflow'
                                                                                        if s == -1:
                                                                                            revert with 0, 17
                                                                                        s = s + 1
                                                                                        u = u + (0 / _17662 / _17661)
                                                                                        continue 
                                                                                    _18192 = mem[64]
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 26
                                                                                    idx = 0
                                                                                    while idx < 26:
                                                                                        mem[idx + _18192 + 68] = mem[_18085 + idx + 32]
                                                                                        idx = idx + 32
                                                                                        continue 
                                                                                    mem[_18192 + 94] = 0
                                                                                    revert with memory
                                                                                      from mem[64]
                                                                                       len _18192 + -mem[64] + 100
                                                                                if mem[_17225 + 96] + mem[_17225 + 128] and mem[_17225] > -1 / mem[_17225 + 96] + mem[_17225 + 128]:
                                                                                    revert with 0, 17
                                                                                if not mem[_17225 + 96] + mem[_17225 + 128]:
                                                                                    revert with 0, 18
                                                                                if (mem[_17225 + 96] * mem[_17225]) + (mem[_17225 + 128] * mem[_17225]) / mem[_17225 + 96] + mem[_17225 + 128] != mem[_17225]:
                                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                                if not (mem[_17225 + 96] * mem[_17225]) + (mem[_17225 + 128] * mem[_17225]):
                                                                                    _18002 = mem[64]
                                                                                    mem[64] = mem[64] + 64
                                                                                    mem[_18002] = 26
                                                                                    mem[_18002 + 32] = 'SafeMath: division by zero'
                                                                                    if not _17662:
                                                                                        _18084 = mem[64]
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 26
                                                                                        idx = 0
                                                                                        while idx < 26:
                                                                                            mem[idx + _18084 + 68] = mem[_18002 + idx + 32]
                                                                                            idx = idx + 32
                                                                                            continue 
                                                                                        mem[_18084 + 94] = 0
                                                                                        revert with memory
                                                                                          from mem[64]
                                                                                           len _18084 + -mem[64] + 100
                                                                                    _18419 = mem[64]
                                                                                    mem[64] = mem[64] + 64
                                                                                    mem[_18419] = 26
                                                                                    mem[_18419 + 32] = 'SafeMath: division by zero'
                                                                                    if _17661:
                                                                                        if u > !(0 / _17662 / _17661):
                                                                                            revert with 0, 17
                                                                                        if u + (0 / _17662 / _17661) < u:
                                                                                            revert with 0, 'SafeMath: addition overflow'
                                                                                        if s == -1:
                                                                                            revert with 0, 17
                                                                                        s = s + 1
                                                                                        u = u + (0 / _17662 / _17661)
                                                                                        continue 
                                                                                    _18531 = mem[64]
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 26
                                                                                    idx = 0
                                                                                    while idx < 26:
                                                                                        mem[idx + _18531 + 68] = mem[_18419 + idx + 32]
                                                                                        idx = idx + 32
                                                                                        continue 
                                                                                    mem[_18531 + 94] = 0
                                                                                    revert with memory
                                                                                      from mem[64]
                                                                                       len _18531 + -mem[64] + 100
                                                                                if (mem[_17225 + 96] * mem[_17225]) + (mem[_17225 + 128] * mem[_17225]) and mem[_13482 + 64] > -1 / (mem[_17225 + 96] * mem[_17225]) + (mem[_17225 + 128] * mem[_17225]):
                                                                                    revert with 0, 17
                                                                                if not (mem[_17225 + 96] * mem[_17225]) + (mem[_17225 + 128] * mem[_17225]):
                                                                                    revert with 0, 18
                                                                                if (mem[_17225 + 96] * mem[_17225] * mem[_13482 + 64]) + (mem[_17225 + 128] * mem[_17225] * mem[_13482 + 64]) / (mem[_17225 + 96] * mem[_17225]) + (mem[_17225 + 128] * mem[_17225]) != mem[_13482 + 64]:
                                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                                _18307 = mem[64]
                                                                                mem[64] = mem[64] + 64
                                                                                mem[_18307] = 26
                                                                                mem[_18307 + 32] = 'SafeMath: division by zero'
                                                                                if not _17662:
                                                                                    _18418 = mem[64]
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 26
                                                                                    idx = 0
                                                                                    while idx < 26:
                                                                                        mem[idx + _18418 + 68] = mem[_18307 + idx + 32]
                                                                                        idx = idx + 32
                                                                                        continue 
                                                                                    mem[_18418 + 94] = 0
                                                                                    revert with memory
                                                                                      from mem[64]
                                                                                       len _18418 + -mem[64] + 100
                                                                                _18724 = mem[64]
                                                                                mem[64] = mem[64] + 64
                                                                                mem[_18724] = 26
                                                                                mem[_18724 + 32] = 'SafeMath: division by zero'
                                                                                if _17661:
                                                                                    if u > !((_17666 * _17664 * _17663) + (_17665 * _17664 * _17663) / _17662 / _17661):
                                                                                        revert with 0, 17
                                                                                    if u + ((_17666 * _17664 * _17663) + (_17665 * _17664 * _17663) / _17662 / _17661) < u:
                                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                                    if s == -1:
                                                                                        revert with 0, 17
                                                                                    s = s + 1
                                                                                    u = u + ((_17666 * _17664 * _17663) + (_17665 * _17664 * _17663) / _17662 / _17661)
                                                                                    continue 
                                                                                _18831 = mem[64]
                                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                mem[mem[64] + 4] = 32
                                                                                mem[mem[64] + 36] = 26
                                                                                idx = 0
                                                                                while idx < 26:
                                                                                    mem[idx + _18831 + 68] = mem[_18724 + idx + 32]
                                                                                    idx = idx + 32
                                                                                    continue 
                                                                                mem[_18831 + 94] = 0
                                                                                revert with memory
                                                                                  from mem[64]
                                                                                   len _18831 + -mem[64] + 100
                                                                            _17128 = mem[_8170 + 32]
                                                                            if _12669 - t > !u:
                                                                                revert with 0, 17
                                                                            if u < 0:
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            stor9[stor12[idx].field_0][Mask(128, 128, stor12[idx].field_256)] = 1
                                                                            mem[0] = idx
                                                                            mem[32] = 12
                                                                            if _17128 > !(_12669 - t + u):
                                                                                revert with 0, 17
                                                                            if _17128 + _12669 - t + u < _17128:
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            if _17128 + _12669 - t + u:
                                                                                if not _17128 + _12669 - t + u:
                                                                                    _17951 = mem[64]
                                                                                    mem[64] = mem[64] + 64
                                                                                    mem[_17951] = 26
                                                                                    mem[_17951 + 32] = 'SafeMath: division by zero'
                                                                                    if not DENOMINATOR:
                                                                                        _18001 = mem[64]
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 26
                                                                                        idx = 0
                                                                                        while idx < 26:
                                                                                            mem[idx + _18001 + 68] = mem[_17951 + idx + 32]
                                                                                            idx = idx + 32
                                                                                            continue 
                                                                                        mem[_18001 + 94] = 0
                                                                                        revert with memory
                                                                                          from mem[64]
                                                                                           len _18001 + -mem[64] + 100
                                                                                    mem[mem[64] + 36] = 0 / DENOMINATOR
                                                                                    require ext_code.size(sub_76089ab4Address)
                                                                                    call sub_76089ab4Address.mintSupply(address arg1, uint256 arg2) with:
                                                                                         gas gas_remaining wei
                                                                                        args this.address, 0 / DENOMINATOR
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    require ext_code.size(sub_76089ab4Address)
                                                                                    call sub_76089ab4Address.createStake(uint256 arg1) with:
                                                                                         gas gas_remaining wei
                                                                                        args (0 / DENOMINATOR)
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    mem[mem[64] + 4] = this.address
                                                                                    staticcall sub_76089ab4Address.stakeCount(address arg1) with:
                                                                                            gas gas_remaining wei
                                                                                           args this.address
                                                                                    mem[mem[64]] = ext_call.return_data[0]
                                                                                    _18529 = mem[64]
                                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                                    require return_data.size >= 32
                                                                                    _18638 = mem[_18529]
                                                                                    if mem[_18529] < 1:
                                                                                        revert with 0, 17
                                                                                    _18879 = mem[64]
                                                                                    mem[mem[64] + 32] = address(this.address)
                                                                                    mem[mem[64] + 52] = _18638 - 1
                                                                                    mem[mem[64] + 84] = 0x100000000000000000000000000000000000000000000000000000000000000
                                                                                    _18880 = mem[64]
                                                                                    mem[mem[64]] = 53
                                                                                    mem[64] = mem[64] + 85
                                                                                    _18882 = sha3(mem[_18880 + 32 len mem[_18880]])
                                                                                    mem[_18879 + 89] = Mask(128, 128, sha3(mem[_18880 + 32 len mem[_18880]]))
                                                                                    mem[_18879 + 121] = sub_4c86259e[idx].field_0
                                                                                    require ext_code.size(sub_76089ab4Address)
                                                                                    call sub_76089ab4Address.moveStake(bytes16 arg1, address arg2) with:
                                                                                         gas gas_remaining wei
                                                                                        args Mask(128, 128, _18882), sub_4c86259e[idx].field_0
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    if sub_ab7789c0 == -1:
                                                                                        revert with 0, 17
                                                                                    sub_ab7789c0++
                                                                                    if 1 > !sub_1b385a01[stor12[idx].field_0]:
                                                                                        revert with 0, 17
                                                                                    mem[0] = sub_4c86259e[idx].field_0
                                                                                    mem[32] = 7
                                                                                    sub_1b385a01[stor12[idx].field_0]++
                                                                                    if sub_04b4a313 > !(0 / DENOMINATOR):
                                                                                        revert with 0, 17
                                                                                    if sub_04b4a313 + (0 / DENOMINATOR) < sub_04b4a313:
                                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                                    sub_04b4a313 += 0 / DENOMINATOR
                                                                                    mem[_18879 + 85] = 0 / DENOMINATOR
                                                                                    emit 0xdbcd8131: (0 / DENOMINATOR), sub_4c86259e[idx].field_0, Mask(128, 128, sub_4c86259e[idx].field_256), Mask(128, 128, _18882)
                                                                                else:
                                                                                    if _17128 + _12669 - t + u and sub_d8830c7d > -1 / _17128 + _12669 - t + u:
                                                                                        revert with 0, 17
                                                                                    if not _17128 + _12669 - t + u:
                                                                                        revert with 0, 18
                                                                                    if (_17128 * sub_d8830c7d) + (_12669 * sub_d8830c7d) - (t * sub_d8830c7d) + (u * sub_d8830c7d) / _17128 + _12669 - t + u != sub_d8830c7d:
                                                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                                                    _18188 = mem[64]
                                                                                    mem[64] = mem[64] + 64
                                                                                    mem[_18188] = 26
                                                                                    mem[_18188 + 32] = 'SafeMath: division by zero'
                                                                                    if not DENOMINATOR:
                                                                                        _18306 = mem[64]
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 26
                                                                                        idx = 0
                                                                                        while idx < 26:
                                                                                            mem[idx + _18306 + 68] = mem[_18188 + idx + 32]
                                                                                            idx = idx + 32
                                                                                            continue 
                                                                                        mem[_18306 + 94] = 0
                                                                                        revert with memory
                                                                                          from mem[64]
                                                                                           len _18306 + -mem[64] + 100
                                                                                    mem[mem[64] + 36] = (_17128 * sub_d8830c7d) + (_12669 * sub_d8830c7d) - (t * sub_d8830c7d) + (u * sub_d8830c7d) / DENOMINATOR
                                                                                    require ext_code.size(sub_76089ab4Address)
                                                                                    call sub_76089ab4Address.mintSupply(address arg1, uint256 arg2) with:
                                                                                         gas gas_remaining wei
                                                                                        args this.address, (_17128 * sub_d8830c7d) + (_12669 * sub_d8830c7d) - (t * sub_d8830c7d) + (u * sub_d8830c7d) / DENOMINATOR
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    require ext_code.size(sub_76089ab4Address)
                                                                                    call sub_76089ab4Address.createStake(uint256 arg1) with:
                                                                                         gas gas_remaining wei
                                                                                        args ((_17128 * sub_d8830c7d) + (_12669 * sub_d8830c7d) - (t * sub_d8830c7d) + (u * sub_d8830c7d) / DENOMINATOR)
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    mem[mem[64] + 4] = this.address
                                                                                    staticcall sub_76089ab4Address.stakeCount(address arg1) with:
                                                                                            gas gas_remaining wei
                                                                                           args this.address
                                                                                    mem[mem[64]] = ext_call.return_data[0]
                                                                                    _18830 = mem[64]
                                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                                    require return_data.size >= 32
                                                                                    _18921 = mem[_18830]
                                                                                    if mem[_18830] < 1:
                                                                                        revert with 0, 17
                                                                                    _19035 = mem[64]
                                                                                    mem[mem[64] + 32] = address(this.address)
                                                                                    mem[mem[64] + 52] = _18921 - 1
                                                                                    mem[mem[64] + 84] = 0x100000000000000000000000000000000000000000000000000000000000000
                                                                                    _19036 = mem[64]
                                                                                    mem[mem[64]] = 53
                                                                                    mem[64] = mem[64] + 85
                                                                                    _19038 = sha3(mem[_19036 + 32 len mem[_19036]])
                                                                                    mem[_19035 + 89] = Mask(128, 128, sha3(mem[_19036 + 32 len mem[_19036]]))
                                                                                    mem[_19035 + 121] = sub_4c86259e[idx].field_0
                                                                                    require ext_code.size(sub_76089ab4Address)
                                                                                    call sub_76089ab4Address.moveStake(bytes16 arg1, address arg2) with:
                                                                                         gas gas_remaining wei
                                                                                        args Mask(128, 128, _19038), sub_4c86259e[idx].field_0
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    if sub_ab7789c0 == -1:
                                                                                        revert with 0, 17
                                                                                    sub_ab7789c0++
                                                                                    if 1 > !sub_1b385a01[stor12[idx].field_0]:
                                                                                        revert with 0, 17
                                                                                    mem[0] = sub_4c86259e[idx].field_0
                                                                                    mem[32] = 7
                                                                                    sub_1b385a01[stor12[idx].field_0]++
                                                                                    if sub_04b4a313 > !((_17128 * sub_d8830c7d) + (_12669 * sub_d8830c7d) - (t * sub_d8830c7d) + (u * sub_d8830c7d) / DENOMINATOR):
                                                                                        revert with 0, 17
                                                                                    if sub_04b4a313 + ((_17128 * sub_d8830c7d) + (_12669 * sub_d8830c7d) - (t * sub_d8830c7d) + (u * sub_d8830c7d) / DENOMINATOR) < sub_04b4a313:
                                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                                    sub_04b4a313 += (_17128 * sub_d8830c7d) + (_12669 * sub_d8830c7d) - (t * sub_d8830c7d) + (u * sub_d8830c7d) / DENOMINATOR
                                                                                    mem[_19035 + 85] = (_17128 * sub_d8830c7d) + (_12669 * sub_d8830c7d) - (t * sub_d8830c7d) + (u * sub_d8830c7d) / DENOMINATOR
                                                                                    emit 0xdbcd8131: ((_17128 * sub_d8830c7d) + (_12669 * sub_d8830c7d) - (t * sub_d8830c7d) + (u * sub_d8830c7d) / DENOMINATOR), sub_4c86259e[idx].field_0, Mask(128, 128, sub_4c86259e[idx].field_256), Mask(128, 128, _19038)
                                                                    else:
                                                                        _8981 = mem[_8170]
                                                                        staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                                                                                gas gas_remaining wei
                                                                               args sub_4c86259e[idx].field_0, Mask(128, 128, mem[_8170])
                                                                        mem[mem[64] len 352] = ext_call.return_data[0 len 352]
                                                                        if not ext_call.success:
                                                                            revert with ext_call.return_data[0 len return_data.size]
                                                                        _9083 = mem[64]
                                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                                        require return_data.size >= 352
                                                                        _9141 = mem[64]
                                                                        if mem[64] + 352 < mem[64] or mem[64] + 352 > test266151307():
                                                                            revert with 0, 65
                                                                        mem[64] = mem[64] + 352
                                                                        require mem[_9083] == Mask(128, 128, mem[_9083])
                                                                        mem[_9141] = mem[_9083]
                                                                        mem[_9141 + 32] = mem[_9083 + 32]
                                                                        mem[_9141 + 64] = mem[_9083 + 64]
                                                                        mem[_9141 + 96] = mem[_9083 + 96]
                                                                        require mem[_9083 + 128] < 5
                                                                        mem[_9141 + 128] = mem[_9083 + 128]
                                                                        mem[_9141 + 160] = mem[_9083 + 160]
                                                                        mem[_9141 + 192] = mem[_9083 + 192]
                                                                        mem[_9141 + 224] = mem[_9083 + 224]
                                                                        mem[_9141 + 256] = mem[_9083 + 256]
                                                                        mem[_9141 + 288] = mem[_9083 + 288]
                                                                        mem[_9141 + 320] = mem[_9083 + 320]
                                                                        if Mask(128, 128, mem[_9141]) != Mask(128, 128, _8981):
                                                                            revert with 0, 'Address does not contain stake with provided id'
                                                                        s = mem[_9141 + 192]
                                                                        t = 0
                                                                        while s < _8832 + _8831:
                                                                            staticcall sub_413c05c6Address.0x8ce1d9e4 with:
                                                                                    gas gas_remaining wei
                                                                                   args s
                                                                            mem[mem[64] len 160] = ext_call.return_data[0 len 160]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            _12628 = mem[64]
                                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                                            require return_data.size >= 160
                                                                            _12754 = mem[64]
                                                                            if mem[64] + 160 > test266151307() or mem[64] + 160 < mem[64]:
                                                                                revert with 0, 65
                                                                            mem[64] = mem[64] + 160
                                                                            mem[_12754] = mem[_12628]
                                                                            mem[_12754 + 32] = mem[_12628 + 32]
                                                                            mem[_12754 + 64] = mem[_12628 + 64]
                                                                            mem[_12754 + 96] = mem[_12628 + 96]
                                                                            mem[_12754 + 128] = mem[_12628 + 128]
                                                                            _13134 = mem[_12754 + 64]
                                                                            _13135 = mem[_12754 + 32]
                                                                            _13136 = mem[_9141 + 64]
                                                                            _13137 = mem[_12754]
                                                                            _13138 = mem[_12754 + 128]
                                                                            _13139 = mem[_12754 + 96]
                                                                            if mem[_12754 + 96] > !mem[_12754 + 128]:
                                                                                revert with 0, 17
                                                                            if mem[_12754 + 96] + mem[_12754 + 128] < mem[_12754 + 96]:
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            if not mem[_12754 + 96] + mem[_12754 + 128]:
                                                                                _13579 = mem[64]
                                                                                mem[64] = mem[64] + 64
                                                                                mem[_13579] = 26
                                                                                mem[_13579 + 32] = 'SafeMath: division by zero'
                                                                                if not _13135:
                                                                                    _13678 = mem[64]
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 26
                                                                                    idx = 0
                                                                                    while idx < 26:
                                                                                        mem[idx + _13678 + 68] = mem[_13579 + idx + 32]
                                                                                        idx = idx + 32
                                                                                        continue 
                                                                                    mem[_13678 + 94] = 0
                                                                                    revert with memory
                                                                                      from mem[64]
                                                                                       len _13678 + -mem[64] + 100
                                                                                _14029 = mem[64]
                                                                                mem[64] = mem[64] + 64
                                                                                mem[_14029] = 26
                                                                                mem[_14029 + 32] = 'SafeMath: division by zero'
                                                                                if _13134:
                                                                                    if t > !(0 / _13135 / _13134):
                                                                                        revert with 0, 17
                                                                                    if t + (0 / _13135 / _13134) < t:
                                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                                    if s == -1:
                                                                                        revert with 0, 17
                                                                                    s = s + 1
                                                                                    t = t + (0 / _13135 / _13134)
                                                                                    continue 
                                                                                _14194 = mem[64]
                                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                mem[mem[64] + 4] = 32
                                                                                mem[mem[64] + 36] = 26
                                                                                idx = 0
                                                                                while idx < 26:
                                                                                    mem[idx + _14194 + 68] = mem[_14029 + idx + 32]
                                                                                    idx = idx + 32
                                                                                    continue 
                                                                                mem[_14194 + 94] = 0
                                                                                revert with memory
                                                                                  from mem[64]
                                                                                   len _14194 + -mem[64] + 100
                                                                            if mem[_12754 + 96] + mem[_12754 + 128] and mem[_12754] > -1 / mem[_12754 + 96] + mem[_12754 + 128]:
                                                                                revert with 0, 17
                                                                            if not mem[_12754 + 96] + mem[_12754 + 128]:
                                                                                revert with 0, 18
                                                                            if (mem[_12754 + 96] * mem[_12754]) + (mem[_12754 + 128] * mem[_12754]) / mem[_12754 + 96] + mem[_12754 + 128] != mem[_12754]:
                                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                                            if not (mem[_12754 + 96] * mem[_12754]) + (mem[_12754 + 128] * mem[_12754]):
                                                                                _13833 = mem[64]
                                                                                mem[64] = mem[64] + 64
                                                                                mem[_13833] = 26
                                                                                mem[_13833 + 32] = 'SafeMath: division by zero'
                                                                                if not _13135:
                                                                                    _14028 = mem[64]
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 26
                                                                                    idx = 0
                                                                                    while idx < 26:
                                                                                        mem[idx + _14028 + 68] = mem[_13833 + idx + 32]
                                                                                        idx = idx + 32
                                                                                        continue 
                                                                                    mem[_14028 + 94] = 0
                                                                                    revert with memory
                                                                                      from mem[64]
                                                                                       len _14028 + -mem[64] + 100
                                                                                _14497 = mem[64]
                                                                                mem[64] = mem[64] + 64
                                                                                mem[_14497] = 26
                                                                                mem[_14497 + 32] = 'SafeMath: division by zero'
                                                                                if _13134:
                                                                                    if t > !(0 / _13135 / _13134):
                                                                                        revert with 0, 17
                                                                                    if t + (0 / _13135 / _13134) < t:
                                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                                    if s == -1:
                                                                                        revert with 0, 17
                                                                                    s = s + 1
                                                                                    t = t + (0 / _13135 / _13134)
                                                                                    continue 
                                                                                _14701 = mem[64]
                                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                mem[mem[64] + 4] = 32
                                                                                mem[mem[64] + 36] = 26
                                                                                idx = 0
                                                                                while idx < 26:
                                                                                    mem[idx + _14701 + 68] = mem[_14497 + idx + 32]
                                                                                    idx = idx + 32
                                                                                    continue 
                                                                                mem[_14701 + 94] = 0
                                                                                revert with memory
                                                                                  from mem[64]
                                                                                   len _14701 + -mem[64] + 100
                                                                            if (mem[_12754 + 96] * mem[_12754]) + (mem[_12754 + 128] * mem[_12754]) and mem[_9141 + 64] > -1 / (mem[_12754 + 96] * mem[_12754]) + (mem[_12754 + 128] * mem[_12754]):
                                                                                revert with 0, 17
                                                                            if not (mem[_12754 + 96] * mem[_12754]) + (mem[_12754 + 128] * mem[_12754]):
                                                                                revert with 0, 18
                                                                            if (mem[_12754 + 96] * mem[_12754] * mem[_9141 + 64]) + (mem[_12754 + 128] * mem[_12754] * mem[_9141 + 64]) / (mem[_12754 + 96] * mem[_12754]) + (mem[_12754 + 128] * mem[_12754]) != mem[_9141 + 64]:
                                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                                            _14363 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_14363] = 26
                                                                            mem[_14363 + 32] = 'SafeMath: division by zero'
                                                                            if not _13135:
                                                                                _14496 = mem[64]
                                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                mem[mem[64] + 4] = 32
                                                                                mem[mem[64] + 36] = 26
                                                                                idx = 0
                                                                                while idx < 26:
                                                                                    mem[idx + _14496 + 68] = mem[_14363 + idx + 32]
                                                                                    idx = idx + 32
                                                                                    continue 
                                                                                mem[_14496 + 94] = 0
                                                                                revert with memory
                                                                                  from mem[64]
                                                                                   len _14496 + -mem[64] + 100
                                                                            _14961 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_14961] = 26
                                                                            mem[_14961 + 32] = 'SafeMath: division by zero'
                                                                            if _13134:
                                                                                if t > !((_13139 * _13137 * _13136) + (_13138 * _13137 * _13136) / _13135 / _13134):
                                                                                    revert with 0, 17
                                                                                if t + ((_13139 * _13137 * _13136) + (_13138 * _13137 * _13136) / _13135 / _13134) < t:
                                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                                if s == -1:
                                                                                    revert with 0, 17
                                                                                s = s + 1
                                                                                t = t + ((_13139 * _13137 * _13136) + (_13138 * _13137 * _13136) / _13135 / _13134)
                                                                                continue 
                                                                            _15133 = mem[64]
                                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                            mem[mem[64] + 4] = 32
                                                                            mem[mem[64] + 36] = 26
                                                                            idx = 0
                                                                            while idx < 26:
                                                                                mem[idx + _15133 + 68] = mem[_14961 + idx + 32]
                                                                                idx = idx + 32
                                                                                continue 
                                                                            mem[_15133 + 94] = 0
                                                                            revert with memory
                                                                              from mem[64]
                                                                               len _15133 + -mem[64] + 100
                                                                        if t >= mem[_8170 + 160]:
                                                                            _12670 = mem[_8170]
                                                                            staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                                                                                    gas gas_remaining wei
                                                                                   args sub_4c86259e[idx].field_0, Mask(128, 128, mem[_8170])
                                                                            mem[mem[64] len 352] = ext_call.return_data[0 len 352]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            _13250 = mem[64]
                                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                                            require return_data.size >= 352
                                                                            _13290 = mem[64]
                                                                            if mem[64] + 352 < mem[64] or mem[64] + 352 > test266151307():
                                                                                revert with 0, 65
                                                                            mem[64] = mem[64] + 352
                                                                            require mem[_13250] == Mask(128, 128, mem[_13250])
                                                                            mem[_13290] = mem[_13250]
                                                                            mem[_13290 + 32] = mem[_13250 + 32]
                                                                            mem[_13290 + 64] = mem[_13250 + 64]
                                                                            mem[_13290 + 96] = mem[_13250 + 96]
                                                                            require mem[_13250 + 128] < 5
                                                                            mem[_13290 + 128] = mem[_13250 + 128]
                                                                            mem[_13290 + 160] = mem[_13250 + 160]
                                                                            mem[_13290 + 192] = mem[_13250 + 192]
                                                                            mem[_13290 + 224] = mem[_13250 + 224]
                                                                            mem[_13290 + 256] = mem[_13250 + 256]
                                                                            mem[_13290 + 288] = mem[_13250 + 288]
                                                                            mem[_13290 + 320] = mem[_13250 + 320]
                                                                            if Mask(128, 128, mem[_13290]) != Mask(128, 128, _12670):
                                                                                revert with 0, 'Address does not contain stake with provided id'
                                                                            s = mem[_13290 + 192]
                                                                            t = 0
                                                                            while s < _8832 + _8831:
                                                                                staticcall sub_413c05c6Address.0x8ce1d9e4 with:
                                                                                        gas gas_remaining wei
                                                                                       args s
                                                                                mem[mem[64] len 160] = ext_call.return_data[0 len 160]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                _17131 = mem[64]
                                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                                require return_data.size >= 160
                                                                                _17233 = mem[64]
                                                                                if mem[64] + 160 > test266151307() or mem[64] + 160 < mem[64]:
                                                                                    revert with 0, 65
                                                                                mem[64] = mem[64] + 160
                                                                                mem[_17233] = mem[_17131]
                                                                                mem[_17233 + 32] = mem[_17131 + 32]
                                                                                mem[_17233 + 64] = mem[_17131 + 64]
                                                                                mem[_17233 + 96] = mem[_17131 + 96]
                                                                                mem[_17233 + 128] = mem[_17131 + 128]
                                                                                _17670 = mem[_17233 + 64]
                                                                                _17671 = mem[_17233 + 32]
                                                                                _17672 = mem[_13290 + 64]
                                                                                _17673 = mem[_17233]
                                                                                _17674 = mem[_17233 + 128]
                                                                                _17675 = mem[_17233 + 96]
                                                                                if mem[_17233 + 96] > !mem[_17233 + 128]:
                                                                                    revert with 0, 17
                                                                                if mem[_17233 + 96] + mem[_17233 + 128] < mem[_17233 + 96]:
                                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                                if not mem[_17233 + 96] + mem[_17233 + 128]:
                                                                                    _17851 = mem[64]
                                                                                    mem[64] = mem[64] + 64
                                                                                    mem[_17851] = 26
                                                                                    mem[_17851 + 32] = 'SafeMath: division by zero'
                                                                                    if not _17671:
                                                                                        _17908 = mem[64]
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 26
                                                                                        idx = 0
                                                                                        while idx < 26:
                                                                                            mem[idx + _17908 + 68] = mem[_17851 + idx + 32]
                                                                                            idx = idx + 32
                                                                                            continue 
                                                                                        mem[_17908 + 94] = 0
                                                                                        revert with memory
                                                                                          from mem[64]
                                                                                           len _17908 + -mem[64] + 100
                                                                                    _18089 = mem[64]
                                                                                    mem[64] = mem[64] + 64
                                                                                    mem[_18089] = 26
                                                                                    mem[_18089 + 32] = 'SafeMath: division by zero'
                                                                                    if _17670:
                                                                                        if t > !(0 / _17671 / _17670):
                                                                                            revert with 0, 17
                                                                                        if t + (0 / _17671 / _17670) < t:
                                                                                            revert with 0, 'SafeMath: addition overflow'
                                                                                        if s == -1:
                                                                                            revert with 0, 17
                                                                                        s = s + 1
                                                                                        t = t + (0 / _17671 / _17670)
                                                                                        continue 
                                                                                    _18198 = mem[64]
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 26
                                                                                    idx = 0
                                                                                    while idx < 26:
                                                                                        mem[idx + _18198 + 68] = mem[_18089 + idx + 32]
                                                                                        idx = idx + 32
                                                                                        continue 
                                                                                    mem[_18198 + 94] = 0
                                                                                    revert with memory
                                                                                      from mem[64]
                                                                                       len _18198 + -mem[64] + 100
                                                                                if mem[_17233 + 96] + mem[_17233 + 128] and mem[_17233] > -1 / mem[_17233 + 96] + mem[_17233 + 128]:
                                                                                    revert with 0, 17
                                                                                if not mem[_17233 + 96] + mem[_17233 + 128]:
                                                                                    revert with 0, 18
                                                                                if (mem[_17233 + 96] * mem[_17233]) + (mem[_17233 + 128] * mem[_17233]) / mem[_17233 + 96] + mem[_17233 + 128] != mem[_17233]:
                                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                                if not (mem[_17233 + 96] * mem[_17233]) + (mem[_17233 + 128] * mem[_17233]):
                                                                                    _18005 = mem[64]
                                                                                    mem[64] = mem[64] + 64
                                                                                    mem[_18005] = 26
                                                                                    mem[_18005 + 32] = 'SafeMath: division by zero'
                                                                                    if not _17671:
                                                                                        _18088 = mem[64]
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 26
                                                                                        idx = 0
                                                                                        while idx < 26:
                                                                                            mem[idx + _18088 + 68] = mem[_18005 + idx + 32]
                                                                                            idx = idx + 32
                                                                                            continue 
                                                                                        mem[_18088 + 94] = 0
                                                                                        revert with memory
                                                                                          from mem[64]
                                                                                           len _18088 + -mem[64] + 100
                                                                                    _18423 = mem[64]
                                                                                    mem[64] = mem[64] + 64
                                                                                    mem[_18423] = 26
                                                                                    mem[_18423 + 32] = 'SafeMath: division by zero'
                                                                                    if _17670:
                                                                                        if t > !(0 / _17671 / _17670):
                                                                                            revert with 0, 17
                                                                                        if t + (0 / _17671 / _17670) < t:
                                                                                            revert with 0, 'SafeMath: addition overflow'
                                                                                        if s == -1:
                                                                                            revert with 0, 17
                                                                                        s = s + 1
                                                                                        t = t + (0 / _17671 / _17670)
                                                                                        continue 
                                                                                    _18535 = mem[64]
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 26
                                                                                    idx = 0
                                                                                    while idx < 26:
                                                                                        mem[idx + _18535 + 68] = mem[_18423 + idx + 32]
                                                                                        idx = idx + 32
                                                                                        continue 
                                                                                    mem[_18535 + 94] = 0
                                                                                    revert with memory
                                                                                      from mem[64]
                                                                                       len _18535 + -mem[64] + 100
                                                                                if (mem[_17233 + 96] * mem[_17233]) + (mem[_17233 + 128] * mem[_17233]) and mem[_13290 + 64] > -1 / (mem[_17233 + 96] * mem[_17233]) + (mem[_17233 + 128] * mem[_17233]):
                                                                                    revert with 0, 17
                                                                                if not (mem[_17233 + 96] * mem[_17233]) + (mem[_17233 + 128] * mem[_17233]):
                                                                                    revert with 0, 18
                                                                                if (mem[_17233 + 96] * mem[_17233] * mem[_13290 + 64]) + (mem[_17233 + 128] * mem[_17233] * mem[_13290 + 64]) / (mem[_17233 + 96] * mem[_17233]) + (mem[_17233 + 128] * mem[_17233]) != mem[_13290 + 64]:
                                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                                _18311 = mem[64]
                                                                                mem[64] = mem[64] + 64
                                                                                mem[_18311] = 26
                                                                                mem[_18311 + 32] = 'SafeMath: division by zero'
                                                                                if not _17671:
                                                                                    _18422 = mem[64]
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 26
                                                                                    idx = 0
                                                                                    while idx < 26:
                                                                                        mem[idx + _18422 + 68] = mem[_18311 + idx + 32]
                                                                                        idx = idx + 32
                                                                                        continue 
                                                                                    mem[_18422 + 94] = 0
                                                                                    revert with memory
                                                                                      from mem[64]
                                                                                       len _18422 + -mem[64] + 100
                                                                                _18727 = mem[64]
                                                                                mem[64] = mem[64] + 64
                                                                                mem[_18727] = 26
                                                                                mem[_18727 + 32] = 'SafeMath: division by zero'
                                                                                if _17670:
                                                                                    if t > !((_17675 * _17673 * _17672) + (_17674 * _17673 * _17672) / _17671 / _17670):
                                                                                        revert with 0, 17
                                                                                    if t + ((_17675 * _17673 * _17672) + (_17674 * _17673 * _17672) / _17671 / _17670) < t:
                                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                                    if s == -1:
                                                                                        revert with 0, 17
                                                                                    s = s + 1
                                                                                    t = t + ((_17675 * _17673 * _17672) + (_17674 * _17673 * _17672) / _17671 / _17670)
                                                                                    continue 
                                                                                _18833 = mem[64]
                                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                mem[mem[64] + 4] = 32
                                                                                mem[mem[64] + 36] = 26
                                                                                idx = 0
                                                                                while idx < 26:
                                                                                    mem[idx + _18833 + 68] = mem[_18727 + idx + 32]
                                                                                    idx = idx + 32
                                                                                    continue 
                                                                                mem[_18833 + 94] = 0
                                                                                revert with memory
                                                                                  from mem[64]
                                                                                   len _18833 + -mem[64] + 100
                                                                            _17130 = mem[_8170 + 32]
                                                                            stor9[stor12[idx].field_0][Mask(128, 128, stor12[idx].field_256)] = 1
                                                                            mem[0] = idx
                                                                            mem[32] = 12
                                                                            if _17130 > !t:
                                                                                revert with 0, 17
                                                                            if _17130 + t < _17130:
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            if _17130 + t:
                                                                                if not _17130 + t:
                                                                                    _17828 = mem[64]
                                                                                    mem[64] = mem[64] + 64
                                                                                    mem[_17828] = 26
                                                                                    mem[_17828 + 32] = 'SafeMath: division by zero'
                                                                                    if not DENOMINATOR:
                                                                                        _17849 = mem[64]
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 26
                                                                                        idx = 0
                                                                                        while idx < 26:
                                                                                            mem[idx + _17849 + 68] = mem[_17828 + idx + 32]
                                                                                            idx = idx + 32
                                                                                            continue 
                                                                                        mem[_17849 + 94] = 0
                                                                                        revert with memory
                                                                                          from mem[64]
                                                                                           len _17849 + -mem[64] + 100
                                                                                    mem[mem[64] + 36] = 0 / DENOMINATOR
                                                                                    require ext_code.size(sub_76089ab4Address)
                                                                                    call sub_76089ab4Address.mintSupply(address arg1, uint256 arg2) with:
                                                                                         gas gas_remaining wei
                                                                                        args this.address, 0 / DENOMINATOR
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    require ext_code.size(sub_76089ab4Address)
                                                                                    call sub_76089ab4Address.createStake(uint256 arg1) with:
                                                                                         gas gas_remaining wei
                                                                                        args (0 / DENOMINATOR)
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    mem[mem[64] + 4] = this.address
                                                                                    staticcall sub_76089ab4Address.stakeCount(address arg1) with:
                                                                                            gas gas_remaining wei
                                                                                           args this.address
                                                                                    mem[mem[64]] = ext_call.return_data[0]
                                                                                    _18195 = mem[64]
                                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                                    require return_data.size >= 32
                                                                                    _18310 = mem[_18195]
                                                                                    if mem[_18195] < 1:
                                                                                        revert with 0, 17
                                                                                    _18590 = mem[64]
                                                                                    mem[mem[64] + 32] = address(this.address)
                                                                                    mem[mem[64] + 52] = _18310 - 1
                                                                                    mem[mem[64] + 84] = 0x100000000000000000000000000000000000000000000000000000000000000
                                                                                    _18591 = mem[64]
                                                                                    mem[mem[64]] = 53
                                                                                    mem[64] = mem[64] + 85
                                                                                    _18593 = sha3(mem[_18591 + 32 len mem[_18591]])
                                                                                    mem[_18590 + 89] = Mask(128, 128, sha3(mem[_18591 + 32 len mem[_18591]]))
                                                                                    mem[_18590 + 121] = sub_4c86259e[idx].field_0
                                                                                    require ext_code.size(sub_76089ab4Address)
                                                                                    call sub_76089ab4Address.moveStake(bytes16 arg1, address arg2) with:
                                                                                         gas gas_remaining wei
                                                                                        args Mask(128, 128, _18593), sub_4c86259e[idx].field_0
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    if sub_ab7789c0 == -1:
                                                                                        revert with 0, 17
                                                                                    sub_ab7789c0++
                                                                                    if 1 > !sub_1b385a01[stor12[idx].field_0]:
                                                                                        revert with 0, 17
                                                                                    mem[0] = sub_4c86259e[idx].field_0
                                                                                    mem[32] = 7
                                                                                    sub_1b385a01[stor12[idx].field_0]++
                                                                                    if sub_04b4a313 > !(0 / DENOMINATOR):
                                                                                        revert with 0, 17
                                                                                    if sub_04b4a313 + (0 / DENOMINATOR) < sub_04b4a313:
                                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                                    sub_04b4a313 += 0 / DENOMINATOR
                                                                                    mem[_18590 + 85] = 0 / DENOMINATOR
                                                                                    emit 0xdbcd8131: (0 / DENOMINATOR), sub_4c86259e[idx].field_0, Mask(128, 128, sub_4c86259e[idx].field_256), Mask(128, 128, _18593)
                                                                                else:
                                                                                    if _17130 + t and sub_d8830c7d > -1 / _17130 + t:
                                                                                        revert with 0, 17
                                                                                    if not _17130 + t:
                                                                                        revert with 0, 18
                                                                                    if (_17130 * sub_d8830c7d) + (t * sub_d8830c7d) / _17130 + t != sub_d8830c7d:
                                                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                                                    _17953 = mem[64]
                                                                                    mem[64] = mem[64] + 64
                                                                                    mem[_17953] = 26
                                                                                    mem[_17953 + 32] = 'SafeMath: division by zero'
                                                                                    if not DENOMINATOR:
                                                                                        _18004 = mem[64]
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 26
                                                                                        idx = 0
                                                                                        while idx < 26:
                                                                                            mem[idx + _18004 + 68] = mem[_17953 + idx + 32]
                                                                                            idx = idx + 32
                                                                                            continue 
                                                                                        mem[_18004 + 94] = 0
                                                                                        revert with memory
                                                                                          from mem[64]
                                                                                           len _18004 + -mem[64] + 100
                                                                                    mem[mem[64] + 36] = (_17130 * sub_d8830c7d) + (t * sub_d8830c7d) / DENOMINATOR
                                                                                    require ext_code.size(sub_76089ab4Address)
                                                                                    call sub_76089ab4Address.mintSupply(address arg1, uint256 arg2) with:
                                                                                         gas gas_remaining wei
                                                                                        args this.address, (_17130 * sub_d8830c7d) + (t * sub_d8830c7d) / DENOMINATOR
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    require ext_code.size(sub_76089ab4Address)
                                                                                    call sub_76089ab4Address.createStake(uint256 arg1) with:
                                                                                         gas gas_remaining wei
                                                                                        args ((_17130 * sub_d8830c7d) + (t * sub_d8830c7d) / DENOMINATOR)
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    mem[mem[64] + 4] = this.address
                                                                                    staticcall sub_76089ab4Address.stakeCount(address arg1) with:
                                                                                            gas gas_remaining wei
                                                                                           args this.address
                                                                                    mem[mem[64]] = ext_call.return_data[0]
                                                                                    _18533 = mem[64]
                                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                                    require return_data.size >= 32
                                                                                    _18642 = mem[_18533]
                                                                                    if mem[_18533] < 1:
                                                                                        revert with 0, 17
                                                                                    _18884 = mem[64]
                                                                                    mem[mem[64] + 32] = address(this.address)
                                                                                    mem[mem[64] + 52] = _18642 - 1
                                                                                    mem[mem[64] + 84] = 0x100000000000000000000000000000000000000000000000000000000000000
                                                                                    _18885 = mem[64]
                                                                                    mem[mem[64]] = 53
                                                                                    mem[64] = mem[64] + 85
                                                                                    _18887 = sha3(mem[_18885 + 32 len mem[_18885]])
                                                                                    mem[_18884 + 89] = Mask(128, 128, sha3(mem[_18885 + 32 len mem[_18885]]))
                                                                                    mem[_18884 + 121] = sub_4c86259e[idx].field_0
                                                                                    require ext_code.size(sub_76089ab4Address)
                                                                                    call sub_76089ab4Address.moveStake(bytes16 arg1, address arg2) with:
                                                                                         gas gas_remaining wei
                                                                                        args Mask(128, 128, _18887), sub_4c86259e[idx].field_0
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    if sub_ab7789c0 == -1:
                                                                                        revert with 0, 17
                                                                                    sub_ab7789c0++
                                                                                    if 1 > !sub_1b385a01[stor12[idx].field_0]:
                                                                                        revert with 0, 17
                                                                                    mem[0] = sub_4c86259e[idx].field_0
                                                                                    mem[32] = 7
                                                                                    sub_1b385a01[stor12[idx].field_0]++
                                                                                    if sub_04b4a313 > !((_17130 * sub_d8830c7d) + (t * sub_d8830c7d) / DENOMINATOR):
                                                                                        revert with 0, 17
                                                                                    if sub_04b4a313 + ((_17130 * sub_d8830c7d) + (t * sub_d8830c7d) / DENOMINATOR) < sub_04b4a313:
                                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                                    sub_04b4a313 += (_17130 * sub_d8830c7d) + (t * sub_d8830c7d) / DENOMINATOR
                                                                                    mem[_18884 + 85] = (_17130 * sub_d8830c7d) + (t * sub_d8830c7d) / DENOMINATOR
                                                                                    emit 0xdbcd8131: ((_17130 * sub_d8830c7d) + (t * sub_d8830c7d) / DENOMINATOR), sub_4c86259e[idx].field_0, Mask(128, 128, sub_4c86259e[idx].field_256), Mask(128, 128, _18887)
                                                                        else:
                                                                            _12671 = mem[_8170 + 160]
                                                                            _12753 = mem[64]
                                                                            mem[64] = mem[64] + 64
                                                                            mem[_12753] = 30
                                                                            mem[_12753 + 32] = 'SafeMath: subtraction overflow'
                                                                            if t > _12671:
                                                                                _13133 = mem[64]
                                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                mem[mem[64] + 4] = 32
                                                                                mem[mem[64] + 36] = 30
                                                                                idx = 0
                                                                                while idx < 30:
                                                                                    mem[idx + _13133 + 68] = mem[_12753 + idx + 32]
                                                                                    idx = idx + 32
                                                                                    continue 
                                                                                mem[_13133 + 98] = 0
                                                                                revert with memory
                                                                                  from mem[64]
                                                                                   len _13133 + -mem[64] + 100
                                                                            if _12671 < t:
                                                                                revert with 0, 17
                                                                            _13321 = mem[_8170]
                                                                            staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                                                                                    gas gas_remaining wei
                                                                                   args sub_4c86259e[idx].field_0, Mask(128, 128, mem[_8170])
                                                                            mem[mem[64] len 352] = ext_call.return_data[0 len 352]
                                                                            if not ext_call.success:
                                                                                revert with ext_call.return_data[0 len return_data.size]
                                                                            _13429 = mem[64]
                                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                                            require return_data.size >= 352
                                                                            _13484 = mem[64]
                                                                            if mem[64] + 352 < mem[64] or mem[64] + 352 > test266151307():
                                                                                revert with 0, 65
                                                                            mem[64] = mem[64] + 352
                                                                            require mem[_13429] == Mask(128, 128, mem[_13429])
                                                                            mem[_13484] = mem[_13429]
                                                                            mem[_13484 + 32] = mem[_13429 + 32]
                                                                            mem[_13484 + 64] = mem[_13429 + 64]
                                                                            mem[_13484 + 96] = mem[_13429 + 96]
                                                                            require mem[_13429 + 128] < 5
                                                                            mem[_13484 + 128] = mem[_13429 + 128]
                                                                            mem[_13484 + 160] = mem[_13429 + 160]
                                                                            mem[_13484 + 192] = mem[_13429 + 192]
                                                                            mem[_13484 + 224] = mem[_13429 + 224]
                                                                            mem[_13484 + 256] = mem[_13429 + 256]
                                                                            mem[_13484 + 288] = mem[_13429 + 288]
                                                                            mem[_13484 + 320] = mem[_13429 + 320]
                                                                            if Mask(128, 128, mem[_13484]) != Mask(128, 128, _13321):
                                                                                revert with 0, 'Address does not contain stake with provided id'
                                                                            s = mem[_13484 + 192]
                                                                            u = 0
                                                                            while s < _8832 + _8831:
                                                                                staticcall sub_413c05c6Address.0x8ce1d9e4 with:
                                                                                        gas gas_remaining wei
                                                                                       args s
                                                                                mem[mem[64] len 160] = ext_call.return_data[0 len 160]
                                                                                if not ext_call.success:
                                                                                    revert with ext_call.return_data[0 len return_data.size]
                                                                                _17133 = mem[64]
                                                                                mem[64] = mem[64] + ceil32(return_data.size)
                                                                                require return_data.size >= 160
                                                                                _17234 = mem[64]
                                                                                if mem[64] + 160 > test266151307() or mem[64] + 160 < mem[64]:
                                                                                    revert with 0, 65
                                                                                mem[64] = mem[64] + 160
                                                                                mem[_17234] = mem[_17133]
                                                                                mem[_17234 + 32] = mem[_17133 + 32]
                                                                                mem[_17234 + 64] = mem[_17133 + 64]
                                                                                mem[_17234 + 96] = mem[_17133 + 96]
                                                                                mem[_17234 + 128] = mem[_17133 + 128]
                                                                                _17676 = mem[_17234 + 64]
                                                                                _17677 = mem[_17234 + 32]
                                                                                _17678 = mem[_13484 + 64]
                                                                                _17679 = mem[_17234]
                                                                                _17680 = mem[_17234 + 128]
                                                                                _17681 = mem[_17234 + 96]
                                                                                if mem[_17234 + 96] > !mem[_17234 + 128]:
                                                                                    revert with 0, 17
                                                                                if mem[_17234 + 96] + mem[_17234 + 128] < mem[_17234 + 96]:
                                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                                if not mem[_17234 + 96] + mem[_17234 + 128]:
                                                                                    _17853 = mem[64]
                                                                                    mem[64] = mem[64] + 64
                                                                                    mem[_17853] = 26
                                                                                    mem[_17853 + 32] = 'SafeMath: division by zero'
                                                                                    if not _17677:
                                                                                        _17909 = mem[64]
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 26
                                                                                        idx = 0
                                                                                        while idx < 26:
                                                                                            mem[idx + _17909 + 68] = mem[_17853 + idx + 32]
                                                                                            idx = idx + 32
                                                                                            continue 
                                                                                        mem[_17909 + 94] = 0
                                                                                        revert with memory
                                                                                          from mem[64]
                                                                                           len _17909 + -mem[64] + 100
                                                                                    _18093 = mem[64]
                                                                                    mem[64] = mem[64] + 64
                                                                                    mem[_18093] = 26
                                                                                    mem[_18093 + 32] = 'SafeMath: division by zero'
                                                                                    if _17676:
                                                                                        if u > !(0 / _17677 / _17676):
                                                                                            revert with 0, 17
                                                                                        if u + (0 / _17677 / _17676) < u:
                                                                                            revert with 0, 'SafeMath: addition overflow'
                                                                                        if s == -1:
                                                                                            revert with 0, 17
                                                                                        s = s + 1
                                                                                        u = u + (0 / _17677 / _17676)
                                                                                        continue 
                                                                                    _18204 = mem[64]
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 26
                                                                                    idx = 0
                                                                                    while idx < 26:
                                                                                        mem[idx + _18204 + 68] = mem[_18093 + idx + 32]
                                                                                        idx = idx + 32
                                                                                        continue 
                                                                                    mem[_18204 + 94] = 0
                                                                                    revert with memory
                                                                                      from mem[64]
                                                                                       len _18204 + -mem[64] + 100
                                                                                if mem[_17234 + 96] + mem[_17234 + 128] and mem[_17234] > -1 / mem[_17234 + 96] + mem[_17234 + 128]:
                                                                                    revert with 0, 17
                                                                                if not mem[_17234 + 96] + mem[_17234 + 128]:
                                                                                    revert with 0, 18
                                                                                if (mem[_17234 + 96] * mem[_17234]) + (mem[_17234 + 128] * mem[_17234]) / mem[_17234 + 96] + mem[_17234 + 128] != mem[_17234]:
                                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                                if not (mem[_17234 + 96] * mem[_17234]) + (mem[_17234 + 128] * mem[_17234]):
                                                                                    _18008 = mem[64]
                                                                                    mem[64] = mem[64] + 64
                                                                                    mem[_18008] = 26
                                                                                    mem[_18008 + 32] = 'SafeMath: division by zero'
                                                                                    if not _17677:
                                                                                        _18092 = mem[64]
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 26
                                                                                        idx = 0
                                                                                        while idx < 26:
                                                                                            mem[idx + _18092 + 68] = mem[_18008 + idx + 32]
                                                                                            idx = idx + 32
                                                                                            continue 
                                                                                        mem[_18092 + 94] = 0
                                                                                        revert with memory
                                                                                          from mem[64]
                                                                                           len _18092 + -mem[64] + 100
                                                                                    _18428 = mem[64]
                                                                                    mem[64] = mem[64] + 64
                                                                                    mem[_18428] = 26
                                                                                    mem[_18428 + 32] = 'SafeMath: division by zero'
                                                                                    if _17676:
                                                                                        if u > !(0 / _17677 / _17676):
                                                                                            revert with 0, 17
                                                                                        if u + (0 / _17677 / _17676) < u:
                                                                                            revert with 0, 'SafeMath: addition overflow'
                                                                                        if s == -1:
                                                                                            revert with 0, 17
                                                                                        s = s + 1
                                                                                        u = u + (0 / _17677 / _17676)
                                                                                        continue 
                                                                                    _18540 = mem[64]
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 26
                                                                                    idx = 0
                                                                                    while idx < 26:
                                                                                        mem[idx + _18540 + 68] = mem[_18428 + idx + 32]
                                                                                        idx = idx + 32
                                                                                        continue 
                                                                                    mem[_18540 + 94] = 0
                                                                                    revert with memory
                                                                                      from mem[64]
                                                                                       len _18540 + -mem[64] + 100
                                                                                if (mem[_17234 + 96] * mem[_17234]) + (mem[_17234 + 128] * mem[_17234]) and mem[_13484 + 64] > -1 / (mem[_17234 + 96] * mem[_17234]) + (mem[_17234 + 128] * mem[_17234]):
                                                                                    revert with 0, 17
                                                                                if not (mem[_17234 + 96] * mem[_17234]) + (mem[_17234 + 128] * mem[_17234]):
                                                                                    revert with 0, 18
                                                                                if (mem[_17234 + 96] * mem[_17234] * mem[_13484 + 64]) + (mem[_17234 + 128] * mem[_17234] * mem[_13484 + 64]) / (mem[_17234 + 96] * mem[_17234]) + (mem[_17234 + 128] * mem[_17234]) != mem[_13484 + 64]:
                                                                                    revert with 0, 'SafeMath: multiplication overflow'
                                                                                _18315 = mem[64]
                                                                                mem[64] = mem[64] + 64
                                                                                mem[_18315] = 26
                                                                                mem[_18315 + 32] = 'SafeMath: division by zero'
                                                                                if not _17677:
                                                                                    _18427 = mem[64]
                                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                    mem[mem[64] + 4] = 32
                                                                                    mem[mem[64] + 36] = 26
                                                                                    idx = 0
                                                                                    while idx < 26:
                                                                                        mem[idx + _18427 + 68] = mem[_18315 + idx + 32]
                                                                                        idx = idx + 32
                                                                                        continue 
                                                                                    mem[_18427 + 94] = 0
                                                                                    revert with memory
                                                                                      from mem[64]
                                                                                       len _18427 + -mem[64] + 100
                                                                                _18731 = mem[64]
                                                                                mem[64] = mem[64] + 64
                                                                                mem[_18731] = 26
                                                                                mem[_18731 + 32] = 'SafeMath: division by zero'
                                                                                if _17676:
                                                                                    if u > !((_17681 * _17679 * _17678) + (_17680 * _17679 * _17678) / _17677 / _17676):
                                                                                        revert with 0, 17
                                                                                    if u + ((_17681 * _17679 * _17678) + (_17680 * _17679 * _17678) / _17677 / _17676) < u:
                                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                                    if s == -1:
                                                                                        revert with 0, 17
                                                                                    s = s + 1
                                                                                    u = u + ((_17681 * _17679 * _17678) + (_17680 * _17679 * _17678) / _17677 / _17676)
                                                                                    continue 
                                                                                _18836 = mem[64]
                                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                mem[mem[64] + 4] = 32
                                                                                mem[mem[64] + 36] = 26
                                                                                idx = 0
                                                                                while idx < 26:
                                                                                    mem[idx + _18836 + 68] = mem[_18731 + idx + 32]
                                                                                    idx = idx + 32
                                                                                    continue 
                                                                                mem[_18836 + 94] = 0
                                                                                revert with memory
                                                                                  from mem[64]
                                                                                   len _18836 + -mem[64] + 100
                                                                            _17132 = mem[_8170 + 32]
                                                                            if _12671 - t > !u:
                                                                                revert with 0, 17
                                                                            if u < 0:
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            stor9[stor12[idx].field_0][Mask(128, 128, stor12[idx].field_256)] = 1
                                                                            mem[0] = idx
                                                                            mem[32] = 12
                                                                            if _17132 > !(_12671 - t + u):
                                                                                revert with 0, 17
                                                                            if _17132 + _12671 - t + u < _17132:
                                                                                revert with 0, 'SafeMath: addition overflow'
                                                                            if _17132 + _12671 - t + u:
                                                                                if not _17132 + _12671 - t + u:
                                                                                    _17956 = mem[64]
                                                                                    mem[64] = mem[64] + 64
                                                                                    mem[_17956] = 26
                                                                                    mem[_17956 + 32] = 'SafeMath: division by zero'
                                                                                    if not DENOMINATOR:
                                                                                        _18007 = mem[64]
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 26
                                                                                        idx = 0
                                                                                        while idx < 26:
                                                                                            mem[idx + _18007 + 68] = mem[_17956 + idx + 32]
                                                                                            idx = idx + 32
                                                                                            continue 
                                                                                        mem[_18007 + 94] = 0
                                                                                        revert with memory
                                                                                          from mem[64]
                                                                                           len _18007 + -mem[64] + 100
                                                                                    mem[mem[64] + 36] = 0 / DENOMINATOR
                                                                                    require ext_code.size(sub_76089ab4Address)
                                                                                    call sub_76089ab4Address.mintSupply(address arg1, uint256 arg2) with:
                                                                                         gas gas_remaining wei
                                                                                        args this.address, 0 / DENOMINATOR
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    require ext_code.size(sub_76089ab4Address)
                                                                                    call sub_76089ab4Address.createStake(uint256 arg1) with:
                                                                                         gas gas_remaining wei
                                                                                        args (0 / DENOMINATOR)
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    mem[mem[64] + 4] = this.address
                                                                                    staticcall sub_76089ab4Address.stakeCount(address arg1) with:
                                                                                            gas gas_remaining wei
                                                                                           args this.address
                                                                                    mem[mem[64]] = ext_call.return_data[0]
                                                                                    _18538 = mem[64]
                                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                                    require return_data.size >= 32
                                                                                    _18646 = mem[_18538]
                                                                                    if mem[_18538] < 1:
                                                                                        revert with 0, 17
                                                                                    _18889 = mem[64]
                                                                                    mem[mem[64] + 32] = address(this.address)
                                                                                    mem[mem[64] + 52] = _18646 - 1
                                                                                    mem[mem[64] + 84] = 0x100000000000000000000000000000000000000000000000000000000000000
                                                                                    _18890 = mem[64]
                                                                                    mem[mem[64]] = 53
                                                                                    mem[64] = mem[64] + 85
                                                                                    _18892 = sha3(mem[_18890 + 32 len mem[_18890]])
                                                                                    mem[_18889 + 89] = Mask(128, 128, sha3(mem[_18890 + 32 len mem[_18890]]))
                                                                                    mem[_18889 + 121] = sub_4c86259e[idx].field_0
                                                                                    require ext_code.size(sub_76089ab4Address)
                                                                                    call sub_76089ab4Address.moveStake(bytes16 arg1, address arg2) with:
                                                                                         gas gas_remaining wei
                                                                                        args Mask(128, 128, _18892), sub_4c86259e[idx].field_0
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    if sub_ab7789c0 == -1:
                                                                                        revert with 0, 17
                                                                                    sub_ab7789c0++
                                                                                    if 1 > !sub_1b385a01[stor12[idx].field_0]:
                                                                                        revert with 0, 17
                                                                                    mem[0] = sub_4c86259e[idx].field_0
                                                                                    mem[32] = 7
                                                                                    sub_1b385a01[stor12[idx].field_0]++
                                                                                    if sub_04b4a313 > !(0 / DENOMINATOR):
                                                                                        revert with 0, 17
                                                                                    if sub_04b4a313 + (0 / DENOMINATOR) < sub_04b4a313:
                                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                                    sub_04b4a313 += 0 / DENOMINATOR
                                                                                    mem[_18889 + 85] = 0 / DENOMINATOR
                                                                                    emit 0xdbcd8131: (0 / DENOMINATOR), sub_4c86259e[idx].field_0, Mask(128, 128, sub_4c86259e[idx].field_256), Mask(128, 128, _18892)
                                                                                else:
                                                                                    if _17132 + _12671 - t + u and sub_d8830c7d > -1 / _17132 + _12671 - t + u:
                                                                                        revert with 0, 17
                                                                                    if not _17132 + _12671 - t + u:
                                                                                        revert with 0, 18
                                                                                    if (_17132 * sub_d8830c7d) + (_12671 * sub_d8830c7d) - (t * sub_d8830c7d) + (u * sub_d8830c7d) / _17132 + _12671 - t + u != sub_d8830c7d:
                                                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                                                    _18200 = mem[64]
                                                                                    mem[64] = mem[64] + 64
                                                                                    mem[_18200] = 26
                                                                                    mem[_18200 + 32] = 'SafeMath: division by zero'
                                                                                    if not DENOMINATOR:
                                                                                        _18314 = mem[64]
                                                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                                        mem[mem[64] + 4] = 32
                                                                                        mem[mem[64] + 36] = 26
                                                                                        idx = 0
                                                                                        while idx < 26:
                                                                                            mem[idx + _18314 + 68] = mem[_18200 + idx + 32]
                                                                                            idx = idx + 32
                                                                                            continue 
                                                                                        mem[_18314 + 94] = 0
                                                                                        revert with memory
                                                                                          from mem[64]
                                                                                           len _18314 + -mem[64] + 100
                                                                                    mem[mem[64] + 36] = (_17132 * sub_d8830c7d) + (_12671 * sub_d8830c7d) - (t * sub_d8830c7d) + (u * sub_d8830c7d) / DENOMINATOR
                                                                                    require ext_code.size(sub_76089ab4Address)
                                                                                    call sub_76089ab4Address.mintSupply(address arg1, uint256 arg2) with:
                                                                                         gas gas_remaining wei
                                                                                        args this.address, (_17132 * sub_d8830c7d) + (_12671 * sub_d8830c7d) - (t * sub_d8830c7d) + (u * sub_d8830c7d) / DENOMINATOR
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    require ext_code.size(sub_76089ab4Address)
                                                                                    call sub_76089ab4Address.createStake(uint256 arg1) with:
                                                                                         gas gas_remaining wei
                                                                                        args ((_17132 * sub_d8830c7d) + (_12671 * sub_d8830c7d) - (t * sub_d8830c7d) + (u * sub_d8830c7d) / DENOMINATOR)
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    mem[mem[64] + 4] = this.address
                                                                                    staticcall sub_76089ab4Address.stakeCount(address arg1) with:
                                                                                            gas gas_remaining wei
                                                                                           args this.address
                                                                                    mem[mem[64]] = ext_call.return_data[0]
                                                                                    _18835 = mem[64]
                                                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                                                    require return_data.size >= 32
                                                                                    _18927 = mem[_18835]
                                                                                    if mem[_18835] < 1:
                                                                                        revert with 0, 17
                                                                                    _19041 = mem[64]
                                                                                    mem[mem[64] + 32] = address(this.address)
                                                                                    mem[mem[64] + 52] = _18927 - 1
                                                                                    mem[mem[64] + 84] = 0x100000000000000000000000000000000000000000000000000000000000000
                                                                                    _19042 = mem[64]
                                                                                    mem[mem[64]] = 53
                                                                                    mem[64] = mem[64] + 85
                                                                                    _19044 = sha3(mem[_19042 + 32 len mem[_19042]])
                                                                                    mem[_19041 + 89] = Mask(128, 128, sha3(mem[_19042 + 32 len mem[_19042]]))
                                                                                    mem[_19041 + 121] = sub_4c86259e[idx].field_0
                                                                                    require ext_code.size(sub_76089ab4Address)
                                                                                    call sub_76089ab4Address.moveStake(bytes16 arg1, address arg2) with:
                                                                                         gas gas_remaining wei
                                                                                        args Mask(128, 128, _19044), sub_4c86259e[idx].field_0
                                                                                    if not ext_call.success:
                                                                                        revert with ext_call.return_data[0 len return_data.size]
                                                                                    if sub_ab7789c0 == -1:
                                                                                        revert with 0, 17
                                                                                    sub_ab7789c0++
                                                                                    if 1 > !sub_1b385a01[stor12[idx].field_0]:
                                                                                        revert with 0, 17
                                                                                    mem[0] = sub_4c86259e[idx].field_0
                                                                                    mem[32] = 7
                                                                                    sub_1b385a01[stor12[idx].field_0]++
                                                                                    if sub_04b4a313 > !((_17132 * sub_d8830c7d) + (_12671 * sub_d8830c7d) - (t * sub_d8830c7d) + (u * sub_d8830c7d) / DENOMINATOR):
                                                                                        revert with 0, 17
                                                                                    if sub_04b4a313 + ((_17132 * sub_d8830c7d) + (_12671 * sub_d8830c7d) - (t * sub_d8830c7d) + (u * sub_d8830c7d) / DENOMINATOR) < sub_04b4a313:
                                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                                    sub_04b4a313 += (_17132 * sub_d8830c7d) + (_12671 * sub_d8830c7d) - (t * sub_d8830c7d) + (u * sub_d8830c7d) / DENOMINATOR
                                                                                    mem[_19041 + 85] = (_17132 * sub_d8830c7d) + (_12671 * sub_d8830c7d) - (t * sub_d8830c7d) + (u * sub_d8830c7d) / DENOMINATOR
                                                                                    emit 0xdbcd8131: ((_17132 * sub_d8830c7d) + (_12671 * sub_d8830c7d) - (t * sub_d8830c7d) + (u * sub_d8830c7d) / DENOMINATOR), sub_4c86259e[idx].field_0, Mask(128, 128, sub_4c86259e[idx].field_256), Mask(128, 128, _19044)
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            continue 
                if uint32(call.func_hash) >> 224 != unknown_0xa4b4ea9a(?????):
                    require unknown_0xab7789c0(?????) == uint32(call.func_hash) >> 224
                    require not msg.value
                    return sub_ab7789c0
                require not msg.value
                require calldata.size - 4 >= 64
                require arg1 == address(arg1)
                require arg2 == Mask(128, 128, arg2)
                return bool(stor9[arg1][arg2])
            if unknown_0xbe647a94(?????) == uint32(call.func_hash) >> 224:
                require not msg.value
                return sub_be647a94
            if unknown_0xd3a8b1da(?????) == uint32(call.func_hash) >> 224:
                require not msg.value
                return sub_d3a8b1da
            if unknown_0xd8830c7d(?????) == uint32(call.func_hash) >> 224:
                require not msg.value
                return sub_d8830c7d
            require unknown_0xd8952a49(?????) == uint32(call.func_hash) >> 224
            require not msg.value
            require calldata.size - 4 >= 64
            require arg1 == address(arg1)
            require arg2 == address(arg2)
            if TOKEN_DEFINERAddress != msg.sender:
                revert with 0, 'Wrong sender.'
            sub_413c05c6Address = address(arg1)
            sub_76089ab4Address = address(arg2)
        if unknown_0xf19557d6(?????) <= uint32(call.func_hash) >> 224:
            if unknown_0xf19557d6(?????) == uint32(call.func_hash) >> 224:
                require not msg.value
                require calldata.size - 4 >= 64
                if TOKEN_DEFINERAddress != msg.sender:
                    revert with 0, 'Wrong sender.'
                if arg2 < sub_d3a8b1da:
                    idx = arg1
                    while idx < arg2:
                        mem[0] = Mask(128, 128, sub_4c86259e[idx].field_256)
                        mem[32] = sha3(sub_4c86259e[idx].field_0, 9)
                        if not stor9[stor12[idx].field_0][Mask(128, 128, stor12[idx].field_256)]:
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            continue 
                        stor9[stor12[idx].field_0][Mask(128, 128, stor12[idx].field_256)] = 0
                        if sub_1b385a01[stor12[idx].field_0] < 1:
                            revert with 0, 17
                        sub_1b385a01[stor12[idx].field_0]--
                        if not sub_ab7789c0:
                            revert with 0, 17
                        sub_ab7789c0--
                        mem[0] = idx
                        mem[32] = 12
                        if 1 > !sub_ed73481d:
                            revert with 0, 17
                        _6932 = mem[64]
                        mem[64] = mem[64] + 352
                        mem[_6932] = 0
                        mem[_6932 + 32] = 0
                        mem[_6932 + 64] = 0
                        mem[_6932 + 96] = 0
                        mem[_6932 + 128] = 0
                        mem[_6932 + 160] = 0
                        mem[_6932 + 192] = 0
                        mem[_6932 + 224] = 0
                        mem[_6932 + 256] = 0
                        mem[_6932 + 288] = 0
                        mem[_6932 + 320] = 0
                        staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                                gas gas_remaining wei
                               args sub_4c86259e[idx].field_0, Mask(128, 128, sub_4c86259e[idx].field_256)
                        mem[mem[64] len 352] = ext_call.return_data[0 len 352]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _6990 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 352
                        _7052 = mem[64]
                        if mem[64] + 352 < mem[64] or mem[64] + 352 > test266151307():
                            revert with 0, 65
                        mem[64] = mem[64] + 352
                        require mem[_6990] == Mask(128, 128, mem[_6990])
                        mem[_7052] = mem[_6990]
                        mem[_7052 + 32] = mem[_6990 + 32]
                        mem[_7052 + 64] = mem[_6990 + 64]
                        mem[_7052 + 96] = mem[_6990 + 96]
                        require mem[_6990 + 128] < 5
                        mem[_7052 + 128] = mem[_6990 + 128]
                        mem[_7052 + 160] = mem[_6990 + 160]
                        mem[_7052 + 192] = mem[_6990 + 192]
                        mem[_7052 + 224] = mem[_6990 + 224]
                        mem[_7052 + 256] = mem[_6990 + 256]
                        mem[_7052 + 288] = mem[_6990 + 288]
                        mem[_7052 + 320] = mem[_6990 + 320]
                        if Mask(128, 128, mem[_7052]) != Mask(128, 128, sub_4c86259e[idx].field_256):
                            _7640 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_7640] = 46
                            mem[_7640 + 32 len 46] = 0xfe53656e64657220646f6573206e6f7420636f6e7461696e207374616b6520776974682070726f76696465642069
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            continue 
                        mem[0] = Mask(128, 128, sub_4c86259e[idx].field_256)
                        mem[32] = sha3(sub_4c86259e[idx].field_0, 9)
                        if stor9[stor12[idx].field_0][Mask(128, 128, stor12[idx].field_256)]:
                            _7696 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_7696] = 32
                            mem[_7696 + 32] = 'Stake has already been converted'
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            continue 
                        if mem[_7052 + 128] > 4:
                            revert with 0, 33
                        if mem[_7052 + 128] != 2:
                            _7787 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_7787] = 44
                            mem[_7787 + 32 len 44] = 0x795374616b65206973206f6e6c7920656c696769626c6520696620697420686173206265656e20636c6f7365
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            continue 
                        if mem[_7052 + 192] >= sub_be647a94:
                            _7845 = mem[64]
                            mem[64] = mem[64] + 128
                            mem[_7845] = 65
                            mem[_7845 + 32 len 65] = 0x645374616b65206973206f6e6c7920656c696769626c65206966206974207761732063726561746564207072696f7220746f2074686520637574206f6666206461
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            continue 
                        if mem[_7052 + 192] > !mem[_7052 + 224]:
                            revert with 0, 17
                        if mem[_7052 + 192] + mem[_7052 + 224] < sub_be647a94:
                            _8032 = mem[64]
                            mem[64] = mem[64] + 128
                            mem[_8032] = 66
                            mem[_8032 + 32 len 66] = 0x645374616b65206973206f6e6c7920656c696769626c652069662069742077617320656e646564206f6e2074686520637574206f666620646179206f722061667465
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            continue 
                        _8031 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_8031] = 17
                        mem[_8031 + 32] = 'Stake is eligible' << 120
                        staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                                gas gas_remaining wei
                               args sub_4c86259e[idx].field_0, Mask(128, 128, sub_4c86259e[idx].field_256)
                        mem[mem[64] len 352] = ext_call.return_data[0 len 352]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _8255 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 352
                        _8314 = mem[64]
                        if mem[64] + 352 < mem[64] or mem[64] + 352 > test266151307():
                            revert with 0, 65
                        mem[64] = mem[64] + 352
                        require mem[_8255] == Mask(128, 128, mem[_8255])
                        mem[_8314] = mem[_8255]
                        mem[_8314 + 32] = mem[_8255 + 32]
                        mem[_8314 + 64] = mem[_8255 + 64]
                        mem[_8314 + 96] = mem[_8255 + 96]
                        require mem[_8255 + 128] < 5
                        mem[_8314 + 128] = mem[_8255 + 128]
                        mem[_8314 + 160] = mem[_8255 + 160]
                        mem[_8314 + 192] = mem[_8255 + 192]
                        mem[_8314 + 224] = mem[_8255 + 224]
                        mem[_8314 + 256] = mem[_8255 + 256]
                        mem[_8314 + 288] = mem[_8255 + 288]
                        mem[_8314 + 320] = mem[_8255 + 320]
                        if Mask(128, 128, mem[_8314]) != Mask(128, 128, sub_4c86259e[idx].field_256):
                            revert with 0, 'Address does not contain stake with provided id'
                        if mem[_8314 + 128] > 4:
                            revert with 0, 33
                        if mem[_8314 + 128] == 3:
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            continue 
                        if mem[_8314 + 128] > 4:
                            revert with 0, 33
                        if mem[_8314 + 128] == 4:
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            continue 
                        if mem[_8314 + 128] > 4:
                            revert with 0, 33
                        if mem[_8314 + 128] == 1:
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            continue 
                        if mem[_8314 + 128] > 4:
                            revert with 0, 33
                        if not mem[_8314 + 128]:
                            _9010 = mem[_8314]
                            staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                                    gas gas_remaining wei
                                   args sub_4c86259e[idx].field_0, Mask(128, 128, mem[_8314])
                            mem[mem[64] len 352] = ext_call.return_data[0 len 352]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9110 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 352
                            _9160 = mem[64]
                            if mem[64] + 352 < mem[64] or mem[64] + 352 > test266151307():
                                revert with 0, 65
                            mem[64] = mem[64] + 352
                            require mem[_9110] == Mask(128, 128, mem[_9110])
                            mem[_9160] = mem[_9110]
                            mem[_9160 + 32] = mem[_9110 + 32]
                            mem[_9160 + 64] = mem[_9110 + 64]
                            mem[_9160 + 96] = mem[_9110 + 96]
                            require mem[_9110 + 128] < 5
                            mem[_9160 + 128] = mem[_9110 + 128]
                            mem[_9160 + 160] = mem[_9110 + 160]
                            mem[_9160 + 192] = mem[_9110 + 192]
                            mem[_9160 + 224] = mem[_9110 + 224]
                            mem[_9160 + 256] = mem[_9110 + 256]
                            mem[_9160 + 288] = mem[_9110 + 288]
                            mem[_9160 + 320] = mem[_9110 + 320]
                            if Mask(128, 128, mem[_9160]) != Mask(128, 128, _9010):
                                revert with 0, 'Address does not contain stake with provided id'
                            s = mem[_9160 + 192]
                            t = 0
                            while s < sub_ed73481d + 1:
                                staticcall sub_413c05c6Address.0x8ce1d9e4 with:
                                        gas gas_remaining wei
                                       args s
                                mem[mem[64] len 160] = ext_call.return_data[0 len 160]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _12646 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 160
                                _12786 = mem[64]
                                if mem[64] + 160 > test266151307() or mem[64] + 160 < mem[64]:
                                    revert with 0, 65
                                mem[64] = mem[64] + 160
                                mem[_12786] = mem[_12646]
                                mem[_12786 + 32] = mem[_12646 + 32]
                                mem[_12786 + 64] = mem[_12646 + 64]
                                mem[_12786 + 96] = mem[_12646 + 96]
                                mem[_12786 + 128] = mem[_12646 + 128]
                                _13188 = mem[_12786 + 64]
                                _13189 = mem[_12786 + 32]
                                _13190 = mem[_9160 + 64]
                                _13191 = mem[_12786]
                                _13192 = mem[_12786 + 128]
                                _13193 = mem[_12786 + 96]
                                if mem[_12786 + 96] > !mem[_12786 + 128]:
                                    revert with 0, 17
                                if mem[_12786 + 96] + mem[_12786 + 128] < mem[_12786 + 96]:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not mem[_12786 + 96] + mem[_12786 + 128]:
                                    _13599 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13599] = 26
                                    mem[_13599 + 32] = 'SafeMath: division by zero'
                                    if not _13189:
                                        _13686 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _13686 + 68] = mem[_13599 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13686 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _13686 + -mem[64] + 100
                                    _14062 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14062] = 26
                                    mem[_14062 + 32] = 'SafeMath: division by zero'
                                    if _13188:
                                        if t > !(0 / _13189 / _13188):
                                            revert with 0, 17
                                        if t + (0 / _13189 / _13188) < t:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if s == -1:
                                            revert with 0, 17
                                        s = s + 1
                                        t = t + (0 / _13189 / _13188)
                                        continue 
                                    _14228 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _14228 + 68] = mem[_14062 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14228 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14228 + -mem[64] + 100
                                if mem[_12786 + 96] + mem[_12786 + 128] and mem[_12786] > -1 / mem[_12786 + 96] + mem[_12786 + 128]:
                                    revert with 0, 17
                                if not mem[_12786 + 96] + mem[_12786 + 128]:
                                    revert with 0, 18
                                if (mem[_12786 + 96] * mem[_12786]) + (mem[_12786 + 128] * mem[_12786]) / mem[_12786 + 96] + mem[_12786 + 128] != mem[_12786]:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not (mem[_12786 + 96] * mem[_12786]) + (mem[_12786 + 128] * mem[_12786]):
                                    _13852 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13852] = 26
                                    mem[_13852 + 32] = 'SafeMath: division by zero'
                                    if not _13189:
                                        _14061 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _14061 + 68] = mem[_13852 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_14061 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _14061 + -mem[64] + 100
                                    _14529 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14529] = 26
                                    mem[_14529 + 32] = 'SafeMath: division by zero'
                                    if _13188:
                                        if t > !(0 / _13189 / _13188):
                                            revert with 0, 17
                                        if t + (0 / _13189 / _13188) < t:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if s == -1:
                                            revert with 0, 17
                                        s = s + 1
                                        t = t + (0 / _13189 / _13188)
                                        continue 
                                    _14739 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _14739 + 68] = mem[_14529 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14739 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14739 + -mem[64] + 100
                                if (mem[_12786 + 96] * mem[_12786]) + (mem[_12786 + 128] * mem[_12786]) and mem[_9160 + 64] > -1 / (mem[_12786 + 96] * mem[_12786]) + (mem[_12786 + 128] * mem[_12786]):
                                    revert with 0, 17
                                if not (mem[_12786 + 96] * mem[_12786]) + (mem[_12786 + 128] * mem[_12786]):
                                    revert with 0, 18
                                if (mem[_12786 + 96] * mem[_12786] * mem[_9160 + 64]) + (mem[_12786 + 128] * mem[_12786] * mem[_9160 + 64]) / (mem[_12786 + 96] * mem[_12786]) + (mem[_12786 + 128] * mem[_12786]) != mem[_9160 + 64]:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _14393 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14393] = 26
                                mem[_14393 + 32] = 'SafeMath: division by zero'
                                if not _13189:
                                    _14528 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _14528 + 68] = mem[_14393 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14528 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14528 + -mem[64] + 100
                                _14989 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14989] = 26
                                mem[_14989 + 32] = 'SafeMath: division by zero'
                                if _13188:
                                    if t > !((_13193 * _13191 * _13190) + (_13192 * _13191 * _13190) / _13189 / _13188):
                                        revert with 0, 17
                                    if t + ((_13193 * _13191 * _13190) + (_13192 * _13191 * _13190) / _13189 / _13188) < t:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s == -1:
                                        revert with 0, 17
                                    s = s + 1
                                    t = t + ((_13193 * _13191 * _13190) + (_13192 * _13191 * _13190) / _13189 / _13188)
                                    continue 
                                _15154 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _15154 + 68] = mem[_14989 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15154 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _15154 + -mem[64] + 100
                            _12644 = mem[_8314 + 32]
                            _12645 = mem[_8314 + 160]
                            if mem[_8314 + 160] > !t:
                                revert with 0, 17
                            if mem[_8314 + 160] + t < mem[_8314 + 160]:
                                revert with 0, 'SafeMath: addition overflow'
                            if mem[_8314 + 32] > !(mem[_8314 + 160] + t):
                                revert with 0, 17
                            if mem[_8314 + 32] + mem[_8314 + 160] + t < mem[_8314 + 32]:
                                revert with 0, 'SafeMath: addition overflow'
                            if not mem[_8314 + 32] + mem[_8314 + 160] + t:
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                            if not mem[_8314 + 32] + mem[_8314 + 160] + t:
                                _13716 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13716] = 26
                                mem[_13716 + 32] = 'SafeMath: division by zero'
                                if not DENOMINATOR:
                                    _13800 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _13800 + 68] = mem[_13716 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_13800 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _13800 + -mem[64] + 100
                                _14301 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14301] = 30
                                mem[_14301 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / DENOMINATOR <= sub_04b4a313:
                                    if sub_04b4a313 < 0 / DENOMINATOR:
                                        revert with 0, 17
                                    sub_04b4a313 -= 0 / DENOMINATOR
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                                _14437 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _14437 + 68] = mem[_14301 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14437 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14437 + -mem[64] + 100
                            if mem[_8314 + 32] + mem[_8314 + 160] + t and sub_d8830c7d > -1 / mem[_8314 + 32] + mem[_8314 + 160] + t:
                                revert with 0, 17
                            if not mem[_8314 + 32] + mem[_8314 + 160] + t:
                                revert with 0, 18
                            if (mem[_8314 + 32] * sub_d8830c7d) + (mem[_8314 + 160] * sub_d8830c7d) + (t * sub_d8830c7d) / mem[_8314 + 32] + mem[_8314 + 160] + t != sub_d8830c7d:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _14126 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14126] = 26
                            mem[_14126 + 32] = 'SafeMath: division by zero'
                            if not DENOMINATOR:
                                _14300 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _14300 + 68] = mem[_14126 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14300 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _14300 + -mem[64] + 100
                            _14804 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14804] = 30
                            mem[_14804 + 32] = 'SafeMath: subtraction overflow'
                            if (_12644 * sub_d8830c7d) + (_12645 * sub_d8830c7d) + (t * sub_d8830c7d) / DENOMINATOR <= sub_04b4a313:
                                if sub_04b4a313 < (_12644 * sub_d8830c7d) + (_12645 * sub_d8830c7d) + (t * sub_d8830c7d) / DENOMINATOR:
                                    revert with 0, 17
                                sub_04b4a313 -= (_12644 * sub_d8830c7d) + (_12645 * sub_d8830c7d) + (t * sub_d8830c7d) / DENOMINATOR
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                            _14920 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _14920 + 68] = mem[_14804 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_14920 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _14920 + -mem[64] + 100
                        _9008 = mem[_8314 + 224]
                        _9009 = mem[_8314 + 192]
                        if mem[_8314 + 192] > !mem[_8314 + 224]:
                            revert with 0, 17
                        if sub_ed73481d + 1 < mem[_8314 + 192] + mem[_8314 + 224]:
                            _9124 = mem[_8314]
                            staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                                    gas gas_remaining wei
                                   args sub_4c86259e[idx].field_0, Mask(128, 128, mem[_8314])
                            mem[mem[64] len 352] = ext_call.return_data[0 len 352]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9186 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 352
                            _9222 = mem[64]
                            if mem[64] + 352 < mem[64] or mem[64] + 352 > test266151307():
                                revert with 0, 65
                            mem[64] = mem[64] + 352
                            require mem[_9186] == Mask(128, 128, mem[_9186])
                            mem[_9222] = mem[_9186]
                            mem[_9222 + 32] = mem[_9186 + 32]
                            mem[_9222 + 64] = mem[_9186 + 64]
                            mem[_9222 + 96] = mem[_9186 + 96]
                            require mem[_9186 + 128] < 5
                            mem[_9222 + 128] = mem[_9186 + 128]
                            mem[_9222 + 160] = mem[_9186 + 160]
                            mem[_9222 + 192] = mem[_9186 + 192]
                            mem[_9222 + 224] = mem[_9186 + 224]
                            mem[_9222 + 256] = mem[_9186 + 256]
                            mem[_9222 + 288] = mem[_9186 + 288]
                            mem[_9222 + 320] = mem[_9186 + 320]
                            if Mask(128, 128, mem[_9222]) != Mask(128, 128, _9124):
                                revert with 0, 'Address does not contain stake with provided id'
                            s = mem[_9222 + 192]
                            t = 0
                            while s < _9009 + _9008:
                                staticcall sub_413c05c6Address.0x8ce1d9e4 with:
                                        gas gas_remaining wei
                                       args s
                                mem[mem[64] len 160] = ext_call.return_data[0 len 160]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _12641 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 160
                                _12782 = mem[64]
                                if mem[64] + 160 > test266151307() or mem[64] + 160 < mem[64]:
                                    revert with 0, 65
                                mem[64] = mem[64] + 160
                                mem[_12782] = mem[_12641]
                                mem[_12782 + 32] = mem[_12641 + 32]
                                mem[_12782 + 64] = mem[_12641 + 64]
                                mem[_12782 + 96] = mem[_12641 + 96]
                                mem[_12782 + 128] = mem[_12641 + 128]
                                _13174 = mem[_12782 + 64]
                                _13175 = mem[_12782 + 32]
                                _13176 = mem[_9222 + 64]
                                _13177 = mem[_12782]
                                _13178 = mem[_12782 + 128]
                                _13179 = mem[_12782 + 96]
                                if mem[_12782 + 96] > !mem[_12782 + 128]:
                                    revert with 0, 17
                                if mem[_12782 + 96] + mem[_12782 + 128] < mem[_12782 + 96]:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not mem[_12782 + 96] + mem[_12782 + 128]:
                                    _13593 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13593] = 26
                                    mem[_13593 + 32] = 'SafeMath: division by zero'
                                    if not _13175:
                                        _13684 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _13684 + 68] = mem[_13593 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13684 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _13684 + -mem[64] + 100
                                    _14050 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14050] = 26
                                    mem[_14050 + 32] = 'SafeMath: division by zero'
                                    if _13174:
                                        if t > !(0 / _13175 / _13174):
                                            revert with 0, 17
                                        if t + (0 / _13175 / _13174) < t:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if s == -1:
                                            revert with 0, 17
                                        s = s + 1
                                        t = t + (0 / _13175 / _13174)
                                        continue 
                                    _14220 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _14220 + 68] = mem[_14050 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14220 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14220 + -mem[64] + 100
                                if mem[_12782 + 96] + mem[_12782 + 128] and mem[_12782] > -1 / mem[_12782 + 96] + mem[_12782 + 128]:
                                    revert with 0, 17
                                if not mem[_12782 + 96] + mem[_12782 + 128]:
                                    revert with 0, 18
                                if (mem[_12782 + 96] * mem[_12782]) + (mem[_12782 + 128] * mem[_12782]) / mem[_12782 + 96] + mem[_12782 + 128] != mem[_12782]:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not (mem[_12782 + 96] * mem[_12782]) + (mem[_12782 + 128] * mem[_12782]):
                                    _13847 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13847] = 26
                                    mem[_13847 + 32] = 'SafeMath: division by zero'
                                    if not _13175:
                                        _14049 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _14049 + 68] = mem[_13847 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_14049 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _14049 + -mem[64] + 100
                                    _14520 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14520] = 26
                                    mem[_14520 + 32] = 'SafeMath: division by zero'
                                    if _13174:
                                        if t > !(0 / _13175 / _13174):
                                            revert with 0, 17
                                        if t + (0 / _13175 / _13174) < t:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if s == -1:
                                            revert with 0, 17
                                        s = s + 1
                                        t = t + (0 / _13175 / _13174)
                                        continue 
                                    _14727 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _14727 + 68] = mem[_14520 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14727 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14727 + -mem[64] + 100
                                if (mem[_12782 + 96] * mem[_12782]) + (mem[_12782 + 128] * mem[_12782]) and mem[_9222 + 64] > -1 / (mem[_12782 + 96] * mem[_12782]) + (mem[_12782 + 128] * mem[_12782]):
                                    revert with 0, 17
                                if not (mem[_12782 + 96] * mem[_12782]) + (mem[_12782 + 128] * mem[_12782]):
                                    revert with 0, 18
                                if (mem[_12782 + 96] * mem[_12782] * mem[_9222 + 64]) + (mem[_12782 + 128] * mem[_12782] * mem[_9222 + 64]) / (mem[_12782 + 96] * mem[_12782]) + (mem[_12782 + 128] * mem[_12782]) != mem[_9222 + 64]:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _14384 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14384] = 26
                                mem[_14384 + 32] = 'SafeMath: division by zero'
                                if not _13175:
                                    _14519 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _14519 + 68] = mem[_14384 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14519 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14519 + -mem[64] + 100
                                _14981 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14981] = 26
                                mem[_14981 + 32] = 'SafeMath: division by zero'
                                if _13174:
                                    if t > !((_13179 * _13177 * _13176) + (_13178 * _13177 * _13176) / _13175 / _13174):
                                        revert with 0, 17
                                    if t + ((_13179 * _13177 * _13176) + (_13178 * _13177 * _13176) / _13175 / _13174) < t:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s == -1:
                                        revert with 0, 17
                                    s = s + 1
                                    t = t + ((_13179 * _13177 * _13176) + (_13178 * _13177 * _13176) / _13175 / _13174)
                                    continue 
                                _15148 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _15148 + 68] = mem[_14981 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15148 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _15148 + -mem[64] + 100
                            if t >= mem[_8314 + 160]:
                                _12672 = mem[_8314]
                                staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                                        gas gas_remaining wei
                                       args sub_4c86259e[idx].field_0, Mask(128, 128, mem[_8314])
                                mem[mem[64] len 352] = ext_call.return_data[0 len 352]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _13256 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 352
                                _13292 = mem[64]
                                if mem[64] + 352 < mem[64] or mem[64] + 352 > test266151307():
                                    revert with 0, 65
                                mem[64] = mem[64] + 352
                                require mem[_13256] == Mask(128, 128, mem[_13256])
                                mem[_13292] = mem[_13256]
                                mem[_13292 + 32] = mem[_13256 + 32]
                                mem[_13292 + 64] = mem[_13256 + 64]
                                mem[_13292 + 96] = mem[_13256 + 96]
                                require mem[_13256 + 128] < 5
                                mem[_13292 + 128] = mem[_13256 + 128]
                                mem[_13292 + 160] = mem[_13256 + 160]
                                mem[_13292 + 192] = mem[_13256 + 192]
                                mem[_13292 + 224] = mem[_13256 + 224]
                                mem[_13292 + 256] = mem[_13256 + 256]
                                mem[_13292 + 288] = mem[_13256 + 288]
                                mem[_13292 + 320] = mem[_13256 + 320]
                                if Mask(128, 128, mem[_13292]) != Mask(128, 128, _12672):
                                    revert with 0, 'Address does not contain stake with provided id'
                                s = mem[_13292 + 192]
                                t = 0
                                while s < sub_ed73481d + 1:
                                    staticcall sub_413c05c6Address.0x8ce1d9e4 with:
                                            gas gas_remaining wei
                                           args s
                                    mem[mem[64] len 160] = ext_call.return_data[0 len 160]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _17135 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 160
                                    _17274 = mem[64]
                                    if mem[64] + 160 > test266151307() or mem[64] + 160 < mem[64]:
                                        revert with 0, 65
                                    mem[64] = mem[64] + 160
                                    mem[_17274] = mem[_17135]
                                    mem[_17274 + 32] = mem[_17135 + 32]
                                    mem[_17274 + 64] = mem[_17135 + 64]
                                    mem[_17274 + 96] = mem[_17135 + 96]
                                    mem[_17274 + 128] = mem[_17135 + 128]
                                    _17682 = mem[_17274 + 64]
                                    _17683 = mem[_17274 + 32]
                                    _17684 = mem[_13292 + 64]
                                    _17685 = mem[_17274]
                                    _17686 = mem[_17274 + 128]
                                    _17687 = mem[_17274 + 96]
                                    if mem[_17274 + 96] > !mem[_17274 + 128]:
                                        revert with 0, 17
                                    if mem[_17274 + 96] + mem[_17274 + 128] < mem[_17274 + 96]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not mem[_17274 + 96] + mem[_17274 + 128]:
                                        _17855 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17855] = 26
                                        mem[_17855 + 32] = 'SafeMath: division by zero'
                                        if not _17683:
                                            _17911 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _17911 + 68] = mem[_17855 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_17911 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _17911 + -mem[64] + 100
                                        _18095 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_18095] = 26
                                        mem[_18095 + 32] = 'SafeMath: division by zero'
                                        if _17682:
                                            if t > !(0 / _17683 / _17682):
                                                revert with 0, 17
                                            if t + (0 / _17683 / _17682) < t:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if s == -1:
                                                revert with 0, 17
                                            s = s + 1
                                            t = t + (0 / _17683 / _17682)
                                            continue 
                                        _18208 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _18208 + 68] = mem[_18095 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_18208 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _18208 + -mem[64] + 100
                                    if mem[_17274 + 96] + mem[_17274 + 128] and mem[_17274] > -1 / mem[_17274 + 96] + mem[_17274 + 128]:
                                        revert with 0, 17
                                    if not mem[_17274 + 96] + mem[_17274 + 128]:
                                        revert with 0, 18
                                    if (mem[_17274 + 96] * mem[_17274]) + (mem[_17274 + 128] * mem[_17274]) / mem[_17274 + 96] + mem[_17274 + 128] != mem[_17274]:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not (mem[_17274 + 96] * mem[_17274]) + (mem[_17274 + 128] * mem[_17274]):
                                        _18011 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_18011] = 26
                                        mem[_18011 + 32] = 'SafeMath: division by zero'
                                        if not _17683:
                                            _18094 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _18094 + 68] = mem[_18011 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_18094 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _18094 + -mem[64] + 100
                                        _18432 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_18432] = 26
                                        mem[_18432 + 32] = 'SafeMath: division by zero'
                                        if _17682:
                                            if t > !(0 / _17683 / _17682):
                                                revert with 0, 17
                                            if t + (0 / _17683 / _17682) < t:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if s == -1:
                                                revert with 0, 17
                                            s = s + 1
                                            t = t + (0 / _17683 / _17682)
                                            continue 
                                        _18543 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _18543 + 68] = mem[_18432 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_18543 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _18543 + -mem[64] + 100
                                    if (mem[_17274 + 96] * mem[_17274]) + (mem[_17274 + 128] * mem[_17274]) and mem[_13292 + 64] > -1 / (mem[_17274 + 96] * mem[_17274]) + (mem[_17274 + 128] * mem[_17274]):
                                        revert with 0, 17
                                    if not (mem[_17274 + 96] * mem[_17274]) + (mem[_17274 + 128] * mem[_17274]):
                                        revert with 0, 18
                                    if (mem[_17274 + 96] * mem[_17274] * mem[_13292 + 64]) + (mem[_17274 + 128] * mem[_17274] * mem[_13292 + 64]) / (mem[_17274 + 96] * mem[_17274]) + (mem[_17274 + 128] * mem[_17274]) != mem[_13292 + 64]:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _18319 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18319] = 26
                                    mem[_18319 + 32] = 'SafeMath: division by zero'
                                    if not _17683:
                                        _18431 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _18431 + 68] = mem[_18319 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_18431 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _18431 + -mem[64] + 100
                                    _18735 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18735] = 26
                                    mem[_18735 + 32] = 'SafeMath: division by zero'
                                    if _17682:
                                        if t > !((_17687 * _17685 * _17684) + (_17686 * _17685 * _17684) / _17683 / _17682):
                                            revert with 0, 17
                                        if t + ((_17687 * _17685 * _17684) + (_17686 * _17685 * _17684) / _17683 / _17682) < t:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if s == -1:
                                            revert with 0, 17
                                        s = s + 1
                                        t = t + ((_17687 * _17685 * _17684) + (_17686 * _17685 * _17684) / _17683 / _17682)
                                        continue 
                                    _18838 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _18838 + 68] = mem[_18735 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_18838 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _18838 + -mem[64] + 100
                                _17134 = mem[_8314 + 32]
                                if mem[_8314 + 32] > !t:
                                    revert with 0, 17
                                if mem[_8314 + 32] + t < mem[_8314 + 32]:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not mem[_8314 + 32] + t:
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                                if not mem[_8314 + 32] + t:
                                    _17814 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17814] = 26
                                    mem[_17814 + 32] = 'SafeMath: division by zero'
                                    if not DENOMINATOR:
                                        _17830 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _17830 + 68] = mem[_17814 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_17830 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _17830 + -mem[64] + 100
                                    _17975 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17975] = 30
                                    mem[_17975 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 / DENOMINATOR <= sub_04b4a313:
                                        if sub_04b4a313 < 0 / DENOMINATOR:
                                            revert with 0, 17
                                        sub_04b4a313 -= 0 / DENOMINATOR
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    _18043 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _18043 + 68] = mem[_17975 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_18043 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _18043 + -mem[64] + 100
                                if mem[_8314 + 32] + t and sub_d8830c7d > -1 / mem[_8314 + 32] + t:
                                    revert with 0, 17
                                if not mem[_8314 + 32] + t:
                                    revert with 0, 18
                                if (mem[_8314 + 32] * sub_d8830c7d) + (t * sub_d8830c7d) / mem[_8314 + 32] + t != sub_d8830c7d:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _17926 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_17926] = 26
                                mem[_17926 + 32] = 'SafeMath: division by zero'
                                if not DENOMINATOR:
                                    _17974 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _17974 + 68] = mem[_17926 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_17974 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _17974 + -mem[64] + 100
                                _18262 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18262] = 30
                                mem[_18262 + 32] = 'SafeMath: subtraction overflow'
                                if (_17134 * sub_d8830c7d) + (t * sub_d8830c7d) / DENOMINATOR <= sub_04b4a313:
                                    if sub_04b4a313 < (_17134 * sub_d8830c7d) + (t * sub_d8830c7d) / DENOMINATOR:
                                        revert with 0, 17
                                    sub_04b4a313 -= (_17134 * sub_d8830c7d) + (t * sub_d8830c7d) / DENOMINATOR
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                                _18374 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _18374 + 68] = mem[_18262 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_18374 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _18374 + -mem[64] + 100
                            _12673 = mem[_8314 + 160]
                            _12781 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12781] = 30
                            mem[_12781 + 32] = 'SafeMath: subtraction overflow'
                            if t > _12673:
                                _13173 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _13173 + 68] = mem[_12781 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13173 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13173 + -mem[64] + 100
                            if _12673 < t:
                                revert with 0, 17
                            _13328 = mem[_8314]
                            staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                                    gas gas_remaining wei
                                   args sub_4c86259e[idx].field_0, Mask(128, 128, mem[_8314])
                            mem[mem[64] len 352] = ext_call.return_data[0 len 352]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _13430 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 352
                            _13487 = mem[64]
                            if mem[64] + 352 < mem[64] or mem[64] + 352 > test266151307():
                                revert with 0, 65
                            mem[64] = mem[64] + 352
                            require mem[_13430] == Mask(128, 128, mem[_13430])
                            mem[_13487] = mem[_13430]
                            mem[_13487 + 32] = mem[_13430 + 32]
                            mem[_13487 + 64] = mem[_13430 + 64]
                            mem[_13487 + 96] = mem[_13430 + 96]
                            require mem[_13430 + 128] < 5
                            mem[_13487 + 128] = mem[_13430 + 128]
                            mem[_13487 + 160] = mem[_13430 + 160]
                            mem[_13487 + 192] = mem[_13430 + 192]
                            mem[_13487 + 224] = mem[_13430 + 224]
                            mem[_13487 + 256] = mem[_13430 + 256]
                            mem[_13487 + 288] = mem[_13430 + 288]
                            mem[_13487 + 320] = mem[_13430 + 320]
                            if Mask(128, 128, mem[_13487]) != Mask(128, 128, _13328):
                                revert with 0, 'Address does not contain stake with provided id'
                            s = mem[_13487 + 192]
                            u = 0
                            while s < sub_ed73481d + 1:
                                staticcall sub_413c05c6Address.0x8ce1d9e4 with:
                                        gas gas_remaining wei
                                       args s
                                mem[mem[64] len 160] = ext_call.return_data[0 len 160]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _17137 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 160
                                _17275 = mem[64]
                                if mem[64] + 160 > test266151307() or mem[64] + 160 < mem[64]:
                                    revert with 0, 65
                                mem[64] = mem[64] + 160
                                mem[_17275] = mem[_17137]
                                mem[_17275 + 32] = mem[_17137 + 32]
                                mem[_17275 + 64] = mem[_17137 + 64]
                                mem[_17275 + 96] = mem[_17137 + 96]
                                mem[_17275 + 128] = mem[_17137 + 128]
                                _17688 = mem[_17275 + 64]
                                _17689 = mem[_17275 + 32]
                                _17690 = mem[_13487 + 64]
                                _17691 = mem[_17275]
                                _17692 = mem[_17275 + 128]
                                _17693 = mem[_17275 + 96]
                                if mem[_17275 + 96] > !mem[_17275 + 128]:
                                    revert with 0, 17
                                if mem[_17275 + 96] + mem[_17275 + 128] < mem[_17275 + 96]:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not mem[_17275 + 96] + mem[_17275 + 128]:
                                    _17857 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17857] = 26
                                    mem[_17857 + 32] = 'SafeMath: division by zero'
                                    if not _17689:
                                        _17912 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _17912 + 68] = mem[_17857 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_17912 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _17912 + -mem[64] + 100
                                    _18098 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18098] = 26
                                    mem[_18098 + 32] = 'SafeMath: division by zero'
                                    if _17688:
                                        if u > !(0 / _17689 / _17688):
                                            revert with 0, 17
                                        if u + (0 / _17689 / _17688) < u:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if s == -1:
                                            revert with 0, 17
                                        s = s + 1
                                        u = u + (0 / _17689 / _17688)
                                        continue 
                                    _18212 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _18212 + 68] = mem[_18098 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_18212 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _18212 + -mem[64] + 100
                                if mem[_17275 + 96] + mem[_17275 + 128] and mem[_17275] > -1 / mem[_17275 + 96] + mem[_17275 + 128]:
                                    revert with 0, 17
                                if not mem[_17275 + 96] + mem[_17275 + 128]:
                                    revert with 0, 18
                                if (mem[_17275 + 96] * mem[_17275]) + (mem[_17275 + 128] * mem[_17275]) / mem[_17275 + 96] + mem[_17275 + 128] != mem[_17275]:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not (mem[_17275 + 96] * mem[_17275]) + (mem[_17275 + 128] * mem[_17275]):
                                    _18013 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18013] = 26
                                    mem[_18013 + 32] = 'SafeMath: division by zero'
                                    if not _17689:
                                        _18097 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _18097 + 68] = mem[_18013 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_18097 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _18097 + -mem[64] + 100
                                    _18435 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18435] = 26
                                    mem[_18435 + 32] = 'SafeMath: division by zero'
                                    if _17688:
                                        if u > !(0 / _17689 / _17688):
                                            revert with 0, 17
                                        if u + (0 / _17689 / _17688) < u:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if s == -1:
                                            revert with 0, 17
                                        s = s + 1
                                        u = u + (0 / _17689 / _17688)
                                        continue 
                                    _18546 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _18546 + 68] = mem[_18435 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_18546 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _18546 + -mem[64] + 100
                                if (mem[_17275 + 96] * mem[_17275]) + (mem[_17275 + 128] * mem[_17275]) and mem[_13487 + 64] > -1 / (mem[_17275 + 96] * mem[_17275]) + (mem[_17275 + 128] * mem[_17275]):
                                    revert with 0, 17
                                if not (mem[_17275 + 96] * mem[_17275]) + (mem[_17275 + 128] * mem[_17275]):
                                    revert with 0, 18
                                if (mem[_17275 + 96] * mem[_17275] * mem[_13487 + 64]) + (mem[_17275 + 128] * mem[_17275] * mem[_13487 + 64]) / (mem[_17275 + 96] * mem[_17275]) + (mem[_17275 + 128] * mem[_17275]) != mem[_13487 + 64]:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _18323 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18323] = 26
                                mem[_18323 + 32] = 'SafeMath: division by zero'
                                if not _17689:
                                    _18434 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _18434 + 68] = mem[_18323 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_18434 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _18434 + -mem[64] + 100
                                _18739 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18739] = 26
                                mem[_18739 + 32] = 'SafeMath: division by zero'
                                if _17688:
                                    if u > !((_17693 * _17691 * _17690) + (_17692 * _17691 * _17690) / _17689 / _17688):
                                        revert with 0, 17
                                    if u + ((_17693 * _17691 * _17690) + (_17692 * _17691 * _17690) / _17689 / _17688) < u:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s == -1:
                                        revert with 0, 17
                                    s = s + 1
                                    u = u + ((_17693 * _17691 * _17690) + (_17692 * _17691 * _17690) / _17689 / _17688)
                                    continue 
                                _18840 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _18840 + 68] = mem[_18739 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_18840 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _18840 + -mem[64] + 100
                            _17136 = mem[_8314 + 32]
                            if _12673 - t > !u:
                                revert with 0, 17
                            if u < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if mem[_8314 + 32] > !(_12673 - t + u):
                                revert with 0, 17
                            if mem[_8314 + 32] + _12673 - t + u < mem[_8314 + 32]:
                                revert with 0, 'SafeMath: addition overflow'
                            if not mem[_8314 + 32] + _12673 - t + u:
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                            if not mem[_8314 + 32] + _12673 - t + u:
                                _17928 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_17928] = 26
                                mem[_17928 + 32] = 'SafeMath: division by zero'
                                if not DENOMINATOR:
                                    _17976 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _17976 + 68] = mem[_17928 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_17976 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _17976 + -mem[64] + 100
                                _18266 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18266] = 30
                                mem[_18266 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / DENOMINATOR <= sub_04b4a313:
                                    if sub_04b4a313 < 0 / DENOMINATOR:
                                        revert with 0, 17
                                    sub_04b4a313 -= 0 / DENOMINATOR
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                                _18377 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _18377 + 68] = mem[_18266 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_18377 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _18377 + -mem[64] + 100
                            if mem[_8314 + 32] + _12673 - t + u and sub_d8830c7d > -1 / mem[_8314 + 32] + _12673 - t + u:
                                revert with 0, 17
                            if not mem[_8314 + 32] + _12673 - t + u:
                                revert with 0, 18
                            if (mem[_8314 + 32] * sub_d8830c7d) + (_12673 * sub_d8830c7d) - (t * sub_d8830c7d) + (u * sub_d8830c7d) / mem[_8314 + 32] + _12673 - t + u != sub_d8830c7d:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _18137 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_18137] = 26
                            mem[_18137 + 32] = 'SafeMath: division by zero'
                            if not DENOMINATOR:
                                _18265 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _18265 + 68] = mem[_18137 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_18265 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _18265 + -mem[64] + 100
                            _18600 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_18600] = 30
                            mem[_18600 + 32] = 'SafeMath: subtraction overflow'
                            if (_17136 * sub_d8830c7d) + (_12673 * sub_d8830c7d) - (t * sub_d8830c7d) + (u * sub_d8830c7d) / DENOMINATOR <= sub_04b4a313:
                                if sub_04b4a313 < (_17136 * sub_d8830c7d) + (_12673 * sub_d8830c7d) - (t * sub_d8830c7d) + (u * sub_d8830c7d) / DENOMINATOR:
                                    revert with 0, 17
                                sub_04b4a313 -= (_17136 * sub_d8830c7d) + (_12673 * sub_d8830c7d) - (t * sub_d8830c7d) + (u * sub_d8830c7d) / DENOMINATOR
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                            _18698 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _18698 + 68] = mem[_18600 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_18698 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _18698 + -mem[64] + 100
                        _9125 = mem[_8314]
                        staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                                gas gas_remaining wei
                               args sub_4c86259e[idx].field_0, Mask(128, 128, mem[_8314])
                        mem[mem[64] len 352] = ext_call.return_data[0 len 352]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _9187 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 352
                        _9223 = mem[64]
                        if mem[64] + 352 < mem[64] or mem[64] + 352 > test266151307():
                            revert with 0, 65
                        mem[64] = mem[64] + 352
                        require mem[_9187] == Mask(128, 128, mem[_9187])
                        mem[_9223] = mem[_9187]
                        mem[_9223 + 32] = mem[_9187 + 32]
                        mem[_9223 + 64] = mem[_9187 + 64]
                        mem[_9223 + 96] = mem[_9187 + 96]
                        require mem[_9187 + 128] < 5
                        mem[_9223 + 128] = mem[_9187 + 128]
                        mem[_9223 + 160] = mem[_9187 + 160]
                        mem[_9223 + 192] = mem[_9187 + 192]
                        mem[_9223 + 224] = mem[_9187 + 224]
                        mem[_9223 + 256] = mem[_9187 + 256]
                        mem[_9223 + 288] = mem[_9187 + 288]
                        mem[_9223 + 320] = mem[_9187 + 320]
                        if Mask(128, 128, mem[_9223]) != Mask(128, 128, _9125):
                            revert with 0, 'Address does not contain stake with provided id'
                        s = mem[_9223 + 192]
                        t = 0
                        while s < _9009 + _9008:
                            staticcall sub_413c05c6Address.0x8ce1d9e4 with:
                                    gas gas_remaining wei
                                   args s
                            mem[mem[64] len 160] = ext_call.return_data[0 len 160]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _12643 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 160
                            _12785 = mem[64]
                            if mem[64] + 160 > test266151307() or mem[64] + 160 < mem[64]:
                                revert with 0, 65
                            mem[64] = mem[64] + 160
                            mem[_12785] = mem[_12643]
                            mem[_12785 + 32] = mem[_12643 + 32]
                            mem[_12785 + 64] = mem[_12643 + 64]
                            mem[_12785 + 96] = mem[_12643 + 96]
                            mem[_12785 + 128] = mem[_12643 + 128]
                            _13182 = mem[_12785 + 64]
                            _13183 = mem[_12785 + 32]
                            _13184 = mem[_9223 + 64]
                            _13185 = mem[_12785]
                            _13186 = mem[_12785 + 128]
                            _13187 = mem[_12785 + 96]
                            if mem[_12785 + 96] > !mem[_12785 + 128]:
                                revert with 0, 17
                            if mem[_12785 + 96] + mem[_12785 + 128] < mem[_12785 + 96]:
                                revert with 0, 'SafeMath: addition overflow'
                            if not mem[_12785 + 96] + mem[_12785 + 128]:
                                _13597 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13597] = 26
                                mem[_13597 + 32] = 'SafeMath: division by zero'
                                if not _13183:
                                    _13685 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _13685 + 68] = mem[_13597 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_13685 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _13685 + -mem[64] + 100
                                _14059 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14059] = 26
                                mem[_14059 + 32] = 'SafeMath: division by zero'
                                if _13182:
                                    if t > !(0 / _13183 / _13182):
                                        revert with 0, 17
                                    if t + (0 / _13183 / _13182) < t:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s == -1:
                                        revert with 0, 17
                                    s = s + 1
                                    t = t + (0 / _13183 / _13182)
                                    continue 
                                _14224 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _14224 + 68] = mem[_14059 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14224 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _14224 + -mem[64] + 100
                            if mem[_12785 + 96] + mem[_12785 + 128] and mem[_12785] > -1 / mem[_12785 + 96] + mem[_12785 + 128]:
                                revert with 0, 17
                            if not mem[_12785 + 96] + mem[_12785 + 128]:
                                revert with 0, 18
                            if (mem[_12785 + 96] * mem[_12785]) + (mem[_12785 + 128] * mem[_12785]) / mem[_12785 + 96] + mem[_12785 + 128] != mem[_12785]:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not (mem[_12785 + 96] * mem[_12785]) + (mem[_12785 + 128] * mem[_12785]):
                                _13850 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13850] = 26
                                mem[_13850 + 32] = 'SafeMath: division by zero'
                                if not _13183:
                                    _14058 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _14058 + 68] = mem[_13850 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14058 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14058 + -mem[64] + 100
                                _14526 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14526] = 26
                                mem[_14526 + 32] = 'SafeMath: division by zero'
                                if _13182:
                                    if t > !(0 / _13183 / _13182):
                                        revert with 0, 17
                                    if t + (0 / _13183 / _13182) < t:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s == -1:
                                        revert with 0, 17
                                    s = s + 1
                                    t = t + (0 / _13183 / _13182)
                                    continue 
                                _14736 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _14736 + 68] = mem[_14526 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14736 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _14736 + -mem[64] + 100
                            if (mem[_12785 + 96] * mem[_12785]) + (mem[_12785 + 128] * mem[_12785]) and mem[_9223 + 64] > -1 / (mem[_12785 + 96] * mem[_12785]) + (mem[_12785 + 128] * mem[_12785]):
                                revert with 0, 17
                            if not (mem[_12785 + 96] * mem[_12785]) + (mem[_12785 + 128] * mem[_12785]):
                                revert with 0, 18
                            if (mem[_12785 + 96] * mem[_12785] * mem[_9223 + 64]) + (mem[_12785 + 128] * mem[_12785] * mem[_9223 + 64]) / (mem[_12785 + 96] * mem[_12785]) + (mem[_12785 + 128] * mem[_12785]) != mem[_9223 + 64]:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _14389 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14389] = 26
                            mem[_14389 + 32] = 'SafeMath: division by zero'
                            if not _13183:
                                _14525 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _14525 + 68] = mem[_14389 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14525 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _14525 + -mem[64] + 100
                            _14985 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14985] = 26
                            mem[_14985 + 32] = 'SafeMath: division by zero'
                            if _13182:
                                if t > !((_13187 * _13185 * _13184) + (_13186 * _13185 * _13184) / _13183 / _13182):
                                    revert with 0, 17
                                if t + ((_13187 * _13185 * _13184) + (_13186 * _13185 * _13184) / _13183 / _13182) < t:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s == -1:
                                    revert with 0, 17
                                s = s + 1
                                t = t + ((_13187 * _13185 * _13184) + (_13186 * _13185 * _13184) / _13183 / _13182)
                                continue 
                            _15152 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _15152 + 68] = mem[_14985 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_15152 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _15152 + -mem[64] + 100
                        if t >= mem[_8314 + 160]:
                            _12674 = mem[_8314]
                            staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                                    gas gas_remaining wei
                                   args sub_4c86259e[idx].field_0, Mask(128, 128, mem[_8314])
                            mem[mem[64] len 352] = ext_call.return_data[0 len 352]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _13257 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 352
                            _13294 = mem[64]
                            if mem[64] + 352 < mem[64] or mem[64] + 352 > test266151307():
                                revert with 0, 65
                            mem[64] = mem[64] + 352
                            require mem[_13257] == Mask(128, 128, mem[_13257])
                            mem[_13294] = mem[_13257]
                            mem[_13294 + 32] = mem[_13257 + 32]
                            mem[_13294 + 64] = mem[_13257 + 64]
                            mem[_13294 + 96] = mem[_13257 + 96]
                            require mem[_13257 + 128] < 5
                            mem[_13294 + 128] = mem[_13257 + 128]
                            mem[_13294 + 160] = mem[_13257 + 160]
                            mem[_13294 + 192] = mem[_13257 + 192]
                            mem[_13294 + 224] = mem[_13257 + 224]
                            mem[_13294 + 256] = mem[_13257 + 256]
                            mem[_13294 + 288] = mem[_13257 + 288]
                            mem[_13294 + 320] = mem[_13257 + 320]
                            if Mask(128, 128, mem[_13294]) != Mask(128, 128, _12674):
                                revert with 0, 'Address does not contain stake with provided id'
                            s = mem[_13294 + 192]
                            t = 0
                            while s < _9009 + _9008:
                                staticcall sub_413c05c6Address.0x8ce1d9e4 with:
                                        gas gas_remaining wei
                                       args s
                                mem[mem[64] len 160] = ext_call.return_data[0 len 160]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _17139 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 160
                                _17283 = mem[64]
                                if mem[64] + 160 > test266151307() or mem[64] + 160 < mem[64]:
                                    revert with 0, 65
                                mem[64] = mem[64] + 160
                                mem[_17283] = mem[_17139]
                                mem[_17283 + 32] = mem[_17139 + 32]
                                mem[_17283 + 64] = mem[_17139 + 64]
                                mem[_17283 + 96] = mem[_17139 + 96]
                                mem[_17283 + 128] = mem[_17139 + 128]
                                _17694 = mem[_17283 + 64]
                                _17695 = mem[_17283 + 32]
                                _17696 = mem[_13294 + 64]
                                _17697 = mem[_17283]
                                _17698 = mem[_17283 + 128]
                                _17699 = mem[_17283 + 96]
                                if mem[_17283 + 96] > !mem[_17283 + 128]:
                                    revert with 0, 17
                                if mem[_17283 + 96] + mem[_17283 + 128] < mem[_17283 + 96]:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not mem[_17283 + 96] + mem[_17283 + 128]:
                                    _17859 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17859] = 26
                                    mem[_17859 + 32] = 'SafeMath: division by zero'
                                    if not _17695:
                                        _17914 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _17914 + 68] = mem[_17859 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_17914 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _17914 + -mem[64] + 100
                                    _18100 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18100] = 26
                                    mem[_18100 + 32] = 'SafeMath: division by zero'
                                    if _17694:
                                        if t > !(0 / _17695 / _17694):
                                            revert with 0, 17
                                        if t + (0 / _17695 / _17694) < t:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if s == -1:
                                            revert with 0, 17
                                        s = s + 1
                                        t = t + (0 / _17695 / _17694)
                                        continue 
                                    _18216 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _18216 + 68] = mem[_18100 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_18216 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _18216 + -mem[64] + 100
                                if mem[_17283 + 96] + mem[_17283 + 128] and mem[_17283] > -1 / mem[_17283 + 96] + mem[_17283 + 128]:
                                    revert with 0, 17
                                if not mem[_17283 + 96] + mem[_17283 + 128]:
                                    revert with 0, 18
                                if (mem[_17283 + 96] * mem[_17283]) + (mem[_17283 + 128] * mem[_17283]) / mem[_17283 + 96] + mem[_17283 + 128] != mem[_17283]:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not (mem[_17283 + 96] * mem[_17283]) + (mem[_17283 + 128] * mem[_17283]):
                                    _18016 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18016] = 26
                                    mem[_18016 + 32] = 'SafeMath: division by zero'
                                    if not _17695:
                                        _18099 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _18099 + 68] = mem[_18016 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_18099 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _18099 + -mem[64] + 100
                                    _18439 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18439] = 26
                                    mem[_18439 + 32] = 'SafeMath: division by zero'
                                    if _17694:
                                        if t > !(0 / _17695 / _17694):
                                            revert with 0, 17
                                        if t + (0 / _17695 / _17694) < t:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if s == -1:
                                            revert with 0, 17
                                        s = s + 1
                                        t = t + (0 / _17695 / _17694)
                                        continue 
                                    _18549 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _18549 + 68] = mem[_18439 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_18549 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _18549 + -mem[64] + 100
                                if (mem[_17283 + 96] * mem[_17283]) + (mem[_17283 + 128] * mem[_17283]) and mem[_13294 + 64] > -1 / (mem[_17283 + 96] * mem[_17283]) + (mem[_17283 + 128] * mem[_17283]):
                                    revert with 0, 17
                                if not (mem[_17283 + 96] * mem[_17283]) + (mem[_17283 + 128] * mem[_17283]):
                                    revert with 0, 18
                                if (mem[_17283 + 96] * mem[_17283] * mem[_13294 + 64]) + (mem[_17283 + 128] * mem[_17283] * mem[_13294 + 64]) / (mem[_17283 + 96] * mem[_17283]) + (mem[_17283 + 128] * mem[_17283]) != mem[_13294 + 64]:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _18327 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18327] = 26
                                mem[_18327 + 32] = 'SafeMath: division by zero'
                                if not _17695:
                                    _18438 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _18438 + 68] = mem[_18327 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_18438 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _18438 + -mem[64] + 100
                                _18743 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18743] = 26
                                mem[_18743 + 32] = 'SafeMath: division by zero'
                                if _17694:
                                    if t > !((_17699 * _17697 * _17696) + (_17698 * _17697 * _17696) / _17695 / _17694):
                                        revert with 0, 17
                                    if t + ((_17699 * _17697 * _17696) + (_17698 * _17697 * _17696) / _17695 / _17694) < t:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s == -1:
                                        revert with 0, 17
                                    s = s + 1
                                    t = t + ((_17699 * _17697 * _17696) + (_17698 * _17697 * _17696) / _17695 / _17694)
                                    continue 
                                _18842 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _18842 + 68] = mem[_18743 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_18842 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _18842 + -mem[64] + 100
                            _17138 = mem[_8314 + 32]
                            if mem[_8314 + 32] > !t:
                                revert with 0, 17
                            if mem[_8314 + 32] + t < mem[_8314 + 32]:
                                revert with 0, 'SafeMath: addition overflow'
                            if not mem[_8314 + 32] + t:
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                            if not mem[_8314 + 32] + t:
                                _17816 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_17816] = 26
                                mem[_17816 + 32] = 'SafeMath: division by zero'
                                if not DENOMINATOR:
                                    _17831 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _17831 + 68] = mem[_17816 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_17831 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _17831 + -mem[64] + 100
                                _17978 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_17978] = 30
                                mem[_17978 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / DENOMINATOR <= sub_04b4a313:
                                    if sub_04b4a313 < 0 / DENOMINATOR:
                                        revert with 0, 17
                                    sub_04b4a313 -= 0 / DENOMINATOR
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                                _18048 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _18048 + 68] = mem[_17978 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_18048 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _18048 + -mem[64] + 100
                            if mem[_8314 + 32] + t and sub_d8830c7d > -1 / mem[_8314 + 32] + t:
                                revert with 0, 17
                            if not mem[_8314 + 32] + t:
                                revert with 0, 18
                            if (mem[_8314 + 32] * sub_d8830c7d) + (t * sub_d8830c7d) / mem[_8314 + 32] + t != sub_d8830c7d:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _17929 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_17929] = 26
                            mem[_17929 + 32] = 'SafeMath: division by zero'
                            if not DENOMINATOR:
                                _17977 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _17977 + 68] = mem[_17929 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_17977 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _17977 + -mem[64] + 100
                            _18268 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_18268] = 30
                            mem[_18268 + 32] = 'SafeMath: subtraction overflow'
                            if (_17138 * sub_d8830c7d) + (t * sub_d8830c7d) / DENOMINATOR <= sub_04b4a313:
                                if sub_04b4a313 < (_17138 * sub_d8830c7d) + (t * sub_d8830c7d) / DENOMINATOR:
                                    revert with 0, 17
                                sub_04b4a313 -= (_17138 * sub_d8830c7d) + (t * sub_d8830c7d) / DENOMINATOR
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                            _18379 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _18379 + 68] = mem[_18268 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_18379 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _18379 + -mem[64] + 100
                        _12675 = mem[_8314 + 160]
                        _12784 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12784] = 30
                        mem[_12784 + 32] = 'SafeMath: subtraction overflow'
                        if t > _12675:
                            _13181 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13181 + 68] = mem[_12784 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_13181 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13181 + -mem[64] + 100
                        if _12675 < t:
                            revert with 0, 17
                        _13330 = mem[_8314]
                        staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                                gas gas_remaining wei
                               args sub_4c86259e[idx].field_0, Mask(128, 128, mem[_8314])
                        mem[mem[64] len 352] = ext_call.return_data[0 len 352]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _13431 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 352
                        _13489 = mem[64]
                        if mem[64] + 352 < mem[64] or mem[64] + 352 > test266151307():
                            revert with 0, 65
                        mem[64] = mem[64] + 352
                        require mem[_13431] == Mask(128, 128, mem[_13431])
                        mem[_13489] = mem[_13431]
                        mem[_13489 + 32] = mem[_13431 + 32]
                        mem[_13489 + 64] = mem[_13431 + 64]
                        mem[_13489 + 96] = mem[_13431 + 96]
                        require mem[_13431 + 128] < 5
                        mem[_13489 + 128] = mem[_13431 + 128]
                        mem[_13489 + 160] = mem[_13431 + 160]
                        mem[_13489 + 192] = mem[_13431 + 192]
                        mem[_13489 + 224] = mem[_13431 + 224]
                        mem[_13489 + 256] = mem[_13431 + 256]
                        mem[_13489 + 288] = mem[_13431 + 288]
                        mem[_13489 + 320] = mem[_13431 + 320]
                        if Mask(128, 128, mem[_13489]) != Mask(128, 128, _13330):
                            revert with 0, 'Address does not contain stake with provided id'
                        s = mem[_13489 + 192]
                        u = 0
                        while s < _9009 + _9008:
                            staticcall sub_413c05c6Address.0x8ce1d9e4 with:
                                    gas gas_remaining wei
                                   args s
                            mem[mem[64] len 160] = ext_call.return_data[0 len 160]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _17141 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 160
                            _17284 = mem[64]
                            if mem[64] + 160 > test266151307() or mem[64] + 160 < mem[64]:
                                revert with 0, 65
                            mem[64] = mem[64] + 160
                            mem[_17284] = mem[_17141]
                            mem[_17284 + 32] = mem[_17141 + 32]
                            mem[_17284 + 64] = mem[_17141 + 64]
                            mem[_17284 + 96] = mem[_17141 + 96]
                            mem[_17284 + 128] = mem[_17141 + 128]
                            _17700 = mem[_17284 + 64]
                            _17701 = mem[_17284 + 32]
                            _17702 = mem[_13489 + 64]
                            _17703 = mem[_17284]
                            _17704 = mem[_17284 + 128]
                            _17705 = mem[_17284 + 96]
                            if mem[_17284 + 96] > !mem[_17284 + 128]:
                                revert with 0, 17
                            if mem[_17284 + 96] + mem[_17284 + 128] < mem[_17284 + 96]:
                                revert with 0, 'SafeMath: addition overflow'
                            if not mem[_17284 + 96] + mem[_17284 + 128]:
                                _17861 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_17861] = 26
                                mem[_17861 + 32] = 'SafeMath: division by zero'
                                if not _17701:
                                    _17915 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _17915 + 68] = mem[_17861 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_17915 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _17915 + -mem[64] + 100
                                _18103 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18103] = 26
                                mem[_18103 + 32] = 'SafeMath: division by zero'
                                if _17700:
                                    if u > !(0 / _17701 / _17700):
                                        revert with 0, 17
                                    if u + (0 / _17701 / _17700) < u:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s == -1:
                                        revert with 0, 17
                                    s = s + 1
                                    u = u + (0 / _17701 / _17700)
                                    continue 
                                _18220 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _18220 + 68] = mem[_18103 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_18220 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _18220 + -mem[64] + 100
                            if mem[_17284 + 96] + mem[_17284 + 128] and mem[_17284] > -1 / mem[_17284 + 96] + mem[_17284 + 128]:
                                revert with 0, 17
                            if not mem[_17284 + 96] + mem[_17284 + 128]:
                                revert with 0, 18
                            if (mem[_17284 + 96] * mem[_17284]) + (mem[_17284 + 128] * mem[_17284]) / mem[_17284 + 96] + mem[_17284 + 128] != mem[_17284]:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not (mem[_17284 + 96] * mem[_17284]) + (mem[_17284 + 128] * mem[_17284]):
                                _18018 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18018] = 26
                                mem[_18018 + 32] = 'SafeMath: division by zero'
                                if not _17701:
                                    _18102 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _18102 + 68] = mem[_18018 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_18102 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _18102 + -mem[64] + 100
                                _18442 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18442] = 26
                                mem[_18442 + 32] = 'SafeMath: division by zero'
                                if _17700:
                                    if u > !(0 / _17701 / _17700):
                                        revert with 0, 17
                                    if u + (0 / _17701 / _17700) < u:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s == -1:
                                        revert with 0, 17
                                    s = s + 1
                                    u = u + (0 / _17701 / _17700)
                                    continue 
                                _18552 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _18552 + 68] = mem[_18442 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_18552 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _18552 + -mem[64] + 100
                            if (mem[_17284 + 96] * mem[_17284]) + (mem[_17284 + 128] * mem[_17284]) and mem[_13489 + 64] > -1 / (mem[_17284 + 96] * mem[_17284]) + (mem[_17284 + 128] * mem[_17284]):
                                revert with 0, 17
                            if not (mem[_17284 + 96] * mem[_17284]) + (mem[_17284 + 128] * mem[_17284]):
                                revert with 0, 18
                            if (mem[_17284 + 96] * mem[_17284] * mem[_13489 + 64]) + (mem[_17284 + 128] * mem[_17284] * mem[_13489 + 64]) / (mem[_17284 + 96] * mem[_17284]) + (mem[_17284 + 128] * mem[_17284]) != mem[_13489 + 64]:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _18331 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_18331] = 26
                            mem[_18331 + 32] = 'SafeMath: division by zero'
                            if not _17701:
                                _18441 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _18441 + 68] = mem[_18331 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_18441 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _18441 + -mem[64] + 100
                            _18747 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_18747] = 26
                            mem[_18747 + 32] = 'SafeMath: division by zero'
                            if _17700:
                                if u > !((_17705 * _17703 * _17702) + (_17704 * _17703 * _17702) / _17701 / _17700):
                                    revert with 0, 17
                                if u + ((_17705 * _17703 * _17702) + (_17704 * _17703 * _17702) / _17701 / _17700) < u:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s == -1:
                                    revert with 0, 17
                                s = s + 1
                                u = u + ((_17705 * _17703 * _17702) + (_17704 * _17703 * _17702) / _17701 / _17700)
                                continue 
                            _18844 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _18844 + 68] = mem[_18747 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_18844 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _18844 + -mem[64] + 100
                        _17140 = mem[_8314 + 32]
                        if _12675 - t > !u:
                            revert with 0, 17
                        if u < 0:
                            revert with 0, 'SafeMath: addition overflow'
                        if mem[_8314 + 32] > !(_12675 - t + u):
                            revert with 0, 17
                        if mem[_8314 + 32] + _12675 - t + u < mem[_8314 + 32]:
                            revert with 0, 'SafeMath: addition overflow'
                        if not mem[_8314 + 32] + _12675 - t + u:
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            continue 
                        if not mem[_8314 + 32] + _12675 - t + u:
                            _17931 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_17931] = 26
                            mem[_17931 + 32] = 'SafeMath: division by zero'
                            if not DENOMINATOR:
                                _17979 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _17979 + 68] = mem[_17931 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_17979 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _17979 + -mem[64] + 100
                            _18272 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_18272] = 30
                            mem[_18272 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / DENOMINATOR <= sub_04b4a313:
                                if sub_04b4a313 < 0 / DENOMINATOR:
                                    revert with 0, 17
                                sub_04b4a313 -= 0 / DENOMINATOR
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                            _18382 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _18382 + 68] = mem[_18272 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_18382 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _18382 + -mem[64] + 100
                        if mem[_8314 + 32] + _12675 - t + u and sub_d8830c7d > -1 / mem[_8314 + 32] + _12675 - t + u:
                            revert with 0, 17
                        if not mem[_8314 + 32] + _12675 - t + u:
                            revert with 0, 18
                        if (mem[_8314 + 32] * sub_d8830c7d) + (_12675 * sub_d8830c7d) - (t * sub_d8830c7d) + (u * sub_d8830c7d) / mem[_8314 + 32] + _12675 - t + u != sub_d8830c7d:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _18143 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_18143] = 26
                        mem[_18143 + 32] = 'SafeMath: division by zero'
                        if not DENOMINATOR:
                            _18271 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _18271 + 68] = mem[_18143 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_18271 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _18271 + -mem[64] + 100
                        _18605 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_18605] = 30
                        mem[_18605 + 32] = 'SafeMath: subtraction overflow'
                        if (_17140 * sub_d8830c7d) + (_12675 * sub_d8830c7d) - (t * sub_d8830c7d) + (u * sub_d8830c7d) / DENOMINATOR <= sub_04b4a313:
                            if sub_04b4a313 < (_17140 * sub_d8830c7d) + (_12675 * sub_d8830c7d) - (t * sub_d8830c7d) + (u * sub_d8830c7d) / DENOMINATOR:
                                revert with 0, 17
                            sub_04b4a313 -= (_17140 * sub_d8830c7d) + (_12675 * sub_d8830c7d) - (t * sub_d8830c7d) + (u * sub_d8830c7d) / DENOMINATOR
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            continue 
                        _18700 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _18700 + 68] = mem[_18605 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_18700 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _18700 + -mem[64] + 100
                else:
                    idx = arg1
                    while idx < sub_d3a8b1da:
                        mem[0] = Mask(128, 128, sub_4c86259e[idx].field_256)
                        mem[32] = sha3(sub_4c86259e[idx].field_0, 9)
                        if not stor9[stor12[idx].field_0][Mask(128, 128, stor12[idx].field_256)]:
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            continue 
                        stor9[stor12[idx].field_0][Mask(128, 128, stor12[idx].field_256)] = 0
                        if sub_1b385a01[stor12[idx].field_0] < 1:
                            revert with 0, 17
                        sub_1b385a01[stor12[idx].field_0]--
                        if not sub_ab7789c0:
                            revert with 0, 17
                        sub_ab7789c0--
                        mem[0] = idx
                        mem[32] = 12
                        if 1 > !sub_ed73481d:
                            revert with 0, 17
                        _6933 = mem[64]
                        mem[64] = mem[64] + 352
                        mem[_6933] = 0
                        mem[_6933 + 32] = 0
                        mem[_6933 + 64] = 0
                        mem[_6933 + 96] = 0
                        mem[_6933 + 128] = 0
                        mem[_6933 + 160] = 0
                        mem[_6933 + 192] = 0
                        mem[_6933 + 224] = 0
                        mem[_6933 + 256] = 0
                        mem[_6933 + 288] = 0
                        mem[_6933 + 320] = 0
                        staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                                gas gas_remaining wei
                               args sub_4c86259e[idx].field_0, Mask(128, 128, sub_4c86259e[idx].field_256)
                        mem[mem[64] len 352] = ext_call.return_data[0 len 352]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _6991 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 352
                        _7053 = mem[64]
                        if mem[64] + 352 < mem[64] or mem[64] + 352 > test266151307():
                            revert with 0, 65
                        mem[64] = mem[64] + 352
                        require mem[_6991] == Mask(128, 128, mem[_6991])
                        mem[_7053] = mem[_6991]
                        mem[_7053 + 32] = mem[_6991 + 32]
                        mem[_7053 + 64] = mem[_6991 + 64]
                        mem[_7053 + 96] = mem[_6991 + 96]
                        require mem[_6991 + 128] < 5
                        mem[_7053 + 128] = mem[_6991 + 128]
                        mem[_7053 + 160] = mem[_6991 + 160]
                        mem[_7053 + 192] = mem[_6991 + 192]
                        mem[_7053 + 224] = mem[_6991 + 224]
                        mem[_7053 + 256] = mem[_6991 + 256]
                        mem[_7053 + 288] = mem[_6991 + 288]
                        mem[_7053 + 320] = mem[_6991 + 320]
                        if Mask(128, 128, mem[_7053]) != Mask(128, 128, sub_4c86259e[idx].field_256):
                            _7643 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_7643] = 46
                            mem[_7643 + 32 len 46] = 0xfe53656e64657220646f6573206e6f7420636f6e7461696e207374616b6520776974682070726f76696465642069
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            continue 
                        mem[0] = Mask(128, 128, sub_4c86259e[idx].field_256)
                        mem[32] = sha3(sub_4c86259e[idx].field_0, 9)
                        if stor9[stor12[idx].field_0][Mask(128, 128, stor12[idx].field_256)]:
                            _7698 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_7698] = 32
                            mem[_7698 + 32] = 'Stake has already been converted'
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            continue 
                        if mem[_7053 + 128] > 4:
                            revert with 0, 33
                        if mem[_7053 + 128] != 2:
                            _7789 = mem[64]
                            mem[64] = mem[64] + 96
                            mem[_7789] = 44
                            mem[_7789 + 32 len 44] = 0x795374616b65206973206f6e6c7920656c696769626c6520696620697420686173206265656e20636c6f7365
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            continue 
                        if mem[_7053 + 192] >= sub_be647a94:
                            _7848 = mem[64]
                            mem[64] = mem[64] + 128
                            mem[_7848] = 65
                            mem[_7848 + 32 len 65] = 0x645374616b65206973206f6e6c7920656c696769626c65206966206974207761732063726561746564207072696f7220746f2074686520637574206f6666206461
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            continue 
                        if mem[_7053 + 192] > !mem[_7053 + 224]:
                            revert with 0, 17
                        if mem[_7053 + 192] + mem[_7053 + 224] < sub_be647a94:
                            _8034 = mem[64]
                            mem[64] = mem[64] + 128
                            mem[_8034] = 66
                            mem[_8034 + 32 len 66] = 0x645374616b65206973206f6e6c7920656c696769626c652069662069742077617320656e646564206f6e2074686520637574206f666620646179206f722061667465
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            continue 
                        _8033 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_8033] = 17
                        mem[_8033 + 32] = 'Stake is eligible' << 120
                        staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                                gas gas_remaining wei
                               args sub_4c86259e[idx].field_0, Mask(128, 128, sub_4c86259e[idx].field_256)
                        mem[mem[64] len 352] = ext_call.return_data[0 len 352]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _8256 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 352
                        _8315 = mem[64]
                        if mem[64] + 352 < mem[64] or mem[64] + 352 > test266151307():
                            revert with 0, 65
                        mem[64] = mem[64] + 352
                        require mem[_8256] == Mask(128, 128, mem[_8256])
                        mem[_8315] = mem[_8256]
                        mem[_8315 + 32] = mem[_8256 + 32]
                        mem[_8315 + 64] = mem[_8256 + 64]
                        mem[_8315 + 96] = mem[_8256 + 96]
                        require mem[_8256 + 128] < 5
                        mem[_8315 + 128] = mem[_8256 + 128]
                        mem[_8315 + 160] = mem[_8256 + 160]
                        mem[_8315 + 192] = mem[_8256 + 192]
                        mem[_8315 + 224] = mem[_8256 + 224]
                        mem[_8315 + 256] = mem[_8256 + 256]
                        mem[_8315 + 288] = mem[_8256 + 288]
                        mem[_8315 + 320] = mem[_8256 + 320]
                        if Mask(128, 128, mem[_8315]) != Mask(128, 128, sub_4c86259e[idx].field_256):
                            revert with 0, 'Address does not contain stake with provided id'
                        if mem[_8315 + 128] > 4:
                            revert with 0, 33
                        if mem[_8315 + 128] == 3:
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            continue 
                        if mem[_8315 + 128] > 4:
                            revert with 0, 33
                        if mem[_8315 + 128] == 4:
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            continue 
                        if mem[_8315 + 128] > 4:
                            revert with 0, 33
                        if mem[_8315 + 128] == 1:
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            continue 
                        if mem[_8315 + 128] > 4:
                            revert with 0, 33
                        if not mem[_8315 + 128]:
                            _9013 = mem[_8315]
                            staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                                    gas gas_remaining wei
                                   args sub_4c86259e[idx].field_0, Mask(128, 128, mem[_8315])
                            mem[mem[64] len 352] = ext_call.return_data[0 len 352]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9111 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 352
                            _9161 = mem[64]
                            if mem[64] + 352 < mem[64] or mem[64] + 352 > test266151307():
                                revert with 0, 65
                            mem[64] = mem[64] + 352
                            require mem[_9111] == Mask(128, 128, mem[_9111])
                            mem[_9161] = mem[_9111]
                            mem[_9161 + 32] = mem[_9111 + 32]
                            mem[_9161 + 64] = mem[_9111 + 64]
                            mem[_9161 + 96] = mem[_9111 + 96]
                            require mem[_9111 + 128] < 5
                            mem[_9161 + 128] = mem[_9111 + 128]
                            mem[_9161 + 160] = mem[_9111 + 160]
                            mem[_9161 + 192] = mem[_9111 + 192]
                            mem[_9161 + 224] = mem[_9111 + 224]
                            mem[_9161 + 256] = mem[_9111 + 256]
                            mem[_9161 + 288] = mem[_9111 + 288]
                            mem[_9161 + 320] = mem[_9111 + 320]
                            if Mask(128, 128, mem[_9161]) != Mask(128, 128, _9013):
                                revert with 0, 'Address does not contain stake with provided id'
                            s = mem[_9161 + 192]
                            t = 0
                            while s < sub_ed73481d + 1:
                                staticcall sub_413c05c6Address.0x8ce1d9e4 with:
                                        gas gas_remaining wei
                                       args s
                                mem[mem[64] len 160] = ext_call.return_data[0 len 160]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _12653 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 160
                                _12793 = mem[64]
                                if mem[64] + 160 > test266151307() or mem[64] + 160 < mem[64]:
                                    revert with 0, 65
                                mem[64] = mem[64] + 160
                                mem[_12793] = mem[_12653]
                                mem[_12793 + 32] = mem[_12653 + 32]
                                mem[_12793 + 64] = mem[_12653 + 64]
                                mem[_12793 + 96] = mem[_12653 + 96]
                                mem[_12793 + 128] = mem[_12653 + 128]
                                _13210 = mem[_12793 + 64]
                                _13211 = mem[_12793 + 32]
                                _13212 = mem[_9161 + 64]
                                _13213 = mem[_12793]
                                _13214 = mem[_12793 + 128]
                                _13215 = mem[_12793 + 96]
                                if mem[_12793 + 96] > !mem[_12793 + 128]:
                                    revert with 0, 17
                                if mem[_12793 + 96] + mem[_12793 + 128] < mem[_12793 + 96]:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not mem[_12793 + 96] + mem[_12793 + 128]:
                                    _13609 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13609] = 26
                                    mem[_13609 + 32] = 'SafeMath: division by zero'
                                    if not _13211:
                                        _13689 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _13689 + 68] = mem[_13609 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13689 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _13689 + -mem[64] + 100
                                    _14083 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14083] = 26
                                    mem[_14083 + 32] = 'SafeMath: division by zero'
                                    if _13210:
                                        if t > !(0 / _13211 / _13210):
                                            revert with 0, 17
                                        if t + (0 / _13211 / _13210) < t:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if s == -1:
                                            revert with 0, 17
                                        s = s + 1
                                        t = t + (0 / _13211 / _13210)
                                        continue 
                                    _14240 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _14240 + 68] = mem[_14083 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14240 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14240 + -mem[64] + 100
                                if mem[_12793 + 96] + mem[_12793 + 128] and mem[_12793] > -1 / mem[_12793 + 96] + mem[_12793 + 128]:
                                    revert with 0, 17
                                if not mem[_12793 + 96] + mem[_12793 + 128]:
                                    revert with 0, 18
                                if (mem[_12793 + 96] * mem[_12793]) + (mem[_12793 + 128] * mem[_12793]) / mem[_12793 + 96] + mem[_12793 + 128] != mem[_12793]:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not (mem[_12793 + 96] * mem[_12793]) + (mem[_12793 + 128] * mem[_12793]):
                                    _13860 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13860] = 26
                                    mem[_13860 + 32] = 'SafeMath: division by zero'
                                    if not _13211:
                                        _14082 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _14082 + 68] = mem[_13860 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_14082 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _14082 + -mem[64] + 100
                                    _14544 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14544] = 26
                                    mem[_14544 + 32] = 'SafeMath: division by zero'
                                    if _13210:
                                        if t > !(0 / _13211 / _13210):
                                            revert with 0, 17
                                        if t + (0 / _13211 / _13210) < t:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if s == -1:
                                            revert with 0, 17
                                        s = s + 1
                                        t = t + (0 / _13211 / _13210)
                                        continue 
                                    _14760 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _14760 + 68] = mem[_14544 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14760 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14760 + -mem[64] + 100
                                if (mem[_12793 + 96] * mem[_12793]) + (mem[_12793 + 128] * mem[_12793]) and mem[_9161 + 64] > -1 / (mem[_12793 + 96] * mem[_12793]) + (mem[_12793 + 128] * mem[_12793]):
                                    revert with 0, 17
                                if not (mem[_12793 + 96] * mem[_12793]) + (mem[_12793 + 128] * mem[_12793]):
                                    revert with 0, 18
                                if (mem[_12793 + 96] * mem[_12793] * mem[_9161 + 64]) + (mem[_12793 + 128] * mem[_12793] * mem[_9161 + 64]) / (mem[_12793 + 96] * mem[_12793]) + (mem[_12793 + 128] * mem[_12793]) != mem[_9161 + 64]:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _14407 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14407] = 26
                                mem[_14407 + 32] = 'SafeMath: division by zero'
                                if not _13211:
                                    _14543 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _14543 + 68] = mem[_14407 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14543 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14543 + -mem[64] + 100
                                _15001 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15001] = 26
                                mem[_15001 + 32] = 'SafeMath: division by zero'
                                if _13210:
                                    if t > !((_13215 * _13213 * _13212) + (_13214 * _13213 * _13212) / _13211 / _13210):
                                        revert with 0, 17
                                    if t + ((_13215 * _13213 * _13212) + (_13214 * _13213 * _13212) / _13211 / _13210) < t:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s == -1:
                                        revert with 0, 17
                                    s = s + 1
                                    t = t + ((_13215 * _13213 * _13212) + (_13214 * _13213 * _13212) / _13211 / _13210)
                                    continue 
                                _15164 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _15164 + 68] = mem[_15001 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15164 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _15164 + -mem[64] + 100
                            _12651 = mem[_8315 + 32]
                            _12652 = mem[_8315 + 160]
                            if mem[_8315 + 160] > !t:
                                revert with 0, 17
                            if mem[_8315 + 160] + t < mem[_8315 + 160]:
                                revert with 0, 'SafeMath: addition overflow'
                            if mem[_8315 + 32] > !(mem[_8315 + 160] + t):
                                revert with 0, 17
                            if mem[_8315 + 32] + mem[_8315 + 160] + t < mem[_8315 + 32]:
                                revert with 0, 'SafeMath: addition overflow'
                            if not mem[_8315 + 32] + mem[_8315 + 160] + t:
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                            if not mem[_8315 + 32] + mem[_8315 + 160] + t:
                                _13723 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13723] = 26
                                mem[_13723 + 32] = 'SafeMath: division by zero'
                                if not DENOMINATOR:
                                    _13803 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _13803 + 68] = mem[_13723 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_13803 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _13803 + -mem[64] + 100
                                _14312 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14312] = 30
                                mem[_14312 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / DENOMINATOR <= sub_04b4a313:
                                    if sub_04b4a313 < 0 / DENOMINATOR:
                                        revert with 0, 17
                                    sub_04b4a313 -= 0 / DENOMINATOR
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                                _14444 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _14444 + 68] = mem[_14312 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14444 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14444 + -mem[64] + 100
                            if mem[_8315 + 32] + mem[_8315 + 160] + t and sub_d8830c7d > -1 / mem[_8315 + 32] + mem[_8315 + 160] + t:
                                revert with 0, 17
                            if not mem[_8315 + 32] + mem[_8315 + 160] + t:
                                revert with 0, 18
                            if (mem[_8315 + 32] * sub_d8830c7d) + (mem[_8315 + 160] * sub_d8830c7d) + (t * sub_d8830c7d) / mem[_8315 + 32] + mem[_8315 + 160] + t != sub_d8830c7d:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _14135 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14135] = 26
                            mem[_14135 + 32] = 'SafeMath: division by zero'
                            if not DENOMINATOR:
                                _14311 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _14311 + 68] = mem[_14135 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14311 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _14311 + -mem[64] + 100
                            _14811 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14811] = 30
                            mem[_14811 + 32] = 'SafeMath: subtraction overflow'
                            if (_12651 * sub_d8830c7d) + (_12652 * sub_d8830c7d) + (t * sub_d8830c7d) / DENOMINATOR <= sub_04b4a313:
                                if sub_04b4a313 < (_12651 * sub_d8830c7d) + (_12652 * sub_d8830c7d) + (t * sub_d8830c7d) / DENOMINATOR:
                                    revert with 0, 17
                                sub_04b4a313 -= (_12651 * sub_d8830c7d) + (_12652 * sub_d8830c7d) + (t * sub_d8830c7d) / DENOMINATOR
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                            _14922 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _14922 + 68] = mem[_14811 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_14922 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _14922 + -mem[64] + 100
                        _9011 = mem[_8315 + 224]
                        _9012 = mem[_8315 + 192]
                        if mem[_8315 + 192] > !mem[_8315 + 224]:
                            revert with 0, 17
                        if sub_ed73481d + 1 < mem[_8315 + 192] + mem[_8315 + 224]:
                            _9126 = mem[_8315]
                            staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                                    gas gas_remaining wei
                                   args sub_4c86259e[idx].field_0, Mask(128, 128, mem[_8315])
                            mem[mem[64] len 352] = ext_call.return_data[0 len 352]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _9188 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 352
                            _9224 = mem[64]
                            if mem[64] + 352 < mem[64] or mem[64] + 352 > test266151307():
                                revert with 0, 65
                            mem[64] = mem[64] + 352
                            require mem[_9188] == Mask(128, 128, mem[_9188])
                            mem[_9224] = mem[_9188]
                            mem[_9224 + 32] = mem[_9188 + 32]
                            mem[_9224 + 64] = mem[_9188 + 64]
                            mem[_9224 + 96] = mem[_9188 + 96]
                            require mem[_9188 + 128] < 5
                            mem[_9224 + 128] = mem[_9188 + 128]
                            mem[_9224 + 160] = mem[_9188 + 160]
                            mem[_9224 + 192] = mem[_9188 + 192]
                            mem[_9224 + 224] = mem[_9188 + 224]
                            mem[_9224 + 256] = mem[_9188 + 256]
                            mem[_9224 + 288] = mem[_9188 + 288]
                            mem[_9224 + 320] = mem[_9188 + 320]
                            if Mask(128, 128, mem[_9224]) != Mask(128, 128, _9126):
                                revert with 0, 'Address does not contain stake with provided id'
                            s = mem[_9224 + 192]
                            t = 0
                            while s < _9012 + _9011:
                                staticcall sub_413c05c6Address.0x8ce1d9e4 with:
                                        gas gas_remaining wei
                                       args s
                                mem[mem[64] len 160] = ext_call.return_data[0 len 160]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _12648 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 160
                                _12789 = mem[64]
                                if mem[64] + 160 > test266151307() or mem[64] + 160 < mem[64]:
                                    revert with 0, 65
                                mem[64] = mem[64] + 160
                                mem[_12789] = mem[_12648]
                                mem[_12789 + 32] = mem[_12648 + 32]
                                mem[_12789 + 64] = mem[_12648 + 64]
                                mem[_12789 + 96] = mem[_12648 + 96]
                                mem[_12789 + 128] = mem[_12648 + 128]
                                _13196 = mem[_12789 + 64]
                                _13197 = mem[_12789 + 32]
                                _13198 = mem[_9224 + 64]
                                _13199 = mem[_12789]
                                _13200 = mem[_12789 + 128]
                                _13201 = mem[_12789 + 96]
                                if mem[_12789 + 96] > !mem[_12789 + 128]:
                                    revert with 0, 17
                                if mem[_12789 + 96] + mem[_12789 + 128] < mem[_12789 + 96]:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not mem[_12789 + 96] + mem[_12789 + 128]:
                                    _13603 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13603] = 26
                                    mem[_13603 + 32] = 'SafeMath: division by zero'
                                    if not _13197:
                                        _13687 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _13687 + 68] = mem[_13603 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13687 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _13687 + -mem[64] + 100
                                    _14071 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14071] = 26
                                    mem[_14071 + 32] = 'SafeMath: division by zero'
                                    if _13196:
                                        if t > !(0 / _13197 / _13196):
                                            revert with 0, 17
                                        if t + (0 / _13197 / _13196) < t:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if s == -1:
                                            revert with 0, 17
                                        s = s + 1
                                        t = t + (0 / _13197 / _13196)
                                        continue 
                                    _14232 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _14232 + 68] = mem[_14071 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14232 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14232 + -mem[64] + 100
                                if mem[_12789 + 96] + mem[_12789 + 128] and mem[_12789] > -1 / mem[_12789 + 96] + mem[_12789 + 128]:
                                    revert with 0, 17
                                if not mem[_12789 + 96] + mem[_12789 + 128]:
                                    revert with 0, 18
                                if (mem[_12789 + 96] * mem[_12789]) + (mem[_12789 + 128] * mem[_12789]) / mem[_12789 + 96] + mem[_12789 + 128] != mem[_12789]:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not (mem[_12789 + 96] * mem[_12789]) + (mem[_12789 + 128] * mem[_12789]):
                                    _13855 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13855] = 26
                                    mem[_13855 + 32] = 'SafeMath: division by zero'
                                    if not _13197:
                                        _14070 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _14070 + 68] = mem[_13855 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_14070 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _14070 + -mem[64] + 100
                                    _14535 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14535] = 26
                                    mem[_14535 + 32] = 'SafeMath: division by zero'
                                    if _13196:
                                        if t > !(0 / _13197 / _13196):
                                            revert with 0, 17
                                        if t + (0 / _13197 / _13196) < t:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if s == -1:
                                            revert with 0, 17
                                        s = s + 1
                                        t = t + (0 / _13197 / _13196)
                                        continue 
                                    _14748 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _14748 + 68] = mem[_14535 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14748 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14748 + -mem[64] + 100
                                if (mem[_12789 + 96] * mem[_12789]) + (mem[_12789 + 128] * mem[_12789]) and mem[_9224 + 64] > -1 / (mem[_12789 + 96] * mem[_12789]) + (mem[_12789 + 128] * mem[_12789]):
                                    revert with 0, 17
                                if not (mem[_12789 + 96] * mem[_12789]) + (mem[_12789 + 128] * mem[_12789]):
                                    revert with 0, 18
                                if (mem[_12789 + 96] * mem[_12789] * mem[_9224 + 64]) + (mem[_12789 + 128] * mem[_12789] * mem[_9224 + 64]) / (mem[_12789 + 96] * mem[_12789]) + (mem[_12789 + 128] * mem[_12789]) != mem[_9224 + 64]:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _14398 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14398] = 26
                                mem[_14398 + 32] = 'SafeMath: division by zero'
                                if not _13197:
                                    _14534 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _14534 + 68] = mem[_14398 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14534 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14534 + -mem[64] + 100
                                _14993 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14993] = 26
                                mem[_14993 + 32] = 'SafeMath: division by zero'
                                if _13196:
                                    if t > !((_13201 * _13199 * _13198) + (_13200 * _13199 * _13198) / _13197 / _13196):
                                        revert with 0, 17
                                    if t + ((_13201 * _13199 * _13198) + (_13200 * _13199 * _13198) / _13197 / _13196) < t:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s == -1:
                                        revert with 0, 17
                                    s = s + 1
                                    t = t + ((_13201 * _13199 * _13198) + (_13200 * _13199 * _13198) / _13197 / _13196)
                                    continue 
                                _15158 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _15158 + 68] = mem[_14993 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15158 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _15158 + -mem[64] + 100
                            if t >= mem[_8315 + 160]:
                                _12676 = mem[_8315]
                                staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                                        gas gas_remaining wei
                                       args sub_4c86259e[idx].field_0, Mask(128, 128, mem[_8315])
                                mem[mem[64] len 352] = ext_call.return_data[0 len 352]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _13259 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 352
                                _13296 = mem[64]
                                if mem[64] + 352 < mem[64] or mem[64] + 352 > test266151307():
                                    revert with 0, 65
                                mem[64] = mem[64] + 352
                                require mem[_13259] == Mask(128, 128, mem[_13259])
                                mem[_13296] = mem[_13259]
                                mem[_13296 + 32] = mem[_13259 + 32]
                                mem[_13296 + 64] = mem[_13259 + 64]
                                mem[_13296 + 96] = mem[_13259 + 96]
                                require mem[_13259 + 128] < 5
                                mem[_13296 + 128] = mem[_13259 + 128]
                                mem[_13296 + 160] = mem[_13259 + 160]
                                mem[_13296 + 192] = mem[_13259 + 192]
                                mem[_13296 + 224] = mem[_13259 + 224]
                                mem[_13296 + 256] = mem[_13259 + 256]
                                mem[_13296 + 288] = mem[_13259 + 288]
                                mem[_13296 + 320] = mem[_13259 + 320]
                                if Mask(128, 128, mem[_13296]) != Mask(128, 128, _12676):
                                    revert with 0, 'Address does not contain stake with provided id'
                                s = mem[_13296 + 192]
                                t = 0
                                while s < sub_ed73481d + 1:
                                    staticcall sub_413c05c6Address.0x8ce1d9e4 with:
                                            gas gas_remaining wei
                                           args s
                                    mem[mem[64] len 160] = ext_call.return_data[0 len 160]
                                    if not ext_call.success:
                                        revert with ext_call.return_data[0 len return_data.size]
                                    _17143 = mem[64]
                                    mem[64] = mem[64] + ceil32(return_data.size)
                                    require return_data.size >= 160
                                    _17302 = mem[64]
                                    if mem[64] + 160 > test266151307() or mem[64] + 160 < mem[64]:
                                        revert with 0, 65
                                    mem[64] = mem[64] + 160
                                    mem[_17302] = mem[_17143]
                                    mem[_17302 + 32] = mem[_17143 + 32]
                                    mem[_17302 + 64] = mem[_17143 + 64]
                                    mem[_17302 + 96] = mem[_17143 + 96]
                                    mem[_17302 + 128] = mem[_17143 + 128]
                                    _17706 = mem[_17302 + 64]
                                    _17707 = mem[_17302 + 32]
                                    _17708 = mem[_13296 + 64]
                                    _17709 = mem[_17302]
                                    _17710 = mem[_17302 + 128]
                                    _17711 = mem[_17302 + 96]
                                    if mem[_17302 + 96] > !mem[_17302 + 128]:
                                        revert with 0, 17
                                    if mem[_17302 + 96] + mem[_17302 + 128] < mem[_17302 + 96]:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if not mem[_17302 + 96] + mem[_17302 + 128]:
                                        _17863 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_17863] = 26
                                        mem[_17863 + 32] = 'SafeMath: division by zero'
                                        if not _17707:
                                            _17917 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _17917 + 68] = mem[_17863 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_17917 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _17917 + -mem[64] + 100
                                        _18105 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_18105] = 26
                                        mem[_18105 + 32] = 'SafeMath: division by zero'
                                        if _17706:
                                            if t > !(0 / _17707 / _17706):
                                                revert with 0, 17
                                            if t + (0 / _17707 / _17706) < t:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if s == -1:
                                                revert with 0, 17
                                            s = s + 1
                                            t = t + (0 / _17707 / _17706)
                                            continue 
                                        _18224 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _18224 + 68] = mem[_18105 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_18224 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _18224 + -mem[64] + 100
                                    if mem[_17302 + 96] + mem[_17302 + 128] and mem[_17302] > -1 / mem[_17302 + 96] + mem[_17302 + 128]:
                                        revert with 0, 17
                                    if not mem[_17302 + 96] + mem[_17302 + 128]:
                                        revert with 0, 18
                                    if (mem[_17302 + 96] * mem[_17302]) + (mem[_17302 + 128] * mem[_17302]) / mem[_17302 + 96] + mem[_17302 + 128] != mem[_17302]:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    if not (mem[_17302 + 96] * mem[_17302]) + (mem[_17302 + 128] * mem[_17302]):
                                        _18021 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_18021] = 26
                                        mem[_18021 + 32] = 'SafeMath: division by zero'
                                        if not _17707:
                                            _18104 = mem[64]
                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                            mem[mem[64] + 4] = 32
                                            mem[mem[64] + 36] = 26
                                            idx = 0
                                            while idx < 26:
                                                mem[idx + _18104 + 68] = mem[_18021 + idx + 32]
                                                idx = idx + 32
                                                continue 
                                            mem[_18104 + 94] = 0
                                            revert with memory
                                              from mem[64]
                                               len _18104 + -mem[64] + 100
                                        _18446 = mem[64]
                                        mem[64] = mem[64] + 64
                                        mem[_18446] = 26
                                        mem[_18446 + 32] = 'SafeMath: division by zero'
                                        if _17706:
                                            if t > !(0 / _17707 / _17706):
                                                revert with 0, 17
                                            if t + (0 / _17707 / _17706) < t:
                                                revert with 0, 'SafeMath: addition overflow'
                                            if s == -1:
                                                revert with 0, 17
                                            s = s + 1
                                            t = t + (0 / _17707 / _17706)
                                            continue 
                                        _18555 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _18555 + 68] = mem[_18446 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_18555 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _18555 + -mem[64] + 100
                                    if (mem[_17302 + 96] * mem[_17302]) + (mem[_17302 + 128] * mem[_17302]) and mem[_13296 + 64] > -1 / (mem[_17302 + 96] * mem[_17302]) + (mem[_17302 + 128] * mem[_17302]):
                                        revert with 0, 17
                                    if not (mem[_17302 + 96] * mem[_17302]) + (mem[_17302 + 128] * mem[_17302]):
                                        revert with 0, 18
                                    if (mem[_17302 + 96] * mem[_17302] * mem[_13296 + 64]) + (mem[_17302 + 128] * mem[_17302] * mem[_13296 + 64]) / (mem[_17302 + 96] * mem[_17302]) + (mem[_17302 + 128] * mem[_17302]) != mem[_13296 + 64]:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _18335 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18335] = 26
                                    mem[_18335 + 32] = 'SafeMath: division by zero'
                                    if not _17707:
                                        _18445 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _18445 + 68] = mem[_18335 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_18445 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _18445 + -mem[64] + 100
                                    _18751 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18751] = 26
                                    mem[_18751 + 32] = 'SafeMath: division by zero'
                                    if _17706:
                                        if t > !((_17711 * _17709 * _17708) + (_17710 * _17709 * _17708) / _17707 / _17706):
                                            revert with 0, 17
                                        if t + ((_17711 * _17709 * _17708) + (_17710 * _17709 * _17708) / _17707 / _17706) < t:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if s == -1:
                                            revert with 0, 17
                                        s = s + 1
                                        t = t + ((_17711 * _17709 * _17708) + (_17710 * _17709 * _17708) / _17707 / _17706)
                                        continue 
                                    _18846 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _18846 + 68] = mem[_18751 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_18846 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _18846 + -mem[64] + 100
                                _17142 = mem[_8315 + 32]
                                if mem[_8315 + 32] > !t:
                                    revert with 0, 17
                                if mem[_8315 + 32] + t < mem[_8315 + 32]:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not mem[_8315 + 32] + t:
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                                if not mem[_8315 + 32] + t:
                                    _17818 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17818] = 26
                                    mem[_17818 + 32] = 'SafeMath: division by zero'
                                    if not DENOMINATOR:
                                        _17832 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _17832 + 68] = mem[_17818 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_17832 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _17832 + -mem[64] + 100
                                    _17981 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17981] = 30
                                    mem[_17981 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 / DENOMINATOR <= sub_04b4a313:
                                        if sub_04b4a313 < 0 / DENOMINATOR:
                                            revert with 0, 17
                                        sub_04b4a313 -= 0 / DENOMINATOR
                                        if idx == -1:
                                            revert with 0, 17
                                        idx = idx + 1
                                        continue 
                                    _18053 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _18053 + 68] = mem[_17981 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_18053 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _18053 + -mem[64] + 100
                                if mem[_8315 + 32] + t and sub_d8830c7d > -1 / mem[_8315 + 32] + t:
                                    revert with 0, 17
                                if not mem[_8315 + 32] + t:
                                    revert with 0, 18
                                if (mem[_8315 + 32] * sub_d8830c7d) + (t * sub_d8830c7d) / mem[_8315 + 32] + t != sub_d8830c7d:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _17932 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_17932] = 26
                                mem[_17932 + 32] = 'SafeMath: division by zero'
                                if not DENOMINATOR:
                                    _17980 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _17980 + 68] = mem[_17932 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_17980 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _17980 + -mem[64] + 100
                                _18274 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18274] = 30
                                mem[_18274 + 32] = 'SafeMath: subtraction overflow'
                                if (_17142 * sub_d8830c7d) + (t * sub_d8830c7d) / DENOMINATOR <= sub_04b4a313:
                                    if sub_04b4a313 < (_17142 * sub_d8830c7d) + (t * sub_d8830c7d) / DENOMINATOR:
                                        revert with 0, 17
                                    sub_04b4a313 -= (_17142 * sub_d8830c7d) + (t * sub_d8830c7d) / DENOMINATOR
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                                _18384 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _18384 + 68] = mem[_18274 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_18384 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _18384 + -mem[64] + 100
                            _12677 = mem[_8315 + 160]
                            _12788 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12788] = 30
                            mem[_12788 + 32] = 'SafeMath: subtraction overflow'
                            if t > _12677:
                                _13195 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _13195 + 68] = mem[_12788 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13195 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13195 + -mem[64] + 100
                            if _12677 < t:
                                revert with 0, 17
                            _13333 = mem[_8315]
                            staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                                    gas gas_remaining wei
                                   args sub_4c86259e[idx].field_0, Mask(128, 128, mem[_8315])
                            mem[mem[64] len 352] = ext_call.return_data[0 len 352]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _13432 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 352
                            _13492 = mem[64]
                            if mem[64] + 352 < mem[64] or mem[64] + 352 > test266151307():
                                revert with 0, 65
                            mem[64] = mem[64] + 352
                            require mem[_13432] == Mask(128, 128, mem[_13432])
                            mem[_13492] = mem[_13432]
                            mem[_13492 + 32] = mem[_13432 + 32]
                            mem[_13492 + 64] = mem[_13432 + 64]
                            mem[_13492 + 96] = mem[_13432 + 96]
                            require mem[_13432 + 128] < 5
                            mem[_13492 + 128] = mem[_13432 + 128]
                            mem[_13492 + 160] = mem[_13432 + 160]
                            mem[_13492 + 192] = mem[_13432 + 192]
                            mem[_13492 + 224] = mem[_13432 + 224]
                            mem[_13492 + 256] = mem[_13432 + 256]
                            mem[_13492 + 288] = mem[_13432 + 288]
                            mem[_13492 + 320] = mem[_13432 + 320]
                            if Mask(128, 128, mem[_13492]) != Mask(128, 128, _13333):
                                revert with 0, 'Address does not contain stake with provided id'
                            s = mem[_13492 + 192]
                            u = 0
                            while s < sub_ed73481d + 1:
                                staticcall sub_413c05c6Address.0x8ce1d9e4 with:
                                        gas gas_remaining wei
                                       args s
                                mem[mem[64] len 160] = ext_call.return_data[0 len 160]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _17145 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 160
                                _17303 = mem[64]
                                if mem[64] + 160 > test266151307() or mem[64] + 160 < mem[64]:
                                    revert with 0, 65
                                mem[64] = mem[64] + 160
                                mem[_17303] = mem[_17145]
                                mem[_17303 + 32] = mem[_17145 + 32]
                                mem[_17303 + 64] = mem[_17145 + 64]
                                mem[_17303 + 96] = mem[_17145 + 96]
                                mem[_17303 + 128] = mem[_17145 + 128]
                                _17712 = mem[_17303 + 64]
                                _17713 = mem[_17303 + 32]
                                _17714 = mem[_13492 + 64]
                                _17715 = mem[_17303]
                                _17716 = mem[_17303 + 128]
                                _17717 = mem[_17303 + 96]
                                if mem[_17303 + 96] > !mem[_17303 + 128]:
                                    revert with 0, 17
                                if mem[_17303 + 96] + mem[_17303 + 128] < mem[_17303 + 96]:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not mem[_17303 + 96] + mem[_17303 + 128]:
                                    _17865 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17865] = 26
                                    mem[_17865 + 32] = 'SafeMath: division by zero'
                                    if not _17713:
                                        _17918 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _17918 + 68] = mem[_17865 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_17918 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _17918 + -mem[64] + 100
                                    _18108 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18108] = 26
                                    mem[_18108 + 32] = 'SafeMath: division by zero'
                                    if _17712:
                                        if u > !(0 / _17713 / _17712):
                                            revert with 0, 17
                                        if u + (0 / _17713 / _17712) < u:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if s == -1:
                                            revert with 0, 17
                                        s = s + 1
                                        u = u + (0 / _17713 / _17712)
                                        continue 
                                    _18228 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _18228 + 68] = mem[_18108 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_18228 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _18228 + -mem[64] + 100
                                if mem[_17303 + 96] + mem[_17303 + 128] and mem[_17303] > -1 / mem[_17303 + 96] + mem[_17303 + 128]:
                                    revert with 0, 17
                                if not mem[_17303 + 96] + mem[_17303 + 128]:
                                    revert with 0, 18
                                if (mem[_17303 + 96] * mem[_17303]) + (mem[_17303 + 128] * mem[_17303]) / mem[_17303 + 96] + mem[_17303 + 128] != mem[_17303]:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not (mem[_17303 + 96] * mem[_17303]) + (mem[_17303 + 128] * mem[_17303]):
                                    _18023 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18023] = 26
                                    mem[_18023 + 32] = 'SafeMath: division by zero'
                                    if not _17713:
                                        _18107 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _18107 + 68] = mem[_18023 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_18107 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _18107 + -mem[64] + 100
                                    _18449 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18449] = 26
                                    mem[_18449 + 32] = 'SafeMath: division by zero'
                                    if _17712:
                                        if u > !(0 / _17713 / _17712):
                                            revert with 0, 17
                                        if u + (0 / _17713 / _17712) < u:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if s == -1:
                                            revert with 0, 17
                                        s = s + 1
                                        u = u + (0 / _17713 / _17712)
                                        continue 
                                    _18558 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _18558 + 68] = mem[_18449 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_18558 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _18558 + -mem[64] + 100
                                if (mem[_17303 + 96] * mem[_17303]) + (mem[_17303 + 128] * mem[_17303]) and mem[_13492 + 64] > -1 / (mem[_17303 + 96] * mem[_17303]) + (mem[_17303 + 128] * mem[_17303]):
                                    revert with 0, 17
                                if not (mem[_17303 + 96] * mem[_17303]) + (mem[_17303 + 128] * mem[_17303]):
                                    revert with 0, 18
                                if (mem[_17303 + 96] * mem[_17303] * mem[_13492 + 64]) + (mem[_17303 + 128] * mem[_17303] * mem[_13492 + 64]) / (mem[_17303 + 96] * mem[_17303]) + (mem[_17303 + 128] * mem[_17303]) != mem[_13492 + 64]:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _18339 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18339] = 26
                                mem[_18339 + 32] = 'SafeMath: division by zero'
                                if not _17713:
                                    _18448 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _18448 + 68] = mem[_18339 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_18448 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _18448 + -mem[64] + 100
                                _18755 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18755] = 26
                                mem[_18755 + 32] = 'SafeMath: division by zero'
                                if _17712:
                                    if u > !((_17717 * _17715 * _17714) + (_17716 * _17715 * _17714) / _17713 / _17712):
                                        revert with 0, 17
                                    if u + ((_17717 * _17715 * _17714) + (_17716 * _17715 * _17714) / _17713 / _17712) < u:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s == -1:
                                        revert with 0, 17
                                    s = s + 1
                                    u = u + ((_17717 * _17715 * _17714) + (_17716 * _17715 * _17714) / _17713 / _17712)
                                    continue 
                                _18848 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _18848 + 68] = mem[_18755 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_18848 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _18848 + -mem[64] + 100
                            _17144 = mem[_8315 + 32]
                            if _12677 - t > !u:
                                revert with 0, 17
                            if u < 0:
                                revert with 0, 'SafeMath: addition overflow'
                            if mem[_8315 + 32] > !(_12677 - t + u):
                                revert with 0, 17
                            if mem[_8315 + 32] + _12677 - t + u < mem[_8315 + 32]:
                                revert with 0, 'SafeMath: addition overflow'
                            if not mem[_8315 + 32] + _12677 - t + u:
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                            if not mem[_8315 + 32] + _12677 - t + u:
                                _17934 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_17934] = 26
                                mem[_17934 + 32] = 'SafeMath: division by zero'
                                if not DENOMINATOR:
                                    _17982 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _17982 + 68] = mem[_17934 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_17982 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _17982 + -mem[64] + 100
                                _18278 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18278] = 30
                                mem[_18278 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / DENOMINATOR <= sub_04b4a313:
                                    if sub_04b4a313 < 0 / DENOMINATOR:
                                        revert with 0, 17
                                    sub_04b4a313 -= 0 / DENOMINATOR
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                                _18387 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _18387 + 68] = mem[_18278 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_18387 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _18387 + -mem[64] + 100
                            if mem[_8315 + 32] + _12677 - t + u and sub_d8830c7d > -1 / mem[_8315 + 32] + _12677 - t + u:
                                revert with 0, 17
                            if not mem[_8315 + 32] + _12677 - t + u:
                                revert with 0, 18
                            if (mem[_8315 + 32] * sub_d8830c7d) + (_12677 * sub_d8830c7d) - (t * sub_d8830c7d) + (u * sub_d8830c7d) / mem[_8315 + 32] + _12677 - t + u != sub_d8830c7d:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _18149 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_18149] = 26
                            mem[_18149 + 32] = 'SafeMath: division by zero'
                            if not DENOMINATOR:
                                _18277 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _18277 + 68] = mem[_18149 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_18277 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _18277 + -mem[64] + 100
                            _18610 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_18610] = 30
                            mem[_18610 + 32] = 'SafeMath: subtraction overflow'
                            if (_17144 * sub_d8830c7d) + (_12677 * sub_d8830c7d) - (t * sub_d8830c7d) + (u * sub_d8830c7d) / DENOMINATOR <= sub_04b4a313:
                                if sub_04b4a313 < (_17144 * sub_d8830c7d) + (_12677 * sub_d8830c7d) - (t * sub_d8830c7d) + (u * sub_d8830c7d) / DENOMINATOR:
                                    revert with 0, 17
                                sub_04b4a313 -= (_17144 * sub_d8830c7d) + (_12677 * sub_d8830c7d) - (t * sub_d8830c7d) + (u * sub_d8830c7d) / DENOMINATOR
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                            _18702 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _18702 + 68] = mem[_18610 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_18702 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _18702 + -mem[64] + 100
                        _9127 = mem[_8315]
                        staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                                gas gas_remaining wei
                               args sub_4c86259e[idx].field_0, Mask(128, 128, mem[_8315])
                        mem[mem[64] len 352] = ext_call.return_data[0 len 352]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _9189 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 352
                        _9225 = mem[64]
                        if mem[64] + 352 < mem[64] or mem[64] + 352 > test266151307():
                            revert with 0, 65
                        mem[64] = mem[64] + 352
                        require mem[_9189] == Mask(128, 128, mem[_9189])
                        mem[_9225] = mem[_9189]
                        mem[_9225 + 32] = mem[_9189 + 32]
                        mem[_9225 + 64] = mem[_9189 + 64]
                        mem[_9225 + 96] = mem[_9189 + 96]
                        require mem[_9189 + 128] < 5
                        mem[_9225 + 128] = mem[_9189 + 128]
                        mem[_9225 + 160] = mem[_9189 + 160]
                        mem[_9225 + 192] = mem[_9189 + 192]
                        mem[_9225 + 224] = mem[_9189 + 224]
                        mem[_9225 + 256] = mem[_9189 + 256]
                        mem[_9225 + 288] = mem[_9189 + 288]
                        mem[_9225 + 320] = mem[_9189 + 320]
                        if Mask(128, 128, mem[_9225]) != Mask(128, 128, _9127):
                            revert with 0, 'Address does not contain stake with provided id'
                        s = mem[_9225 + 192]
                        t = 0
                        while s < _9012 + _9011:
                            staticcall sub_413c05c6Address.0x8ce1d9e4 with:
                                    gas gas_remaining wei
                                   args s
                            mem[mem[64] len 160] = ext_call.return_data[0 len 160]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _12650 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 160
                            _12792 = mem[64]
                            if mem[64] + 160 > test266151307() or mem[64] + 160 < mem[64]:
                                revert with 0, 65
                            mem[64] = mem[64] + 160
                            mem[_12792] = mem[_12650]
                            mem[_12792 + 32] = mem[_12650 + 32]
                            mem[_12792 + 64] = mem[_12650 + 64]
                            mem[_12792 + 96] = mem[_12650 + 96]
                            mem[_12792 + 128] = mem[_12650 + 128]
                            _13204 = mem[_12792 + 64]
                            _13205 = mem[_12792 + 32]
                            _13206 = mem[_9225 + 64]
                            _13207 = mem[_12792]
                            _13208 = mem[_12792 + 128]
                            _13209 = mem[_12792 + 96]
                            if mem[_12792 + 96] > !mem[_12792 + 128]:
                                revert with 0, 17
                            if mem[_12792 + 96] + mem[_12792 + 128] < mem[_12792 + 96]:
                                revert with 0, 'SafeMath: addition overflow'
                            if not mem[_12792 + 96] + mem[_12792 + 128]:
                                _13607 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13607] = 26
                                mem[_13607 + 32] = 'SafeMath: division by zero'
                                if not _13205:
                                    _13688 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _13688 + 68] = mem[_13607 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_13688 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _13688 + -mem[64] + 100
                                _14080 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14080] = 26
                                mem[_14080 + 32] = 'SafeMath: division by zero'
                                if _13204:
                                    if t > !(0 / _13205 / _13204):
                                        revert with 0, 17
                                    if t + (0 / _13205 / _13204) < t:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s == -1:
                                        revert with 0, 17
                                    s = s + 1
                                    t = t + (0 / _13205 / _13204)
                                    continue 
                                _14236 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _14236 + 68] = mem[_14080 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14236 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _14236 + -mem[64] + 100
                            if mem[_12792 + 96] + mem[_12792 + 128] and mem[_12792] > -1 / mem[_12792 + 96] + mem[_12792 + 128]:
                                revert with 0, 17
                            if not mem[_12792 + 96] + mem[_12792 + 128]:
                                revert with 0, 18
                            if (mem[_12792 + 96] * mem[_12792]) + (mem[_12792 + 128] * mem[_12792]) / mem[_12792 + 96] + mem[_12792 + 128] != mem[_12792]:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not (mem[_12792 + 96] * mem[_12792]) + (mem[_12792 + 128] * mem[_12792]):
                                _13858 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13858] = 26
                                mem[_13858 + 32] = 'SafeMath: division by zero'
                                if not _13205:
                                    _14079 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _14079 + 68] = mem[_13858 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14079 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14079 + -mem[64] + 100
                                _14541 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14541] = 26
                                mem[_14541 + 32] = 'SafeMath: division by zero'
                                if _13204:
                                    if t > !(0 / _13205 / _13204):
                                        revert with 0, 17
                                    if t + (0 / _13205 / _13204) < t:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s == -1:
                                        revert with 0, 17
                                    s = s + 1
                                    t = t + (0 / _13205 / _13204)
                                    continue 
                                _14757 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _14757 + 68] = mem[_14541 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14757 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _14757 + -mem[64] + 100
                            if (mem[_12792 + 96] * mem[_12792]) + (mem[_12792 + 128] * mem[_12792]) and mem[_9225 + 64] > -1 / (mem[_12792 + 96] * mem[_12792]) + (mem[_12792 + 128] * mem[_12792]):
                                revert with 0, 17
                            if not (mem[_12792 + 96] * mem[_12792]) + (mem[_12792 + 128] * mem[_12792]):
                                revert with 0, 18
                            if (mem[_12792 + 96] * mem[_12792] * mem[_9225 + 64]) + (mem[_12792 + 128] * mem[_12792] * mem[_9225 + 64]) / (mem[_12792 + 96] * mem[_12792]) + (mem[_12792 + 128] * mem[_12792]) != mem[_9225 + 64]:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _14403 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14403] = 26
                            mem[_14403 + 32] = 'SafeMath: division by zero'
                            if not _13205:
                                _14540 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _14540 + 68] = mem[_14403 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14540 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _14540 + -mem[64] + 100
                            _14997 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14997] = 26
                            mem[_14997 + 32] = 'SafeMath: division by zero'
                            if _13204:
                                if t > !((_13209 * _13207 * _13206) + (_13208 * _13207 * _13206) / _13205 / _13204):
                                    revert with 0, 17
                                if t + ((_13209 * _13207 * _13206) + (_13208 * _13207 * _13206) / _13205 / _13204) < t:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s == -1:
                                    revert with 0, 17
                                s = s + 1
                                t = t + ((_13209 * _13207 * _13206) + (_13208 * _13207 * _13206) / _13205 / _13204)
                                continue 
                            _15162 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _15162 + 68] = mem[_14997 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_15162 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _15162 + -mem[64] + 100
                        if t >= mem[_8315 + 160]:
                            _12678 = mem[_8315]
                            staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                                    gas gas_remaining wei
                                   args sub_4c86259e[idx].field_0, Mask(128, 128, mem[_8315])
                            mem[mem[64] len 352] = ext_call.return_data[0 len 352]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _13260 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 352
                            _13298 = mem[64]
                            if mem[64] + 352 < mem[64] or mem[64] + 352 > test266151307():
                                revert with 0, 65
                            mem[64] = mem[64] + 352
                            require mem[_13260] == Mask(128, 128, mem[_13260])
                            mem[_13298] = mem[_13260]
                            mem[_13298 + 32] = mem[_13260 + 32]
                            mem[_13298 + 64] = mem[_13260 + 64]
                            mem[_13298 + 96] = mem[_13260 + 96]
                            require mem[_13260 + 128] < 5
                            mem[_13298 + 128] = mem[_13260 + 128]
                            mem[_13298 + 160] = mem[_13260 + 160]
                            mem[_13298 + 192] = mem[_13260 + 192]
                            mem[_13298 + 224] = mem[_13260 + 224]
                            mem[_13298 + 256] = mem[_13260 + 256]
                            mem[_13298 + 288] = mem[_13260 + 288]
                            mem[_13298 + 320] = mem[_13260 + 320]
                            if Mask(128, 128, mem[_13298]) != Mask(128, 128, _12678):
                                revert with 0, 'Address does not contain stake with provided id'
                            s = mem[_13298 + 192]
                            t = 0
                            while s < _9012 + _9011:
                                staticcall sub_413c05c6Address.0x8ce1d9e4 with:
                                        gas gas_remaining wei
                                       args s
                                mem[mem[64] len 160] = ext_call.return_data[0 len 160]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                _17147 = mem[64]
                                mem[64] = mem[64] + ceil32(return_data.size)
                                require return_data.size >= 160
                                _17311 = mem[64]
                                if mem[64] + 160 > test266151307() or mem[64] + 160 < mem[64]:
                                    revert with 0, 65
                                mem[64] = mem[64] + 160
                                mem[_17311] = mem[_17147]
                                mem[_17311 + 32] = mem[_17147 + 32]
                                mem[_17311 + 64] = mem[_17147 + 64]
                                mem[_17311 + 96] = mem[_17147 + 96]
                                mem[_17311 + 128] = mem[_17147 + 128]
                                _17718 = mem[_17311 + 64]
                                _17719 = mem[_17311 + 32]
                                _17720 = mem[_13298 + 64]
                                _17721 = mem[_17311]
                                _17722 = mem[_17311 + 128]
                                _17723 = mem[_17311 + 96]
                                if mem[_17311 + 96] > !mem[_17311 + 128]:
                                    revert with 0, 17
                                if mem[_17311 + 96] + mem[_17311 + 128] < mem[_17311 + 96]:
                                    revert with 0, 'SafeMath: addition overflow'
                                if not mem[_17311 + 96] + mem[_17311 + 128]:
                                    _17867 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_17867] = 26
                                    mem[_17867 + 32] = 'SafeMath: division by zero'
                                    if not _17719:
                                        _17920 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _17920 + 68] = mem[_17867 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_17920 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _17920 + -mem[64] + 100
                                    _18110 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18110] = 26
                                    mem[_18110 + 32] = 'SafeMath: division by zero'
                                    if _17718:
                                        if t > !(0 / _17719 / _17718):
                                            revert with 0, 17
                                        if t + (0 / _17719 / _17718) < t:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if s == -1:
                                            revert with 0, 17
                                        s = s + 1
                                        t = t + (0 / _17719 / _17718)
                                        continue 
                                    _18232 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _18232 + 68] = mem[_18110 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_18232 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _18232 + -mem[64] + 100
                                if mem[_17311 + 96] + mem[_17311 + 128] and mem[_17311] > -1 / mem[_17311 + 96] + mem[_17311 + 128]:
                                    revert with 0, 17
                                if not mem[_17311 + 96] + mem[_17311 + 128]:
                                    revert with 0, 18
                                if (mem[_17311 + 96] * mem[_17311]) + (mem[_17311 + 128] * mem[_17311]) / mem[_17311 + 96] + mem[_17311 + 128] != mem[_17311]:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not (mem[_17311 + 96] * mem[_17311]) + (mem[_17311 + 128] * mem[_17311]):
                                    _18026 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18026] = 26
                                    mem[_18026 + 32] = 'SafeMath: division by zero'
                                    if not _17719:
                                        _18109 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 26
                                        idx = 0
                                        while idx < 26:
                                            mem[idx + _18109 + 68] = mem[_18026 + idx + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_18109 + 94] = 0
                                        revert with memory
                                          from mem[64]
                                           len _18109 + -mem[64] + 100
                                    _18453 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_18453] = 26
                                    mem[_18453 + 32] = 'SafeMath: division by zero'
                                    if _17718:
                                        if t > !(0 / _17719 / _17718):
                                            revert with 0, 17
                                        if t + (0 / _17719 / _17718) < t:
                                            revert with 0, 'SafeMath: addition overflow'
                                        if s == -1:
                                            revert with 0, 17
                                        s = s + 1
                                        t = t + (0 / _17719 / _17718)
                                        continue 
                                    _18561 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _18561 + 68] = mem[_18453 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_18561 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _18561 + -mem[64] + 100
                                if (mem[_17311 + 96] * mem[_17311]) + (mem[_17311 + 128] * mem[_17311]) and mem[_13298 + 64] > -1 / (mem[_17311 + 96] * mem[_17311]) + (mem[_17311 + 128] * mem[_17311]):
                                    revert with 0, 17
                                if not (mem[_17311 + 96] * mem[_17311]) + (mem[_17311 + 128] * mem[_17311]):
                                    revert with 0, 18
                                if (mem[_17311 + 96] * mem[_17311] * mem[_13298 + 64]) + (mem[_17311 + 128] * mem[_17311] * mem[_13298 + 64]) / (mem[_17311 + 96] * mem[_17311]) + (mem[_17311 + 128] * mem[_17311]) != mem[_13298 + 64]:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _18343 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18343] = 26
                                mem[_18343 + 32] = 'SafeMath: division by zero'
                                if not _17719:
                                    _18452 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _18452 + 68] = mem[_18343 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_18452 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _18452 + -mem[64] + 100
                                _18759 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18759] = 26
                                mem[_18759 + 32] = 'SafeMath: division by zero'
                                if _17718:
                                    if t > !((_17723 * _17721 * _17720) + (_17722 * _17721 * _17720) / _17719 / _17718):
                                        revert with 0, 17
                                    if t + ((_17723 * _17721 * _17720) + (_17722 * _17721 * _17720) / _17719 / _17718) < t:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s == -1:
                                        revert with 0, 17
                                    s = s + 1
                                    t = t + ((_17723 * _17721 * _17720) + (_17722 * _17721 * _17720) / _17719 / _17718)
                                    continue 
                                _18850 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _18850 + 68] = mem[_18759 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_18850 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _18850 + -mem[64] + 100
                            _17146 = mem[_8315 + 32]
                            if mem[_8315 + 32] > !t:
                                revert with 0, 17
                            if mem[_8315 + 32] + t < mem[_8315 + 32]:
                                revert with 0, 'SafeMath: addition overflow'
                            if not mem[_8315 + 32] + t:
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                            if not mem[_8315 + 32] + t:
                                _17820 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_17820] = 26
                                mem[_17820 + 32] = 'SafeMath: division by zero'
                                if not DENOMINATOR:
                                    _17833 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _17833 + 68] = mem[_17820 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_17833 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _17833 + -mem[64] + 100
                                _17984 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_17984] = 30
                                mem[_17984 + 32] = 'SafeMath: subtraction overflow'
                                if 0 / DENOMINATOR <= sub_04b4a313:
                                    if sub_04b4a313 < 0 / DENOMINATOR:
                                        revert with 0, 17
                                    sub_04b4a313 -= 0 / DENOMINATOR
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    continue 
                                _18058 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _18058 + 68] = mem[_17984 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_18058 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _18058 + -mem[64] + 100
                            if mem[_8315 + 32] + t and sub_d8830c7d > -1 / mem[_8315 + 32] + t:
                                revert with 0, 17
                            if not mem[_8315 + 32] + t:
                                revert with 0, 18
                            if (mem[_8315 + 32] * sub_d8830c7d) + (t * sub_d8830c7d) / mem[_8315 + 32] + t != sub_d8830c7d:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _17935 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_17935] = 26
                            mem[_17935 + 32] = 'SafeMath: division by zero'
                            if not DENOMINATOR:
                                _17983 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _17983 + 68] = mem[_17935 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_17983 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _17983 + -mem[64] + 100
                            _18280 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_18280] = 30
                            mem[_18280 + 32] = 'SafeMath: subtraction overflow'
                            if (_17146 * sub_d8830c7d) + (t * sub_d8830c7d) / DENOMINATOR <= sub_04b4a313:
                                if sub_04b4a313 < (_17146 * sub_d8830c7d) + (t * sub_d8830c7d) / DENOMINATOR:
                                    revert with 0, 17
                                sub_04b4a313 -= (_17146 * sub_d8830c7d) + (t * sub_d8830c7d) / DENOMINATOR
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                            _18389 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _18389 + 68] = mem[_18280 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_18389 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _18389 + -mem[64] + 100
                        _12679 = mem[_8315 + 160]
                        _12791 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12791] = 30
                        mem[_12791 + 32] = 'SafeMath: subtraction overflow'
                        if t > _12679:
                            _13203 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13203 + 68] = mem[_12791 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_13203 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13203 + -mem[64] + 100
                        if _12679 < t:
                            revert with 0, 17
                        _13335 = mem[_8315]
                        staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                                gas gas_remaining wei
                               args sub_4c86259e[idx].field_0, Mask(128, 128, mem[_8315])
                        mem[mem[64] len 352] = ext_call.return_data[0 len 352]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _13433 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 352
                        _13494 = mem[64]
                        if mem[64] + 352 < mem[64] or mem[64] + 352 > test266151307():
                            revert with 0, 65
                        mem[64] = mem[64] + 352
                        require mem[_13433] == Mask(128, 128, mem[_13433])
                        mem[_13494] = mem[_13433]
                        mem[_13494 + 32] = mem[_13433 + 32]
                        mem[_13494 + 64] = mem[_13433 + 64]
                        mem[_13494 + 96] = mem[_13433 + 96]
                        require mem[_13433 + 128] < 5
                        mem[_13494 + 128] = mem[_13433 + 128]
                        mem[_13494 + 160] = mem[_13433 + 160]
                        mem[_13494 + 192] = mem[_13433 + 192]
                        mem[_13494 + 224] = mem[_13433 + 224]
                        mem[_13494 + 256] = mem[_13433 + 256]
                        mem[_13494 + 288] = mem[_13433 + 288]
                        mem[_13494 + 320] = mem[_13433 + 320]
                        if Mask(128, 128, mem[_13494]) != Mask(128, 128, _13335):
                            revert with 0, 'Address does not contain stake with provided id'
                        s = mem[_13494 + 192]
                        u = 0
                        while s < _9012 + _9011:
                            staticcall sub_413c05c6Address.0x8ce1d9e4 with:
                                    gas gas_remaining wei
                                   args s
                            mem[mem[64] len 160] = ext_call.return_data[0 len 160]
                            if not ext_call.success:
                                revert with ext_call.return_data[0 len return_data.size]
                            _17149 = mem[64]
                            mem[64] = mem[64] + ceil32(return_data.size)
                            require return_data.size >= 160
                            _17312 = mem[64]
                            if mem[64] + 160 > test266151307() or mem[64] + 160 < mem[64]:
                                revert with 0, 65
                            mem[64] = mem[64] + 160
                            mem[_17312] = mem[_17149]
                            mem[_17312 + 32] = mem[_17149 + 32]
                            mem[_17312 + 64] = mem[_17149 + 64]
                            mem[_17312 + 96] = mem[_17149 + 96]
                            mem[_17312 + 128] = mem[_17149 + 128]
                            _17724 = mem[_17312 + 64]
                            _17725 = mem[_17312 + 32]
                            _17726 = mem[_13494 + 64]
                            _17727 = mem[_17312]
                            _17728 = mem[_17312 + 128]
                            _17729 = mem[_17312 + 96]
                            if mem[_17312 + 96] > !mem[_17312 + 128]:
                                revert with 0, 17
                            if mem[_17312 + 96] + mem[_17312 + 128] < mem[_17312 + 96]:
                                revert with 0, 'SafeMath: addition overflow'
                            if not mem[_17312 + 96] + mem[_17312 + 128]:
                                _17869 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_17869] = 26
                                mem[_17869 + 32] = 'SafeMath: division by zero'
                                if not _17725:
                                    _17921 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _17921 + 68] = mem[_17869 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_17921 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _17921 + -mem[64] + 100
                                _18113 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18113] = 26
                                mem[_18113 + 32] = 'SafeMath: division by zero'
                                if _17724:
                                    if u > !(0 / _17725 / _17724):
                                        revert with 0, 17
                                    if u + (0 / _17725 / _17724) < u:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s == -1:
                                        revert with 0, 17
                                    s = s + 1
                                    u = u + (0 / _17725 / _17724)
                                    continue 
                                _18236 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _18236 + 68] = mem[_18113 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_18236 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _18236 + -mem[64] + 100
                            if mem[_17312 + 96] + mem[_17312 + 128] and mem[_17312] > -1 / mem[_17312 + 96] + mem[_17312 + 128]:
                                revert with 0, 17
                            if not mem[_17312 + 96] + mem[_17312 + 128]:
                                revert with 0, 18
                            if (mem[_17312 + 96] * mem[_17312]) + (mem[_17312 + 128] * mem[_17312]) / mem[_17312 + 96] + mem[_17312 + 128] != mem[_17312]:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not (mem[_17312 + 96] * mem[_17312]) + (mem[_17312 + 128] * mem[_17312]):
                                _18028 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18028] = 26
                                mem[_18028 + 32] = 'SafeMath: division by zero'
                                if not _17725:
                                    _18112 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _18112 + 68] = mem[_18028 + idx + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_18112 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _18112 + -mem[64] + 100
                                _18456 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_18456] = 26
                                mem[_18456 + 32] = 'SafeMath: division by zero'
                                if _17724:
                                    if u > !(0 / _17725 / _17724):
                                        revert with 0, 17
                                    if u + (0 / _17725 / _17724) < u:
                                        revert with 0, 'SafeMath: addition overflow'
                                    if s == -1:
                                        revert with 0, 17
                                    s = s + 1
                                    u = u + (0 / _17725 / _17724)
                                    continue 
                                _18564 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _18564 + 68] = mem[_18456 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_18564 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _18564 + -mem[64] + 100
                            if (mem[_17312 + 96] * mem[_17312]) + (mem[_17312 + 128] * mem[_17312]) and mem[_13494 + 64] > -1 / (mem[_17312 + 96] * mem[_17312]) + (mem[_17312 + 128] * mem[_17312]):
                                revert with 0, 17
                            if not (mem[_17312 + 96] * mem[_17312]) + (mem[_17312 + 128] * mem[_17312]):
                                revert with 0, 18
                            if (mem[_17312 + 96] * mem[_17312] * mem[_13494 + 64]) + (mem[_17312 + 128] * mem[_17312] * mem[_13494 + 64]) / (mem[_17312 + 96] * mem[_17312]) + (mem[_17312 + 128] * mem[_17312]) != mem[_13494 + 64]:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _18347 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_18347] = 26
                            mem[_18347 + 32] = 'SafeMath: division by zero'
                            if not _17725:
                                _18455 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _18455 + 68] = mem[_18347 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_18455 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _18455 + -mem[64] + 100
                            _18763 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_18763] = 26
                            mem[_18763 + 32] = 'SafeMath: division by zero'
                            if _17724:
                                if u > !((_17729 * _17727 * _17726) + (_17728 * _17727 * _17726) / _17725 / _17724):
                                    revert with 0, 17
                                if u + ((_17729 * _17727 * _17726) + (_17728 * _17727 * _17726) / _17725 / _17724) < u:
                                    revert with 0, 'SafeMath: addition overflow'
                                if s == -1:
                                    revert with 0, 17
                                s = s + 1
                                u = u + ((_17729 * _17727 * _17726) + (_17728 * _17727 * _17726) / _17725 / _17724)
                                continue 
                            _18852 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _18852 + 68] = mem[_18763 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_18852 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _18852 + -mem[64] + 100
                        _17148 = mem[_8315 + 32]
                        if _12679 - t > !u:
                            revert with 0, 17
                        if u < 0:
                            revert with 0, 'SafeMath: addition overflow'
                        if mem[_8315 + 32] > !(_12679 - t + u):
                            revert with 0, 17
                        if mem[_8315 + 32] + _12679 - t + u < mem[_8315 + 32]:
                            revert with 0, 'SafeMath: addition overflow'
                        if not mem[_8315 + 32] + _12679 - t + u:
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            continue 
                        if not mem[_8315 + 32] + _12679 - t + u:
                            _17937 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_17937] = 26
                            mem[_17937 + 32] = 'SafeMath: division by zero'
                            if not DENOMINATOR:
                                _17985 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _17985 + 68] = mem[_17937 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_17985 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _17985 + -mem[64] + 100
                            _18284 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_18284] = 30
                            mem[_18284 + 32] = 'SafeMath: subtraction overflow'
                            if 0 / DENOMINATOR <= sub_04b4a313:
                                if sub_04b4a313 < 0 / DENOMINATOR:
                                    revert with 0, 17
                                sub_04b4a313 -= 0 / DENOMINATOR
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                continue 
                            _18392 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _18392 + 68] = mem[_18284 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_18392 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _18392 + -mem[64] + 100
                        if mem[_8315 + 32] + _12679 - t + u and sub_d8830c7d > -1 / mem[_8315 + 32] + _12679 - t + u:
                            revert with 0, 17
                        if not mem[_8315 + 32] + _12679 - t + u:
                            revert with 0, 18
                        if (mem[_8315 + 32] * sub_d8830c7d) + (_12679 * sub_d8830c7d) - (t * sub_d8830c7d) + (u * sub_d8830c7d) / mem[_8315 + 32] + _12679 - t + u != sub_d8830c7d:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _18155 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_18155] = 26
                        mem[_18155 + 32] = 'SafeMath: division by zero'
                        if not DENOMINATOR:
                            _18283 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _18283 + 68] = mem[_18155 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_18283 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _18283 + -mem[64] + 100
                        _18615 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_18615] = 30
                        mem[_18615 + 32] = 'SafeMath: subtraction overflow'
                        if (_17148 * sub_d8830c7d) + (_12679 * sub_d8830c7d) - (t * sub_d8830c7d) + (u * sub_d8830c7d) / DENOMINATOR <= sub_04b4a313:
                            if sub_04b4a313 < (_17148 * sub_d8830c7d) + (_12679 * sub_d8830c7d) - (t * sub_d8830c7d) + (u * sub_d8830c7d) / DENOMINATOR:
                                revert with 0, 17
                            sub_04b4a313 -= (_17148 * sub_d8830c7d) + (_12679 * sub_d8830c7d) - (t * sub_d8830c7d) + (u * sub_d8830c7d) / DENOMINATOR
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            continue 
                        _18704 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _18704 + 68] = mem[_18615 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_18704 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _18704 + -mem[64] + 100
            if unknown_0xf4a8f345(?????) == uint32(call.func_hash) >> 224:
                require not msg.value
                return sub_f4a8f345
            if uint32(call.func_hash) >> 224 != unknown_0xf5eb88fe(?????):
                require unknown_0xf785ccd0(?????) == uint32(call.func_hash) >> 224
                require not msg.value
                require calldata.size - 4 >= 64
                if TOKEN_DEFINERAddress != msg.sender:
                    revert with 0, 'Wrong sender.'
                sub_d8830c7d = arg1
                DENOMINATOR = arg2
            require not msg.value
            require calldata.size - 4 >= 96
            require arg1 == address(arg1)
            require arg2 == Mask(128, 128, arg2)
            staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                    gas gas_remaining wei
                   args address(arg1), Mask(128, 128, arg2)
            mem[128 len 352] = ext_call.return_data[0 len 352]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 352
            if not bool(ceil32(return_data.size) + 480 <= test266151307()):
                revert with 0, 65
            require ext_call.return_data[0] == Mask(128, 128, ext_call.return_data[0])
            mem[ceil32(return_data.size) + 128] = ext_call.return_data[0]
            mem[ceil32(return_data.size) + 160] = ext_call.return_data[32]
            mem[ceil32(return_data.size) + 192] = ext_call.return_data[64]
            mem[ceil32(return_data.size) + 224] = ext_call.return_data[96]
            require ext_call.return_data[128] < 5
            mem[ceil32(return_data.size) + 256] = ext_call.return_data[128]
            mem[ceil32(return_data.size) + 288] = ext_call.return_data[160]
            mem[ceil32(return_data.size) + 320] = ext_call.return_data[192]
            mem[ceil32(return_data.size) + 352] = ext_call.return_data[224]
            mem[ceil32(return_data.size) + 384] = ext_call.return_data[256]
            mem[ceil32(return_data.size) + 416] = ext_call.return_data[288]
            mem[ceil32(return_data.size) + 448] = ext_call.return_data[320]
            if Mask(128, 128, ext_call.return_data[0]) != Mask(128, 128, arg2):
                revert with 0, 'Address does not contain stake with provided id'
            if ext_call.return_data[128] > 4:
                revert with 0, 33
            if ext_call.return_data[128] == 3:
                return 0
            if ext_call.return_data[128] > 4:
                revert with 0, 33
            if ext_call.return_data[128] == 4:
                return 0
            if ext_call.return_data[128] > 4:
                revert with 0, 33
            if ext_call.return_data[128] == 1:
                return 0
            if ext_call.return_data[128] > 4:
                revert with 0, 33
            if not ext_call.return_data[128]:
                staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                        gas gas_remaining wei
                       args address(arg1), Mask(128, 128, ext_call.return_data[0])
                mem[ceil32(return_data.size) + 480 len 352] = ext_call.return_data[0 len 352]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                require return_data.size >= 352
                if not bool((2 * ceil32(return_data.size)) + 832 <= test266151307()):
                    revert with 0, 65
                mem[64] = (2 * ceil32(return_data.size)) + 832
                require ext_call.return_data[0] == Mask(128, 128, ext_call.return_data[0])
                mem[(2 * ceil32(return_data.size)) + 480] = ext_call.return_data[0]
                mem[(2 * ceil32(return_data.size)) + 512] = ext_call.return_data[32]
                mem[(2 * ceil32(return_data.size)) + 544] = ext_call.return_data[64]
                mem[(2 * ceil32(return_data.size)) + 576] = ext_call.return_data[96]
                require ext_call.return_data[128] < 5
                mem[(2 * ceil32(return_data.size)) + 608] = ext_call.return_data[128]
                mem[(2 * ceil32(return_data.size)) + 640] = ext_call.return_data[160]
                mem[(2 * ceil32(return_data.size)) + 672] = ext_call.return_data[192]
                mem[(2 * ceil32(return_data.size)) + 704] = ext_call.return_data[224]
                mem[(2 * ceil32(return_data.size)) + 736] = ext_call.return_data[256]
                mem[(2 * ceil32(return_data.size)) + 768] = ext_call.return_data[288]
                mem[(2 * ceil32(return_data.size)) + 800] = ext_call.return_data[320]
                if Mask(128, 128, ext_call.return_data[0]) != Mask(128, 128, ext_call.return_data[0]):
                    revert with 0, 'Address does not contain stake with provided id'
                idx = mem[(2 * ceil32(return_data.size)) + 672]
                s = 0
                while idx < arg3:
                    staticcall sub_413c05c6Address.0x8ce1d9e4 with:
                            gas gas_remaining wei
                           args idx
                    mem[mem[64] len 160] = ext_call.return_data[0 len 160]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _6546 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 160
                    _6618 = mem[64]
                    if mem[64] + 160 > test266151307() or mem[64] + 160 < mem[64]:
                        revert with 0, 65
                    mem[64] = mem[64] + 160
                    mem[_6618] = mem[_6546]
                    mem[_6618 + 32] = mem[_6546 + 32]
                    mem[_6618 + 64] = mem[_6546 + 64]
                    mem[_6618 + 96] = mem[_6546 + 96]
                    mem[_6618 + 128] = mem[_6546 + 128]
                    _6798 = mem[_6618 + 64]
                    _6799 = mem[_6618 + 32]
                    _6800 = mem[(2 * ceil32(return_data.size)) + 544]
                    _6801 = mem[_6618]
                    _6802 = mem[_6618 + 128]
                    _6803 = mem[_6618 + 96]
                    if mem[_6618 + 96] > !mem[_6618 + 128]:
                        revert with 0, 17
                    if mem[_6618 + 96] + mem[_6618 + 128] < mem[_6618 + 96]:
                        revert with 0, 'SafeMath: addition overflow'
                    if not mem[_6618 + 96] + mem[_6618 + 128]:
                        _7113 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_7113] = 26
                        mem[_7113 + 32] = 'SafeMath: division by zero'
                        if not _6799:
                            _7161 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _7161 + 68] = mem[_7113 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_7161 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _7161 + -mem[64] + 100
                        _7494 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_7494] = 26
                        mem[_7494 + 32] = 'SafeMath: division by zero'
                        if _6798:
                            if s > !(0 / _6799 / _6798):
                                revert with 0, 17
                            if s + (0 / _6799 / _6798) < s:
                                revert with 0, 'SafeMath: addition overflow'
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + (0 / _6799 / _6798)
                            continue 
                        _7602 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _7602 + 68] = mem[_7494 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_7602 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _7602 + -mem[64] + 100
                    if mem[_6618 + 96] + mem[_6618 + 128] and mem[_6618] > -1 / mem[_6618 + 96] + mem[_6618 + 128]:
                        revert with 0, 17
                    if not mem[_6618 + 96] + mem[_6618 + 128]:
                        revert with 0, 18
                    if (mem[_6618 + 96] * mem[_6618]) + (mem[_6618 + 128] * mem[_6618]) / mem[_6618 + 96] + mem[_6618 + 128] != mem[_6618]:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not (mem[_6618 + 96] * mem[_6618]) + (mem[_6618 + 128] * mem[_6618]):
                        _7313 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_7313] = 26
                        mem[_7313 + 32] = 'SafeMath: division by zero'
                        if not _6799:
                            _7493 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _7493 + 68] = mem[_7313 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_7493 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _7493 + -mem[64] + 100
                        _7801 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_7801] = 26
                        mem[_7801 + 32] = 'SafeMath: division by zero'
                        if _6798:
                            if s > !(0 / _6799 / _6798):
                                revert with 0, 17
                            if s + (0 / _6799 / _6798) < s:
                                revert with 0, 'SafeMath: addition overflow'
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + (0 / _6799 / _6798)
                            continue 
                        _7947 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _7947 + 68] = mem[_7801 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_7947 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _7947 + -mem[64] + 100
                    if (mem[_6618 + 96] * mem[_6618]) + (mem[_6618 + 128] * mem[_6618]) and mem[(2 * ceil32(return_data.size)) + 544] > -1 / (mem[_6618 + 96] * mem[_6618]) + (mem[_6618 + 128] * mem[_6618]):
                        revert with 0, 17
                    if not (mem[_6618 + 96] * mem[_6618]) + (mem[_6618 + 128] * mem[_6618]):
                        revert with 0, 18
                    if (mem[_6618 + 96] * mem[_6618] * mem[(2 * ceil32(return_data.size)) + 544]) + (mem[_6618 + 128] * mem[_6618] * mem[(2 * ceil32(return_data.size)) + 544]) / (mem[_6618 + 96] * mem[_6618]) + (mem[_6618 + 128] * mem[_6618]) != mem[(2 * ceil32(return_data.size)) + 544]:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _7709 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_7709] = 26
                    mem[_7709 + 32] = 'SafeMath: division by zero'
                    if not _6799:
                        _7800 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _7800 + 68] = mem[_7709 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_7800 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _7800 + -mem[64] + 100
                    _8079 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_8079] = 26
                    mem[_8079 + 32] = 'SafeMath: division by zero'
                    if _6798:
                        if s > !((_6803 * _6801 * _6800) + (_6802 * _6801 * _6800) / _6799 / _6798):
                            revert with 0, 17
                        if s + ((_6803 * _6801 * _6800) + (_6802 * _6801 * _6800) / _6799 / _6798) < s:
                            revert with 0, 'SafeMath: addition overflow'
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + ((_6803 * _6801 * _6800) + (_6802 * _6801 * _6800) / _6799 / _6798)
                        continue 
                    _8152 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _8152 + 68] = mem[_8079 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_8152 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _8152 + -mem[64] + 100
                _6545 = mem[ceil32(return_data.size) + 288]
                if mem[ceil32(return_data.size) + 288] > !s:
                    revert with 0, 17
                if mem[ceil32(return_data.size) + 288] + s < mem[ceil32(return_data.size) + 288]:
                    revert with 0, 'SafeMath: addition overflow'
                mem[mem[64]] = mem[ceil32(return_data.size) + 160]
                return mem[mem[64]], _6545 + s
            if ext_call.return_data[192] > !ext_call.return_data[224]:
                revert with 0, 17
            staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                    gas gas_remaining wei
                   args address(arg1), Mask(128, 128, ext_call.return_data[0])
            mem[ceil32(return_data.size) + 480 len 352] = ext_call.return_data[0 len 352]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 352
            if not bool((2 * ceil32(return_data.size)) + 832 <= test266151307()):
                revert with 0, 65
            mem[64] = (2 * ceil32(return_data.size)) + 832
            require ext_call.return_data[0] == Mask(128, 128, ext_call.return_data[0])
            mem[(2 * ceil32(return_data.size)) + 480] = ext_call.return_data[0]
            mem[(2 * ceil32(return_data.size)) + 512] = ext_call.return_data[32]
            mem[(2 * ceil32(return_data.size)) + 544] = ext_call.return_data[64]
            mem[(2 * ceil32(return_data.size)) + 576] = ext_call.return_data[96]
            require ext_call.return_data[128] < 5
            mem[(2 * ceil32(return_data.size)) + 608] = ext_call.return_data[128]
            mem[(2 * ceil32(return_data.size)) + 640] = ext_call.return_data[160]
            mem[(2 * ceil32(return_data.size)) + 672] = ext_call.return_data[192]
            mem[(2 * ceil32(return_data.size)) + 704] = ext_call.return_data[224]
            mem[(2 * ceil32(return_data.size)) + 736] = ext_call.return_data[256]
            mem[(2 * ceil32(return_data.size)) + 768] = ext_call.return_data[288]
            mem[(2 * ceil32(return_data.size)) + 800] = ext_call.return_data[320]
            if Mask(128, 128, ext_call.return_data[0]) != Mask(128, 128, ext_call.return_data[0]):
                revert with 0, 'Address does not contain stake with provided id'
            if arg3 < ext_call.return_data[192] + ext_call.return_data[224]:
                idx = mem[(2 * ceil32(return_data.size)) + 672]
                s = 0
                while idx < ext_call.return_data[192] + ext_call.return_data[224]:
                    staticcall sub_413c05c6Address.0x8ce1d9e4 with:
                            gas gas_remaining wei
                           args idx
                    mem[mem[64] len 160] = ext_call.return_data[0 len 160]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _6541 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 160
                    _6614 = mem[64]
                    if mem[64] + 160 > test266151307() or mem[64] + 160 < mem[64]:
                        revert with 0, 65
                    mem[64] = mem[64] + 160
                    mem[_6614] = mem[_6541]
                    mem[_6614 + 32] = mem[_6541 + 32]
                    mem[_6614 + 64] = mem[_6541 + 64]
                    mem[_6614 + 96] = mem[_6541 + 96]
                    mem[_6614 + 128] = mem[_6541 + 128]
                    _6784 = mem[_6614 + 64]
                    _6785 = mem[_6614 + 32]
                    _6786 = mem[(2 * ceil32(return_data.size)) + 544]
                    _6787 = mem[_6614]
                    _6788 = mem[_6614 + 128]
                    _6789 = mem[_6614 + 96]
                    if mem[_6614 + 96] > !mem[_6614 + 128]:
                        revert with 0, 17
                    if mem[_6614 + 96] + mem[_6614 + 128] < mem[_6614 + 96]:
                        revert with 0, 'SafeMath: addition overflow'
                    if not mem[_6614 + 96] + mem[_6614 + 128]:
                        _7107 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_7107] = 26
                        mem[_7107 + 32] = 'SafeMath: division by zero'
                        if not _6785:
                            _7159 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _7159 + 68] = mem[_7107 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_7159 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _7159 + -mem[64] + 100
                        _7483 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_7483] = 26
                        mem[_7483 + 32] = 'SafeMath: division by zero'
                        if _6784:
                            if s > !(0 / _6785 / _6784):
                                revert with 0, 17
                            if s + (0 / _6785 / _6784) < s:
                                revert with 0, 'SafeMath: addition overflow'
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + (0 / _6785 / _6784)
                            continue 
                        _7594 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _7594 + 68] = mem[_7483 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_7594 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _7594 + -mem[64] + 100
                    if mem[_6614 + 96] + mem[_6614 + 128] and mem[_6614] > -1 / mem[_6614 + 96] + mem[_6614 + 128]:
                        revert with 0, 17
                    if not mem[_6614 + 96] + mem[_6614 + 128]:
                        revert with 0, 18
                    if (mem[_6614 + 96] * mem[_6614]) + (mem[_6614 + 128] * mem[_6614]) / mem[_6614 + 96] + mem[_6614 + 128] != mem[_6614]:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not (mem[_6614 + 96] * mem[_6614]) + (mem[_6614 + 128] * mem[_6614]):
                        _7307 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_7307] = 26
                        mem[_7307 + 32] = 'SafeMath: division by zero'
                        if not _6785:
                            _7482 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _7482 + 68] = mem[_7307 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_7482 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _7482 + -mem[64] + 100
                        _7793 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_7793] = 26
                        mem[_7793 + 32] = 'SafeMath: division by zero'
                        if _6784:
                            if s > !(0 / _6785 / _6784):
                                revert with 0, 17
                            if s + (0 / _6785 / _6784) < s:
                                revert with 0, 'SafeMath: addition overflow'
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + (0 / _6785 / _6784)
                            continue 
                        _7935 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _7935 + 68] = mem[_7793 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_7935 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _7935 + -mem[64] + 100
                    if (mem[_6614 + 96] * mem[_6614]) + (mem[_6614 + 128] * mem[_6614]) and mem[(2 * ceil32(return_data.size)) + 544] > -1 / (mem[_6614 + 96] * mem[_6614]) + (mem[_6614 + 128] * mem[_6614]):
                        revert with 0, 17
                    if not (mem[_6614 + 96] * mem[_6614]) + (mem[_6614 + 128] * mem[_6614]):
                        revert with 0, 18
                    if (mem[_6614 + 96] * mem[_6614] * mem[(2 * ceil32(return_data.size)) + 544]) + (mem[_6614 + 128] * mem[_6614] * mem[(2 * ceil32(return_data.size)) + 544]) / (mem[_6614 + 96] * mem[_6614]) + (mem[_6614 + 128] * mem[_6614]) != mem[(2 * ceil32(return_data.size)) + 544]:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _7701 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_7701] = 26
                    mem[_7701 + 32] = 'SafeMath: division by zero'
                    if not _6785:
                        _7792 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _7792 + 68] = mem[_7701 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_7792 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _7792 + -mem[64] + 100
                    _8072 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_8072] = 26
                    mem[_8072 + 32] = 'SafeMath: division by zero'
                    if _6784:
                        if s > !((_6789 * _6787 * _6786) + (_6788 * _6787 * _6786) / _6785 / _6784):
                            revert with 0, 17
                        if s + ((_6789 * _6787 * _6786) + (_6788 * _6787 * _6786) / _6785 / _6784) < s:
                            revert with 0, 'SafeMath: addition overflow'
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + ((_6789 * _6787 * _6786) + (_6788 * _6787 * _6786) / _6785 / _6784)
                        continue 
                    _8147 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _8147 + 68] = mem[_8072 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_8147 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _8147 + -mem[64] + 100
                if s >= mem[ceil32(return_data.size) + 288]:
                    _6562 = mem[ceil32(return_data.size) + 128]
                    staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                            gas gas_remaining wei
                           args address(arg1), Mask(128, 128, mem[ceil32(return_data.size) + 128])
                    mem[mem[64] len 352] = ext_call.return_data[0 len 352]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _6817 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 352
                    _6860 = mem[64]
                    if mem[64] + 352 < mem[64] or mem[64] + 352 > test266151307():
                        revert with 0, 65
                    mem[64] = mem[64] + 352
                    require mem[_6817] == Mask(128, 128, mem[_6817])
                    mem[_6860] = mem[_6817]
                    mem[_6860 + 32] = mem[_6817 + 32]
                    mem[_6860 + 64] = mem[_6817 + 64]
                    mem[_6860 + 96] = mem[_6817 + 96]
                    require mem[_6817 + 128] < 5
                    mem[_6860 + 128] = mem[_6817 + 128]
                    mem[_6860 + 160] = mem[_6817 + 160]
                    mem[_6860 + 192] = mem[_6817 + 192]
                    mem[_6860 + 224] = mem[_6817 + 224]
                    mem[_6860 + 256] = mem[_6817 + 256]
                    mem[_6860 + 288] = mem[_6817 + 288]
                    mem[_6860 + 320] = mem[_6817 + 320]
                    if Mask(128, 128, mem[_6860]) != Mask(128, 128, _6562):
                        revert with 0, 'Address does not contain stake with provided id'
                    idx = mem[_6860 + 192]
                    s = 0
                    while idx < arg3:
                        staticcall sub_413c05c6Address.0x8ce1d9e4 with:
                                gas gas_remaining wei
                               args idx
                        mem[mem[64] len 160] = ext_call.return_data[0 len 160]
                        if not ext_call.success:
                            revert with ext_call.return_data[0 len return_data.size]
                        _12655 = mem[64]
                        mem[64] = mem[64] + ceil32(return_data.size)
                        require return_data.size >= 160
                        _12795 = mem[64]
                        if mem[64] + 160 > test266151307() or mem[64] + 160 < mem[64]:
                            revert with 0, 65
                        mem[64] = mem[64] + 160
                        mem[_12795] = mem[_12655]
                        mem[_12795 + 32] = mem[_12655 + 32]
                        mem[_12795 + 64] = mem[_12655 + 64]
                        mem[_12795 + 96] = mem[_12655 + 96]
                        mem[_12795 + 128] = mem[_12655 + 128]
                        _13216 = mem[_12795 + 64]
                        _13217 = mem[_12795 + 32]
                        _13218 = mem[_6860 + 64]
                        _13219 = mem[_12795]
                        _13220 = mem[_12795 + 128]
                        _13221 = mem[_12795 + 96]
                        if mem[_12795 + 96] > !mem[_12795 + 128]:
                            revert with 0, 17
                        if mem[_12795 + 96] + mem[_12795 + 128] < mem[_12795 + 96]:
                            revert with 0, 'SafeMath: addition overflow'
                        if not mem[_12795 + 96] + mem[_12795 + 128]:
                            _13611 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13611] = 26
                            mem[_13611 + 32] = 'SafeMath: division by zero'
                            if not _13217:
                                _13690 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _13690 + 68] = mem[_13611 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13690 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _13690 + -mem[64] + 100
                            _14085 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14085] = 26
                            mem[_14085 + 32] = 'SafeMath: division by zero'
                            if _13216:
                                if s > !(0 / _13217 / _13216):
                                    revert with 0, 17
                                if s + (0 / _13217 / _13216) < s:
                                    revert with 0, 'SafeMath: addition overflow'
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (0 / _13217 / _13216)
                                continue 
                            _14244 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _14244 + 68] = mem[_14085 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_14244 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _14244 + -mem[64] + 100
                        if mem[_12795 + 96] + mem[_12795 + 128] and mem[_12795] > -1 / mem[_12795 + 96] + mem[_12795 + 128]:
                            revert with 0, 17
                        if not mem[_12795 + 96] + mem[_12795 + 128]:
                            revert with 0, 18
                        if (mem[_12795 + 96] * mem[_12795]) + (mem[_12795 + 128] * mem[_12795]) / mem[_12795 + 96] + mem[_12795 + 128] != mem[_12795]:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not (mem[_12795 + 96] * mem[_12795]) + (mem[_12795 + 128] * mem[_12795]):
                            _13862 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13862] = 26
                            mem[_13862 + 32] = 'SafeMath: division by zero'
                            if not _13217:
                                _14084 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _14084 + 68] = mem[_13862 + idx + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14084 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _14084 + -mem[64] + 100
                            _14547 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14547] = 26
                            mem[_14547 + 32] = 'SafeMath: division by zero'
                            if _13216:
                                if s > !(0 / _13217 / _13216):
                                    revert with 0, 17
                                if s + (0 / _13217 / _13216) < s:
                                    revert with 0, 'SafeMath: addition overflow'
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s + (0 / _13217 / _13216)
                                continue 
                            _14763 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _14763 + 68] = mem[_14547 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_14763 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _14763 + -mem[64] + 100
                        if (mem[_12795 + 96] * mem[_12795]) + (mem[_12795 + 128] * mem[_12795]) and mem[_6860 + 64] > -1 / (mem[_12795 + 96] * mem[_12795]) + (mem[_12795 + 128] * mem[_12795]):
                            revert with 0, 17
                        if not (mem[_12795 + 96] * mem[_12795]) + (mem[_12795 + 128] * mem[_12795]):
                            revert with 0, 18
                        if (mem[_12795 + 96] * mem[_12795] * mem[_6860 + 64]) + (mem[_12795 + 128] * mem[_12795] * mem[_6860 + 64]) / (mem[_12795 + 96] * mem[_12795]) + (mem[_12795 + 128] * mem[_12795]) != mem[_6860 + 64]:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _14410 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14410] = 26
                        mem[_14410 + 32] = 'SafeMath: division by zero'
                        if not _13217:
                            _14546 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _14546 + 68] = mem[_14410 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_14546 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _14546 + -mem[64] + 100
                        _15004 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_15004] = 26
                        mem[_15004 + 32] = 'SafeMath: division by zero'
                        if _13216:
                            if s > !((_13221 * _13219 * _13218) + (_13220 * _13219 * _13218) / _13217 / _13216):
                                revert with 0, 17
                            if s + ((_13221 * _13219 * _13218) + (_13220 * _13219 * _13218) / _13217 / _13216) < s:
                                revert with 0, 'SafeMath: addition overflow'
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + ((_13221 * _13219 * _13218) + (_13220 * _13219 * _13218) / _13217 / _13216)
                            continue 
                        _15166 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _15166 + 68] = mem[_15004 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_15166 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _15166 + -mem[64] + 100
                    mem[mem[64]] = mem[ceil32(return_data.size) + 160]
                    return mem[mem[64]], s
                _6563 = mem[ceil32(return_data.size) + 288]
                _6613 = mem[64]
                mem[64] = mem[64] + 64
                mem[_6613] = 30
                mem[_6613 + 32] = 'SafeMath: subtraction overflow'
                if s > _6563:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if _6563 < s:
                    revert with 0, 17
                _6883 = mem[ceil32(return_data.size) + 128]
                staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                        gas gas_remaining wei
                       args address(arg1), Mask(128, 128, mem[ceil32(return_data.size) + 128])
                mem[mem[64] len 352] = ext_call.return_data[0 len 352]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _6964 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 352
                _7013 = mem[64]
                if mem[64] + 352 < mem[64] or mem[64] + 352 > test266151307():
                    revert with 0, 65
                mem[64] = mem[64] + 352
                require mem[_6964] == Mask(128, 128, mem[_6964])
                mem[_7013] = mem[_6964]
                mem[_7013 + 32] = mem[_6964 + 32]
                mem[_7013 + 64] = mem[_6964 + 64]
                mem[_7013 + 96] = mem[_6964 + 96]
                require mem[_6964 + 128] < 5
                mem[_7013 + 128] = mem[_6964 + 128]
                mem[_7013 + 160] = mem[_6964 + 160]
                mem[_7013 + 192] = mem[_6964 + 192]
                mem[_7013 + 224] = mem[_6964 + 224]
                mem[_7013 + 256] = mem[_6964 + 256]
                mem[_7013 + 288] = mem[_6964 + 288]
                mem[_7013 + 320] = mem[_6964 + 320]
                if Mask(128, 128, mem[_7013]) != Mask(128, 128, _6883):
                    revert with 0, 'Address does not contain stake with provided id'
                idx = mem[_7013 + 192]
                t = 0
                while idx < arg3:
                    staticcall sub_413c05c6Address.0x8ce1d9e4 with:
                            gas gas_remaining wei
                           args idx
                    mem[mem[64] len 160] = ext_call.return_data[0 len 160]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _12657 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 160
                    _12796 = mem[64]
                    if mem[64] + 160 > test266151307() or mem[64] + 160 < mem[64]:
                        revert with 0, 65
                    mem[64] = mem[64] + 160
                    mem[_12796] = mem[_12657]
                    mem[_12796 + 32] = mem[_12657 + 32]
                    mem[_12796 + 64] = mem[_12657 + 64]
                    mem[_12796 + 96] = mem[_12657 + 96]
                    mem[_12796 + 128] = mem[_12657 + 128]
                    _13222 = mem[_12796 + 64]
                    _13223 = mem[_12796 + 32]
                    _13224 = mem[_7013 + 64]
                    _13225 = mem[_12796]
                    _13226 = mem[_12796 + 128]
                    _13227 = mem[_12796 + 96]
                    if mem[_12796 + 96] > !mem[_12796 + 128]:
                        revert with 0, 17
                    if mem[_12796 + 96] + mem[_12796 + 128] < mem[_12796 + 96]:
                        revert with 0, 'SafeMath: addition overflow'
                    if not mem[_12796 + 96] + mem[_12796 + 128]:
                        _13613 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13613] = 26
                        mem[_13613 + 32] = 'SafeMath: division by zero'
                        if not _13223:
                            _13691 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _13691 + 68] = mem[_13613 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_13691 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _13691 + -mem[64] + 100
                        _14087 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14087] = 26
                        mem[_14087 + 32] = 'SafeMath: division by zero'
                        if _13222:
                            if t > !(0 / _13223 / _13222):
                                revert with 0, 17
                            if t + (0 / _13223 / _13222) < t:
                                revert with 0, 'SafeMath: addition overflow'
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            t = t + (0 / _13223 / _13222)
                            continue 
                        _14248 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _14248 + 68] = mem[_14087 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_14248 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _14248 + -mem[64] + 100
                    if mem[_12796 + 96] + mem[_12796 + 128] and mem[_12796] > -1 / mem[_12796 + 96] + mem[_12796 + 128]:
                        revert with 0, 17
                    if not mem[_12796 + 96] + mem[_12796 + 128]:
                        revert with 0, 18
                    if (mem[_12796 + 96] * mem[_12796]) + (mem[_12796 + 128] * mem[_12796]) / mem[_12796 + 96] + mem[_12796 + 128] != mem[_12796]:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not (mem[_12796 + 96] * mem[_12796]) + (mem[_12796 + 128] * mem[_12796]):
                        _13864 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13864] = 26
                        mem[_13864 + 32] = 'SafeMath: division by zero'
                        if not _13223:
                            _14086 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _14086 + 68] = mem[_13864 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_14086 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _14086 + -mem[64] + 100
                        _14550 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14550] = 26
                        mem[_14550 + 32] = 'SafeMath: division by zero'
                        if _13222:
                            if t > !(0 / _13223 / _13222):
                                revert with 0, 17
                            if t + (0 / _13223 / _13222) < t:
                                revert with 0, 'SafeMath: addition overflow'
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            t = t + (0 / _13223 / _13222)
                            continue 
                        _14766 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _14766 + 68] = mem[_14550 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_14766 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _14766 + -mem[64] + 100
                    if (mem[_12796 + 96] * mem[_12796]) + (mem[_12796 + 128] * mem[_12796]) and mem[_7013 + 64] > -1 / (mem[_12796 + 96] * mem[_12796]) + (mem[_12796 + 128] * mem[_12796]):
                        revert with 0, 17
                    if not (mem[_12796 + 96] * mem[_12796]) + (mem[_12796 + 128] * mem[_12796]):
                        revert with 0, 18
                    if (mem[_12796 + 96] * mem[_12796] * mem[_7013 + 64]) + (mem[_12796 + 128] * mem[_12796] * mem[_7013 + 64]) / (mem[_12796 + 96] * mem[_12796]) + (mem[_12796 + 128] * mem[_12796]) != mem[_7013 + 64]:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _14413 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14413] = 26
                    mem[_14413 + 32] = 'SafeMath: division by zero'
                    if not _13223:
                        _14549 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _14549 + 68] = mem[_14413 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_14549 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _14549 + -mem[64] + 100
                    _15007 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_15007] = 26
                    mem[_15007 + 32] = 'SafeMath: division by zero'
                    if _13222:
                        if t > !((_13227 * _13225 * _13224) + (_13226 * _13225 * _13224) / _13223 / _13222):
                            revert with 0, 17
                        if t + ((_13227 * _13225 * _13224) + (_13226 * _13225 * _13224) / _13223 / _13222) < t:
                            revert with 0, 'SafeMath: addition overflow'
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        t = t + ((_13227 * _13225 * _13224) + (_13226 * _13225 * _13224) / _13223 / _13222)
                        continue 
                    _15168 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _15168 + 68] = mem[_15007 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_15168 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _15168 + -mem[64] + 100
                if _6563 - s > !t:
                    revert with 0, 17
                if t < 0:
                    revert with 0, 'SafeMath: addition overflow'
                mem[mem[64]] = mem[ceil32(return_data.size) + 160]
                return mem[mem[64]], _6563 - s + t
            idx = mem[(2 * ceil32(return_data.size)) + 672]
            s = 0
            while idx < ext_call.return_data[192] + ext_call.return_data[224]:
                staticcall sub_413c05c6Address.0x8ce1d9e4 with:
                        gas gas_remaining wei
                       args idx
                mem[mem[64] len 160] = ext_call.return_data[0 len 160]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _6543 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 160
                _6617 = mem[64]
                if mem[64] + 160 > test266151307() or mem[64] + 160 < mem[64]:
                    revert with 0, 65
                mem[64] = mem[64] + 160
                mem[_6617] = mem[_6543]
                mem[_6617 + 32] = mem[_6543 + 32]
                mem[_6617 + 64] = mem[_6543 + 64]
                mem[_6617 + 96] = mem[_6543 + 96]
                mem[_6617 + 128] = mem[_6543 + 128]
                _6792 = mem[_6617 + 64]
                _6793 = mem[_6617 + 32]
                _6794 = mem[(2 * ceil32(return_data.size)) + 544]
                _6795 = mem[_6617]
                _6796 = mem[_6617 + 128]
                _6797 = mem[_6617 + 96]
                if mem[_6617 + 96] > !mem[_6617 + 128]:
                    revert with 0, 17
                if mem[_6617 + 96] + mem[_6617 + 128] < mem[_6617 + 96]:
                    revert with 0, 'SafeMath: addition overflow'
                if not mem[_6617 + 96] + mem[_6617 + 128]:
                    _7111 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_7111] = 26
                    mem[_7111 + 32] = 'SafeMath: division by zero'
                    if not _6793:
                        _7160 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _7160 + 68] = mem[_7111 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_7160 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _7160 + -mem[64] + 100
                    _7492 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_7492] = 26
                    mem[_7492 + 32] = 'SafeMath: division by zero'
                    if _6792:
                        if s > !(0 / _6793 / _6792):
                            revert with 0, 17
                        if s + (0 / _6793 / _6792) < s:
                            revert with 0, 'SafeMath: addition overflow'
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + (0 / _6793 / _6792)
                        continue 
                    _7598 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _7598 + 68] = mem[_7492 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_7598 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _7598 + -mem[64] + 100
                if mem[_6617 + 96] + mem[_6617 + 128] and mem[_6617] > -1 / mem[_6617 + 96] + mem[_6617 + 128]:
                    revert with 0, 17
                if not mem[_6617 + 96] + mem[_6617 + 128]:
                    revert with 0, 18
                if (mem[_6617 + 96] * mem[_6617]) + (mem[_6617 + 128] * mem[_6617]) / mem[_6617 + 96] + mem[_6617 + 128] != mem[_6617]:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not (mem[_6617 + 96] * mem[_6617]) + (mem[_6617 + 128] * mem[_6617]):
                    _7311 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_7311] = 26
                    mem[_7311 + 32] = 'SafeMath: division by zero'
                    if not _6793:
                        _7491 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _7491 + 68] = mem[_7311 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_7491 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _7491 + -mem[64] + 100
                    _7798 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_7798] = 26
                    mem[_7798 + 32] = 'SafeMath: division by zero'
                    if _6792:
                        if s > !(0 / _6793 / _6792):
                            revert with 0, 17
                        if s + (0 / _6793 / _6792) < s:
                            revert with 0, 'SafeMath: addition overflow'
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + (0 / _6793 / _6792)
                        continue 
                    _7944 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _7944 + 68] = mem[_7798 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_7944 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _7944 + -mem[64] + 100
                if (mem[_6617 + 96] * mem[_6617]) + (mem[_6617 + 128] * mem[_6617]) and mem[(2 * ceil32(return_data.size)) + 544] > -1 / (mem[_6617 + 96] * mem[_6617]) + (mem[_6617 + 128] * mem[_6617]):
                    revert with 0, 17
                if not (mem[_6617 + 96] * mem[_6617]) + (mem[_6617 + 128] * mem[_6617]):
                    revert with 0, 18
                if (mem[_6617 + 96] * mem[_6617] * mem[(2 * ceil32(return_data.size)) + 544]) + (mem[_6617 + 128] * mem[_6617] * mem[(2 * ceil32(return_data.size)) + 544]) / (mem[_6617 + 96] * mem[_6617]) + (mem[_6617 + 128] * mem[_6617]) != mem[(2 * ceil32(return_data.size)) + 544]:
                    revert with 0, 'SafeMath: multiplication overflow'
                _7706 = mem[64]
                mem[64] = mem[64] + 64
                mem[_7706] = 26
                mem[_7706 + 32] = 'SafeMath: division by zero'
                if not _6793:
                    _7797 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _7797 + 68] = mem[_7706 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_7797 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _7797 + -mem[64] + 100
                _8076 = mem[64]
                mem[64] = mem[64] + 64
                mem[_8076] = 26
                mem[_8076 + 32] = 'SafeMath: division by zero'
                if _6792:
                    if s > !((_6797 * _6795 * _6794) + (_6796 * _6795 * _6794) / _6793 / _6792):
                        revert with 0, 17
                    if s + ((_6797 * _6795 * _6794) + (_6796 * _6795 * _6794) / _6793 / _6792) < s:
                        revert with 0, 'SafeMath: addition overflow'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + ((_6797 * _6795 * _6794) + (_6796 * _6795 * _6794) / _6793 / _6792)
                    continue 
                _8150 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _8150 + 68] = mem[_8076 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_8150 + 94] = 0
                revert with memory
                  from mem[64]
                   len _8150 + -mem[64] + 100
            if s >= mem[ceil32(return_data.size) + 288]:
                _6564 = mem[ceil32(return_data.size) + 128]
                staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                        gas gas_remaining wei
                       args address(arg1), Mask(128, 128, mem[ceil32(return_data.size) + 128])
                mem[mem[64] len 352] = ext_call.return_data[0 len 352]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _6818 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 352
                _6862 = mem[64]
                if mem[64] + 352 < mem[64] or mem[64] + 352 > test266151307():
                    revert with 0, 65
                mem[64] = mem[64] + 352
                require mem[_6818] == Mask(128, 128, mem[_6818])
                mem[_6862] = mem[_6818]
                mem[_6862 + 32] = mem[_6818 + 32]
                mem[_6862 + 64] = mem[_6818 + 64]
                mem[_6862 + 96] = mem[_6818 + 96]
                require mem[_6818 + 128] < 5
                mem[_6862 + 128] = mem[_6818 + 128]
                mem[_6862 + 160] = mem[_6818 + 160]
                mem[_6862 + 192] = mem[_6818 + 192]
                mem[_6862 + 224] = mem[_6818 + 224]
                mem[_6862 + 256] = mem[_6818 + 256]
                mem[_6862 + 288] = mem[_6818 + 288]
                mem[_6862 + 320] = mem[_6818 + 320]
                if Mask(128, 128, mem[_6862]) != Mask(128, 128, _6564):
                    revert with 0, 'Address does not contain stake with provided id'
                idx = mem[_6862 + 192]
                s = 0
                while idx < ext_call.return_data[192] + ext_call.return_data[224]:
                    staticcall sub_413c05c6Address.0x8ce1d9e4 with:
                            gas gas_remaining wei
                           args idx
                    mem[mem[64] len 160] = ext_call.return_data[0 len 160]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _12659 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 160
                    _12805 = mem[64]
                    if mem[64] + 160 > test266151307() or mem[64] + 160 < mem[64]:
                        revert with 0, 65
                    mem[64] = mem[64] + 160
                    mem[_12805] = mem[_12659]
                    mem[_12805 + 32] = mem[_12659 + 32]
                    mem[_12805 + 64] = mem[_12659 + 64]
                    mem[_12805 + 96] = mem[_12659 + 96]
                    mem[_12805 + 128] = mem[_12659 + 128]
                    _13228 = mem[_12805 + 64]
                    _13229 = mem[_12805 + 32]
                    _13230 = mem[_6862 + 64]
                    _13231 = mem[_12805]
                    _13232 = mem[_12805 + 128]
                    _13233 = mem[_12805 + 96]
                    if mem[_12805 + 96] > !mem[_12805 + 128]:
                        revert with 0, 17
                    if mem[_12805 + 96] + mem[_12805 + 128] < mem[_12805 + 96]:
                        revert with 0, 'SafeMath: addition overflow'
                    if not mem[_12805 + 96] + mem[_12805 + 128]:
                        _13615 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13615] = 26
                        mem[_13615 + 32] = 'SafeMath: division by zero'
                        if not _13229:
                            _13692 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _13692 + 68] = mem[_13615 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_13692 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _13692 + -mem[64] + 100
                        _14089 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14089] = 26
                        mem[_14089 + 32] = 'SafeMath: division by zero'
                        if _13228:
                            if s > !(0 / _13229 / _13228):
                                revert with 0, 17
                            if s + (0 / _13229 / _13228) < s:
                                revert with 0, 'SafeMath: addition overflow'
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + (0 / _13229 / _13228)
                            continue 
                        _14252 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _14252 + 68] = mem[_14089 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_14252 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _14252 + -mem[64] + 100
                    if mem[_12805 + 96] + mem[_12805 + 128] and mem[_12805] > -1 / mem[_12805 + 96] + mem[_12805 + 128]:
                        revert with 0, 17
                    if not mem[_12805 + 96] + mem[_12805 + 128]:
                        revert with 0, 18
                    if (mem[_12805 + 96] * mem[_12805]) + (mem[_12805 + 128] * mem[_12805]) / mem[_12805 + 96] + mem[_12805 + 128] != mem[_12805]:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not (mem[_12805 + 96] * mem[_12805]) + (mem[_12805 + 128] * mem[_12805]):
                        _13866 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13866] = 26
                        mem[_13866 + 32] = 'SafeMath: division by zero'
                        if not _13229:
                            _14088 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _14088 + 68] = mem[_13866 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_14088 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _14088 + -mem[64] + 100
                        _14553 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14553] = 26
                        mem[_14553 + 32] = 'SafeMath: division by zero'
                        if _13228:
                            if s > !(0 / _13229 / _13228):
                                revert with 0, 17
                            if s + (0 / _13229 / _13228) < s:
                                revert with 0, 'SafeMath: addition overflow'
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + (0 / _13229 / _13228)
                            continue 
                        _14769 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _14769 + 68] = mem[_14553 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_14769 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _14769 + -mem[64] + 100
                    if (mem[_12805 + 96] * mem[_12805]) + (mem[_12805 + 128] * mem[_12805]) and mem[_6862 + 64] > -1 / (mem[_12805 + 96] * mem[_12805]) + (mem[_12805 + 128] * mem[_12805]):
                        revert with 0, 17
                    if not (mem[_12805 + 96] * mem[_12805]) + (mem[_12805 + 128] * mem[_12805]):
                        revert with 0, 18
                    if (mem[_12805 + 96] * mem[_12805] * mem[_6862 + 64]) + (mem[_12805 + 128] * mem[_12805] * mem[_6862 + 64]) / (mem[_12805 + 96] * mem[_12805]) + (mem[_12805 + 128] * mem[_12805]) != mem[_6862 + 64]:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _14416 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14416] = 26
                    mem[_14416 + 32] = 'SafeMath: division by zero'
                    if not _13229:
                        _14552 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _14552 + 68] = mem[_14416 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_14552 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _14552 + -mem[64] + 100
                    _15010 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_15010] = 26
                    mem[_15010 + 32] = 'SafeMath: division by zero'
                    if _13228:
                        if s > !((_13233 * _13231 * _13230) + (_13232 * _13231 * _13230) / _13229 / _13228):
                            revert with 0, 17
                        if s + ((_13233 * _13231 * _13230) + (_13232 * _13231 * _13230) / _13229 / _13228) < s:
                            revert with 0, 'SafeMath: addition overflow'
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + ((_13233 * _13231 * _13230) + (_13232 * _13231 * _13230) / _13229 / _13228)
                        continue 
                    _15170 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _15170 + 68] = mem[_15010 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_15170 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _15170 + -mem[64] + 100
                mem[mem[64]] = mem[ceil32(return_data.size) + 160]
                return mem[mem[64]], s
            _6565 = mem[ceil32(return_data.size) + 288]
            _6616 = mem[64]
            mem[64] = mem[64] + 64
            mem[_6616] = 30
            mem[_6616 + 32] = 'SafeMath: subtraction overflow'
            if s > _6565:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if _6565 < s:
                revert with 0, 17
            _6885 = mem[ceil32(return_data.size) + 128]
            staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                    gas gas_remaining wei
                   args address(arg1), Mask(128, 128, mem[ceil32(return_data.size) + 128])
            mem[mem[64] len 352] = ext_call.return_data[0 len 352]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _6965 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 352
            _7015 = mem[64]
            if mem[64] + 352 < mem[64] or mem[64] + 352 > test266151307():
                revert with 0, 65
            mem[64] = mem[64] + 352
            require mem[_6965] == Mask(128, 128, mem[_6965])
            mem[_7015] = mem[_6965]
            mem[_7015 + 32] = mem[_6965 + 32]
            mem[_7015 + 64] = mem[_6965 + 64]
            mem[_7015 + 96] = mem[_6965 + 96]
            require mem[_6965 + 128] < 5
            mem[_7015 + 128] = mem[_6965 + 128]
            mem[_7015 + 160] = mem[_6965 + 160]
            mem[_7015 + 192] = mem[_6965 + 192]
            mem[_7015 + 224] = mem[_6965 + 224]
            mem[_7015 + 256] = mem[_6965 + 256]
            mem[_7015 + 288] = mem[_6965 + 288]
            mem[_7015 + 320] = mem[_6965 + 320]
            if Mask(128, 128, mem[_7015]) != Mask(128, 128, _6885):
                revert with 0, 'Address does not contain stake with provided id'
            idx = mem[_7015 + 192]
            t = 0
            while idx < ext_call.return_data[192] + ext_call.return_data[224]:
                staticcall sub_413c05c6Address.0x8ce1d9e4 with:
                        gas gas_remaining wei
                       args idx
                mem[mem[64] len 160] = ext_call.return_data[0 len 160]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _12661 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 160
                _12806 = mem[64]
                if mem[64] + 160 > test266151307() or mem[64] + 160 < mem[64]:
                    revert with 0, 65
                mem[64] = mem[64] + 160
                mem[_12806] = mem[_12661]
                mem[_12806 + 32] = mem[_12661 + 32]
                mem[_12806 + 64] = mem[_12661 + 64]
                mem[_12806 + 96] = mem[_12661 + 96]
                mem[_12806 + 128] = mem[_12661 + 128]
                _13234 = mem[_12806 + 64]
                _13235 = mem[_12806 + 32]
                _13236 = mem[_7015 + 64]
                _13237 = mem[_12806]
                _13238 = mem[_12806 + 128]
                _13239 = mem[_12806 + 96]
                if mem[_12806 + 96] > !mem[_12806 + 128]:
                    revert with 0, 17
                if mem[_12806 + 96] + mem[_12806 + 128] < mem[_12806 + 96]:
                    revert with 0, 'SafeMath: addition overflow'
                if not mem[_12806 + 96] + mem[_12806 + 128]:
                    _13617 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_13617] = 26
                    mem[_13617 + 32] = 'SafeMath: division by zero'
                    if not _13235:
                        _13693 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _13693 + 68] = mem[_13617 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_13693 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _13693 + -mem[64] + 100
                    _14091 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14091] = 26
                    mem[_14091 + 32] = 'SafeMath: division by zero'
                    if _13234:
                        if t > !(0 / _13235 / _13234):
                            revert with 0, 17
                        if t + (0 / _13235 / _13234) < t:
                            revert with 0, 'SafeMath: addition overflow'
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        t = t + (0 / _13235 / _13234)
                        continue 
                    _14256 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _14256 + 68] = mem[_14091 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_14256 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _14256 + -mem[64] + 100
                if mem[_12806 + 96] + mem[_12806 + 128] and mem[_12806] > -1 / mem[_12806 + 96] + mem[_12806 + 128]:
                    revert with 0, 17
                if not mem[_12806 + 96] + mem[_12806 + 128]:
                    revert with 0, 18
                if (mem[_12806 + 96] * mem[_12806]) + (mem[_12806 + 128] * mem[_12806]) / mem[_12806 + 96] + mem[_12806 + 128] != mem[_12806]:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not (mem[_12806 + 96] * mem[_12806]) + (mem[_12806 + 128] * mem[_12806]):
                    _13868 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_13868] = 26
                    mem[_13868 + 32] = 'SafeMath: division by zero'
                    if not _13235:
                        _14090 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _14090 + 68] = mem[_13868 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_14090 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _14090 + -mem[64] + 100
                    _14556 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14556] = 26
                    mem[_14556 + 32] = 'SafeMath: division by zero'
                    if _13234:
                        if t > !(0 / _13235 / _13234):
                            revert with 0, 17
                        if t + (0 / _13235 / _13234) < t:
                            revert with 0, 'SafeMath: addition overflow'
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        t = t + (0 / _13235 / _13234)
                        continue 
                    _14772 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _14772 + 68] = mem[_14556 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_14772 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _14772 + -mem[64] + 100
                if (mem[_12806 + 96] * mem[_12806]) + (mem[_12806 + 128] * mem[_12806]) and mem[_7015 + 64] > -1 / (mem[_12806 + 96] * mem[_12806]) + (mem[_12806 + 128] * mem[_12806]):
                    revert with 0, 17
                if not (mem[_12806 + 96] * mem[_12806]) + (mem[_12806 + 128] * mem[_12806]):
                    revert with 0, 18
                if (mem[_12806 + 96] * mem[_12806] * mem[_7015 + 64]) + (mem[_12806 + 128] * mem[_12806] * mem[_7015 + 64]) / (mem[_12806 + 96] * mem[_12806]) + (mem[_12806 + 128] * mem[_12806]) != mem[_7015 + 64]:
                    revert with 0, 'SafeMath: multiplication overflow'
                _14419 = mem[64]
                mem[64] = mem[64] + 64
                mem[_14419] = 26
                mem[_14419 + 32] = 'SafeMath: division by zero'
                if not _13235:
                    _14555 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _14555 + 68] = mem[_14419 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_14555 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _14555 + -mem[64] + 100
                _15013 = mem[64]
                mem[64] = mem[64] + 64
                mem[_15013] = 26
                mem[_15013 + 32] = 'SafeMath: division by zero'
                if _13234:
                    if t > !((_13239 * _13237 * _13236) + (_13238 * _13237 * _13236) / _13235 / _13234):
                        revert with 0, 17
                    if t + ((_13239 * _13237 * _13236) + (_13238 * _13237 * _13236) / _13235 / _13234) < t:
                        revert with 0, 'SafeMath: addition overflow'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    t = t + ((_13239 * _13237 * _13236) + (_13238 * _13237 * _13236) / _13235 / _13234)
                    continue 
                _15172 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _15172 + 68] = mem[_15013 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_15172 + 94] = 0
                revert with memory
                  from mem[64]
                   len _15172 + -mem[64] + 100
            if _6565 - s > !t:
                revert with 0, 17
            if t < 0:
                revert with 0, 'SafeMath: addition overflow'
            mem[mem[64]] = mem[ceil32(return_data.size) + 160]
            return mem[mem[64]], _6565 - s + t
        if uint32(call.func_hash) >> 224 != unknown_0xdb45a4ec(?????):
            if unknown_0xddeed3d5(?????) == uint32(call.func_hash) >> 224:
                require not msg.value
                return bool(uint8(stor1.field_160))
            if uint32(call.func_hash) >> 224 != unknown_0xe6a4f059(?????):
                require unknown_0xed73481d(?????) == uint32(call.func_hash) >> 224
                require not msg.value
                return sub_ed73481d
            require not msg.value
            require calldata.size - 4 >= 64
            require arg1 == address(arg1)
            require arg2 == Mask(128, 128, arg2)
            return bool(stor8[arg1][arg2])
        require not msg.value
        require calldata.size - 4 >= 128
        require arg1 == address(arg1)
        require arg2 == Mask(128, 128, arg2)
        mem[128] = 0
        mem[160] = 0
        mem[192] = 0
        mem[224] = 0
        mem[256] = 0
        mem[288] = 0
        mem[320] = 0
        mem[352] = 0
        mem[384] = 0
        mem[416] = 0
        mem[448] = 0
        staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                gas gas_remaining wei
               args address(arg1), Mask(128, 128, arg2)
        mem[480 len 352] = ext_call.return_data[0 len 352]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 352
        if not bool(ceil32(return_data.size) + 832 <= test266151307()):
            revert with 0, 65
        require ext_call.return_data[0] == Mask(128, 128, ext_call.return_data[0])
        mem[ceil32(return_data.size) + 480] = ext_call.return_data[0]
        mem[ceil32(return_data.size) + 512] = ext_call.return_data[32]
        mem[ceil32(return_data.size) + 544] = ext_call.return_data[64]
        mem[ceil32(return_data.size) + 576] = ext_call.return_data[96]
        require ext_call.return_data[128] < 5
        mem[ceil32(return_data.size) + 608] = ext_call.return_data[128]
        mem[ceil32(return_data.size) + 640] = ext_call.return_data[160]
        mem[ceil32(return_data.size) + 672] = ext_call.return_data[192]
        mem[ceil32(return_data.size) + 704] = ext_call.return_data[224]
        mem[ceil32(return_data.size) + 736] = ext_call.return_data[256]
        mem[ceil32(return_data.size) + 768] = ext_call.return_data[288]
        mem[ceil32(return_data.size) + 800] = ext_call.return_data[320]
        if Mask(128, 128, ext_call.return_data[0]) != Mask(128, 128, arg2):
            return 0
        mem[0] = Mask(128, 128, arg2)
        mem[32] = sha3(address(arg1), 9)
        if stor9[address(arg1)][Mask(128, 128, arg2)]:
            return 0
        if ext_call.return_data[128] > 4:
            revert with 0, 33
        if ext_call.return_data[128] != 2:
            return 0
        if ext_call.return_data[192] >= arg3:
            return 0
        if ext_call.return_data[192] > !ext_call.return_data[224]:
            revert with 0, 17
        if ext_call.return_data[192] + ext_call.return_data[224] < arg3:
            return 0
        mem[ceil32(return_data.size) + 832] = 17
        mem[ceil32(return_data.size) + 864] = 'Stake is eligible' << 120
        staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                gas gas_remaining wei
               args address(arg1), Mask(128, 128, arg2)
        mem[ceil32(return_data.size) + 896 len 352] = ext_call.return_data[0 len 352]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 352
        if not bool((2 * ceil32(return_data.size)) + 1248 <= test266151307()):
            revert with 0, 65
        require ext_call.return_data[0] == Mask(128, 128, ext_call.return_data[0])
        mem[(2 * ceil32(return_data.size)) + 896] = ext_call.return_data[0]
        mem[(2 * ceil32(return_data.size)) + 928] = ext_call.return_data[32]
        mem[(2 * ceil32(return_data.size)) + 960] = ext_call.return_data[64]
        mem[(2 * ceil32(return_data.size)) + 992] = ext_call.return_data[96]
        require ext_call.return_data[128] < 5
        mem[(2 * ceil32(return_data.size)) + 1024] = ext_call.return_data[128]
        mem[(2 * ceil32(return_data.size)) + 1056] = ext_call.return_data[160]
        mem[(2 * ceil32(return_data.size)) + 1088] = ext_call.return_data[192]
        mem[(2 * ceil32(return_data.size)) + 1120] = ext_call.return_data[224]
        mem[(2 * ceil32(return_data.size)) + 1152] = ext_call.return_data[256]
        mem[(2 * ceil32(return_data.size)) + 1184] = ext_call.return_data[288]
        mem[(2 * ceil32(return_data.size)) + 1216] = ext_call.return_data[320]
        if Mask(128, 128, ext_call.return_data[0]) != Mask(128, 128, arg2):
            revert with 0, 'Address does not contain stake with provided id'
        if ext_call.return_data[128] > 4:
            revert with 0, 33
        if ext_call.return_data[128] == 3:
            return 0
        if ext_call.return_data[128] > 4:
            revert with 0, 33
        if ext_call.return_data[128] == 4:
            return 0
        if ext_call.return_data[128] > 4:
            revert with 0, 33
        if ext_call.return_data[128] == 1:
            return 0
        if ext_call.return_data[128] > 4:
            revert with 0, 33
        if not ext_call.return_data[128]:
            staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                    gas gas_remaining wei
                   args address(arg1), Mask(128, 128, ext_call.return_data[0])
            mem[(2 * ceil32(return_data.size)) + 1248 len 352] = ext_call.return_data[0 len 352]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 352
            if not bool((4 * ceil32(return_data.size)) + 1600 <= test266151307()):
                revert with 0, 65
            mem[64] = (4 * ceil32(return_data.size)) + 1600
            require ext_call.return_data[0] == Mask(128, 128, ext_call.return_data[0])
            mem[(4 * ceil32(return_data.size)) + 1248] = ext_call.return_data[0]
            mem[(4 * ceil32(return_data.size)) + 1280] = ext_call.return_data[32]
            mem[(4 * ceil32(return_data.size)) + 1312] = ext_call.return_data[64]
            mem[(4 * ceil32(return_data.size)) + 1344] = ext_call.return_data[96]
            require ext_call.return_data[128] < 5
            mem[(4 * ceil32(return_data.size)) + 1376] = ext_call.return_data[128]
            mem[(4 * ceil32(return_data.size)) + 1408] = ext_call.return_data[160]
            mem[(4 * ceil32(return_data.size)) + 1440] = ext_call.return_data[192]
            mem[(4 * ceil32(return_data.size)) + 1472] = ext_call.return_data[224]
            mem[(4 * ceil32(return_data.size)) + 1504] = ext_call.return_data[256]
            mem[(4 * ceil32(return_data.size)) + 1536] = ext_call.return_data[288]
            mem[(4 * ceil32(return_data.size)) + 1568] = ext_call.return_data[320]
            if Mask(128, 128, ext_call.return_data[0]) != Mask(128, 128, ext_call.return_data[0]):
                revert with 0, 'Address does not contain stake with provided id'
            idx = mem[(4 * ceil32(return_data.size)) + 1440]
            s = 0
            while idx < arg4:
                staticcall sub_413c05c6Address.0x8ce1d9e4 with:
                        gas gas_remaining wei
                       args idx
                mem[mem[64] len 160] = ext_call.return_data[0 len 160]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _6531 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 160
                _6611 = mem[64]
                if mem[64] + 160 > test266151307() or mem[64] + 160 < mem[64]:
                    revert with 0, 65
                mem[64] = mem[64] + 160
                mem[_6611] = mem[_6531]
                mem[_6611 + 32] = mem[_6531 + 32]
                mem[_6611 + 64] = mem[_6531 + 64]
                mem[_6611 + 96] = mem[_6531 + 96]
                mem[_6611 + 128] = mem[_6531 + 128]
                _6776 = mem[_6611 + 64]
                _6777 = mem[_6611 + 32]
                _6778 = mem[(4 * ceil32(return_data.size)) + 1312]
                _6779 = mem[_6611]
                _6780 = mem[_6611 + 128]
                _6781 = mem[_6611 + 96]
                if mem[_6611 + 96] > !mem[_6611 + 128]:
                    revert with 0, 17
                if mem[_6611 + 96] + mem[_6611 + 128] < mem[_6611 + 96]:
                    revert with 0, 'SafeMath: addition overflow'
                if not mem[_6611 + 96] + mem[_6611 + 128]:
                    _7103 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_7103] = 26
                    mem[_7103 + 32] = 'SafeMath: division by zero'
                    if not _6777:
                        _7156 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _7156 + 68] = mem[_7103 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_7156 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _7156 + -mem[64] + 100
                    _7474 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_7474] = 26
                    mem[_7474 + 32] = 'SafeMath: division by zero'
                    if _6776:
                        if s > !(0 / _6777 / _6776):
                            revert with 0, 17
                        if s + (0 / _6777 / _6776) < s:
                            revert with 0, 'SafeMath: addition overflow'
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + (0 / _6777 / _6776)
                        continue 
                    _7588 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _7588 + 68] = mem[_7474 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_7588 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _7588 + -mem[64] + 100
                if mem[_6611 + 96] + mem[_6611 + 128] and mem[_6611] > -1 / mem[_6611 + 96] + mem[_6611 + 128]:
                    revert with 0, 17
                if not mem[_6611 + 96] + mem[_6611 + 128]:
                    revert with 0, 18
                if (mem[_6611 + 96] * mem[_6611]) + (mem[_6611 + 128] * mem[_6611]) / mem[_6611 + 96] + mem[_6611 + 128] != mem[_6611]:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not (mem[_6611 + 96] * mem[_6611]) + (mem[_6611 + 128] * mem[_6611]):
                    _7297 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_7297] = 26
                    mem[_7297 + 32] = 'SafeMath: division by zero'
                    if not _6777:
                        _7473 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _7473 + 68] = mem[_7297 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_7473 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _7473 + -mem[64] + 100
                    _7784 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_7784] = 26
                    mem[_7784 + 32] = 'SafeMath: division by zero'
                    if _6776:
                        if s > !(0 / _6777 / _6776):
                            revert with 0, 17
                        if s + (0 / _6777 / _6776) < s:
                            revert with 0, 'SafeMath: addition overflow'
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + (0 / _6777 / _6776)
                        continue 
                    _7926 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _7926 + 68] = mem[_7784 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_7926 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _7926 + -mem[64] + 100
                if (mem[_6611 + 96] * mem[_6611]) + (mem[_6611 + 128] * mem[_6611]) and mem[(4 * ceil32(return_data.size)) + 1312] > -1 / (mem[_6611 + 96] * mem[_6611]) + (mem[_6611 + 128] * mem[_6611]):
                    revert with 0, 17
                if not (mem[_6611 + 96] * mem[_6611]) + (mem[_6611 + 128] * mem[_6611]):
                    revert with 0, 18
                if (mem[_6611 + 96] * mem[_6611] * mem[(4 * ceil32(return_data.size)) + 1312]) + (mem[_6611 + 128] * mem[_6611] * mem[(4 * ceil32(return_data.size)) + 1312]) / (mem[_6611 + 96] * mem[_6611]) + (mem[_6611 + 128] * mem[_6611]) != mem[(4 * ceil32(return_data.size)) + 1312]:
                    revert with 0, 'SafeMath: multiplication overflow'
                _7692 = mem[64]
                mem[64] = mem[64] + 64
                mem[_7692] = 26
                mem[_7692 + 32] = 'SafeMath: division by zero'
                if not _6777:
                    _7783 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _7783 + 68] = mem[_7692 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_7783 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _7783 + -mem[64] + 100
                _8068 = mem[64]
                mem[64] = mem[64] + 64
                mem[_8068] = 26
                mem[_8068 + 32] = 'SafeMath: division by zero'
                if _6776:
                    if s > !((_6781 * _6779 * _6778) + (_6780 * _6779 * _6778) / _6777 / _6776):
                        revert with 0, 17
                    if s + ((_6781 * _6779 * _6778) + (_6780 * _6779 * _6778) / _6777 / _6776) < s:
                        revert with 0, 'SafeMath: addition overflow'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + ((_6781 * _6779 * _6778) + (_6780 * _6779 * _6778) / _6777 / _6776)
                    continue 
                _8144 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _8144 + 68] = mem[_8068 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_8144 + 94] = 0
                revert with memory
                  from mem[64]
                   len _8144 + -mem[64] + 100
            _6530 = mem[(2 * ceil32(return_data.size)) + 1056]
            if mem[(2 * ceil32(return_data.size)) + 1056] > !s:
                revert with 0, 17
            if mem[(2 * ceil32(return_data.size)) + 1056] + s < mem[(2 * ceil32(return_data.size)) + 1056]:
                revert with 0, 'SafeMath: addition overflow'
            mem[mem[64]] = mem[(2 * ceil32(return_data.size)) + 928]
            return mem[mem[64]], _6530 + s
        if ext_call.return_data[192] > !ext_call.return_data[224]:
            revert with 0, 17
        staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                gas gas_remaining wei
               args address(arg1), Mask(128, 128, ext_call.return_data[0])
        mem[(2 * ceil32(return_data.size)) + 1248 len 352] = ext_call.return_data[0 len 352]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 352
        if not bool((4 * ceil32(return_data.size)) + 1600 <= test266151307()):
            revert with 0, 65
        mem[64] = (4 * ceil32(return_data.size)) + 1600
        require ext_call.return_data[0] == Mask(128, 128, ext_call.return_data[0])
        mem[(4 * ceil32(return_data.size)) + 1248] = ext_call.return_data[0]
        mem[(4 * ceil32(return_data.size)) + 1280] = ext_call.return_data[32]
        mem[(4 * ceil32(return_data.size)) + 1312] = ext_call.return_data[64]
        mem[(4 * ceil32(return_data.size)) + 1344] = ext_call.return_data[96]
        require ext_call.return_data[128] < 5
        mem[(4 * ceil32(return_data.size)) + 1376] = ext_call.return_data[128]
        mem[(4 * ceil32(return_data.size)) + 1408] = ext_call.return_data[160]
        mem[(4 * ceil32(return_data.size)) + 1440] = ext_call.return_data[192]
        mem[(4 * ceil32(return_data.size)) + 1472] = ext_call.return_data[224]
        mem[(4 * ceil32(return_data.size)) + 1504] = ext_call.return_data[256]
        mem[(4 * ceil32(return_data.size)) + 1536] = ext_call.return_data[288]
        mem[(4 * ceil32(return_data.size)) + 1568] = ext_call.return_data[320]
        if Mask(128, 128, ext_call.return_data[0]) != Mask(128, 128, ext_call.return_data[0]):
            revert with 0, 'Address does not contain stake with provided id'
        if arg4 < ext_call.return_data[192] + ext_call.return_data[224]:
            idx = mem[(4 * ceil32(return_data.size)) + 1440]
            s = 0
            while idx < ext_call.return_data[192] + ext_call.return_data[224]:
                staticcall sub_413c05c6Address.0x8ce1d9e4 with:
                        gas gas_remaining wei
                       args idx
                mem[mem[64] len 160] = ext_call.return_data[0 len 160]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _6526 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 160
                _6607 = mem[64]
                if mem[64] + 160 > test266151307() or mem[64] + 160 < mem[64]:
                    revert with 0, 65
                mem[64] = mem[64] + 160
                mem[_6607] = mem[_6526]
                mem[_6607 + 32] = mem[_6526 + 32]
                mem[_6607 + 64] = mem[_6526 + 64]
                mem[_6607 + 96] = mem[_6526 + 96]
                mem[_6607 + 128] = mem[_6526 + 128]
                _6762 = mem[_6607 + 64]
                _6763 = mem[_6607 + 32]
                _6764 = mem[(4 * ceil32(return_data.size)) + 1312]
                _6765 = mem[_6607]
                _6766 = mem[_6607 + 128]
                _6767 = mem[_6607 + 96]
                if mem[_6607 + 96] > !mem[_6607 + 128]:
                    revert with 0, 17
                if mem[_6607 + 96] + mem[_6607 + 128] < mem[_6607 + 96]:
                    revert with 0, 'SafeMath: addition overflow'
                if not mem[_6607 + 96] + mem[_6607 + 128]:
                    _7097 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_7097] = 26
                    mem[_7097 + 32] = 'SafeMath: division by zero'
                    if not _6763:
                        _7154 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _7154 + 68] = mem[_7097 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_7154 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _7154 + -mem[64] + 100
                    _7462 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_7462] = 26
                    mem[_7462 + 32] = 'SafeMath: division by zero'
                    if _6762:
                        if s > !(0 / _6763 / _6762):
                            revert with 0, 17
                        if s + (0 / _6763 / _6762) < s:
                            revert with 0, 'SafeMath: addition overflow'
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + (0 / _6763 / _6762)
                        continue 
                    _7580 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _7580 + 68] = mem[_7462 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_7580 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _7580 + -mem[64] + 100
                if mem[_6607 + 96] + mem[_6607 + 128] and mem[_6607] > -1 / mem[_6607 + 96] + mem[_6607 + 128]:
                    revert with 0, 17
                if not mem[_6607 + 96] + mem[_6607 + 128]:
                    revert with 0, 18
                if (mem[_6607 + 96] * mem[_6607]) + (mem[_6607 + 128] * mem[_6607]) / mem[_6607 + 96] + mem[_6607 + 128] != mem[_6607]:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not (mem[_6607 + 96] * mem[_6607]) + (mem[_6607 + 128] * mem[_6607]):
                    _7292 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_7292] = 26
                    mem[_7292 + 32] = 'SafeMath: division by zero'
                    if not _6763:
                        _7461 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _7461 + 68] = mem[_7292 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_7461 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _7461 + -mem[64] + 100
                    _7776 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_7776] = 26
                    mem[_7776 + 32] = 'SafeMath: division by zero'
                    if _6762:
                        if s > !(0 / _6763 / _6762):
                            revert with 0, 17
                        if s + (0 / _6763 / _6762) < s:
                            revert with 0, 'SafeMath: addition overflow'
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + (0 / _6763 / _6762)
                        continue 
                    _7914 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _7914 + 68] = mem[_7776 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_7914 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _7914 + -mem[64] + 100
                if (mem[_6607 + 96] * mem[_6607]) + (mem[_6607 + 128] * mem[_6607]) and mem[(4 * ceil32(return_data.size)) + 1312] > -1 / (mem[_6607 + 96] * mem[_6607]) + (mem[_6607 + 128] * mem[_6607]):
                    revert with 0, 17
                if not (mem[_6607 + 96] * mem[_6607]) + (mem[_6607 + 128] * mem[_6607]):
                    revert with 0, 18
                if (mem[_6607 + 96] * mem[_6607] * mem[(4 * ceil32(return_data.size)) + 1312]) + (mem[_6607 + 128] * mem[_6607] * mem[(4 * ceil32(return_data.size)) + 1312]) / (mem[_6607 + 96] * mem[_6607]) + (mem[_6607 + 128] * mem[_6607]) != mem[(4 * ceil32(return_data.size)) + 1312]:
                    revert with 0, 'SafeMath: multiplication overflow'
                _7684 = mem[64]
                mem[64] = mem[64] + 64
                mem[_7684] = 26
                mem[_7684 + 32] = 'SafeMath: division by zero'
                if not _6763:
                    _7775 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _7775 + 68] = mem[_7684 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_7775 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _7775 + -mem[64] + 100
                _8062 = mem[64]
                mem[64] = mem[64] + 64
                mem[_8062] = 26
                mem[_8062 + 32] = 'SafeMath: division by zero'
                if _6762:
                    if s > !((_6767 * _6765 * _6764) + (_6766 * _6765 * _6764) / _6763 / _6762):
                        revert with 0, 17
                    if s + ((_6767 * _6765 * _6764) + (_6766 * _6765 * _6764) / _6763 / _6762) < s:
                        revert with 0, 'SafeMath: addition overflow'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + ((_6767 * _6765 * _6764) + (_6766 * _6765 * _6764) / _6763 / _6762)
                    continue 
                _8138 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _8138 + 68] = mem[_8062 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_8138 + 94] = 0
                revert with memory
                  from mem[64]
                   len _8138 + -mem[64] + 100
            if s >= mem[(2 * ceil32(return_data.size)) + 1056]:
                _6558 = mem[(2 * ceil32(return_data.size)) + 896]
                staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                        gas gas_remaining wei
                       args address(arg1), Mask(128, 128, mem[(2 * ceil32(return_data.size)) + 896])
                mem[mem[64] len 352] = ext_call.return_data[0 len 352]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _6814 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 352
                _6856 = mem[64]
                if mem[64] + 352 < mem[64] or mem[64] + 352 > test266151307():
                    revert with 0, 65
                mem[64] = mem[64] + 352
                require mem[_6814] == Mask(128, 128, mem[_6814])
                mem[_6856] = mem[_6814]
                mem[_6856 + 32] = mem[_6814 + 32]
                mem[_6856 + 64] = mem[_6814 + 64]
                mem[_6856 + 96] = mem[_6814 + 96]
                require mem[_6814 + 128] < 5
                mem[_6856 + 128] = mem[_6814 + 128]
                mem[_6856 + 160] = mem[_6814 + 160]
                mem[_6856 + 192] = mem[_6814 + 192]
                mem[_6856 + 224] = mem[_6814 + 224]
                mem[_6856 + 256] = mem[_6814 + 256]
                mem[_6856 + 288] = mem[_6814 + 288]
                mem[_6856 + 320] = mem[_6814 + 320]
                if Mask(128, 128, mem[_6856]) != Mask(128, 128, _6558):
                    revert with 0, 'Address does not contain stake with provided id'
                idx = mem[_6856 + 192]
                s = 0
                while idx < arg4:
                    staticcall sub_413c05c6Address.0x8ce1d9e4 with:
                            gas gas_remaining wei
                           args idx
                    mem[mem[64] len 160] = ext_call.return_data[0 len 160]
                    if not ext_call.success:
                        revert with ext_call.return_data[0 len return_data.size]
                    _12633 = mem[64]
                    mem[64] = mem[64] + ceil32(return_data.size)
                    require return_data.size >= 160
                    _12756 = mem[64]
                    if mem[64] + 160 > test266151307() or mem[64] + 160 < mem[64]:
                        revert with 0, 65
                    mem[64] = mem[64] + 160
                    mem[_12756] = mem[_12633]
                    mem[_12756 + 32] = mem[_12633 + 32]
                    mem[_12756 + 64] = mem[_12633 + 64]
                    mem[_12756 + 96] = mem[_12633 + 96]
                    mem[_12756 + 128] = mem[_12633 + 128]
                    _13147 = mem[_12756 + 64]
                    _13148 = mem[_12756 + 32]
                    _13149 = mem[_6856 + 64]
                    _13150 = mem[_12756]
                    _13151 = mem[_12756 + 128]
                    _13152 = mem[_12756 + 96]
                    if mem[_12756 + 96] > !mem[_12756 + 128]:
                        revert with 0, 17
                    if mem[_12756 + 96] + mem[_12756 + 128] < mem[_12756 + 96]:
                        revert with 0, 'SafeMath: addition overflow'
                    if not mem[_12756 + 96] + mem[_12756 + 128]:
                        _13583 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13583] = 26
                        mem[_13583 + 32] = 'SafeMath: division by zero'
                        if not _13148:
                            _13680 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _13680 + 68] = mem[_13583 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_13680 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _13680 + -mem[64] + 100
                        _14035 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14035] = 26
                        mem[_14035 + 32] = 'SafeMath: division by zero'
                        if _13147:
                            if s > !(0 / _13148 / _13147):
                                revert with 0, 17
                            if s + (0 / _13148 / _13147) < s:
                                revert with 0, 'SafeMath: addition overflow'
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + (0 / _13148 / _13147)
                            continue 
                        _14204 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _14204 + 68] = mem[_14035 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_14204 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _14204 + -mem[64] + 100
                    if mem[_12756 + 96] + mem[_12756 + 128] and mem[_12756] > -1 / mem[_12756 + 96] + mem[_12756 + 128]:
                        revert with 0, 17
                    if not mem[_12756 + 96] + mem[_12756 + 128]:
                        revert with 0, 18
                    if (mem[_12756 + 96] * mem[_12756]) + (mem[_12756 + 128] * mem[_12756]) / mem[_12756 + 96] + mem[_12756 + 128] != mem[_12756]:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not (mem[_12756 + 96] * mem[_12756]) + (mem[_12756 + 128] * mem[_12756]):
                        _13838 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13838] = 26
                        mem[_13838 + 32] = 'SafeMath: division by zero'
                        if not _13148:
                            _14034 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _14034 + 68] = mem[_13838 + idx + 32]
                                idx = idx + 32
                                continue 
                            mem[_14034 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _14034 + -mem[64] + 100
                        _14505 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14505] = 26
                        mem[_14505 + 32] = 'SafeMath: division by zero'
                        if _13147:
                            if s > !(0 / _13148 / _13147):
                                revert with 0, 17
                            if s + (0 / _13148 / _13147) < s:
                                revert with 0, 'SafeMath: addition overflow'
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s + (0 / _13148 / _13147)
                            continue 
                        _14709 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _14709 + 68] = mem[_14505 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_14709 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _14709 + -mem[64] + 100
                    if (mem[_12756 + 96] * mem[_12756]) + (mem[_12756 + 128] * mem[_12756]) and mem[_6856 + 64] > -1 / (mem[_12756 + 96] * mem[_12756]) + (mem[_12756 + 128] * mem[_12756]):
                        revert with 0, 17
                    if not (mem[_12756 + 96] * mem[_12756]) + (mem[_12756 + 128] * mem[_12756]):
                        revert with 0, 18
                    if (mem[_12756 + 96] * mem[_12756] * mem[_6856 + 64]) + (mem[_12756 + 128] * mem[_12756] * mem[_6856 + 64]) / (mem[_12756 + 96] * mem[_12756]) + (mem[_12756 + 128] * mem[_12756]) != mem[_6856 + 64]:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _14370 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14370] = 26
                    mem[_14370 + 32] = 'SafeMath: division by zero'
                    if not _13148:
                        _14504 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _14504 + 68] = mem[_14370 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_14504 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _14504 + -mem[64] + 100
                    _14968 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14968] = 26
                    mem[_14968 + 32] = 'SafeMath: division by zero'
                    if _13147:
                        if s > !((_13152 * _13150 * _13149) + (_13151 * _13150 * _13149) / _13148 / _13147):
                            revert with 0, 17
                        if s + ((_13152 * _13150 * _13149) + (_13151 * _13150 * _13149) / _13148 / _13147) < s:
                            revert with 0, 'SafeMath: addition overflow'
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + ((_13152 * _13150 * _13149) + (_13151 * _13150 * _13149) / _13148 / _13147)
                        continue 
                    _15138 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _15138 + 68] = mem[_14968 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_15138 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _15138 + -mem[64] + 100
                mem[mem[64]] = mem[(2 * ceil32(return_data.size)) + 928]
                return mem[mem[64]], s
            _6559 = mem[(2 * ceil32(return_data.size)) + 1056]
            _6606 = mem[64]
            mem[64] = mem[64] + 64
            mem[_6606] = 30
            mem[_6606 + 32] = 'SafeMath: subtraction overflow'
            if s > _6559:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if _6559 < s:
                revert with 0, 17
            _6878 = mem[(2 * ceil32(return_data.size)) + 896]
            staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                    gas gas_remaining wei
                   args address(arg1), Mask(128, 128, mem[(2 * ceil32(return_data.size)) + 896])
            mem[mem[64] len 352] = ext_call.return_data[0 len 352]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _6962 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 352
            _7009 = mem[64]
            if mem[64] + 352 < mem[64] or mem[64] + 352 > test266151307():
                revert with 0, 65
            mem[64] = mem[64] + 352
            require mem[_6962] == Mask(128, 128, mem[_6962])
            mem[_7009] = mem[_6962]
            mem[_7009 + 32] = mem[_6962 + 32]
            mem[_7009 + 64] = mem[_6962 + 64]
            mem[_7009 + 96] = mem[_6962 + 96]
            require mem[_6962 + 128] < 5
            mem[_7009 + 128] = mem[_6962 + 128]
            mem[_7009 + 160] = mem[_6962 + 160]
            mem[_7009 + 192] = mem[_6962 + 192]
            mem[_7009 + 224] = mem[_6962 + 224]
            mem[_7009 + 256] = mem[_6962 + 256]
            mem[_7009 + 288] = mem[_6962 + 288]
            mem[_7009 + 320] = mem[_6962 + 320]
            if Mask(128, 128, mem[_7009]) != Mask(128, 128, _6878):
                revert with 0, 'Address does not contain stake with provided id'
            idx = mem[_7009 + 192]
            t = 0
            while idx < arg4:
                staticcall sub_413c05c6Address.0x8ce1d9e4 with:
                        gas gas_remaining wei
                       args idx
                mem[mem[64] len 160] = ext_call.return_data[0 len 160]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _12635 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 160
                _12757 = mem[64]
                if mem[64] + 160 > test266151307() or mem[64] + 160 < mem[64]:
                    revert with 0, 65
                mem[64] = mem[64] + 160
                mem[_12757] = mem[_12635]
                mem[_12757 + 32] = mem[_12635 + 32]
                mem[_12757 + 64] = mem[_12635 + 64]
                mem[_12757 + 96] = mem[_12635 + 96]
                mem[_12757 + 128] = mem[_12635 + 128]
                _13153 = mem[_12757 + 64]
                _13154 = mem[_12757 + 32]
                _13155 = mem[_7009 + 64]
                _13156 = mem[_12757]
                _13157 = mem[_12757 + 128]
                _13158 = mem[_12757 + 96]
                if mem[_12757 + 96] > !mem[_12757 + 128]:
                    revert with 0, 17
                if mem[_12757 + 96] + mem[_12757 + 128] < mem[_12757 + 96]:
                    revert with 0, 'SafeMath: addition overflow'
                if not mem[_12757 + 96] + mem[_12757 + 128]:
                    _13585 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_13585] = 26
                    mem[_13585 + 32] = 'SafeMath: division by zero'
                    if not _13154:
                        _13681 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _13681 + 68] = mem[_13585 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_13681 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _13681 + -mem[64] + 100
                    _14037 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14037] = 26
                    mem[_14037 + 32] = 'SafeMath: division by zero'
                    if _13153:
                        if t > !(0 / _13154 / _13153):
                            revert with 0, 17
                        if t + (0 / _13154 / _13153) < t:
                            revert with 0, 'SafeMath: addition overflow'
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        t = t + (0 / _13154 / _13153)
                        continue 
                    _14208 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _14208 + 68] = mem[_14037 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_14208 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _14208 + -mem[64] + 100
                if mem[_12757 + 96] + mem[_12757 + 128] and mem[_12757] > -1 / mem[_12757 + 96] + mem[_12757 + 128]:
                    revert with 0, 17
                if not mem[_12757 + 96] + mem[_12757 + 128]:
                    revert with 0, 18
                if (mem[_12757 + 96] * mem[_12757]) + (mem[_12757 + 128] * mem[_12757]) / mem[_12757 + 96] + mem[_12757 + 128] != mem[_12757]:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not (mem[_12757 + 96] * mem[_12757]) + (mem[_12757 + 128] * mem[_12757]):
                    _13840 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_13840] = 26
                    mem[_13840 + 32] = 'SafeMath: division by zero'
                    if not _13154:
                        _14036 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _14036 + 68] = mem[_13840 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_14036 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _14036 + -mem[64] + 100
                    _14508 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14508] = 26
                    mem[_14508 + 32] = 'SafeMath: division by zero'
                    if _13153:
                        if t > !(0 / _13154 / _13153):
                            revert with 0, 17
                        if t + (0 / _13154 / _13153) < t:
                            revert with 0, 'SafeMath: addition overflow'
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        t = t + (0 / _13154 / _13153)
                        continue 
                    _14712 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _14712 + 68] = mem[_14508 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_14712 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _14712 + -mem[64] + 100
                if (mem[_12757 + 96] * mem[_12757]) + (mem[_12757 + 128] * mem[_12757]) and mem[_7009 + 64] > -1 / (mem[_12757 + 96] * mem[_12757]) + (mem[_12757 + 128] * mem[_12757]):
                    revert with 0, 17
                if not (mem[_12757 + 96] * mem[_12757]) + (mem[_12757 + 128] * mem[_12757]):
                    revert with 0, 18
                if (mem[_12757 + 96] * mem[_12757] * mem[_7009 + 64]) + (mem[_12757 + 128] * mem[_12757] * mem[_7009 + 64]) / (mem[_12757 + 96] * mem[_12757]) + (mem[_12757 + 128] * mem[_12757]) != mem[_7009 + 64]:
                    revert with 0, 'SafeMath: multiplication overflow'
                _14373 = mem[64]
                mem[64] = mem[64] + 64
                mem[_14373] = 26
                mem[_14373 + 32] = 'SafeMath: division by zero'
                if not _13154:
                    _14507 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _14507 + 68] = mem[_14373 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_14507 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _14507 + -mem[64] + 100
                _14971 = mem[64]
                mem[64] = mem[64] + 64
                mem[_14971] = 26
                mem[_14971 + 32] = 'SafeMath: division by zero'
                if _13153:
                    if t > !((_13158 * _13156 * _13155) + (_13157 * _13156 * _13155) / _13154 / _13153):
                        revert with 0, 17
                    if t + ((_13158 * _13156 * _13155) + (_13157 * _13156 * _13155) / _13154 / _13153) < t:
                        revert with 0, 'SafeMath: addition overflow'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    t = t + ((_13158 * _13156 * _13155) + (_13157 * _13156 * _13155) / _13154 / _13153)
                    continue 
                _15140 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _15140 + 68] = mem[_14971 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_15140 + 94] = 0
                revert with memory
                  from mem[64]
                   len _15140 + -mem[64] + 100
            if _6559 - s > !t:
                revert with 0, 17
            if t < 0:
                revert with 0, 'SafeMath: addition overflow'
            mem[mem[64]] = mem[(2 * ceil32(return_data.size)) + 928]
            return mem[mem[64]], _6559 - s + t
        idx = mem[(4 * ceil32(return_data.size)) + 1440]
        s = 0
        while idx < ext_call.return_data[192] + ext_call.return_data[224]:
            staticcall sub_413c05c6Address.0x8ce1d9e4 with:
                    gas gas_remaining wei
                   args idx
            mem[mem[64] len 160] = ext_call.return_data[0 len 160]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _6528 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 160
            _6610 = mem[64]
            if mem[64] + 160 > test266151307() or mem[64] + 160 < mem[64]:
                revert with 0, 65
            mem[64] = mem[64] + 160
            mem[_6610] = mem[_6528]
            mem[_6610 + 32] = mem[_6528 + 32]
            mem[_6610 + 64] = mem[_6528 + 64]
            mem[_6610 + 96] = mem[_6528 + 96]
            mem[_6610 + 128] = mem[_6528 + 128]
            _6770 = mem[_6610 + 64]
            _6771 = mem[_6610 + 32]
            _6772 = mem[(4 * ceil32(return_data.size)) + 1312]
            _6773 = mem[_6610]
            _6774 = mem[_6610 + 128]
            _6775 = mem[_6610 + 96]
            if mem[_6610 + 96] > !mem[_6610 + 128]:
                revert with 0, 17
            if mem[_6610 + 96] + mem[_6610 + 128] < mem[_6610 + 96]:
                revert with 0, 'SafeMath: addition overflow'
            if not mem[_6610 + 96] + mem[_6610 + 128]:
                _7101 = mem[64]
                mem[64] = mem[64] + 64
                mem[_7101] = 26
                mem[_7101 + 32] = 'SafeMath: division by zero'
                if not _6771:
                    _7155 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _7155 + 68] = mem[_7101 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_7155 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _7155 + -mem[64] + 100
                _7472 = mem[64]
                mem[64] = mem[64] + 64
                mem[_7472] = 26
                mem[_7472 + 32] = 'SafeMath: division by zero'
                if _6770:
                    if s > !(0 / _6771 / _6770):
                        revert with 0, 17
                    if s + (0 / _6771 / _6770) < s:
                        revert with 0, 'SafeMath: addition overflow'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + (0 / _6771 / _6770)
                    continue 
                _7584 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _7584 + 68] = mem[_7472 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_7584 + 94] = 0
                revert with memory
                  from mem[64]
                   len _7584 + -mem[64] + 100
            if mem[_6610 + 96] + mem[_6610 + 128] and mem[_6610] > -1 / mem[_6610 + 96] + mem[_6610 + 128]:
                revert with 0, 17
            if not mem[_6610 + 96] + mem[_6610 + 128]:
                revert with 0, 18
            if (mem[_6610 + 96] * mem[_6610]) + (mem[_6610 + 128] * mem[_6610]) / mem[_6610 + 96] + mem[_6610 + 128] != mem[_6610]:
                revert with 0, 'SafeMath: multiplication overflow'
            if not (mem[_6610 + 96] * mem[_6610]) + (mem[_6610 + 128] * mem[_6610]):
                _7295 = mem[64]
                mem[64] = mem[64] + 64
                mem[_7295] = 26
                mem[_7295 + 32] = 'SafeMath: division by zero'
                if not _6771:
                    _7471 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _7471 + 68] = mem[_7295 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_7471 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _7471 + -mem[64] + 100
                _7781 = mem[64]
                mem[64] = mem[64] + 64
                mem[_7781] = 26
                mem[_7781 + 32] = 'SafeMath: division by zero'
                if _6770:
                    if s > !(0 / _6771 / _6770):
                        revert with 0, 17
                    if s + (0 / _6771 / _6770) < s:
                        revert with 0, 'SafeMath: addition overflow'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + (0 / _6771 / _6770)
                    continue 
                _7923 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _7923 + 68] = mem[_7781 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_7923 + 94] = 0
                revert with memory
                  from mem[64]
                   len _7923 + -mem[64] + 100
            if (mem[_6610 + 96] * mem[_6610]) + (mem[_6610 + 128] * mem[_6610]) and mem[(4 * ceil32(return_data.size)) + 1312] > -1 / (mem[_6610 + 96] * mem[_6610]) + (mem[_6610 + 128] * mem[_6610]):
                revert with 0, 17
            if not (mem[_6610 + 96] * mem[_6610]) + (mem[_6610 + 128] * mem[_6610]):
                revert with 0, 18
            if (mem[_6610 + 96] * mem[_6610] * mem[(4 * ceil32(return_data.size)) + 1312]) + (mem[_6610 + 128] * mem[_6610] * mem[(4 * ceil32(return_data.size)) + 1312]) / (mem[_6610 + 96] * mem[_6610]) + (mem[_6610 + 128] * mem[_6610]) != mem[(4 * ceil32(return_data.size)) + 1312]:
                revert with 0, 'SafeMath: multiplication overflow'
            _7689 = mem[64]
            mem[64] = mem[64] + 64
            mem[_7689] = 26
            mem[_7689 + 32] = 'SafeMath: division by zero'
            if not _6771:
                _7780 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _7780 + 68] = mem[_7689 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_7780 + 94] = 0
                revert with memory
                  from mem[64]
                   len _7780 + -mem[64] + 100
            _8065 = mem[64]
            mem[64] = mem[64] + 64
            mem[_8065] = 26
            mem[_8065 + 32] = 'SafeMath: division by zero'
            if _6770:
                if s > !((_6775 * _6773 * _6772) + (_6774 * _6773 * _6772) / _6771 / _6770):
                    revert with 0, 17
                if s + ((_6775 * _6773 * _6772) + (_6774 * _6773 * _6772) / _6771 / _6770) < s:
                    revert with 0, 'SafeMath: addition overflow'
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + ((_6775 * _6773 * _6772) + (_6774 * _6773 * _6772) / _6771 / _6770)
                continue 
            _8142 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _8142 + 68] = mem[_8065 + idx + 32]
                idx = idx + 32
                continue 
            mem[_8142 + 94] = 0
            revert with memory
              from mem[64]
               len _8142 + -mem[64] + 100
        if s >= mem[(2 * ceil32(return_data.size)) + 1056]:
            _6560 = mem[(2 * ceil32(return_data.size)) + 896]
            staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                    gas gas_remaining wei
                   args address(arg1), Mask(128, 128, mem[(2 * ceil32(return_data.size)) + 896])
            mem[mem[64] len 352] = ext_call.return_data[0 len 352]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _6815 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 352
            _6858 = mem[64]
            if mem[64] + 352 < mem[64] or mem[64] + 352 > test266151307():
                revert with 0, 65
            mem[64] = mem[64] + 352
            require mem[_6815] == Mask(128, 128, mem[_6815])
            mem[_6858] = mem[_6815]
            mem[_6858 + 32] = mem[_6815 + 32]
            mem[_6858 + 64] = mem[_6815 + 64]
            mem[_6858 + 96] = mem[_6815 + 96]
            require mem[_6815 + 128] < 5
            mem[_6858 + 128] = mem[_6815 + 128]
            mem[_6858 + 160] = mem[_6815 + 160]
            mem[_6858 + 192] = mem[_6815 + 192]
            mem[_6858 + 224] = mem[_6815 + 224]
            mem[_6858 + 256] = mem[_6815 + 256]
            mem[_6858 + 288] = mem[_6815 + 288]
            mem[_6858 + 320] = mem[_6815 + 320]
            if Mask(128, 128, mem[_6858]) != Mask(128, 128, _6560):
                revert with 0, 'Address does not contain stake with provided id'
            idx = mem[_6858 + 192]
            s = 0
            while idx < ext_call.return_data[192] + ext_call.return_data[224]:
                staticcall sub_413c05c6Address.0x8ce1d9e4 with:
                        gas gas_remaining wei
                       args idx
                mem[mem[64] len 160] = ext_call.return_data[0 len 160]
                if not ext_call.success:
                    revert with ext_call.return_data[0 len return_data.size]
                _12637 = mem[64]
                mem[64] = mem[64] + ceil32(return_data.size)
                require return_data.size >= 160
                _12765 = mem[64]
                if mem[64] + 160 > test266151307() or mem[64] + 160 < mem[64]:
                    revert with 0, 65
                mem[64] = mem[64] + 160
                mem[_12765] = mem[_12637]
                mem[_12765 + 32] = mem[_12637 + 32]
                mem[_12765 + 64] = mem[_12637 + 64]
                mem[_12765 + 96] = mem[_12637 + 96]
                mem[_12765 + 128] = mem[_12637 + 128]
                _13160 = mem[_12765 + 64]
                _13161 = mem[_12765 + 32]
                _13162 = mem[_6858 + 64]
                _13163 = mem[_12765]
                _13164 = mem[_12765 + 128]
                _13165 = mem[_12765 + 96]
                if mem[_12765 + 96] > !mem[_12765 + 128]:
                    revert with 0, 17
                if mem[_12765 + 96] + mem[_12765 + 128] < mem[_12765 + 96]:
                    revert with 0, 'SafeMath: addition overflow'
                if not mem[_12765 + 96] + mem[_12765 + 128]:
                    _13587 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_13587] = 26
                    mem[_13587 + 32] = 'SafeMath: division by zero'
                    if not _13161:
                        _13682 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _13682 + 68] = mem[_13587 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_13682 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _13682 + -mem[64] + 100
                    _14039 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14039] = 26
                    mem[_14039 + 32] = 'SafeMath: division by zero'
                    if _13160:
                        if s > !(0 / _13161 / _13160):
                            revert with 0, 17
                        if s + (0 / _13161 / _13160) < s:
                            revert with 0, 'SafeMath: addition overflow'
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + (0 / _13161 / _13160)
                        continue 
                    _14212 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _14212 + 68] = mem[_14039 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_14212 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _14212 + -mem[64] + 100
                if mem[_12765 + 96] + mem[_12765 + 128] and mem[_12765] > -1 / mem[_12765 + 96] + mem[_12765 + 128]:
                    revert with 0, 17
                if not mem[_12765 + 96] + mem[_12765 + 128]:
                    revert with 0, 18
                if (mem[_12765 + 96] * mem[_12765]) + (mem[_12765 + 128] * mem[_12765]) / mem[_12765 + 96] + mem[_12765 + 128] != mem[_12765]:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not (mem[_12765 + 96] * mem[_12765]) + (mem[_12765 + 128] * mem[_12765]):
                    _13842 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_13842] = 26
                    mem[_13842 + 32] = 'SafeMath: division by zero'
                    if not _13161:
                        _14038 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _14038 + 68] = mem[_13842 + idx + 32]
                            idx = idx + 32
                            continue 
                        mem[_14038 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _14038 + -mem[64] + 100
                    _14511 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14511] = 26
                    mem[_14511 + 32] = 'SafeMath: division by zero'
                    if _13160:
                        if s > !(0 / _13161 / _13160):
                            revert with 0, 17
                        if s + (0 / _13161 / _13160) < s:
                            revert with 0, 'SafeMath: addition overflow'
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s + (0 / _13161 / _13160)
                        continue 
                    _14715 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _14715 + 68] = mem[_14511 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_14715 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _14715 + -mem[64] + 100
                if (mem[_12765 + 96] * mem[_12765]) + (mem[_12765 + 128] * mem[_12765]) and mem[_6858 + 64] > -1 / (mem[_12765 + 96] * mem[_12765]) + (mem[_12765 + 128] * mem[_12765]):
                    revert with 0, 17
                if not (mem[_12765 + 96] * mem[_12765]) + (mem[_12765 + 128] * mem[_12765]):
                    revert with 0, 18
                if (mem[_12765 + 96] * mem[_12765] * mem[_6858 + 64]) + (mem[_12765 + 128] * mem[_12765] * mem[_6858 + 64]) / (mem[_12765 + 96] * mem[_12765]) + (mem[_12765 + 128] * mem[_12765]) != mem[_6858 + 64]:
                    revert with 0, 'SafeMath: multiplication overflow'
                _14376 = mem[64]
                mem[64] = mem[64] + 64
                mem[_14376] = 26
                mem[_14376 + 32] = 'SafeMath: division by zero'
                if not _13161:
                    _14510 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _14510 + 68] = mem[_14376 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_14510 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _14510 + -mem[64] + 100
                _14974 = mem[64]
                mem[64] = mem[64] + 64
                mem[_14974] = 26
                mem[_14974 + 32] = 'SafeMath: division by zero'
                if _13160:
                    if s > !((_13165 * _13163 * _13162) + (_13164 * _13163 * _13162) / _13161 / _13160):
                        revert with 0, 17
                    if s + ((_13165 * _13163 * _13162) + (_13164 * _13163 * _13162) / _13161 / _13160) < s:
                        revert with 0, 'SafeMath: addition overflow'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + ((_13165 * _13163 * _13162) + (_13164 * _13163 * _13162) / _13161 / _13160)
                    continue 
                _15142 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _15142 + 68] = mem[_14974 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_15142 + 94] = 0
                revert with memory
                  from mem[64]
                   len _15142 + -mem[64] + 100
            mem[mem[64]] = mem[(2 * ceil32(return_data.size)) + 928]
            return mem[mem[64]], s
        _6561 = mem[(2 * ceil32(return_data.size)) + 1056]
        _6609 = mem[64]
        mem[64] = mem[64] + 64
        mem[_6609] = 30
        mem[_6609 + 32] = 'SafeMath: subtraction overflow'
        if s > _6561:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if _6561 < s:
            revert with 0, 17
        _6880 = mem[(2 * ceil32(return_data.size)) + 896]
        staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                gas gas_remaining wei
               args address(arg1), Mask(128, 128, mem[(2 * ceil32(return_data.size)) + 896])
        mem[mem[64] len 352] = ext_call.return_data[0 len 352]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        _6963 = mem[64]
        mem[64] = mem[64] + ceil32(return_data.size)
        require return_data.size >= 352
        _7011 = mem[64]
        if mem[64] + 352 < mem[64] or mem[64] + 352 > test266151307():
            revert with 0, 65
        mem[64] = mem[64] + 352
        require mem[_6963] == Mask(128, 128, mem[_6963])
        mem[_7011] = mem[_6963]
        mem[_7011 + 32] = mem[_6963 + 32]
        mem[_7011 + 64] = mem[_6963 + 64]
        mem[_7011 + 96] = mem[_6963 + 96]
        require mem[_6963 + 128] < 5
        mem[_7011 + 128] = mem[_6963 + 128]
        mem[_7011 + 160] = mem[_6963 + 160]
        mem[_7011 + 192] = mem[_6963 + 192]
        mem[_7011 + 224] = mem[_6963 + 224]
        mem[_7011 + 256] = mem[_6963 + 256]
        mem[_7011 + 288] = mem[_6963 + 288]
        mem[_7011 + 320] = mem[_6963 + 320]
        if Mask(128, 128, mem[_7011]) != Mask(128, 128, _6880):
            revert with 0, 'Address does not contain stake with provided id'
        idx = mem[_7011 + 192]
        t = 0
        while idx < ext_call.return_data[192] + ext_call.return_data[224]:
            staticcall sub_413c05c6Address.0x8ce1d9e4 with:
                    gas gas_remaining wei
                   args idx
            mem[mem[64] len 160] = ext_call.return_data[0 len 160]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _12639 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 160
            _12766 = mem[64]
            if mem[64] + 160 > test266151307() or mem[64] + 160 < mem[64]:
                revert with 0, 65
            mem[64] = mem[64] + 160
            mem[_12766] = mem[_12639]
            mem[_12766 + 32] = mem[_12639 + 32]
            mem[_12766 + 64] = mem[_12639 + 64]
            mem[_12766 + 96] = mem[_12639 + 96]
            mem[_12766 + 128] = mem[_12639 + 128]
            _13166 = mem[_12766 + 64]
            _13167 = mem[_12766 + 32]
            _13168 = mem[_7011 + 64]
            _13169 = mem[_12766]
            _13170 = mem[_12766 + 128]
            _13171 = mem[_12766 + 96]
            if mem[_12766 + 96] > !mem[_12766 + 128]:
                revert with 0, 17
            if mem[_12766 + 96] + mem[_12766 + 128] < mem[_12766 + 96]:
                revert with 0, 'SafeMath: addition overflow'
            if not mem[_12766 + 96] + mem[_12766 + 128]:
                _13589 = mem[64]
                mem[64] = mem[64] + 64
                mem[_13589] = 26
                mem[_13589 + 32] = 'SafeMath: division by zero'
                if not _13167:
                    _13683 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _13683 + 68] = mem[_13589 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_13683 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _13683 + -mem[64] + 100
                _14041 = mem[64]
                mem[64] = mem[64] + 64
                mem[_14041] = 26
                mem[_14041 + 32] = 'SafeMath: division by zero'
                if _13166:
                    if t > !(0 / _13167 / _13166):
                        revert with 0, 17
                    if t + (0 / _13167 / _13166) < t:
                        revert with 0, 'SafeMath: addition overflow'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    t = t + (0 / _13167 / _13166)
                    continue 
                _14216 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _14216 + 68] = mem[_14041 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_14216 + 94] = 0
                revert with memory
                  from mem[64]
                   len _14216 + -mem[64] + 100
            if mem[_12766 + 96] + mem[_12766 + 128] and mem[_12766] > -1 / mem[_12766 + 96] + mem[_12766 + 128]:
                revert with 0, 17
            if not mem[_12766 + 96] + mem[_12766 + 128]:
                revert with 0, 18
            if (mem[_12766 + 96] * mem[_12766]) + (mem[_12766 + 128] * mem[_12766]) / mem[_12766 + 96] + mem[_12766 + 128] != mem[_12766]:
                revert with 0, 'SafeMath: multiplication overflow'
            if not (mem[_12766 + 96] * mem[_12766]) + (mem[_12766 + 128] * mem[_12766]):
                _13844 = mem[64]
                mem[64] = mem[64] + 64
                mem[_13844] = 26
                mem[_13844 + 32] = 'SafeMath: division by zero'
                if not _13167:
                    _14040 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _14040 + 68] = mem[_13844 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_14040 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _14040 + -mem[64] + 100
                _14514 = mem[64]
                mem[64] = mem[64] + 64
                mem[_14514] = 26
                mem[_14514 + 32] = 'SafeMath: division by zero'
                if _13166:
                    if t > !(0 / _13167 / _13166):
                        revert with 0, 17
                    if t + (0 / _13167 / _13166) < t:
                        revert with 0, 'SafeMath: addition overflow'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    t = t + (0 / _13167 / _13166)
                    continue 
                _14718 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _14718 + 68] = mem[_14514 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_14718 + 94] = 0
                revert with memory
                  from mem[64]
                   len _14718 + -mem[64] + 100
            if (mem[_12766 + 96] * mem[_12766]) + (mem[_12766 + 128] * mem[_12766]) and mem[_7011 + 64] > -1 / (mem[_12766 + 96] * mem[_12766]) + (mem[_12766 + 128] * mem[_12766]):
                revert with 0, 17
            if not (mem[_12766 + 96] * mem[_12766]) + (mem[_12766 + 128] * mem[_12766]):
                revert with 0, 18
            if (mem[_12766 + 96] * mem[_12766] * mem[_7011 + 64]) + (mem[_12766 + 128] * mem[_12766] * mem[_7011 + 64]) / (mem[_12766 + 96] * mem[_12766]) + (mem[_12766 + 128] * mem[_12766]) != mem[_7011 + 64]:
                revert with 0, 'SafeMath: multiplication overflow'
            _14379 = mem[64]
            mem[64] = mem[64] + 64
            mem[_14379] = 26
            mem[_14379 + 32] = 'SafeMath: division by zero'
            if not _13167:
                _14513 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _14513 + 68] = mem[_14379 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_14513 + 94] = 0
                revert with memory
                  from mem[64]
                   len _14513 + -mem[64] + 100
            _14977 = mem[64]
            mem[64] = mem[64] + 64
            mem[_14977] = 26
            mem[_14977 + 32] = 'SafeMath: division by zero'
            if _13166:
                if t > !((_13171 * _13169 * _13168) + (_13170 * _13169 * _13168) / _13167 / _13166):
                    revert with 0, 17
                if t + ((_13171 * _13169 * _13168) + (_13170 * _13169 * _13168) / _13167 / _13166) < t:
                    revert with 0, 'SafeMath: addition overflow'
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                t = t + ((_13171 * _13169 * _13168) + (_13170 * _13169 * _13168) / _13167 / _13166)
                continue 
            _15144 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _15144 + 68] = mem[_14977 + idx + 32]
                idx = idx + 32
                continue 
            mem[_15144 + 94] = 0
            revert with memory
              from mem[64]
               len _15144 + -mem[64] + 100
        if _6561 - s > !t:
            revert with 0, 17
        if t < 0:
            revert with 0, 'SafeMath: addition overflow'
        mem[mem[64]] = mem[(2 * ceil32(return_data.size)) + 928]
        return mem[mem[64]], _6561 - s + t
    if unknown_0x461e356f(?????) <= uint32(call.func_hash) >> 224:
        if unknown_0x73178c0d(?????) > uint32(call.func_hash) >> 224:
            if uint32(call.func_hash) >> 224 != unknown_0x461e356f(?????):
                if unknown_0x4c86259e(?????) == uint32(call.func_hash) >> 224:
                    require not msg.value
                    require calldata.size - 4 >= 32
                    return sub_4c86259e[arg1].field_0, Mask(128, 128, sub_4c86259e[arg1].field_256)
                if unknown_0x4e4c7d9b(?????) == uint32(call.func_hash) >> 224:
                    require not msg.value
                    if TOKEN_DEFINERAddress != msg.sender:
                        revert with 0, 'Wrong sender.'
                    TOKEN_DEFINERAddress = 0
                else:
                    require unknown_0x64229836(?????) == uint32(call.func_hash) >> 224
                    require not msg.value
                    require calldata.size - 4 >= 32
                    require arg1 == bool(arg1)
                    if TOKEN_DEFINERAddress != msg.sender:
                        revert with 0, 'Wrong sender.'
                    Mask(96, 0, stor1.field_160) = Mask(96, 0, bool(arg1))
            require not msg.value
            require calldata.size - 4 >= 96
            require arg1 == address(arg1)
            require arg2 == Mask(128, 128, arg2)
            staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                    gas gas_remaining wei
                   args address(arg1), Mask(128, 128, arg2)
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 352
            if not bool(ceil32(return_data.size) + 832 <= test266151307()):
                revert with 0, 65
            require ext_call.return_data[0] == Mask(128, 128, ext_call.return_data[0])
            require ext_call.return_data[128] < 5
            if Mask(128, 128, ext_call.return_data[0]) != Mask(128, 128, arg2):
                if ext_call.return_data[128] >= 5:
                    revert with 0, 33
                return Mask(128, 128, ext_call.return_data[0]), 
                       ext_call.return_data[32],
                       ext_call.return_data[64],
                       ext_call.return_data[96],
                       ext_call.return_data[128],
                       ext_call.return_data[160],
                       ext_call.return_data[192],
                       ext_call.return_data[224],
                       ext_call.return_data[256],
                       ext_call.return_data[288],
                       ext_call.return_data[320],
                       0,
                       416,
                       46,
                       0xfe53656e64657220646f6573206e6f7420636f6e7461696e207374616b6520776974682070726f76696465642069, mem[ceil32(return_data.size) + 910 len 18] >> 112,
                       0
            if stor9[address(arg1)][Mask(128, 128, arg2)]:
                if ext_call.return_data[128] >= 5:
                    revert with 0, 33
                return Mask(128, 128, ext_call.return_data[0]), 
                       ext_call.return_data[32],
                       ext_call.return_data[64],
                       ext_call.return_data[96],
                       ext_call.return_data[128],
                       ext_call.return_data[160],
                       ext_call.return_data[192],
                       ext_call.return_data[224],
                       ext_call.return_data[256],
                       ext_call.return_data[288],
                       ext_call.return_data[320],
                       0,
                       416,
                       32,
                       'Stake has already been converted'
            if ext_call.return_data[128] > 4:
                revert with 0, 33
            if ext_call.return_data[128] != 2:
                if ext_call.return_data[128] >= 5:
                    revert with 0, 33
                return Mask(128, 128, ext_call.return_data[0]), 
                       ext_call.return_data[32],
                       ext_call.return_data[64],
                       ext_call.return_data[96],
                       ext_call.return_data[128],
                       ext_call.return_data[160],
                       ext_call.return_data[192],
                       ext_call.return_data[224],
                       ext_call.return_data[256],
                       ext_call.return_data[288],
                       ext_call.return_data[320],
                       0,
                       416,
                       44,
                       0x795374616b65206973206f6e6c7920656c696769626c6520696620697420686173206265656e20636c6f7365, mem[ceil32(return_data.size) + 908 len 20] >> 96,
                       0
            if ext_call.return_data[192] >= arg3:
                if ext_call.return_data[128] >= 5:
                    revert with 0, 33
                return Mask(128, 128, ext_call.return_data[0]), 
                       ext_call.return_data[32],
                       ext_call.return_data[64],
                       ext_call.return_data[96],
                       ext_call.return_data[128],
                       ext_call.return_data[160],
                       ext_call.return_data[192],
                       ext_call.return_data[224],
                       ext_call.return_data[256],
                       ext_call.return_data[288],
                       ext_call.return_data[320],
                       0,
                       416,
                       65,
                       0x645374616b65206973206f6e6c7920656c696769626c65206966206974207761732063726561746564207072696f7220746f2074686520637574206f6666206461, mem[ceil32(return_data.size) + 929 len 31] >> 264,
                       0
            if ext_call.return_data[192] > !ext_call.return_data[224]:
                revert with 0, 17
            if ext_call.return_data[128] >= 5:
                revert with 0, 33
            if ext_call.return_data[192] + ext_call.return_data[224] >= arg3:
                return Mask(128, 128, ext_call.return_data[0]), 
                       ext_call.return_data[32],
                       ext_call.return_data[64],
                       ext_call.return_data[96],
                       ext_call.return_data[128],
                       ext_call.return_data[160],
                       ext_call.return_data[192],
                       ext_call.return_data[224],
                       ext_call.return_data[256],
                       ext_call.return_data[288],
                       ext_call.return_data[320],
                       1,
                       416,
                       17,
                       'Stake is eligible',
                       0
            return Mask(128, 128, ext_call.return_data[0]), 
                   ext_call.return_data[32],
                   ext_call.return_data[64],
                   ext_call.return_data[96],
                   ext_call.return_data[128],
                   ext_call.return_data[160],
                   ext_call.return_data[192],
                   ext_call.return_data[224],
                   ext_call.return_data[256],
                   ext_call.return_data[288],
                   ext_call.return_data[320],
                   0,
                   416,
                   66,
                   0x645374616b65206973206f6e6c7920656c696769626c652069662069742077617320656e646564206f6e2074686520637574206f666620646179206f722061667465, mem[ceil32(return_data.size) + 930 len 30] >> 272,
                   0
        if unknown_0x73178c0d(?????) == uint32(call.func_hash) >> 224:
            require not msg.value
            return TOKEN_DEFINERAddress
        if unknown_0x76089ab4(?????) == uint32(call.func_hash) >> 224:
            require not msg.value
            return sub_76089ab4Address
        if unknown_0x86ba6c67(?????) == uint32(call.func_hash) >> 224:
            require not msg.value
            require calldata.size - 4 >= 64
            if sub_d3a8b1da < 1:
                revert with 0, 17
            if arg1 > sub_d3a8b1da - 1:
                mem[128] = 0
                mem[64] = 160
                mem[160] = 32
                mem[192] = 0
                idx = 0
                s = 160
                t = 224
                while idx < mem[128]:
                    _6477 = mem[s]
                    mem[t] = mem[mem[s] + 12 len 20]
                    mem[t + 32] = Mask(128, 128, mem[_6477 + 32])
                    idx = idx + 1
                    s = s + 32
                    t = t + 64
                    continue 
                return memory
                  from mem[64]
                   len -mem[64] + 224
            if sub_d3a8b1da < 1:
                revert with 0, 17
            if arg1 > !arg2:
                revert with 0, 17
            if arg1 + arg2 <= sub_d3a8b1da - 1:
                if arg2 > test266151307():
                    revert with 0, 65
                mem[128] = arg2
                mem[64] = (32 * arg2) + 160
                if not arg2:
                    if arg1 > !arg2:
                        revert with 0, 17
                    s = 0
                    idx = arg1
                    while idx < arg1 + arg2:
                        if 1 > !idx:
                            revert with 0, 17
                        mem[0] = idx + 1
                        mem[32] = 12
                        _6598 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_6598] = sub_4c86259e[idx + 1].field_0
                        mem[_6598 + 32] = Mask(128, 128, sub_4c86259e[idx + 1].field_256)
                        if s >= mem[128]:
                            revert with 0, 50
                        mem[(32 * s) + 160] = _6598
                        if s == -1:
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        s = s + 1
                        idx = idx + 1
                        continue 
                    _6555 = mem[64]
                    mem[mem[64]] = 32
                    _6596 = mem[128]
                    mem[mem[64] + 32] = mem[128]
                    idx = 0
                    s = 160
                    t = mem[64] + 64
                    while idx < _6596:
                        _12508 = mem[s]
                        mem[t] = mem[mem[s] + 12 len 20]
                        mem[t + 32] = Mask(128, 128, mem[_12508 + 32])
                        idx = idx + 1
                        s = s + 32
                        t = t + 64
                        continue 
                    return memory
                      from mem[64]
                       len _6555 + (64 * _6596) + -mem[64] + 64
                mem[64] = (32 * arg2) + 224
                mem[(32 * arg2) + 160] = 0
                mem[(32 * arg2) + 192] = 0
                mem[160] = (32 * arg2) + 160
                s = 160
                idx = arg2
                while idx - 1:
                    mem[64] = mem[64] + 64
                    mem[(32 * arg2) + 160] = 0
                    mem[(32 * arg2) + 192] = 0
                    mem[s + 32] = (32 * arg2) + 160
                    s = s + 32
                    idx = idx - 1
                    continue 
                if arg1 > !arg2:
                    revert with 0, 17
                s = 0
                idx = arg1
                while idx < arg1 + arg2:
                    if 1 > !idx:
                        revert with 0, 17
                    mem[0] = idx + 1
                    mem[32] = 12
                    _12730 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12730] = sub_4c86259e[idx + 1].field_0
                    mem[_12730 + 32] = Mask(128, 128, sub_4c86259e[idx + 1].field_256)
                    if s >= mem[128]:
                        revert with 0, 50
                    mem[(32 * s) + 160] = _12730
                    if s == -1:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    s = s + 1
                    idx = idx + 1
                    continue 
                _12662 = mem[64]
                mem[mem[64]] = 32
                _12728 = mem[128]
                mem[mem[64] + 32] = mem[128]
                idx = 0
                s = 160
                t = mem[64] + 64
                while idx < _12728:
                    _16938 = mem[s]
                    mem[t] = mem[mem[s] + 12 len 20]
                    mem[t + 32] = Mask(128, 128, mem[_16938 + 32])
                    idx = idx + 1
                    s = s + 32
                    t = t + 64
                    continue 
                return memory
                  from mem[64]
                   len _12662 + (64 * _12728) + -mem[64] + 64
            if sub_d3a8b1da < 1:
                revert with 0, 17
            if sub_d3a8b1da - 1 < arg1:
                revert with 0, 17
            if sub_d3a8b1da + -arg1 - 1 > test266151307():
                revert with 0, 65
            mem[128] = sub_d3a8b1da + -arg1 - 1
            mem[64] = (32 * sub_d3a8b1da + -arg1 - 1) + 160
            if not sub_d3a8b1da + -arg1 - 1:
                if arg1 > !(sub_d3a8b1da + -arg1 - 1):
                    revert with 0, 17
                s = 0
                idx = arg1
                while idx < sub_d3a8b1da - 1:
                    if 1 > !idx:
                        revert with 0, 17
                    mem[0] = idx + 1
                    mem[32] = 12
                    _6602 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_6602] = sub_4c86259e[idx + 1].field_0
                    mem[_6602 + 32] = Mask(128, 128, sub_4c86259e[idx + 1].field_256)
                    if s >= mem[128]:
                        revert with 0, 50
                    mem[(32 * s) + 160] = _6602
                    if s == -1:
                        revert with 0, 17
                    if idx == -1:
                        revert with 0, 17
                    s = s + 1
                    idx = idx + 1
                    continue 
                _6556 = mem[64]
                mem[mem[64]] = 32
                _6600 = mem[128]
                mem[mem[64] + 32] = mem[128]
                idx = 0
                s = 160
                t = mem[64] + 64
                while idx < _6600:
                    _12511 = mem[s]
                    mem[t] = mem[mem[s] + 12 len 20]
                    mem[t + 32] = Mask(128, 128, mem[_12511 + 32])
                    idx = idx + 1
                    s = s + 32
                    t = t + 64
                    continue 
                return memory
                  from mem[64]
                   len _6556 + (64 * _6600) + -mem[64] + 64
            mem[64] = (32 * sub_d3a8b1da + -arg1 - 1) + 224
            mem[(32 * sub_d3a8b1da + -arg1 - 1) + 160] = 0
            mem[(32 * sub_d3a8b1da + -arg1 - 1) + 192] = 0
            mem[160] = (32 * sub_d3a8b1da + -arg1 - 1) + 160
            s = 160
            idx = sub_d3a8b1da + -arg1 - 1
            while idx - 1:
                mem[64] = mem[64] + 64
                mem[(32 * sub_d3a8b1da + -arg1 - 1) + 160] = 0
                mem[(32 * sub_d3a8b1da + -arg1 - 1) + 192] = 0
                mem[s + 32] = (32 * sub_d3a8b1da + -arg1 - 1) + 160
                s = s + 32
                idx = idx - 1
                continue 
            if arg1 > !(sub_d3a8b1da + -arg1 - 1):
                revert with 0, 17
            s = 0
            idx = arg1
            while idx < sub_d3a8b1da - 1:
                if 1 > !idx:
                    revert with 0, 17
                mem[0] = idx + 1
                mem[32] = 12
                _12734 = mem[64]
                mem[64] = mem[64] + 64
                mem[_12734] = sub_4c86259e[idx + 1].field_0
                mem[_12734 + 32] = Mask(128, 128, sub_4c86259e[idx + 1].field_256)
                if s >= mem[128]:
                    revert with 0, 50
                mem[(32 * s) + 160] = _12734
                if s == -1:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                s = s + 1
                idx = idx + 1
                continue 
            _12663 = mem[64]
            mem[mem[64]] = 32
            _12732 = mem[128]
            mem[mem[64] + 32] = mem[128]
            idx = 0
            s = 160
            t = mem[64] + 64
            while idx < _12732:
                _16941 = mem[s]
                mem[t] = mem[mem[s] + 12 len 20]
                mem[t + 32] = Mask(128, 128, mem[_16941 + 32])
                idx = idx + 1
                s = s + 32
                t = t + 64
                continue 
            return memory
              from mem[64]
               len _12663 + (64 * _12732) + -mem[64] + 64
        require unknown_0x88b1d22d(?????) == uint32(call.func_hash) >> 224
        require not msg.value
        require calldata.size - 4 >= 96
        require arg1 == address(arg1)
        require arg2 == Mask(128, 128, arg2)
        staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                gas gas_remaining wei
               args address(arg1), Mask(128, 128, arg2)
        mem[128 len 352] = ext_call.return_data[0 len 352]
        if not ext_call.success:
            revert with ext_call.return_data[0 len return_data.size]
        require return_data.size >= 352
        if not bool(ceil32(return_data.size) + 480 <= test266151307()):
            revert with 0, 65
        mem[64] = ceil32(return_data.size) + 480
        require ext_call.return_data[0] == Mask(128, 128, ext_call.return_data[0])
        mem[ceil32(return_data.size) + 128] = ext_call.return_data[0]
        mem[ceil32(return_data.size) + 160] = ext_call.return_data[32]
        mem[ceil32(return_data.size) + 192] = ext_call.return_data[64]
        mem[ceil32(return_data.size) + 224] = ext_call.return_data[96]
        require ext_call.return_data[128] < 5
        mem[ceil32(return_data.size) + 256] = ext_call.return_data[128]
        mem[ceil32(return_data.size) + 288] = ext_call.return_data[160]
        mem[ceil32(return_data.size) + 320] = ext_call.return_data[192]
        mem[ceil32(return_data.size) + 352] = ext_call.return_data[224]
        mem[ceil32(return_data.size) + 384] = ext_call.return_data[256]
        mem[ceil32(return_data.size) + 416] = ext_call.return_data[288]
        mem[ceil32(return_data.size) + 448] = ext_call.return_data[320]
        if Mask(128, 128, ext_call.return_data[0]) != Mask(128, 128, arg2):
            revert with 0, 'Address does not contain stake with provided id'
        idx = mem[ceil32(return_data.size) + 320]
        s = 0
        while idx < arg3:
            staticcall sub_413c05c6Address.0x8ce1d9e4 with:
                    gas gas_remaining wei
                   args idx
            mem[mem[64] len 160] = ext_call.return_data[0 len 160]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            _6522 = mem[64]
            mem[64] = mem[64] + ceil32(return_data.size)
            require return_data.size >= 160
            _6604 = mem[64]
            if mem[64] + 160 > test266151307() or mem[64] + 160 < mem[64]:
                revert with 0, 65
            mem[64] = mem[64] + 160
            mem[_6604] = mem[_6522]
            mem[_6604 + 32] = mem[_6522 + 32]
            mem[_6604 + 64] = mem[_6522 + 64]
            mem[_6604 + 96] = mem[_6522 + 96]
            mem[_6604 + 128] = mem[_6522 + 128]
            _6754 = mem[_6604 + 64]
            _6755 = mem[_6604 + 32]
            _6756 = mem[ceil32(return_data.size) + 192]
            _6757 = mem[_6604]
            _6758 = mem[_6604 + 128]
            _6759 = mem[_6604 + 96]
            if mem[_6604 + 96] > !mem[_6604 + 128]:
                revert with 0, 17
            if mem[_6604 + 96] + mem[_6604 + 128] < mem[_6604 + 96]:
                revert with 0, 'SafeMath: addition overflow'
            if not mem[_6604 + 96] + mem[_6604 + 128]:
                _7087 = mem[64]
                mem[64] = mem[64] + 64
                mem[_7087] = 26
                mem[_7087 + 32] = 'SafeMath: division by zero'
                if not _6755:
                    _7153 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _7153 + 68] = mem[_7087 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_7153 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _7153 + -mem[64] + 100
                _7448 = mem[64]
                mem[64] = mem[64] + 64
                mem[_7448] = 26
                mem[_7448 + 32] = 'SafeMath: division by zero'
                if _6754:
                    if s > !(0 / _6755 / _6754):
                        revert with 0, 17
                    if s + (0 / _6755 / _6754) < s:
                        revert with 0, 'SafeMath: addition overflow'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + (0 / _6755 / _6754)
                    continue 
                _7570 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _7570 + 68] = mem[_7448 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_7570 + 94] = 0
                revert with memory
                  from mem[64]
                   len _7570 + -mem[64] + 100
            if mem[_6604 + 96] + mem[_6604 + 128] and mem[_6604] > -1 / mem[_6604 + 96] + mem[_6604 + 128]:
                revert with 0, 17
            if not mem[_6604 + 96] + mem[_6604 + 128]:
                revert with 0, 18
            if (mem[_6604 + 96] * mem[_6604]) + (mem[_6604 + 128] * mem[_6604]) / mem[_6604 + 96] + mem[_6604 + 128] != mem[_6604]:
                revert with 0, 'SafeMath: multiplication overflow'
            if not (mem[_6604 + 96] * mem[_6604]) + (mem[_6604 + 128] * mem[_6604]):
                _7285 = mem[64]
                mem[64] = mem[64] + 64
                mem[_7285] = 26
                mem[_7285 + 32] = 'SafeMath: division by zero'
                if not _6755:
                    _7447 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _7447 + 68] = mem[_7285 + idx + 32]
                        idx = idx + 32
                        continue 
                    mem[_7447 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _7447 + -mem[64] + 100
                _7765 = mem[64]
                mem[64] = mem[64] + 64
                mem[_7765] = 26
                mem[_7765 + 32] = 'SafeMath: division by zero'
                if _6754:
                    if s > !(0 / _6755 / _6754):
                        revert with 0, 17
                    if s + (0 / _6755 / _6754) < s:
                        revert with 0, 'SafeMath: addition overflow'
                    if idx == -1:
                        revert with 0, 17
                    idx = idx + 1
                    s = s + (0 / _6755 / _6754)
                    continue 
                _7905 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _7905 + 68] = mem[_7765 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_7905 + 94] = 0
                revert with memory
                  from mem[64]
                   len _7905 + -mem[64] + 100
            if (mem[_6604 + 96] * mem[_6604]) + (mem[_6604 + 128] * mem[_6604]) and mem[ceil32(return_data.size) + 192] > -1 / (mem[_6604 + 96] * mem[_6604]) + (mem[_6604 + 128] * mem[_6604]):
                revert with 0, 17
            if not (mem[_6604 + 96] * mem[_6604]) + (mem[_6604 + 128] * mem[_6604]):
                revert with 0, 18
            if (mem[_6604 + 96] * mem[_6604] * mem[ceil32(return_data.size) + 192]) + (mem[_6604 + 128] * mem[_6604] * mem[ceil32(return_data.size) + 192]) / (mem[_6604 + 96] * mem[_6604]) + (mem[_6604 + 128] * mem[_6604]) != mem[ceil32(return_data.size) + 192]:
                revert with 0, 'SafeMath: multiplication overflow'
            _7679 = mem[64]
            mem[64] = mem[64] + 64
            mem[_7679] = 26
            mem[_7679 + 32] = 'SafeMath: division by zero'
            if not _6755:
                _7764 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _7764 + 68] = mem[_7679 + idx + 32]
                    idx = idx + 32
                    continue 
                mem[_7764 + 94] = 0
                revert with memory
                  from mem[64]
                   len _7764 + -mem[64] + 100
            _8057 = mem[64]
            mem[64] = mem[64] + 64
            mem[_8057] = 26
            mem[_8057 + 32] = 'SafeMath: division by zero'
            if _6754:
                if s > !((_6759 * _6757 * _6756) + (_6758 * _6757 * _6756) / _6755 / _6754):
                    revert with 0, 17
                if s + ((_6759 * _6757 * _6756) + (_6758 * _6757 * _6756) / _6755 / _6754) < s:
                    revert with 0, 'SafeMath: addition overflow'
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s + ((_6759 * _6757 * _6756) + (_6758 * _6757 * _6756) / _6755 / _6754)
                continue 
            _8134 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _8134 + 68] = mem[_8057 + idx + 32]
                idx = idx + 32
                continue 
            mem[_8134 + 94] = 0
            revert with memory
              from mem[64]
               len _8134 + -mem[64] + 100
        return s
    if unknown_0x2c8bff0e(?????) <= uint32(call.func_hash) >> 224:
        if unknown_0x2c8bff0e(?????) == uint32(call.func_hash) >> 224:
            require not msg.value
            require calldata.size - 4 >= 32
            require arg1 == address(arg1)
            return sub_2c8bff0e[arg1]
        if unknown_0x382c0ab3(?????) == uint32(call.func_hash) >> 224:
            require not msg.value
            require calldata.size - 4 >= 32
            if TOKEN_DEFINERAddress != msg.sender:
                revert with 0, 'Wrong sender.'
            sub_be647a94 = arg1
        else:
            if uint32(call.func_hash) >> 224 != unknown_0x39df9599(?????):
                require unknown_0x413c05c6(?????) == uint32(call.func_hash) >> 224
                require not msg.value
                return sub_413c05c6Address
            require not msg.value
            require calldata.size - 4 >= 32
            require arg1 == Mask(128, 128, arg1)
            if not uint8(stor1.field_160):
                revert with 0, 'Register is disabled'
            mem[128] = 0
            mem[160] = 0
            mem[192] = 0
            mem[224] = 0
            mem[256] = 0
            mem[288] = 0
            mem[320] = 0
            mem[352] = 0
            mem[384] = 0
            mem[416] = 0
            mem[448] = 0
            staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                    gas gas_remaining wei
                   args msg.sender, Mask(128, 128, arg1)
            mem[480 len 352] = ext_call.return_data[0 len 352]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 352
            if not bool(ceil32(return_data.size) + 832 <= test266151307()):
                revert with 0, 65
            require ext_call.return_data[0] == Mask(128, 128, ext_call.return_data[0])
            mem[ceil32(return_data.size) + 480] = ext_call.return_data[0]
            mem[ceil32(return_data.size) + 512] = ext_call.return_data[32]
            mem[ceil32(return_data.size) + 544] = ext_call.return_data[64]
            mem[ceil32(return_data.size) + 576] = ext_call.return_data[96]
            require ext_call.return_data[128] < 5
            mem[ceil32(return_data.size) + 608] = ext_call.return_data[128]
            mem[ceil32(return_data.size) + 640] = ext_call.return_data[160]
            mem[ceil32(return_data.size) + 672] = ext_call.return_data[192]
            mem[ceil32(return_data.size) + 704] = ext_call.return_data[224]
            mem[ceil32(return_data.size) + 736] = ext_call.return_data[256]
            mem[ceil32(return_data.size) + 768] = ext_call.return_data[288]
            mem[ceil32(return_data.size) + 800] = ext_call.return_data[320]
            if Mask(128, 128, ext_call.return_data[0]) != Mask(128, 128, arg1):
                revert with 0, 
                            32,
                            46,
                            0xfe53656e64657220646f6573206e6f7420636f6e7461696e207374616b6520776974682070726f76696465642069, mem[ceil32(return_data.size) + 910 len 18] >> 112,
                            0
            if stor9[address(msg.sender)][Mask(128, 128, arg1)]:
                revert with 0, 'Stake has already been converted'
            if ext_call.return_data[128] > 4:
                revert with 0, 33
            if ext_call.return_data[128] != 2:
                revert with 0, 
                            32,
                            44,
                            0x795374616b65206973206f6e6c7920656c696769626c6520696620697420686173206265656e20636c6f7365, mem[ceil32(return_data.size) + 908 len 20] >> 96,
                            0
            if ext_call.return_data[192] >= sub_be647a94:
                revert with 0, 
                            32,
                            65,
                            0x645374616b65206973206f6e6c7920656c696769626c65206966206974207761732063726561746564207072696f7220746f2074686520637574206f6666206461, mem[ceil32(return_data.size) + 929 len 31] >> 264,
                            0
            if ext_call.return_data[192] > !ext_call.return_data[224]:
                revert with 0, 17
            if ext_call.return_data[192] + ext_call.return_data[224] < sub_be647a94:
                revert with 0, 
                            32,
                            66,
                            0x645374616b65206973206f6e6c7920656c696769626c652069662069742077617320656e646564206f6e2074686520637574206f666620646179206f722061667465, mem[ceil32(return_data.size) + 930 len 30] >> 272,
                            0
            mem[ceil32(return_data.size) + 832] = 17
            mem[ceil32(return_data.size) + 864] = 'Stake is eligible' << 120
            if stor8[msg.sender][Mask(128, 128, arg1)]:
                revert with 0, 'Stake has already been registered'
            stor8[msg.sender][Mask(128, 128, arg1)] = 1
            mem[ceil32(return_data.size) + 896] = msg.sender
            mem[ceil32(return_data.size) + 928] = Mask(128, 128, arg1)
            sub_4c86259e[stor10].field_0 = msg.sender
            sub_4c86259e[stor10].field_256 = 0
            sub_4c86259e[stor10].field_512 = 0
            if sub_d3a8b1da == -1:
                revert with 0, 17
            sub_d3a8b1da++
            if 1 > !sub_2c8bff0e[msg.sender]:
                revert with 0, 17
            sub_2c8bff0e[msg.sender]++
            if 1 > !sub_ed73481d:
                revert with 0, 17
            mem[ceil32(return_data.size) + 960] = 0
            mem[ceil32(return_data.size) + 992] = 0
            mem[ceil32(return_data.size) + 1024] = 0
            mem[ceil32(return_data.size) + 1056] = 0
            mem[ceil32(return_data.size) + 1088] = 0
            mem[ceil32(return_data.size) + 1120] = 0
            mem[ceil32(return_data.size) + 1152] = 0
            mem[ceil32(return_data.size) + 1184] = 0
            mem[ceil32(return_data.size) + 1216] = 0
            mem[ceil32(return_data.size) + 1248] = 0
            mem[ceil32(return_data.size) + 1280] = 0
            staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                    gas gas_remaining wei
                   args msg.sender, Mask(128, 128, arg1)
            mem[ceil32(return_data.size) + 1312 len 352] = ext_call.return_data[0 len 352]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 352
            if not bool((2 * ceil32(return_data.size)) + 1664 <= test266151307()):
                revert with 0, 65
            require ext_call.return_data[0] == Mask(128, 128, ext_call.return_data[0])
            mem[(2 * ceil32(return_data.size)) + 1312] = ext_call.return_data[0]
            mem[(2 * ceil32(return_data.size)) + 1344] = ext_call.return_data[32]
            mem[(2 * ceil32(return_data.size)) + 1376] = ext_call.return_data[64]
            mem[(2 * ceil32(return_data.size)) + 1408] = ext_call.return_data[96]
            require ext_call.return_data[128] < 5
            mem[(2 * ceil32(return_data.size)) + 1440] = ext_call.return_data[128]
            mem[(2 * ceil32(return_data.size)) + 1472] = ext_call.return_data[160]
            mem[(2 * ceil32(return_data.size)) + 1504] = ext_call.return_data[192]
            mem[(2 * ceil32(return_data.size)) + 1536] = ext_call.return_data[224]
            mem[(2 * ceil32(return_data.size)) + 1568] = ext_call.return_data[256]
            mem[(2 * ceil32(return_data.size)) + 1600] = ext_call.return_data[288]
            mem[(2 * ceil32(return_data.size)) + 1632] = ext_call.return_data[320]
            if Mask(128, 128, ext_call.return_data[0]) != Mask(128, 128, arg1):
                if sub_f4a8f345 > -1:
                    revert with 0, 17
                if sub_f4a8f345 < sub_f4a8f345:
                    revert with 0, 'SafeMath: addition overflow'
            else:
                mem[0] = Mask(128, 128, arg1)
                mem[32] = sha3(address(msg.sender), 9)
                if stor9[address(msg.sender)][Mask(128, 128, arg1)]:
                    if sub_f4a8f345 > -1:
                        revert with 0, 17
                    if sub_f4a8f345 < sub_f4a8f345:
                        revert with 0, 'SafeMath: addition overflow'
                else:
                    if ext_call.return_data[128] > 4:
                        revert with 0, 33
                    if ext_call.return_data[128] != 2:
                        if sub_f4a8f345 > -1:
                            revert with 0, 17
                        if sub_f4a8f345 < sub_f4a8f345:
                            revert with 0, 'SafeMath: addition overflow'
                    else:
                        if ext_call.return_data[192] >= sub_be647a94:
                            if sub_f4a8f345 > -1:
                                revert with 0, 17
                            if sub_f4a8f345 < sub_f4a8f345:
                                revert with 0, 'SafeMath: addition overflow'
                        else:
                            if ext_call.return_data[192] > !ext_call.return_data[224]:
                                revert with 0, 17
                            if ext_call.return_data[192] + ext_call.return_data[224] < sub_be647a94:
                                if sub_f4a8f345 > -1:
                                    revert with 0, 17
                                if sub_f4a8f345 < sub_f4a8f345:
                                    revert with 0, 'SafeMath: addition overflow'
                            else:
                                mem[(2 * ceil32(return_data.size)) + 1664] = 17
                                mem[(2 * ceil32(return_data.size)) + 1696] = 'Stake is eligible' << 120
                                staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                                        gas gas_remaining wei
                                       args msg.sender, Mask(128, 128, arg1)
                                mem[(2 * ceil32(return_data.size)) + 1728 len 352] = ext_call.return_data[0 len 352]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 352
                                if not bool((4 * ceil32(return_data.size)) + 2080 <= test266151307()):
                                    revert with 0, 65
                                require ext_call.return_data[0] == Mask(128, 128, ext_call.return_data[0])
                                mem[(4 * ceil32(return_data.size)) + 1728] = ext_call.return_data[0]
                                mem[(4 * ceil32(return_data.size)) + 1760] = ext_call.return_data[32]
                                mem[(4 * ceil32(return_data.size)) + 1792] = ext_call.return_data[64]
                                mem[(4 * ceil32(return_data.size)) + 1824] = ext_call.return_data[96]
                                require ext_call.return_data[128] < 5
                                mem[(4 * ceil32(return_data.size)) + 1856] = ext_call.return_data[128]
                                mem[(4 * ceil32(return_data.size)) + 1888] = ext_call.return_data[160]
                                mem[(4 * ceil32(return_data.size)) + 1920] = ext_call.return_data[192]
                                mem[(4 * ceil32(return_data.size)) + 1952] = ext_call.return_data[224]
                                mem[(4 * ceil32(return_data.size)) + 1984] = ext_call.return_data[256]
                                mem[(4 * ceil32(return_data.size)) + 2016] = ext_call.return_data[288]
                                mem[(4 * ceil32(return_data.size)) + 2048] = ext_call.return_data[320]
                                if Mask(128, 128, ext_call.return_data[0]) != Mask(128, 128, arg1):
                                    revert with 0, 'Address does not contain stake with provided id'
                                if ext_call.return_data[128] > 4:
                                    revert with 0, 33
                                if ext_call.return_data[128] == 3:
                                    if sub_f4a8f345 > -1:
                                        revert with 0, 17
                                    if sub_f4a8f345 < sub_f4a8f345:
                                        revert with 0, 'SafeMath: addition overflow'
                                else:
                                    if ext_call.return_data[128] > 4:
                                        revert with 0, 33
                                    if ext_call.return_data[128] == 4:
                                        if sub_f4a8f345 > -1:
                                            revert with 0, 17
                                        if sub_f4a8f345 < sub_f4a8f345:
                                            revert with 0, 'SafeMath: addition overflow'
                                    else:
                                        if ext_call.return_data[128] > 4:
                                            revert with 0, 33
                                        if ext_call.return_data[128] == 1:
                                            if sub_f4a8f345 > -1:
                                                revert with 0, 17
                                            if sub_f4a8f345 < sub_f4a8f345:
                                                revert with 0, 'SafeMath: addition overflow'
                                        else:
                                            if ext_call.return_data[128] > 4:
                                                revert with 0, 33
                                            if not ext_call.return_data[128]:
                                                staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                                                        gas gas_remaining wei
                                                       args msg.sender, Mask(128, 128, ext_call.return_data[0])
                                                mem[(4 * ceil32(return_data.size)) + 2080 len 352] = ext_call.return_data[0 len 352]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 352
                                                if not bool((6 * ceil32(return_data.size)) + 2432 <= test266151307()):
                                                    revert with 0, 65
                                                mem[64] = (6 * ceil32(return_data.size)) + 2432
                                                require ext_call.return_data[0] == Mask(128, 128, ext_call.return_data[0])
                                                mem[(6 * ceil32(return_data.size)) + 2080] = ext_call.return_data[0]
                                                mem[(6 * ceil32(return_data.size)) + 2112] = ext_call.return_data[32]
                                                mem[(6 * ceil32(return_data.size)) + 2144] = ext_call.return_data[64]
                                                mem[(6 * ceil32(return_data.size)) + 2176] = ext_call.return_data[96]
                                                require ext_call.return_data[128] < 5
                                                mem[(6 * ceil32(return_data.size)) + 2208] = ext_call.return_data[128]
                                                mem[(6 * ceil32(return_data.size)) + 2240] = ext_call.return_data[160]
                                                mem[(6 * ceil32(return_data.size)) + 2272] = ext_call.return_data[192]
                                                mem[(6 * ceil32(return_data.size)) + 2304] = ext_call.return_data[224]
                                                mem[(6 * ceil32(return_data.size)) + 2336] = ext_call.return_data[256]
                                                mem[(6 * ceil32(return_data.size)) + 2368] = ext_call.return_data[288]
                                                mem[(6 * ceil32(return_data.size)) + 2400] = ext_call.return_data[320]
                                                if Mask(128, 128, ext_call.return_data[0]) != Mask(128, 128, ext_call.return_data[0]):
                                                    revert with 0, 'Address does not contain stake with provided id'
                                                idx = mem[(6 * ceil32(return_data.size)) + 2272]
                                                s = 0
                                                while idx < sub_ed73481d + 1:
                                                    staticcall sub_413c05c6Address.0x8ce1d9e4 with:
                                                            gas gas_remaining wei
                                                           args idx
                                                    mem[mem[64] len 160] = ext_call.return_data[0 len 160]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _6519 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 160
                                                    _6584 = mem[64]
                                                    if mem[64] + 160 > test266151307() or mem[64] + 160 < mem[64]:
                                                        revert with 0, 65
                                                    mem[64] = mem[64] + 160
                                                    mem[_6584] = mem[_6519]
                                                    mem[_6584 + 32] = mem[_6519 + 32]
                                                    mem[_6584 + 64] = mem[_6519 + 64]
                                                    mem[_6584 + 96] = mem[_6519 + 96]
                                                    mem[_6584 + 128] = mem[_6519 + 128]
                                                    _6742 = mem[_6584 + 64]
                                                    _6743 = mem[_6584 + 32]
                                                    _6744 = mem[(6 * ceil32(return_data.size)) + 2144]
                                                    _6745 = mem[_6584]
                                                    _6746 = mem[_6584 + 128]
                                                    _6747 = mem[_6584 + 96]
                                                    if mem[_6584 + 96] > !mem[_6584 + 128]:
                                                        revert with 0, 17
                                                    if mem[_6584 + 96] + mem[_6584 + 128] < mem[_6584 + 96]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if not mem[_6584 + 96] + mem[_6584 + 128]:
                                                        _7085 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_7085] = 26
                                                        mem[_7085 + 32] = 'SafeMath: division by zero'
                                                        if not _6743:
                                                            _7152 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _7152 + 68] = mem[_7085 + idx + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_7152 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _7152 + -mem[64] + 100
                                                        _7446 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_7446] = 26
                                                        mem[_7446 + 32] = 'SafeMath: division by zero'
                                                        if _6742:
                                                            if s > !(0 / _6743 / _6742):
                                                                revert with 0, 17
                                                            if s + (0 / _6743 / _6742) < s:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            if idx == -1:
                                                                revert with 0, 17
                                                            idx = idx + 1
                                                            s = s + (0 / _6743 / _6742)
                                                            continue 
                                                        _7566 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _7566 + 68] = mem[_7446 + idx + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_7566 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _7566 + -mem[64] + 100
                                                    if mem[_6584 + 96] + mem[_6584 + 128] and mem[_6584] > -1 / mem[_6584 + 96] + mem[_6584 + 128]:
                                                        revert with 0, 17
                                                    if not mem[_6584 + 96] + mem[_6584 + 128]:
                                                        revert with 0, 18
                                                    if (mem[_6584 + 96] * mem[_6584]) + (mem[_6584 + 128] * mem[_6584]) / mem[_6584 + 96] + mem[_6584 + 128] != mem[_6584]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not (mem[_6584 + 96] * mem[_6584]) + (mem[_6584 + 128] * mem[_6584]):
                                                        _7283 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_7283] = 26
                                                        mem[_7283 + 32] = 'SafeMath: division by zero'
                                                        if not _6743:
                                                            _7445 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _7445 + 68] = mem[_7283 + idx + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_7445 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _7445 + -mem[64] + 100
                                                        _7762 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_7762] = 26
                                                        mem[_7762 + 32] = 'SafeMath: division by zero'
                                                        if _6742:
                                                            if s > !(0 / _6743 / _6742):
                                                                revert with 0, 17
                                                            if s + (0 / _6743 / _6742) < s:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            if idx == -1:
                                                                revert with 0, 17
                                                            idx = idx + 1
                                                            s = s + (0 / _6743 / _6742)
                                                            continue 
                                                        _7902 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _7902 + 68] = mem[_7762 + idx + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_7902 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _7902 + -mem[64] + 100
                                                    if (mem[_6584 + 96] * mem[_6584]) + (mem[_6584 + 128] * mem[_6584]) and mem[(6 * ceil32(return_data.size)) + 2144] > -1 / (mem[_6584 + 96] * mem[_6584]) + (mem[_6584 + 128] * mem[_6584]):
                                                        revert with 0, 17
                                                    if not (mem[_6584 + 96] * mem[_6584]) + (mem[_6584 + 128] * mem[_6584]):
                                                        revert with 0, 18
                                                    if (mem[_6584 + 96] * mem[_6584] * mem[(6 * ceil32(return_data.size)) + 2144]) + (mem[_6584 + 128] * mem[_6584] * mem[(6 * ceil32(return_data.size)) + 2144]) / (mem[_6584 + 96] * mem[_6584]) + (mem[_6584 + 128] * mem[_6584]) != mem[(6 * ceil32(return_data.size)) + 2144]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _7676 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_7676] = 26
                                                    mem[_7676 + 32] = 'SafeMath: division by zero'
                                                    if not _6743:
                                                        _7761 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _7761 + 68] = mem[_7676 + idx + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_7761 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _7761 + -mem[64] + 100
                                                    _8054 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_8054] = 26
                                                    mem[_8054 + 32] = 'SafeMath: division by zero'
                                                    if _6742:
                                                        if s > !((_6747 * _6745 * _6744) + (_6746 * _6745 * _6744) / _6743 / _6742):
                                                            revert with 0, 17
                                                        if s + ((_6747 * _6745 * _6744) + (_6746 * _6745 * _6744) / _6743 / _6742) < s:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if idx == -1:
                                                            revert with 0, 17
                                                        idx = idx + 1
                                                        s = s + ((_6747 * _6745 * _6744) + (_6746 * _6745 * _6744) / _6743 / _6742)
                                                        continue 
                                                    _8132 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _8132 + 68] = mem[_8054 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_8132 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _8132 + -mem[64] + 100
                                                if mem[(4 * ceil32(return_data.size)) + 1888] > !s:
                                                    revert with 0, 17
                                                if mem[(4 * ceil32(return_data.size)) + 1888] + s < mem[(4 * ceil32(return_data.size)) + 1888]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if mem[(4 * ceil32(return_data.size)) + 1760] > !(mem[(4 * ceil32(return_data.size)) + 1888] + s):
                                                    revert with 0, 17
                                                if mem[(4 * ceil32(return_data.size)) + 1760] + mem[(4 * ceil32(return_data.size)) + 1888] + s < mem[(4 * ceil32(return_data.size)) + 1760]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if sub_f4a8f345 > !(mem[(4 * ceil32(return_data.size)) + 1760] + mem[(4 * ceil32(return_data.size)) + 1888] + s):
                                                    revert with 0, 17
                                                if sub_f4a8f345 + mem[(4 * ceil32(return_data.size)) + 1760] + mem[(4 * ceil32(return_data.size)) + 1888] + s < sub_f4a8f345:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                sub_f4a8f345 = sub_f4a8f345 + mem[(4 * ceil32(return_data.size)) + 1760] + mem[(4 * ceil32(return_data.size)) + 1888] + s
                                            else:
                                                if ext_call.return_data[192] > !ext_call.return_data[224]:
                                                    revert with 0, 17
                                                staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                                                        gas gas_remaining wei
                                                       args msg.sender, Mask(128, 128, ext_call.return_data[0])
                                                mem[(4 * ceil32(return_data.size)) + 2080 len 352] = ext_call.return_data[0 len 352]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 352
                                                if not bool((6 * ceil32(return_data.size)) + 2432 <= test266151307()):
                                                    revert with 0, 65
                                                mem[64] = (6 * ceil32(return_data.size)) + 2432
                                                require ext_call.return_data[0] == Mask(128, 128, ext_call.return_data[0])
                                                mem[(6 * ceil32(return_data.size)) + 2080] = ext_call.return_data[0]
                                                mem[(6 * ceil32(return_data.size)) + 2112] = ext_call.return_data[32]
                                                mem[(6 * ceil32(return_data.size)) + 2144] = ext_call.return_data[64]
                                                mem[(6 * ceil32(return_data.size)) + 2176] = ext_call.return_data[96]
                                                require ext_call.return_data[128] < 5
                                                mem[(6 * ceil32(return_data.size)) + 2208] = ext_call.return_data[128]
                                                mem[(6 * ceil32(return_data.size)) + 2240] = ext_call.return_data[160]
                                                mem[(6 * ceil32(return_data.size)) + 2272] = ext_call.return_data[192]
                                                mem[(6 * ceil32(return_data.size)) + 2304] = ext_call.return_data[224]
                                                mem[(6 * ceil32(return_data.size)) + 2336] = ext_call.return_data[256]
                                                mem[(6 * ceil32(return_data.size)) + 2368] = ext_call.return_data[288]
                                                mem[(6 * ceil32(return_data.size)) + 2400] = ext_call.return_data[320]
                                                if Mask(128, 128, ext_call.return_data[0]) != Mask(128, 128, ext_call.return_data[0]):
                                                    revert with 0, 'Address does not contain stake with provided id'
                                                if sub_ed73481d + 1 < ext_call.return_data[192] + ext_call.return_data[224]:
                                                    idx = mem[(6 * ceil32(return_data.size)) + 2272]
                                                    s = 0
                                                    while idx < ext_call.return_data[192] + ext_call.return_data[224]:
                                                        staticcall sub_413c05c6Address.0x8ce1d9e4 with:
                                                                gas gas_remaining wei
                                                               args idx
                                                        mem[mem[64] len 160] = ext_call.return_data[0 len 160]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _6514 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 160
                                                        _6580 = mem[64]
                                                        if mem[64] + 160 > test266151307() or mem[64] + 160 < mem[64]:
                                                            revert with 0, 65
                                                        mem[64] = mem[64] + 160
                                                        mem[_6580] = mem[_6514]
                                                        mem[_6580 + 32] = mem[_6514 + 32]
                                                        mem[_6580 + 64] = mem[_6514 + 64]
                                                        mem[_6580 + 96] = mem[_6514 + 96]
                                                        mem[_6580 + 128] = mem[_6514 + 128]
                                                        _6728 = mem[_6580 + 64]
                                                        _6729 = mem[_6580 + 32]
                                                        _6730 = mem[(6 * ceil32(return_data.size)) + 2144]
                                                        _6731 = mem[_6580]
                                                        _6732 = mem[_6580 + 128]
                                                        _6733 = mem[_6580 + 96]
                                                        if mem[_6580 + 96] > !mem[_6580 + 128]:
                                                            revert with 0, 17
                                                        if mem[_6580 + 96] + mem[_6580 + 128] < mem[_6580 + 96]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if not mem[_6580 + 96] + mem[_6580 + 128]:
                                                            _7079 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_7079] = 26
                                                            mem[_7079 + 32] = 'SafeMath: division by zero'
                                                            if not _6729:
                                                                _7149 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _7149 + 68] = mem[_7079 + idx + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_7149 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _7149 + -mem[64] + 100
                                                            _7435 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_7435] = 26
                                                            mem[_7435 + 32] = 'SafeMath: division by zero'
                                                            if _6728:
                                                                if s > !(0 / _6729 / _6728):
                                                                    revert with 0, 17
                                                                if s + (0 / _6729 / _6728) < s:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                if idx == -1:
                                                                    revert with 0, 17
                                                                idx = idx + 1
                                                                s = s + (0 / _6729 / _6728)
                                                                continue 
                                                            _7558 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _7558 + 68] = mem[_7435 + idx + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_7558 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _7558 + -mem[64] + 100
                                                        if mem[_6580 + 96] + mem[_6580 + 128] and mem[_6580] > -1 / mem[_6580 + 96] + mem[_6580 + 128]:
                                                            revert with 0, 17
                                                        if not mem[_6580 + 96] + mem[_6580 + 128]:
                                                            revert with 0, 18
                                                        if (mem[_6580 + 96] * mem[_6580]) + (mem[_6580 + 128] * mem[_6580]) / mem[_6580 + 96] + mem[_6580 + 128] != mem[_6580]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not (mem[_6580 + 96] * mem[_6580]) + (mem[_6580 + 128] * mem[_6580]):
                                                            _7278 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_7278] = 26
                                                            mem[_7278 + 32] = 'SafeMath: division by zero'
                                                            if not _6729:
                                                                _7434 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _7434 + 68] = mem[_7278 + idx + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_7434 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _7434 + -mem[64] + 100
                                                            _7753 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_7753] = 26
                                                            mem[_7753 + 32] = 'SafeMath: division by zero'
                                                            if _6728:
                                                                if s > !(0 / _6729 / _6728):
                                                                    revert with 0, 17
                                                                if s + (0 / _6729 / _6728) < s:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                if idx == -1:
                                                                    revert with 0, 17
                                                                idx = idx + 1
                                                                s = s + (0 / _6729 / _6728)
                                                                continue 
                                                            _7890 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _7890 + 68] = mem[_7753 + idx + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_7890 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _7890 + -mem[64] + 100
                                                        if (mem[_6580 + 96] * mem[_6580]) + (mem[_6580 + 128] * mem[_6580]) and mem[(6 * ceil32(return_data.size)) + 2144] > -1 / (mem[_6580 + 96] * mem[_6580]) + (mem[_6580 + 128] * mem[_6580]):
                                                            revert with 0, 17
                                                        if not (mem[_6580 + 96] * mem[_6580]) + (mem[_6580 + 128] * mem[_6580]):
                                                            revert with 0, 18
                                                        if (mem[_6580 + 96] * mem[_6580] * mem[(6 * ceil32(return_data.size)) + 2144]) + (mem[_6580 + 128] * mem[_6580] * mem[(6 * ceil32(return_data.size)) + 2144]) / (mem[_6580 + 96] * mem[_6580]) + (mem[_6580 + 128] * mem[_6580]) != mem[(6 * ceil32(return_data.size)) + 2144]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _7668 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_7668] = 26
                                                        mem[_7668 + 32] = 'SafeMath: division by zero'
                                                        if not _6729:
                                                            _7752 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _7752 + 68] = mem[_7668 + idx + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_7752 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _7752 + -mem[64] + 100
                                                        _8047 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_8047] = 26
                                                        mem[_8047 + 32] = 'SafeMath: division by zero'
                                                        if _6728:
                                                            if s > !((_6733 * _6731 * _6730) + (_6732 * _6731 * _6730) / _6729 / _6728):
                                                                revert with 0, 17
                                                            if s + ((_6733 * _6731 * _6730) + (_6732 * _6731 * _6730) / _6729 / _6728) < s:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            if idx == -1:
                                                                revert with 0, 17
                                                            idx = idx + 1
                                                            s = s + ((_6733 * _6731 * _6730) + (_6732 * _6731 * _6730) / _6729 / _6728)
                                                            continue 
                                                        _8127 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _8127 + 68] = mem[_8047 + idx + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_8127 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _8127 + -mem[64] + 100
                                                    if s >= mem[(4 * ceil32(return_data.size)) + 1888]:
                                                        _6551 = mem[(4 * ceil32(return_data.size)) + 1728]
                                                        staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                                                                gas gas_remaining wei
                                                               args msg.sender, Mask(128, 128, mem[(4 * ceil32(return_data.size)) + 1728])
                                                        mem[mem[64] len 352] = ext_call.return_data[0 len 352]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _6807 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 352
                                                        _6842 = mem[64]
                                                        if mem[64] + 352 < mem[64] or mem[64] + 352 > test266151307():
                                                            revert with 0, 65
                                                        mem[64] = mem[64] + 352
                                                        require mem[_6807] == Mask(128, 128, mem[_6807])
                                                        mem[_6842] = mem[_6807]
                                                        mem[_6842 + 32] = mem[_6807 + 32]
                                                        mem[_6842 + 64] = mem[_6807 + 64]
                                                        mem[_6842 + 96] = mem[_6807 + 96]
                                                        require mem[_6807 + 128] < 5
                                                        mem[_6842 + 128] = mem[_6807 + 128]
                                                        mem[_6842 + 160] = mem[_6807 + 160]
                                                        mem[_6842 + 192] = mem[_6807 + 192]
                                                        mem[_6842 + 224] = mem[_6807 + 224]
                                                        mem[_6842 + 256] = mem[_6807 + 256]
                                                        mem[_6842 + 288] = mem[_6807 + 288]
                                                        mem[_6842 + 320] = mem[_6807 + 320]
                                                        if Mask(128, 128, mem[_6842]) != Mask(128, 128, _6551):
                                                            revert with 0, 'Address does not contain stake with provided id'
                                                        idx = mem[_6842 + 192]
                                                        s = 0
                                                        while idx < sub_ed73481d + 1:
                                                            staticcall sub_413c05c6Address.0x8ce1d9e4 with:
                                                                    gas gas_remaining wei
                                                                   args idx
                                                            mem[mem[64] len 160] = ext_call.return_data[0 len 160]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _12609 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 160
                                                            _12704 = mem[64]
                                                            if mem[64] + 160 > test266151307() or mem[64] + 160 < mem[64]:
                                                                revert with 0, 65
                                                            mem[64] = mem[64] + 160
                                                            mem[_12704] = mem[_12609]
                                                            mem[_12704 + 32] = mem[_12609 + 32]
                                                            mem[_12704 + 64] = mem[_12609 + 64]
                                                            mem[_12704 + 96] = mem[_12609 + 96]
                                                            mem[_12704 + 128] = mem[_12609 + 128]
                                                            _13072 = mem[_12704 + 64]
                                                            _13073 = mem[_12704 + 32]
                                                            _13074 = mem[_6842 + 64]
                                                            _13075 = mem[_12704]
                                                            _13076 = mem[_12704 + 128]
                                                            _13077 = mem[_12704 + 96]
                                                            if mem[_12704 + 96] > !mem[_12704 + 128]:
                                                                revert with 0, 17
                                                            if mem[_12704 + 96] + mem[_12704 + 128] < mem[_12704 + 96]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            if not mem[_12704 + 96] + mem[_12704 + 128]:
                                                                _13555 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_13555] = 26
                                                                mem[_13555 + 32] = 'SafeMath: division by zero'
                                                                if not _13073:
                                                                    _13668 = mem[64]
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 26
                                                                    idx = 0
                                                                    while idx < 26:
                                                                        mem[idx + _13668 + 68] = mem[_13555 + idx + 32]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    mem[_13668 + 94] = 0
                                                                    revert with memory
                                                                      from mem[64]
                                                                       len _13668 + -mem[64] + 100
                                                                _13971 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_13971] = 26
                                                                mem[_13971 + 32] = 'SafeMath: division by zero'
                                                                if _13072:
                                                                    if s > !(0 / _13073 / _13072):
                                                                        revert with 0, 17
                                                                    if s + (0 / _13073 / _13072) < s:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    if idx == -1:
                                                                        revert with 0, 17
                                                                    idx = idx + 1
                                                                    s = s + (0 / _13073 / _13072)
                                                                    continue 
                                                                _14160 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _14160 + 68] = mem[_13971 + idx + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_14160 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _14160 + -mem[64] + 100
                                                            if mem[_12704 + 96] + mem[_12704 + 128] and mem[_12704] > -1 / mem[_12704 + 96] + mem[_12704 + 128]:
                                                                revert with 0, 17
                                                            if not mem[_12704 + 96] + mem[_12704 + 128]:
                                                                revert with 0, 18
                                                            if (mem[_12704 + 96] * mem[_12704]) + (mem[_12704 + 128] * mem[_12704]) / mem[_12704 + 96] + mem[_12704 + 128] != mem[_12704]:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            if not (mem[_12704 + 96] * mem[_12704]) + (mem[_12704 + 128] * mem[_12704]):
                                                                _13812 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_13812] = 26
                                                                mem[_13812 + 32] = 'SafeMath: division by zero'
                                                                if not _13073:
                                                                    _13970 = mem[64]
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 26
                                                                    idx = 0
                                                                    while idx < 26:
                                                                        mem[idx + _13970 + 68] = mem[_13812 + idx + 32]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    mem[_13970 + 94] = 0
                                                                    revert with memory
                                                                      from mem[64]
                                                                       len _13970 + -mem[64] + 100
                                                                _14459 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_14459] = 26
                                                                mem[_14459 + 32] = 'SafeMath: division by zero'
                                                                if _13072:
                                                                    if s > !(0 / _13073 / _13072):
                                                                        revert with 0, 17
                                                                    if s + (0 / _13073 / _13072) < s:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    if idx == -1:
                                                                        revert with 0, 17
                                                                    idx = idx + 1
                                                                    s = s + (0 / _13073 / _13072)
                                                                    continue 
                                                                _14651 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _14651 + 68] = mem[_14459 + idx + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_14651 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _14651 + -mem[64] + 100
                                                            if (mem[_12704 + 96] * mem[_12704]) + (mem[_12704 + 128] * mem[_12704]) and mem[_6842 + 64] > -1 / (mem[_12704 + 96] * mem[_12704]) + (mem[_12704 + 128] * mem[_12704]):
                                                                revert with 0, 17
                                                            if not (mem[_12704 + 96] * mem[_12704]) + (mem[_12704 + 128] * mem[_12704]):
                                                                revert with 0, 18
                                                            if (mem[_12704 + 96] * mem[_12704] * mem[_6842 + 64]) + (mem[_12704 + 128] * mem[_12704] * mem[_6842 + 64]) / (mem[_12704 + 96] * mem[_12704]) + (mem[_12704 + 128] * mem[_12704]) != mem[_6842 + 64]:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            _14330 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_14330] = 26
                                                            mem[_14330 + 32] = 'SafeMath: division by zero'
                                                            if not _13073:
                                                                _14458 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _14458 + 68] = mem[_14330 + idx + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_14458 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _14458 + -mem[64] + 100
                                                            _14936 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_14936] = 26
                                                            mem[_14936 + 32] = 'SafeMath: division by zero'
                                                            if _13072:
                                                                if s > !((_13077 * _13075 * _13074) + (_13076 * _13075 * _13074) / _13073 / _13072):
                                                                    revert with 0, 17
                                                                if s + ((_13077 * _13075 * _13074) + (_13076 * _13075 * _13074) / _13073 / _13072) < s:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                if idx == -1:
                                                                    revert with 0, 17
                                                                idx = idx + 1
                                                                s = s + ((_13077 * _13075 * _13074) + (_13076 * _13075 * _13074) / _13073 / _13072)
                                                                continue 
                                                            _15100 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _15100 + 68] = mem[_14936 + idx + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_15100 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _15100 + -mem[64] + 100
                                                        if mem[(4 * ceil32(return_data.size)) + 1760] > !s:
                                                            revert with 0, 17
                                                        if mem[(4 * ceil32(return_data.size)) + 1760] + s < mem[(4 * ceil32(return_data.size)) + 1760]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if sub_f4a8f345 > !(mem[(4 * ceil32(return_data.size)) + 1760] + s):
                                                            revert with 0, 17
                                                        if sub_f4a8f345 + mem[(4 * ceil32(return_data.size)) + 1760] + s < sub_f4a8f345:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        sub_f4a8f345 = sub_f4a8f345 + mem[(4 * ceil32(return_data.size)) + 1760] + s
                                                    else:
                                                        _6552 = mem[(4 * ceil32(return_data.size)) + 1888]
                                                        _6579 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_6579] = 30
                                                        mem[_6579 + 32] = 'SafeMath: subtraction overflow'
                                                        if s > _6552:
                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                        if _6552 < s:
                                                            revert with 0, 17
                                                        _6870 = mem[(4 * ceil32(return_data.size)) + 1728]
                                                        staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                                                                gas gas_remaining wei
                                                               args msg.sender, Mask(128, 128, mem[(4 * ceil32(return_data.size)) + 1728])
                                                        mem[mem[64] len 352] = ext_call.return_data[0 len 352]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _6960 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 352
                                                        _7004 = mem[64]
                                                        if mem[64] + 352 < mem[64] or mem[64] + 352 > test266151307():
                                                            revert with 0, 65
                                                        mem[64] = mem[64] + 352
                                                        require mem[_6960] == Mask(128, 128, mem[_6960])
                                                        mem[_7004] = mem[_6960]
                                                        mem[_7004 + 32] = mem[_6960 + 32]
                                                        mem[_7004 + 64] = mem[_6960 + 64]
                                                        mem[_7004 + 96] = mem[_6960 + 96]
                                                        require mem[_6960 + 128] < 5
                                                        mem[_7004 + 128] = mem[_6960 + 128]
                                                        mem[_7004 + 160] = mem[_6960 + 160]
                                                        mem[_7004 + 192] = mem[_6960 + 192]
                                                        mem[_7004 + 224] = mem[_6960 + 224]
                                                        mem[_7004 + 256] = mem[_6960 + 256]
                                                        mem[_7004 + 288] = mem[_6960 + 288]
                                                        mem[_7004 + 320] = mem[_6960 + 320]
                                                        if Mask(128, 128, mem[_7004]) != Mask(128, 128, _6870):
                                                            revert with 0, 'Address does not contain stake with provided id'
                                                        idx = mem[_7004 + 192]
                                                        t = 0
                                                        while idx < sub_ed73481d + 1:
                                                            staticcall sub_413c05c6Address.0x8ce1d9e4 with:
                                                                    gas gas_remaining wei
                                                                   args idx
                                                            mem[mem[64] len 160] = ext_call.return_data[0 len 160]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _12611 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 160
                                                            _12705 = mem[64]
                                                            if mem[64] + 160 > test266151307() or mem[64] + 160 < mem[64]:
                                                                revert with 0, 65
                                                            mem[64] = mem[64] + 160
                                                            mem[_12705] = mem[_12611]
                                                            mem[_12705 + 32] = mem[_12611 + 32]
                                                            mem[_12705 + 64] = mem[_12611 + 64]
                                                            mem[_12705 + 96] = mem[_12611 + 96]
                                                            mem[_12705 + 128] = mem[_12611 + 128]
                                                            _13078 = mem[_12705 + 64]
                                                            _13079 = mem[_12705 + 32]
                                                            _13080 = mem[_7004 + 64]
                                                            _13081 = mem[_12705]
                                                            _13082 = mem[_12705 + 128]
                                                            _13083 = mem[_12705 + 96]
                                                            if mem[_12705 + 96] > !mem[_12705 + 128]:
                                                                revert with 0, 17
                                                            if mem[_12705 + 96] + mem[_12705 + 128] < mem[_12705 + 96]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            if not mem[_12705 + 96] + mem[_12705 + 128]:
                                                                _13557 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_13557] = 26
                                                                mem[_13557 + 32] = 'SafeMath: division by zero'
                                                                if not _13079:
                                                                    _13670 = mem[64]
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 26
                                                                    idx = 0
                                                                    while idx < 26:
                                                                        mem[idx + _13670 + 68] = mem[_13557 + idx + 32]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    mem[_13670 + 94] = 0
                                                                    revert with memory
                                                                      from mem[64]
                                                                       len _13670 + -mem[64] + 100
                                                                _13973 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_13973] = 26
                                                                mem[_13973 + 32] = 'SafeMath: division by zero'
                                                                if _13078:
                                                                    if t > !(0 / _13079 / _13078):
                                                                        revert with 0, 17
                                                                    if t + (0 / _13079 / _13078) < t:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    if idx == -1:
                                                                        revert with 0, 17
                                                                    idx = idx + 1
                                                                    t = t + (0 / _13079 / _13078)
                                                                    continue 
                                                                _14164 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _14164 + 68] = mem[_13973 + idx + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_14164 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _14164 + -mem[64] + 100
                                                            if mem[_12705 + 96] + mem[_12705 + 128] and mem[_12705] > -1 / mem[_12705 + 96] + mem[_12705 + 128]:
                                                                revert with 0, 17
                                                            if not mem[_12705 + 96] + mem[_12705 + 128]:
                                                                revert with 0, 18
                                                            if (mem[_12705 + 96] * mem[_12705]) + (mem[_12705 + 128] * mem[_12705]) / mem[_12705 + 96] + mem[_12705 + 128] != mem[_12705]:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            if not (mem[_12705 + 96] * mem[_12705]) + (mem[_12705 + 128] * mem[_12705]):
                                                                _13814 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_13814] = 26
                                                                mem[_13814 + 32] = 'SafeMath: division by zero'
                                                                if not _13079:
                                                                    _13972 = mem[64]
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 26
                                                                    idx = 0
                                                                    while idx < 26:
                                                                        mem[idx + _13972 + 68] = mem[_13814 + idx + 32]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    mem[_13972 + 94] = 0
                                                                    revert with memory
                                                                      from mem[64]
                                                                       len _13972 + -mem[64] + 100
                                                                _14462 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_14462] = 26
                                                                mem[_14462 + 32] = 'SafeMath: division by zero'
                                                                if _13078:
                                                                    if t > !(0 / _13079 / _13078):
                                                                        revert with 0, 17
                                                                    if t + (0 / _13079 / _13078) < t:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    if idx == -1:
                                                                        revert with 0, 17
                                                                    idx = idx + 1
                                                                    t = t + (0 / _13079 / _13078)
                                                                    continue 
                                                                _14654 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _14654 + 68] = mem[_14462 + idx + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_14654 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _14654 + -mem[64] + 100
                                                            if (mem[_12705 + 96] * mem[_12705]) + (mem[_12705 + 128] * mem[_12705]) and mem[_7004 + 64] > -1 / (mem[_12705 + 96] * mem[_12705]) + (mem[_12705 + 128] * mem[_12705]):
                                                                revert with 0, 17
                                                            if not (mem[_12705 + 96] * mem[_12705]) + (mem[_12705 + 128] * mem[_12705]):
                                                                revert with 0, 18
                                                            if (mem[_12705 + 96] * mem[_12705] * mem[_7004 + 64]) + (mem[_12705 + 128] * mem[_12705] * mem[_7004 + 64]) / (mem[_12705 + 96] * mem[_12705]) + (mem[_12705 + 128] * mem[_12705]) != mem[_7004 + 64]:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            _14333 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_14333] = 26
                                                            mem[_14333 + 32] = 'SafeMath: division by zero'
                                                            if not _13079:
                                                                _14461 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _14461 + 68] = mem[_14333 + idx + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_14461 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _14461 + -mem[64] + 100
                                                            _14939 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_14939] = 26
                                                            mem[_14939 + 32] = 'SafeMath: division by zero'
                                                            if _13078:
                                                                if t > !((_13083 * _13081 * _13080) + (_13082 * _13081 * _13080) / _13079 / _13078):
                                                                    revert with 0, 17
                                                                if t + ((_13083 * _13081 * _13080) + (_13082 * _13081 * _13080) / _13079 / _13078) < t:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                if idx == -1:
                                                                    revert with 0, 17
                                                                idx = idx + 1
                                                                t = t + ((_13083 * _13081 * _13080) + (_13082 * _13081 * _13080) / _13079 / _13078)
                                                                continue 
                                                            _15102 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _15102 + 68] = mem[_14939 + idx + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_15102 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _15102 + -mem[64] + 100
                                                        if _6552 - s > !t:
                                                            revert with 0, 17
                                                        if t < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if mem[(4 * ceil32(return_data.size)) + 1760] > !(_6552 - s + t):
                                                            revert with 0, 17
                                                        if mem[(4 * ceil32(return_data.size)) + 1760] + _6552 - s + t < mem[(4 * ceil32(return_data.size)) + 1760]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if sub_f4a8f345 > !(mem[(4 * ceil32(return_data.size)) + 1760] + _6552 - s + t):
                                                            revert with 0, 17
                                                        if sub_f4a8f345 + mem[(4 * ceil32(return_data.size)) + 1760] + _6552 - s + t < sub_f4a8f345:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        sub_f4a8f345 = sub_f4a8f345 + mem[(4 * ceil32(return_data.size)) + 1760] + _6552 - s + t
                                                else:
                                                    idx = mem[(6 * ceil32(return_data.size)) + 2272]
                                                    s = 0
                                                    while idx < ext_call.return_data[192] + ext_call.return_data[224]:
                                                        staticcall sub_413c05c6Address.0x8ce1d9e4 with:
                                                                gas gas_remaining wei
                                                               args idx
                                                        mem[mem[64] len 160] = ext_call.return_data[0 len 160]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _6516 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 160
                                                        _6583 = mem[64]
                                                        if mem[64] + 160 > test266151307() or mem[64] + 160 < mem[64]:
                                                            revert with 0, 65
                                                        mem[64] = mem[64] + 160
                                                        mem[_6583] = mem[_6516]
                                                        mem[_6583 + 32] = mem[_6516 + 32]
                                                        mem[_6583 + 64] = mem[_6516 + 64]
                                                        mem[_6583 + 96] = mem[_6516 + 96]
                                                        mem[_6583 + 128] = mem[_6516 + 128]
                                                        _6736 = mem[_6583 + 64]
                                                        _6737 = mem[_6583 + 32]
                                                        _6738 = mem[(6 * ceil32(return_data.size)) + 2144]
                                                        _6739 = mem[_6583]
                                                        _6740 = mem[_6583 + 128]
                                                        _6741 = mem[_6583 + 96]
                                                        if mem[_6583 + 96] > !mem[_6583 + 128]:
                                                            revert with 0, 17
                                                        if mem[_6583 + 96] + mem[_6583 + 128] < mem[_6583 + 96]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if not mem[_6583 + 96] + mem[_6583 + 128]:
                                                            _7083 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_7083] = 26
                                                            mem[_7083 + 32] = 'SafeMath: division by zero'
                                                            if not _6737:
                                                                _7150 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _7150 + 68] = mem[_7083 + idx + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_7150 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _7150 + -mem[64] + 100
                                                            _7444 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_7444] = 26
                                                            mem[_7444 + 32] = 'SafeMath: division by zero'
                                                            if _6736:
                                                                if s > !(0 / _6737 / _6736):
                                                                    revert with 0, 17
                                                                if s + (0 / _6737 / _6736) < s:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                if idx == -1:
                                                                    revert with 0, 17
                                                                idx = idx + 1
                                                                s = s + (0 / _6737 / _6736)
                                                                continue 
                                                            _7562 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _7562 + 68] = mem[_7444 + idx + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_7562 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _7562 + -mem[64] + 100
                                                        if mem[_6583 + 96] + mem[_6583 + 128] and mem[_6583] > -1 / mem[_6583 + 96] + mem[_6583 + 128]:
                                                            revert with 0, 17
                                                        if not mem[_6583 + 96] + mem[_6583 + 128]:
                                                            revert with 0, 18
                                                        if (mem[_6583 + 96] * mem[_6583]) + (mem[_6583 + 128] * mem[_6583]) / mem[_6583 + 96] + mem[_6583 + 128] != mem[_6583]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not (mem[_6583 + 96] * mem[_6583]) + (mem[_6583 + 128] * mem[_6583]):
                                                            _7281 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_7281] = 26
                                                            mem[_7281 + 32] = 'SafeMath: division by zero'
                                                            if not _6737:
                                                                _7443 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _7443 + 68] = mem[_7281 + idx + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_7443 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _7443 + -mem[64] + 100
                                                            _7759 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_7759] = 26
                                                            mem[_7759 + 32] = 'SafeMath: division by zero'
                                                            if _6736:
                                                                if s > !(0 / _6737 / _6736):
                                                                    revert with 0, 17
                                                                if s + (0 / _6737 / _6736) < s:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                if idx == -1:
                                                                    revert with 0, 17
                                                                idx = idx + 1
                                                                s = s + (0 / _6737 / _6736)
                                                                continue 
                                                            _7899 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _7899 + 68] = mem[_7759 + idx + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_7899 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _7899 + -mem[64] + 100
                                                        if (mem[_6583 + 96] * mem[_6583]) + (mem[_6583 + 128] * mem[_6583]) and mem[(6 * ceil32(return_data.size)) + 2144] > -1 / (mem[_6583 + 96] * mem[_6583]) + (mem[_6583 + 128] * mem[_6583]):
                                                            revert with 0, 17
                                                        if not (mem[_6583 + 96] * mem[_6583]) + (mem[_6583 + 128] * mem[_6583]):
                                                            revert with 0, 18
                                                        if (mem[_6583 + 96] * mem[_6583] * mem[(6 * ceil32(return_data.size)) + 2144]) + (mem[_6583 + 128] * mem[_6583] * mem[(6 * ceil32(return_data.size)) + 2144]) / (mem[_6583 + 96] * mem[_6583]) + (mem[_6583 + 128] * mem[_6583]) != mem[(6 * ceil32(return_data.size)) + 2144]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _7673 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_7673] = 26
                                                        mem[_7673 + 32] = 'SafeMath: division by zero'
                                                        if not _6737:
                                                            _7758 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _7758 + 68] = mem[_7673 + idx + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_7758 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _7758 + -mem[64] + 100
                                                        _8051 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_8051] = 26
                                                        mem[_8051 + 32] = 'SafeMath: division by zero'
                                                        if _6736:
                                                            if s > !((_6741 * _6739 * _6738) + (_6740 * _6739 * _6738) / _6737 / _6736):
                                                                revert with 0, 17
                                                            if s + ((_6741 * _6739 * _6738) + (_6740 * _6739 * _6738) / _6737 / _6736) < s:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            if idx == -1:
                                                                revert with 0, 17
                                                            idx = idx + 1
                                                            s = s + ((_6741 * _6739 * _6738) + (_6740 * _6739 * _6738) / _6737 / _6736)
                                                            continue 
                                                        _8130 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _8130 + 68] = mem[_8051 + idx + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_8130 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _8130 + -mem[64] + 100
                                                    if s >= mem[(4 * ceil32(return_data.size)) + 1888]:
                                                        _6553 = mem[(4 * ceil32(return_data.size)) + 1728]
                                                        staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                                                                gas gas_remaining wei
                                                               args msg.sender, Mask(128, 128, mem[(4 * ceil32(return_data.size)) + 1728])
                                                        mem[mem[64] len 352] = ext_call.return_data[0 len 352]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _6808 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 352
                                                        _6844 = mem[64]
                                                        if mem[64] + 352 < mem[64] or mem[64] + 352 > test266151307():
                                                            revert with 0, 65
                                                        mem[64] = mem[64] + 352
                                                        require mem[_6808] == Mask(128, 128, mem[_6808])
                                                        mem[_6844] = mem[_6808]
                                                        mem[_6844 + 32] = mem[_6808 + 32]
                                                        mem[_6844 + 64] = mem[_6808 + 64]
                                                        mem[_6844 + 96] = mem[_6808 + 96]
                                                        require mem[_6808 + 128] < 5
                                                        mem[_6844 + 128] = mem[_6808 + 128]
                                                        mem[_6844 + 160] = mem[_6808 + 160]
                                                        mem[_6844 + 192] = mem[_6808 + 192]
                                                        mem[_6844 + 224] = mem[_6808 + 224]
                                                        mem[_6844 + 256] = mem[_6808 + 256]
                                                        mem[_6844 + 288] = mem[_6808 + 288]
                                                        mem[_6844 + 320] = mem[_6808 + 320]
                                                        if Mask(128, 128, mem[_6844]) != Mask(128, 128, _6553):
                                                            revert with 0, 'Address does not contain stake with provided id'
                                                        idx = mem[_6844 + 192]
                                                        s = 0
                                                        while idx < ext_call.return_data[192] + ext_call.return_data[224]:
                                                            staticcall sub_413c05c6Address.0x8ce1d9e4 with:
                                                                    gas gas_remaining wei
                                                                   args idx
                                                            mem[mem[64] len 160] = ext_call.return_data[0 len 160]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _12613 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 160
                                                            _12713 = mem[64]
                                                            if mem[64] + 160 > test266151307() or mem[64] + 160 < mem[64]:
                                                                revert with 0, 65
                                                            mem[64] = mem[64] + 160
                                                            mem[_12713] = mem[_12613]
                                                            mem[_12713 + 32] = mem[_12613 + 32]
                                                            mem[_12713 + 64] = mem[_12613 + 64]
                                                            mem[_12713 + 96] = mem[_12613 + 96]
                                                            mem[_12713 + 128] = mem[_12613 + 128]
                                                            _13084 = mem[_12713 + 64]
                                                            _13085 = mem[_12713 + 32]
                                                            _13086 = mem[_6844 + 64]
                                                            _13087 = mem[_12713]
                                                            _13088 = mem[_12713 + 128]
                                                            _13089 = mem[_12713 + 96]
                                                            if mem[_12713 + 96] > !mem[_12713 + 128]:
                                                                revert with 0, 17
                                                            if mem[_12713 + 96] + mem[_12713 + 128] < mem[_12713 + 96]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            if not mem[_12713 + 96] + mem[_12713 + 128]:
                                                                _13559 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_13559] = 26
                                                                mem[_13559 + 32] = 'SafeMath: division by zero'
                                                                if not _13085:
                                                                    _13671 = mem[64]
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 26
                                                                    idx = 0
                                                                    while idx < 26:
                                                                        mem[idx + _13671 + 68] = mem[_13559 + idx + 32]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    mem[_13671 + 94] = 0
                                                                    revert with memory
                                                                      from mem[64]
                                                                       len _13671 + -mem[64] + 100
                                                                _13975 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_13975] = 26
                                                                mem[_13975 + 32] = 'SafeMath: division by zero'
                                                                if _13084:
                                                                    if s > !(0 / _13085 / _13084):
                                                                        revert with 0, 17
                                                                    if s + (0 / _13085 / _13084) < s:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    if idx == -1:
                                                                        revert with 0, 17
                                                                    idx = idx + 1
                                                                    s = s + (0 / _13085 / _13084)
                                                                    continue 
                                                                _14168 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _14168 + 68] = mem[_13975 + idx + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_14168 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _14168 + -mem[64] + 100
                                                            if mem[_12713 + 96] + mem[_12713 + 128] and mem[_12713] > -1 / mem[_12713 + 96] + mem[_12713 + 128]:
                                                                revert with 0, 17
                                                            if not mem[_12713 + 96] + mem[_12713 + 128]:
                                                                revert with 0, 18
                                                            if (mem[_12713 + 96] * mem[_12713]) + (mem[_12713 + 128] * mem[_12713]) / mem[_12713 + 96] + mem[_12713 + 128] != mem[_12713]:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            if not (mem[_12713 + 96] * mem[_12713]) + (mem[_12713 + 128] * mem[_12713]):
                                                                _13816 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_13816] = 26
                                                                mem[_13816 + 32] = 'SafeMath: division by zero'
                                                                if not _13085:
                                                                    _13974 = mem[64]
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 26
                                                                    idx = 0
                                                                    while idx < 26:
                                                                        mem[idx + _13974 + 68] = mem[_13816 + idx + 32]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    mem[_13974 + 94] = 0
                                                                    revert with memory
                                                                      from mem[64]
                                                                       len _13974 + -mem[64] + 100
                                                                _14465 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_14465] = 26
                                                                mem[_14465 + 32] = 'SafeMath: division by zero'
                                                                if _13084:
                                                                    if s > !(0 / _13085 / _13084):
                                                                        revert with 0, 17
                                                                    if s + (0 / _13085 / _13084) < s:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    if idx == -1:
                                                                        revert with 0, 17
                                                                    idx = idx + 1
                                                                    s = s + (0 / _13085 / _13084)
                                                                    continue 
                                                                _14657 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _14657 + 68] = mem[_14465 + idx + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_14657 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _14657 + -mem[64] + 100
                                                            if (mem[_12713 + 96] * mem[_12713]) + (mem[_12713 + 128] * mem[_12713]) and mem[_6844 + 64] > -1 / (mem[_12713 + 96] * mem[_12713]) + (mem[_12713 + 128] * mem[_12713]):
                                                                revert with 0, 17
                                                            if not (mem[_12713 + 96] * mem[_12713]) + (mem[_12713 + 128] * mem[_12713]):
                                                                revert with 0, 18
                                                            if (mem[_12713 + 96] * mem[_12713] * mem[_6844 + 64]) + (mem[_12713 + 128] * mem[_12713] * mem[_6844 + 64]) / (mem[_12713 + 96] * mem[_12713]) + (mem[_12713 + 128] * mem[_12713]) != mem[_6844 + 64]:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            _14336 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_14336] = 26
                                                            mem[_14336 + 32] = 'SafeMath: division by zero'
                                                            if not _13085:
                                                                _14464 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _14464 + 68] = mem[_14336 + idx + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_14464 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _14464 + -mem[64] + 100
                                                            _14942 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_14942] = 26
                                                            mem[_14942 + 32] = 'SafeMath: division by zero'
                                                            if _13084:
                                                                if s > !((_13089 * _13087 * _13086) + (_13088 * _13087 * _13086) / _13085 / _13084):
                                                                    revert with 0, 17
                                                                if s + ((_13089 * _13087 * _13086) + (_13088 * _13087 * _13086) / _13085 / _13084) < s:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                if idx == -1:
                                                                    revert with 0, 17
                                                                idx = idx + 1
                                                                s = s + ((_13089 * _13087 * _13086) + (_13088 * _13087 * _13086) / _13085 / _13084)
                                                                continue 
                                                            _15104 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _15104 + 68] = mem[_14942 + idx + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_15104 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _15104 + -mem[64] + 100
                                                        if mem[(4 * ceil32(return_data.size)) + 1760] > !s:
                                                            revert with 0, 17
                                                        if mem[(4 * ceil32(return_data.size)) + 1760] + s < mem[(4 * ceil32(return_data.size)) + 1760]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if sub_f4a8f345 > !(mem[(4 * ceil32(return_data.size)) + 1760] + s):
                                                            revert with 0, 17
                                                        if sub_f4a8f345 + mem[(4 * ceil32(return_data.size)) + 1760] + s < sub_f4a8f345:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        sub_f4a8f345 = sub_f4a8f345 + mem[(4 * ceil32(return_data.size)) + 1760] + s
                                                    else:
                                                        _6554 = mem[(4 * ceil32(return_data.size)) + 1888]
                                                        _6582 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_6582] = 30
                                                        mem[_6582 + 32] = 'SafeMath: subtraction overflow'
                                                        if s > _6554:
                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                        if _6554 < s:
                                                            revert with 0, 17
                                                        _6872 = mem[(4 * ceil32(return_data.size)) + 1728]
                                                        staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                                                                gas gas_remaining wei
                                                               args msg.sender, Mask(128, 128, mem[(4 * ceil32(return_data.size)) + 1728])
                                                        mem[mem[64] len 352] = ext_call.return_data[0 len 352]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _6961 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 352
                                                        _7006 = mem[64]
                                                        if mem[64] + 352 < mem[64] or mem[64] + 352 > test266151307():
                                                            revert with 0, 65
                                                        mem[64] = mem[64] + 352
                                                        require mem[_6961] == Mask(128, 128, mem[_6961])
                                                        mem[_7006] = mem[_6961]
                                                        mem[_7006 + 32] = mem[_6961 + 32]
                                                        mem[_7006 + 64] = mem[_6961 + 64]
                                                        mem[_7006 + 96] = mem[_6961 + 96]
                                                        require mem[_6961 + 128] < 5
                                                        mem[_7006 + 128] = mem[_6961 + 128]
                                                        mem[_7006 + 160] = mem[_6961 + 160]
                                                        mem[_7006 + 192] = mem[_6961 + 192]
                                                        mem[_7006 + 224] = mem[_6961 + 224]
                                                        mem[_7006 + 256] = mem[_6961 + 256]
                                                        mem[_7006 + 288] = mem[_6961 + 288]
                                                        mem[_7006 + 320] = mem[_6961 + 320]
                                                        if Mask(128, 128, mem[_7006]) != Mask(128, 128, _6872):
                                                            revert with 0, 'Address does not contain stake with provided id'
                                                        idx = mem[_7006 + 192]
                                                        t = 0
                                                        while idx < ext_call.return_data[192] + ext_call.return_data[224]:
                                                            staticcall sub_413c05c6Address.0x8ce1d9e4 with:
                                                                    gas gas_remaining wei
                                                                   args idx
                                                            mem[mem[64] len 160] = ext_call.return_data[0 len 160]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _12615 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 160
                                                            _12714 = mem[64]
                                                            if mem[64] + 160 > test266151307() or mem[64] + 160 < mem[64]:
                                                                revert with 0, 65
                                                            mem[64] = mem[64] + 160
                                                            mem[_12714] = mem[_12615]
                                                            mem[_12714 + 32] = mem[_12615 + 32]
                                                            mem[_12714 + 64] = mem[_12615 + 64]
                                                            mem[_12714 + 96] = mem[_12615 + 96]
                                                            mem[_12714 + 128] = mem[_12615 + 128]
                                                            _13090 = mem[_12714 + 64]
                                                            _13091 = mem[_12714 + 32]
                                                            _13092 = mem[_7006 + 64]
                                                            _13093 = mem[_12714]
                                                            _13094 = mem[_12714 + 128]
                                                            _13095 = mem[_12714 + 96]
                                                            if mem[_12714 + 96] > !mem[_12714 + 128]:
                                                                revert with 0, 17
                                                            if mem[_12714 + 96] + mem[_12714 + 128] < mem[_12714 + 96]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            if not mem[_12714 + 96] + mem[_12714 + 128]:
                                                                _13561 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_13561] = 26
                                                                mem[_13561 + 32] = 'SafeMath: division by zero'
                                                                if not _13091:
                                                                    _13673 = mem[64]
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 26
                                                                    idx = 0
                                                                    while idx < 26:
                                                                        mem[idx + _13673 + 68] = mem[_13561 + idx + 32]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    mem[_13673 + 94] = 0
                                                                    revert with memory
                                                                      from mem[64]
                                                                       len _13673 + -mem[64] + 100
                                                                _13977 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_13977] = 26
                                                                mem[_13977 + 32] = 'SafeMath: division by zero'
                                                                if _13090:
                                                                    if t > !(0 / _13091 / _13090):
                                                                        revert with 0, 17
                                                                    if t + (0 / _13091 / _13090) < t:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    if idx == -1:
                                                                        revert with 0, 17
                                                                    idx = idx + 1
                                                                    t = t + (0 / _13091 / _13090)
                                                                    continue 
                                                                _14172 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _14172 + 68] = mem[_13977 + idx + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_14172 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _14172 + -mem[64] + 100
                                                            if mem[_12714 + 96] + mem[_12714 + 128] and mem[_12714] > -1 / mem[_12714 + 96] + mem[_12714 + 128]:
                                                                revert with 0, 17
                                                            if not mem[_12714 + 96] + mem[_12714 + 128]:
                                                                revert with 0, 18
                                                            if (mem[_12714 + 96] * mem[_12714]) + (mem[_12714 + 128] * mem[_12714]) / mem[_12714 + 96] + mem[_12714 + 128] != mem[_12714]:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            if not (mem[_12714 + 96] * mem[_12714]) + (mem[_12714 + 128] * mem[_12714]):
                                                                _13818 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_13818] = 26
                                                                mem[_13818 + 32] = 'SafeMath: division by zero'
                                                                if not _13091:
                                                                    _13976 = mem[64]
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 26
                                                                    idx = 0
                                                                    while idx < 26:
                                                                        mem[idx + _13976 + 68] = mem[_13818 + idx + 32]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    mem[_13976 + 94] = 0
                                                                    revert with memory
                                                                      from mem[64]
                                                                       len _13976 + -mem[64] + 100
                                                                _14468 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_14468] = 26
                                                                mem[_14468 + 32] = 'SafeMath: division by zero'
                                                                if _13090:
                                                                    if t > !(0 / _13091 / _13090):
                                                                        revert with 0, 17
                                                                    if t + (0 / _13091 / _13090) < t:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    if idx == -1:
                                                                        revert with 0, 17
                                                                    idx = idx + 1
                                                                    t = t + (0 / _13091 / _13090)
                                                                    continue 
                                                                _14660 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _14660 + 68] = mem[_14468 + idx + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_14660 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _14660 + -mem[64] + 100
                                                            if (mem[_12714 + 96] * mem[_12714]) + (mem[_12714 + 128] * mem[_12714]) and mem[_7006 + 64] > -1 / (mem[_12714 + 96] * mem[_12714]) + (mem[_12714 + 128] * mem[_12714]):
                                                                revert with 0, 17
                                                            if not (mem[_12714 + 96] * mem[_12714]) + (mem[_12714 + 128] * mem[_12714]):
                                                                revert with 0, 18
                                                            if (mem[_12714 + 96] * mem[_12714] * mem[_7006 + 64]) + (mem[_12714 + 128] * mem[_12714] * mem[_7006 + 64]) / (mem[_12714 + 96] * mem[_12714]) + (mem[_12714 + 128] * mem[_12714]) != mem[_7006 + 64]:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            _14339 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_14339] = 26
                                                            mem[_14339 + 32] = 'SafeMath: division by zero'
                                                            if not _13091:
                                                                _14467 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _14467 + 68] = mem[_14339 + idx + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_14467 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _14467 + -mem[64] + 100
                                                            _14945 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_14945] = 26
                                                            mem[_14945 + 32] = 'SafeMath: division by zero'
                                                            if _13090:
                                                                if t > !((_13095 * _13093 * _13092) + (_13094 * _13093 * _13092) / _13091 / _13090):
                                                                    revert with 0, 17
                                                                if t + ((_13095 * _13093 * _13092) + (_13094 * _13093 * _13092) / _13091 / _13090) < t:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                if idx == -1:
                                                                    revert with 0, 17
                                                                idx = idx + 1
                                                                t = t + ((_13095 * _13093 * _13092) + (_13094 * _13093 * _13092) / _13091 / _13090)
                                                                continue 
                                                            _15106 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _15106 + 68] = mem[_14945 + idx + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_15106 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _15106 + -mem[64] + 100
                                                        if _6554 - s > !t:
                                                            revert with 0, 17
                                                        if t < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if mem[(4 * ceil32(return_data.size)) + 1760] > !(_6554 - s + t):
                                                            revert with 0, 17
                                                        if mem[(4 * ceil32(return_data.size)) + 1760] + _6554 - s + t < mem[(4 * ceil32(return_data.size)) + 1760]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if sub_f4a8f345 > !(mem[(4 * ceil32(return_data.size)) + 1760] + _6554 - s + t):
                                                            revert with 0, 17
                                                        if sub_f4a8f345 + mem[(4 * ceil32(return_data.size)) + 1760] + _6554 - s + t < sub_f4a8f345:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        sub_f4a8f345 = sub_f4a8f345 + mem[(4 * ceil32(return_data.size)) + 1760] + _6554 - s + t
    else:
        if unknown_0x04b4a313(?????) == uint32(call.func_hash) >> 224:
            require not msg.value
            return sub_04b4a313
        if uint32(call.func_hash) >> 224 != unknown_0x04e35cba(?????):
            if unknown_0x1b385a01(?????) == uint32(call.func_hash) >> 224:
                require not msg.value
                require calldata.size - 4 >= 32
                require arg1 == address(arg1)
                return sub_1b385a01[arg1]
            require unknown_0x226fc72a(?????) == uint32(call.func_hash) >> 224
            require not msg.value
            require calldata.size - 4 >= 32
            if TOKEN_DEFINERAddress != msg.sender:
                revert with 0, 'Wrong sender.'
            sub_ed73481d = arg1
        else:
            require not msg.value
            require calldata.size - 4 >= 64
            require arg1 == address(arg1)
            require arg2 == Mask(128, 128, arg2)
            if TOKEN_DEFINERAddress != msg.sender:
                revert with 0, 'Wrong sender.'
            if not uint8(stor1.field_160):
                revert with 0, 'Register is disabled'
            mem[128] = 0
            mem[160] = 0
            mem[192] = 0
            mem[224] = 0
            mem[256] = 0
            mem[288] = 0
            mem[320] = 0
            mem[352] = 0
            mem[384] = 0
            mem[416] = 0
            mem[448] = 0
            staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                    gas gas_remaining wei
                   args address(arg1), Mask(128, 128, arg2)
            mem[480 len 352] = ext_call.return_data[0 len 352]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 352
            if not bool(ceil32(return_data.size) + 832 <= test266151307()):
                revert with 0, 65
            require ext_call.return_data[0] == Mask(128, 128, ext_call.return_data[0])
            mem[ceil32(return_data.size) + 480] = ext_call.return_data[0]
            mem[ceil32(return_data.size) + 512] = ext_call.return_data[32]
            mem[ceil32(return_data.size) + 544] = ext_call.return_data[64]
            mem[ceil32(return_data.size) + 576] = ext_call.return_data[96]
            require ext_call.return_data[128] < 5
            mem[ceil32(return_data.size) + 608] = ext_call.return_data[128]
            mem[ceil32(return_data.size) + 640] = ext_call.return_data[160]
            mem[ceil32(return_data.size) + 672] = ext_call.return_data[192]
            mem[ceil32(return_data.size) + 704] = ext_call.return_data[224]
            mem[ceil32(return_data.size) + 736] = ext_call.return_data[256]
            mem[ceil32(return_data.size) + 768] = ext_call.return_data[288]
            mem[ceil32(return_data.size) + 800] = ext_call.return_data[320]
            if Mask(128, 128, ext_call.return_data[0]) != Mask(128, 128, arg2):
                revert with 0, 
                            32,
                            46,
                            0xfe53656e64657220646f6573206e6f7420636f6e7461696e207374616b6520776974682070726f76696465642069, mem[ceil32(return_data.size) + 910 len 18] >> 112,
                            0
            if stor9[address(arg1)][Mask(128, 128, arg2)]:
                revert with 0, 'Stake has already been converted'
            if ext_call.return_data[128] > 4:
                revert with 0, 33
            if ext_call.return_data[128] != 2:
                revert with 0, 
                            32,
                            44,
                            0x795374616b65206973206f6e6c7920656c696769626c6520696620697420686173206265656e20636c6f7365, mem[ceil32(return_data.size) + 908 len 20] >> 96,
                            0
            if ext_call.return_data[192] >= sub_be647a94:
                revert with 0, 
                            32,
                            65,
                            0x645374616b65206973206f6e6c7920656c696769626c65206966206974207761732063726561746564207072696f7220746f2074686520637574206f6666206461, mem[ceil32(return_data.size) + 929 len 31] >> 264,
                            0
            if ext_call.return_data[192] > !ext_call.return_data[224]:
                revert with 0, 17
            if ext_call.return_data[192] + ext_call.return_data[224] < sub_be647a94:
                revert with 0, 
                            32,
                            66,
                            0x645374616b65206973206f6e6c7920656c696769626c652069662069742077617320656e646564206f6e2074686520637574206f666620646179206f722061667465, mem[ceil32(return_data.size) + 930 len 30] >> 272,
                            0
            mem[ceil32(return_data.size) + 832] = 17
            mem[ceil32(return_data.size) + 864] = 'Stake is eligible' << 120
            if stor8[address(arg1)][Mask(128, 128, arg2)]:
                revert with 0, 'Stake has already been registered'
            stor8[address(arg1)][Mask(128, 128, arg2)] = 1
            mem[ceil32(return_data.size) + 896] = address(arg1)
            mem[ceil32(return_data.size) + 928] = Mask(128, 128, arg2)
            sub_4c86259e[stor10].field_0 = address(arg1)
            sub_4c86259e[stor10].field_256 = 0
            sub_4c86259e[stor10].field_512 = 0
            if sub_d3a8b1da == -1:
                revert with 0, 17
            sub_d3a8b1da++
            if 1 > !sub_2c8bff0e[address(arg1)]:
                revert with 0, 17
            sub_2c8bff0e[address(arg1)]++
            if 1 > !sub_ed73481d:
                revert with 0, 17
            mem[ceil32(return_data.size) + 960] = 0
            mem[ceil32(return_data.size) + 992] = 0
            mem[ceil32(return_data.size) + 1024] = 0
            mem[ceil32(return_data.size) + 1056] = 0
            mem[ceil32(return_data.size) + 1088] = 0
            mem[ceil32(return_data.size) + 1120] = 0
            mem[ceil32(return_data.size) + 1152] = 0
            mem[ceil32(return_data.size) + 1184] = 0
            mem[ceil32(return_data.size) + 1216] = 0
            mem[ceil32(return_data.size) + 1248] = 0
            mem[ceil32(return_data.size) + 1280] = 0
            staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                    gas gas_remaining wei
                   args address(arg1), Mask(128, 128, arg2)
            mem[ceil32(return_data.size) + 1312 len 352] = ext_call.return_data[0 len 352]
            if not ext_call.success:
                revert with ext_call.return_data[0 len return_data.size]
            require return_data.size >= 352
            if not bool((2 * ceil32(return_data.size)) + 1664 <= test266151307()):
                revert with 0, 65
            require ext_call.return_data[0] == Mask(128, 128, ext_call.return_data[0])
            mem[(2 * ceil32(return_data.size)) + 1312] = ext_call.return_data[0]
            mem[(2 * ceil32(return_data.size)) + 1344] = ext_call.return_data[32]
            mem[(2 * ceil32(return_data.size)) + 1376] = ext_call.return_data[64]
            mem[(2 * ceil32(return_data.size)) + 1408] = ext_call.return_data[96]
            require ext_call.return_data[128] < 5
            mem[(2 * ceil32(return_data.size)) + 1440] = ext_call.return_data[128]
            mem[(2 * ceil32(return_data.size)) + 1472] = ext_call.return_data[160]
            mem[(2 * ceil32(return_data.size)) + 1504] = ext_call.return_data[192]
            mem[(2 * ceil32(return_data.size)) + 1536] = ext_call.return_data[224]
            mem[(2 * ceil32(return_data.size)) + 1568] = ext_call.return_data[256]
            mem[(2 * ceil32(return_data.size)) + 1600] = ext_call.return_data[288]
            mem[(2 * ceil32(return_data.size)) + 1632] = ext_call.return_data[320]
            if Mask(128, 128, ext_call.return_data[0]) != Mask(128, 128, arg2):
                if sub_f4a8f345 > -1:
                    revert with 0, 17
                if sub_f4a8f345 < sub_f4a8f345:
                    revert with 0, 'SafeMath: addition overflow'
            else:
                mem[0] = Mask(128, 128, arg2)
                mem[32] = sha3(address(arg1), 9)
                if stor9[address(arg1)][Mask(128, 128, arg2)]:
                    if sub_f4a8f345 > -1:
                        revert with 0, 17
                    if sub_f4a8f345 < sub_f4a8f345:
                        revert with 0, 'SafeMath: addition overflow'
                else:
                    if ext_call.return_data[128] > 4:
                        revert with 0, 33
                    if ext_call.return_data[128] != 2:
                        if sub_f4a8f345 > -1:
                            revert with 0, 17
                        if sub_f4a8f345 < sub_f4a8f345:
                            revert with 0, 'SafeMath: addition overflow'
                    else:
                        if ext_call.return_data[192] >= sub_be647a94:
                            if sub_f4a8f345 > -1:
                                revert with 0, 17
                            if sub_f4a8f345 < sub_f4a8f345:
                                revert with 0, 'SafeMath: addition overflow'
                        else:
                            if ext_call.return_data[192] > !ext_call.return_data[224]:
                                revert with 0, 17
                            if ext_call.return_data[192] + ext_call.return_data[224] < sub_be647a94:
                                if sub_f4a8f345 > -1:
                                    revert with 0, 17
                                if sub_f4a8f345 < sub_f4a8f345:
                                    revert with 0, 'SafeMath: addition overflow'
                            else:
                                mem[(2 * ceil32(return_data.size)) + 1664] = 17
                                mem[(2 * ceil32(return_data.size)) + 1696] = 'Stake is eligible' << 120
                                staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                                        gas gas_remaining wei
                                       args address(arg1), Mask(128, 128, arg2)
                                mem[(2 * ceil32(return_data.size)) + 1728 len 352] = ext_call.return_data[0 len 352]
                                if not ext_call.success:
                                    revert with ext_call.return_data[0 len return_data.size]
                                require return_data.size >= 352
                                if not bool((4 * ceil32(return_data.size)) + 2080 <= test266151307()):
                                    revert with 0, 65
                                require ext_call.return_data[0] == Mask(128, 128, ext_call.return_data[0])
                                mem[(4 * ceil32(return_data.size)) + 1728] = ext_call.return_data[0]
                                mem[(4 * ceil32(return_data.size)) + 1760] = ext_call.return_data[32]
                                mem[(4 * ceil32(return_data.size)) + 1792] = ext_call.return_data[64]
                                mem[(4 * ceil32(return_data.size)) + 1824] = ext_call.return_data[96]
                                require ext_call.return_data[128] < 5
                                mem[(4 * ceil32(return_data.size)) + 1856] = ext_call.return_data[128]
                                mem[(4 * ceil32(return_data.size)) + 1888] = ext_call.return_data[160]
                                mem[(4 * ceil32(return_data.size)) + 1920] = ext_call.return_data[192]
                                mem[(4 * ceil32(return_data.size)) + 1952] = ext_call.return_data[224]
                                mem[(4 * ceil32(return_data.size)) + 1984] = ext_call.return_data[256]
                                mem[(4 * ceil32(return_data.size)) + 2016] = ext_call.return_data[288]
                                mem[(4 * ceil32(return_data.size)) + 2048] = ext_call.return_data[320]
                                if Mask(128, 128, ext_call.return_data[0]) != Mask(128, 128, arg2):
                                    revert with 0, 'Address does not contain stake with provided id'
                                if ext_call.return_data[128] > 4:
                                    revert with 0, 33
                                if ext_call.return_data[128] == 3:
                                    if sub_f4a8f345 > -1:
                                        revert with 0, 17
                                    if sub_f4a8f345 < sub_f4a8f345:
                                        revert with 0, 'SafeMath: addition overflow'
                                else:
                                    if ext_call.return_data[128] > 4:
                                        revert with 0, 33
                                    if ext_call.return_data[128] == 4:
                                        if sub_f4a8f345 > -1:
                                            revert with 0, 17
                                        if sub_f4a8f345 < sub_f4a8f345:
                                            revert with 0, 'SafeMath: addition overflow'
                                    else:
                                        if ext_call.return_data[128] > 4:
                                            revert with 0, 33
                                        if ext_call.return_data[128] == 1:
                                            if sub_f4a8f345 > -1:
                                                revert with 0, 17
                                            if sub_f4a8f345 < sub_f4a8f345:
                                                revert with 0, 'SafeMath: addition overflow'
                                        else:
                                            if ext_call.return_data[128] > 4:
                                                revert with 0, 33
                                            if not ext_call.return_data[128]:
                                                staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                                                        gas gas_remaining wei
                                                       args address(arg1), Mask(128, 128, ext_call.return_data[0])
                                                mem[(4 * ceil32(return_data.size)) + 2080 len 352] = ext_call.return_data[0 len 352]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 352
                                                if not bool((6 * ceil32(return_data.size)) + 2432 <= test266151307()):
                                                    revert with 0, 65
                                                mem[64] = (6 * ceil32(return_data.size)) + 2432
                                                require ext_call.return_data[0] == Mask(128, 128, ext_call.return_data[0])
                                                mem[(6 * ceil32(return_data.size)) + 2080] = ext_call.return_data[0]
                                                mem[(6 * ceil32(return_data.size)) + 2112] = ext_call.return_data[32]
                                                mem[(6 * ceil32(return_data.size)) + 2144] = ext_call.return_data[64]
                                                mem[(6 * ceil32(return_data.size)) + 2176] = ext_call.return_data[96]
                                                require ext_call.return_data[128] < 5
                                                mem[(6 * ceil32(return_data.size)) + 2208] = ext_call.return_data[128]
                                                mem[(6 * ceil32(return_data.size)) + 2240] = ext_call.return_data[160]
                                                mem[(6 * ceil32(return_data.size)) + 2272] = ext_call.return_data[192]
                                                mem[(6 * ceil32(return_data.size)) + 2304] = ext_call.return_data[224]
                                                mem[(6 * ceil32(return_data.size)) + 2336] = ext_call.return_data[256]
                                                mem[(6 * ceil32(return_data.size)) + 2368] = ext_call.return_data[288]
                                                mem[(6 * ceil32(return_data.size)) + 2400] = ext_call.return_data[320]
                                                if Mask(128, 128, ext_call.return_data[0]) != Mask(128, 128, ext_call.return_data[0]):
                                                    revert with 0, 'Address does not contain stake with provided id'
                                                idx = mem[(6 * ceil32(return_data.size)) + 2272]
                                                s = 0
                                                while idx < sub_ed73481d + 1:
                                                    staticcall sub_413c05c6Address.0x8ce1d9e4 with:
                                                            gas gas_remaining wei
                                                           args idx
                                                    mem[mem[64] len 160] = ext_call.return_data[0 len 160]
                                                    if not ext_call.success:
                                                        revert with ext_call.return_data[0 len return_data.size]
                                                    _6512 = mem[64]
                                                    mem[64] = mem[64] + ceil32(return_data.size)
                                                    require return_data.size >= 160
                                                    _6572 = mem[64]
                                                    if mem[64] + 160 > test266151307() or mem[64] + 160 < mem[64]:
                                                        revert with 0, 65
                                                    mem[64] = mem[64] + 160
                                                    mem[_6572] = mem[_6512]
                                                    mem[_6572 + 32] = mem[_6512 + 32]
                                                    mem[_6572 + 64] = mem[_6512 + 64]
                                                    mem[_6572 + 96] = mem[_6512 + 96]
                                                    mem[_6572 + 128] = mem[_6512 + 128]
                                                    _6720 = mem[_6572 + 64]
                                                    _6721 = mem[_6572 + 32]
                                                    _6722 = mem[(6 * ceil32(return_data.size)) + 2144]
                                                    _6723 = mem[_6572]
                                                    _6724 = mem[_6572 + 128]
                                                    _6725 = mem[_6572 + 96]
                                                    if mem[_6572 + 96] > !mem[_6572 + 128]:
                                                        revert with 0, 17
                                                    if mem[_6572 + 96] + mem[_6572 + 128] < mem[_6572 + 96]:
                                                        revert with 0, 'SafeMath: addition overflow'
                                                    if not mem[_6572 + 96] + mem[_6572 + 128]:
                                                        _7075 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_7075] = 26
                                                        mem[_7075 + 32] = 'SafeMath: division by zero'
                                                        if not _6721:
                                                            _7148 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _7148 + 68] = mem[_7075 + idx + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_7148 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _7148 + -mem[64] + 100
                                                        _7426 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_7426] = 26
                                                        mem[_7426 + 32] = 'SafeMath: division by zero'
                                                        if _6720:
                                                            if s > !(0 / _6721 / _6720):
                                                                revert with 0, 17
                                                            if s + (0 / _6721 / _6720) < s:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            if idx == -1:
                                                                revert with 0, 17
                                                            idx = idx + 1
                                                            s = s + (0 / _6721 / _6720)
                                                            continue 
                                                        _7554 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _7554 + 68] = mem[_7426 + idx + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_7554 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _7554 + -mem[64] + 100
                                                    if mem[_6572 + 96] + mem[_6572 + 128] and mem[_6572] > -1 / mem[_6572 + 96] + mem[_6572 + 128]:
                                                        revert with 0, 17
                                                    if not mem[_6572 + 96] + mem[_6572 + 128]:
                                                        revert with 0, 18
                                                    if (mem[_6572 + 96] * mem[_6572]) + (mem[_6572 + 128] * mem[_6572]) / mem[_6572 + 96] + mem[_6572 + 128] != mem[_6572]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    if not (mem[_6572 + 96] * mem[_6572]) + (mem[_6572 + 128] * mem[_6572]):
                                                        _7275 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_7275] = 26
                                                        mem[_7275 + 32] = 'SafeMath: division by zero'
                                                        if not _6721:
                                                            _7425 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _7425 + 68] = mem[_7275 + idx + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_7425 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _7425 + -mem[64] + 100
                                                        _7747 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_7747] = 26
                                                        mem[_7747 + 32] = 'SafeMath: division by zero'
                                                        if _6720:
                                                            if s > !(0 / _6721 / _6720):
                                                                revert with 0, 17
                                                            if s + (0 / _6721 / _6720) < s:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            if idx == -1:
                                                                revert with 0, 17
                                                            idx = idx + 1
                                                            s = s + (0 / _6721 / _6720)
                                                            continue 
                                                        _7881 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _7881 + 68] = mem[_7747 + idx + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_7881 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _7881 + -mem[64] + 100
                                                    if (mem[_6572 + 96] * mem[_6572]) + (mem[_6572 + 128] * mem[_6572]) and mem[(6 * ceil32(return_data.size)) + 2144] > -1 / (mem[_6572 + 96] * mem[_6572]) + (mem[_6572 + 128] * mem[_6572]):
                                                        revert with 0, 17
                                                    if not (mem[_6572 + 96] * mem[_6572]) + (mem[_6572 + 128] * mem[_6572]):
                                                        revert with 0, 18
                                                    if (mem[_6572 + 96] * mem[_6572] * mem[(6 * ceil32(return_data.size)) + 2144]) + (mem[_6572 + 128] * mem[_6572] * mem[(6 * ceil32(return_data.size)) + 2144]) / (mem[_6572 + 96] * mem[_6572]) + (mem[_6572 + 128] * mem[_6572]) != mem[(6 * ceil32(return_data.size)) + 2144]:
                                                        revert with 0, 'SafeMath: multiplication overflow'
                                                    _7663 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_7663] = 26
                                                    mem[_7663 + 32] = 'SafeMath: division by zero'
                                                    if not _6721:
                                                        _7746 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _7746 + 68] = mem[_7663 + idx + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_7746 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _7746 + -mem[64] + 100
                                                    _8043 = mem[64]
                                                    mem[64] = mem[64] + 64
                                                    mem[_8043] = 26
                                                    mem[_8043 + 32] = 'SafeMath: division by zero'
                                                    if _6720:
                                                        if s > !((_6725 * _6723 * _6722) + (_6724 * _6723 * _6722) / _6721 / _6720):
                                                            revert with 0, 17
                                                        if s + ((_6725 * _6723 * _6722) + (_6724 * _6723 * _6722) / _6721 / _6720) < s:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if idx == -1:
                                                            revert with 0, 17
                                                        idx = idx + 1
                                                        s = s + ((_6725 * _6723 * _6722) + (_6724 * _6723 * _6722) / _6721 / _6720)
                                                        continue 
                                                    _8124 = mem[64]
                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                    mem[mem[64] + 4] = 32
                                                    mem[mem[64] + 36] = 26
                                                    idx = 0
                                                    while idx < 26:
                                                        mem[idx + _8124 + 68] = mem[_8043 + idx + 32]
                                                        idx = idx + 32
                                                        continue 
                                                    mem[_8124 + 94] = 0
                                                    revert with memory
                                                      from mem[64]
                                                       len _8124 + -mem[64] + 100
                                                if mem[(4 * ceil32(return_data.size)) + 1888] > !s:
                                                    revert with 0, 17
                                                if mem[(4 * ceil32(return_data.size)) + 1888] + s < mem[(4 * ceil32(return_data.size)) + 1888]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if mem[(4 * ceil32(return_data.size)) + 1760] > !(mem[(4 * ceil32(return_data.size)) + 1888] + s):
                                                    revert with 0, 17
                                                if mem[(4 * ceil32(return_data.size)) + 1760] + mem[(4 * ceil32(return_data.size)) + 1888] + s < mem[(4 * ceil32(return_data.size)) + 1760]:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                if sub_f4a8f345 > !(mem[(4 * ceil32(return_data.size)) + 1760] + mem[(4 * ceil32(return_data.size)) + 1888] + s):
                                                    revert with 0, 17
                                                if sub_f4a8f345 + mem[(4 * ceil32(return_data.size)) + 1760] + mem[(4 * ceil32(return_data.size)) + 1888] + s < sub_f4a8f345:
                                                    revert with 0, 'SafeMath: addition overflow'
                                                sub_f4a8f345 = sub_f4a8f345 + mem[(4 * ceil32(return_data.size)) + 1760] + mem[(4 * ceil32(return_data.size)) + 1888] + s
                                            else:
                                                if ext_call.return_data[192] > !ext_call.return_data[224]:
                                                    revert with 0, 17
                                                staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                                                        gas gas_remaining wei
                                                       args address(arg1), Mask(128, 128, ext_call.return_data[0])
                                                mem[(4 * ceil32(return_data.size)) + 2080 len 352] = ext_call.return_data[0 len 352]
                                                if not ext_call.success:
                                                    revert with ext_call.return_data[0 len return_data.size]
                                                require return_data.size >= 352
                                                if not bool((6 * ceil32(return_data.size)) + 2432 <= test266151307()):
                                                    revert with 0, 65
                                                mem[64] = (6 * ceil32(return_data.size)) + 2432
                                                require ext_call.return_data[0] == Mask(128, 128, ext_call.return_data[0])
                                                mem[(6 * ceil32(return_data.size)) + 2080] = ext_call.return_data[0]
                                                mem[(6 * ceil32(return_data.size)) + 2112] = ext_call.return_data[32]
                                                mem[(6 * ceil32(return_data.size)) + 2144] = ext_call.return_data[64]
                                                mem[(6 * ceil32(return_data.size)) + 2176] = ext_call.return_data[96]
                                                require ext_call.return_data[128] < 5
                                                mem[(6 * ceil32(return_data.size)) + 2208] = ext_call.return_data[128]
                                                mem[(6 * ceil32(return_data.size)) + 2240] = ext_call.return_data[160]
                                                mem[(6 * ceil32(return_data.size)) + 2272] = ext_call.return_data[192]
                                                mem[(6 * ceil32(return_data.size)) + 2304] = ext_call.return_data[224]
                                                mem[(6 * ceil32(return_data.size)) + 2336] = ext_call.return_data[256]
                                                mem[(6 * ceil32(return_data.size)) + 2368] = ext_call.return_data[288]
                                                mem[(6 * ceil32(return_data.size)) + 2400] = ext_call.return_data[320]
                                                if Mask(128, 128, ext_call.return_data[0]) != Mask(128, 128, ext_call.return_data[0]):
                                                    revert with 0, 'Address does not contain stake with provided id'
                                                if sub_ed73481d + 1 < ext_call.return_data[192] + ext_call.return_data[224]:
                                                    idx = mem[(6 * ceil32(return_data.size)) + 2272]
                                                    s = 0
                                                    while idx < ext_call.return_data[192] + ext_call.return_data[224]:
                                                        staticcall sub_413c05c6Address.0x8ce1d9e4 with:
                                                                gas gas_remaining wei
                                                               args idx
                                                        mem[mem[64] len 160] = ext_call.return_data[0 len 160]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _6507 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 160
                                                        _6568 = mem[64]
                                                        if mem[64] + 160 > test266151307() or mem[64] + 160 < mem[64]:
                                                            revert with 0, 65
                                                        mem[64] = mem[64] + 160
                                                        mem[_6568] = mem[_6507]
                                                        mem[_6568 + 32] = mem[_6507 + 32]
                                                        mem[_6568 + 64] = mem[_6507 + 64]
                                                        mem[_6568 + 96] = mem[_6507 + 96]
                                                        mem[_6568 + 128] = mem[_6507 + 128]
                                                        _6706 = mem[_6568 + 64]
                                                        _6707 = mem[_6568 + 32]
                                                        _6708 = mem[(6 * ceil32(return_data.size)) + 2144]
                                                        _6709 = mem[_6568]
                                                        _6710 = mem[_6568 + 128]
                                                        _6711 = mem[_6568 + 96]
                                                        if mem[_6568 + 96] > !mem[_6568 + 128]:
                                                            revert with 0, 17
                                                        if mem[_6568 + 96] + mem[_6568 + 128] < mem[_6568 + 96]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if not mem[_6568 + 96] + mem[_6568 + 128]:
                                                            _7069 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_7069] = 26
                                                            mem[_7069 + 32] = 'SafeMath: division by zero'
                                                            if not _6707:
                                                                _7145 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _7145 + 68] = mem[_7069 + idx + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_7145 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _7145 + -mem[64] + 100
                                                            _7415 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_7415] = 26
                                                            mem[_7415 + 32] = 'SafeMath: division by zero'
                                                            if _6706:
                                                                if s > !(0 / _6707 / _6706):
                                                                    revert with 0, 17
                                                                if s + (0 / _6707 / _6706) < s:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                if idx == -1:
                                                                    revert with 0, 17
                                                                idx = idx + 1
                                                                s = s + (0 / _6707 / _6706)
                                                                continue 
                                                            _7546 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _7546 + 68] = mem[_7415 + idx + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_7546 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _7546 + -mem[64] + 100
                                                        if mem[_6568 + 96] + mem[_6568 + 128] and mem[_6568] > -1 / mem[_6568 + 96] + mem[_6568 + 128]:
                                                            revert with 0, 17
                                                        if not mem[_6568 + 96] + mem[_6568 + 128]:
                                                            revert with 0, 18
                                                        if (mem[_6568 + 96] * mem[_6568]) + (mem[_6568 + 128] * mem[_6568]) / mem[_6568 + 96] + mem[_6568 + 128] != mem[_6568]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not (mem[_6568 + 96] * mem[_6568]) + (mem[_6568 + 128] * mem[_6568]):
                                                            _7270 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_7270] = 26
                                                            mem[_7270 + 32] = 'SafeMath: division by zero'
                                                            if not _6707:
                                                                _7414 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _7414 + 68] = mem[_7270 + idx + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_7414 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _7414 + -mem[64] + 100
                                                            _7738 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_7738] = 26
                                                            mem[_7738 + 32] = 'SafeMath: division by zero'
                                                            if _6706:
                                                                if s > !(0 / _6707 / _6706):
                                                                    revert with 0, 17
                                                                if s + (0 / _6707 / _6706) < s:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                if idx == -1:
                                                                    revert with 0, 17
                                                                idx = idx + 1
                                                                s = s + (0 / _6707 / _6706)
                                                                continue 
                                                            _7869 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _7869 + 68] = mem[_7738 + idx + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_7869 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _7869 + -mem[64] + 100
                                                        if (mem[_6568 + 96] * mem[_6568]) + (mem[_6568 + 128] * mem[_6568]) and mem[(6 * ceil32(return_data.size)) + 2144] > -1 / (mem[_6568 + 96] * mem[_6568]) + (mem[_6568 + 128] * mem[_6568]):
                                                            revert with 0, 17
                                                        if not (mem[_6568 + 96] * mem[_6568]) + (mem[_6568 + 128] * mem[_6568]):
                                                            revert with 0, 18
                                                        if (mem[_6568 + 96] * mem[_6568] * mem[(6 * ceil32(return_data.size)) + 2144]) + (mem[_6568 + 128] * mem[_6568] * mem[(6 * ceil32(return_data.size)) + 2144]) / (mem[_6568 + 96] * mem[_6568]) + (mem[_6568 + 128] * mem[_6568]) != mem[(6 * ceil32(return_data.size)) + 2144]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _7655 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_7655] = 26
                                                        mem[_7655 + 32] = 'SafeMath: division by zero'
                                                        if not _6707:
                                                            _7737 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _7737 + 68] = mem[_7655 + idx + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_7737 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _7737 + -mem[64] + 100
                                                        _8036 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_8036] = 26
                                                        mem[_8036 + 32] = 'SafeMath: division by zero'
                                                        if _6706:
                                                            if s > !((_6711 * _6709 * _6708) + (_6710 * _6709 * _6708) / _6707 / _6706):
                                                                revert with 0, 17
                                                            if s + ((_6711 * _6709 * _6708) + (_6710 * _6709 * _6708) / _6707 / _6706) < s:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            if idx == -1:
                                                                revert with 0, 17
                                                            idx = idx + 1
                                                            s = s + ((_6711 * _6709 * _6708) + (_6710 * _6709 * _6708) / _6707 / _6706)
                                                            continue 
                                                        _8119 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _8119 + 68] = mem[_8036 + idx + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_8119 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _8119 + -mem[64] + 100
                                                    if s >= mem[(4 * ceil32(return_data.size)) + 1888]:
                                                        _6547 = mem[(4 * ceil32(return_data.size)) + 1728]
                                                        staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                                                                gas gas_remaining wei
                                                               args address(arg1), Mask(128, 128, mem[(4 * ceil32(return_data.size)) + 1728])
                                                        mem[mem[64] len 352] = ext_call.return_data[0 len 352]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _6804 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 352
                                                        _6838 = mem[64]
                                                        if mem[64] + 352 < mem[64] or mem[64] + 352 > test266151307():
                                                            revert with 0, 65
                                                        mem[64] = mem[64] + 352
                                                        require mem[_6804] == Mask(128, 128, mem[_6804])
                                                        mem[_6838] = mem[_6804]
                                                        mem[_6838 + 32] = mem[_6804 + 32]
                                                        mem[_6838 + 64] = mem[_6804 + 64]
                                                        mem[_6838 + 96] = mem[_6804 + 96]
                                                        require mem[_6804 + 128] < 5
                                                        mem[_6838 + 128] = mem[_6804 + 128]
                                                        mem[_6838 + 160] = mem[_6804 + 160]
                                                        mem[_6838 + 192] = mem[_6804 + 192]
                                                        mem[_6838 + 224] = mem[_6804 + 224]
                                                        mem[_6838 + 256] = mem[_6804 + 256]
                                                        mem[_6838 + 288] = mem[_6804 + 288]
                                                        mem[_6838 + 320] = mem[_6804 + 320]
                                                        if Mask(128, 128, mem[_6838]) != Mask(128, 128, _6547):
                                                            revert with 0, 'Address does not contain stake with provided id'
                                                        idx = mem[_6838 + 192]
                                                        s = 0
                                                        while idx < sub_ed73481d + 1:
                                                            staticcall sub_413c05c6Address.0x8ce1d9e4 with:
                                                                    gas gas_remaining wei
                                                                   args idx
                                                            mem[mem[64] len 160] = ext_call.return_data[0 len 160]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _12601 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 160
                                                            _12680 = mem[64]
                                                            if mem[64] + 160 > test266151307() or mem[64] + 160 < mem[64]:
                                                                revert with 0, 65
                                                            mem[64] = mem[64] + 160
                                                            mem[_12680] = mem[_12601]
                                                            mem[_12680 + 32] = mem[_12601 + 32]
                                                            mem[_12680 + 64] = mem[_12601 + 64]
                                                            mem[_12680 + 96] = mem[_12601 + 96]
                                                            mem[_12680 + 128] = mem[_12601 + 128]
                                                            _13048 = mem[_12680 + 64]
                                                            _13049 = mem[_12680 + 32]
                                                            _13050 = mem[_6838 + 64]
                                                            _13051 = mem[_12680]
                                                            _13052 = mem[_12680 + 128]
                                                            _13053 = mem[_12680 + 96]
                                                            if mem[_12680 + 96] > !mem[_12680 + 128]:
                                                                revert with 0, 17
                                                            if mem[_12680 + 96] + mem[_12680 + 128] < mem[_12680 + 96]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            if not mem[_12680 + 96] + mem[_12680 + 128]:
                                                                _13547 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_13547] = 26
                                                                mem[_13547 + 32] = 'SafeMath: division by zero'
                                                                if not _13049:
                                                                    _13662 = mem[64]
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 26
                                                                    idx = 0
                                                                    while idx < 26:
                                                                        mem[idx + _13662 + 68] = mem[_13547 + idx + 32]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    mem[_13662 + 94] = 0
                                                                    revert with memory
                                                                      from mem[64]
                                                                       len _13662 + -mem[64] + 100
                                                                _13963 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_13963] = 26
                                                                mem[_13963 + 32] = 'SafeMath: division by zero'
                                                                if _13048:
                                                                    if s > !(0 / _13049 / _13048):
                                                                        revert with 0, 17
                                                                    if s + (0 / _13049 / _13048) < s:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    if idx == -1:
                                                                        revert with 0, 17
                                                                    idx = idx + 1
                                                                    s = s + (0 / _13049 / _13048)
                                                                    continue 
                                                                _14144 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _14144 + 68] = mem[_13963 + idx + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_14144 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _14144 + -mem[64] + 100
                                                            if mem[_12680 + 96] + mem[_12680 + 128] and mem[_12680] > -1 / mem[_12680 + 96] + mem[_12680 + 128]:
                                                                revert with 0, 17
                                                            if not mem[_12680 + 96] + mem[_12680 + 128]:
                                                                revert with 0, 18
                                                            if (mem[_12680 + 96] * mem[_12680]) + (mem[_12680 + 128] * mem[_12680]) / mem[_12680 + 96] + mem[_12680 + 128] != mem[_12680]:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            if not (mem[_12680 + 96] * mem[_12680]) + (mem[_12680 + 128] * mem[_12680]):
                                                                _13804 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_13804] = 26
                                                                mem[_13804 + 32] = 'SafeMath: division by zero'
                                                                if not _13049:
                                                                    _13962 = mem[64]
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 26
                                                                    idx = 0
                                                                    while idx < 26:
                                                                        mem[idx + _13962 + 68] = mem[_13804 + idx + 32]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    mem[_13962 + 94] = 0
                                                                    revert with memory
                                                                      from mem[64]
                                                                       len _13962 + -mem[64] + 100
                                                                _14447 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_14447] = 26
                                                                mem[_14447 + 32] = 'SafeMath: division by zero'
                                                                if _13048:
                                                                    if s > !(0 / _13049 / _13048):
                                                                        revert with 0, 17
                                                                    if s + (0 / _13049 / _13048) < s:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    if idx == -1:
                                                                        revert with 0, 17
                                                                    idx = idx + 1
                                                                    s = s + (0 / _13049 / _13048)
                                                                    continue 
                                                                _14639 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _14639 + 68] = mem[_14447 + idx + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_14639 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _14639 + -mem[64] + 100
                                                            if (mem[_12680 + 96] * mem[_12680]) + (mem[_12680 + 128] * mem[_12680]) and mem[_6838 + 64] > -1 / (mem[_12680 + 96] * mem[_12680]) + (mem[_12680 + 128] * mem[_12680]):
                                                                revert with 0, 17
                                                            if not (mem[_12680 + 96] * mem[_12680]) + (mem[_12680 + 128] * mem[_12680]):
                                                                revert with 0, 18
                                                            if (mem[_12680 + 96] * mem[_12680] * mem[_6838 + 64]) + (mem[_12680 + 128] * mem[_12680] * mem[_6838 + 64]) / (mem[_12680 + 96] * mem[_12680]) + (mem[_12680 + 128] * mem[_12680]) != mem[_6838 + 64]:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            _14318 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_14318] = 26
                                                            mem[_14318 + 32] = 'SafeMath: division by zero'
                                                            if not _13049:
                                                                _14446 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _14446 + 68] = mem[_14318 + idx + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_14446 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _14446 + -mem[64] + 100
                                                            _14924 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_14924] = 26
                                                            mem[_14924 + 32] = 'SafeMath: division by zero'
                                                            if _13048:
                                                                if s > !((_13053 * _13051 * _13050) + (_13052 * _13051 * _13050) / _13049 / _13048):
                                                                    revert with 0, 17
                                                                if s + ((_13053 * _13051 * _13050) + (_13052 * _13051 * _13050) / _13049 / _13048) < s:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                if idx == -1:
                                                                    revert with 0, 17
                                                                idx = idx + 1
                                                                s = s + ((_13053 * _13051 * _13050) + (_13052 * _13051 * _13050) / _13049 / _13048)
                                                                continue 
                                                            _15092 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _15092 + 68] = mem[_14924 + idx + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_15092 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _15092 + -mem[64] + 100
                                                        if mem[(4 * ceil32(return_data.size)) + 1760] > !s:
                                                            revert with 0, 17
                                                        if mem[(4 * ceil32(return_data.size)) + 1760] + s < mem[(4 * ceil32(return_data.size)) + 1760]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if sub_f4a8f345 > !(mem[(4 * ceil32(return_data.size)) + 1760] + s):
                                                            revert with 0, 17
                                                        if sub_f4a8f345 + mem[(4 * ceil32(return_data.size)) + 1760] + s < sub_f4a8f345:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        sub_f4a8f345 = sub_f4a8f345 + mem[(4 * ceil32(return_data.size)) + 1760] + s
                                                    else:
                                                        _6548 = mem[(4 * ceil32(return_data.size)) + 1888]
                                                        _6567 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_6567] = 30
                                                        mem[_6567 + 32] = 'SafeMath: subtraction overflow'
                                                        if s > _6548:
                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                        if _6548 < s:
                                                            revert with 0, 17
                                                        _6865 = mem[(4 * ceil32(return_data.size)) + 1728]
                                                        staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                                                                gas gas_remaining wei
                                                               args address(arg1), Mask(128, 128, mem[(4 * ceil32(return_data.size)) + 1728])
                                                        mem[mem[64] len 352] = ext_call.return_data[0 len 352]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _6958 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 352
                                                        _6999 = mem[64]
                                                        if mem[64] + 352 < mem[64] or mem[64] + 352 > test266151307():
                                                            revert with 0, 65
                                                        mem[64] = mem[64] + 352
                                                        require mem[_6958] == Mask(128, 128, mem[_6958])
                                                        mem[_6999] = mem[_6958]
                                                        mem[_6999 + 32] = mem[_6958 + 32]
                                                        mem[_6999 + 64] = mem[_6958 + 64]
                                                        mem[_6999 + 96] = mem[_6958 + 96]
                                                        require mem[_6958 + 128] < 5
                                                        mem[_6999 + 128] = mem[_6958 + 128]
                                                        mem[_6999 + 160] = mem[_6958 + 160]
                                                        mem[_6999 + 192] = mem[_6958 + 192]
                                                        mem[_6999 + 224] = mem[_6958 + 224]
                                                        mem[_6999 + 256] = mem[_6958 + 256]
                                                        mem[_6999 + 288] = mem[_6958 + 288]
                                                        mem[_6999 + 320] = mem[_6958 + 320]
                                                        if Mask(128, 128, mem[_6999]) != Mask(128, 128, _6865):
                                                            revert with 0, 'Address does not contain stake with provided id'
                                                        idx = mem[_6999 + 192]
                                                        t = 0
                                                        while idx < sub_ed73481d + 1:
                                                            staticcall sub_413c05c6Address.0x8ce1d9e4 with:
                                                                    gas gas_remaining wei
                                                                   args idx
                                                            mem[mem[64] len 160] = ext_call.return_data[0 len 160]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _12603 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 160
                                                            _12681 = mem[64]
                                                            if mem[64] + 160 > test266151307() or mem[64] + 160 < mem[64]:
                                                                revert with 0, 65
                                                            mem[64] = mem[64] + 160
                                                            mem[_12681] = mem[_12603]
                                                            mem[_12681 + 32] = mem[_12603 + 32]
                                                            mem[_12681 + 64] = mem[_12603 + 64]
                                                            mem[_12681 + 96] = mem[_12603 + 96]
                                                            mem[_12681 + 128] = mem[_12603 + 128]
                                                            _13054 = mem[_12681 + 64]
                                                            _13055 = mem[_12681 + 32]
                                                            _13056 = mem[_6999 + 64]
                                                            _13057 = mem[_12681]
                                                            _13058 = mem[_12681 + 128]
                                                            _13059 = mem[_12681 + 96]
                                                            if mem[_12681 + 96] > !mem[_12681 + 128]:
                                                                revert with 0, 17
                                                            if mem[_12681 + 96] + mem[_12681 + 128] < mem[_12681 + 96]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            if not mem[_12681 + 96] + mem[_12681 + 128]:
                                                                _13549 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_13549] = 26
                                                                mem[_13549 + 32] = 'SafeMath: division by zero'
                                                                if not _13055:
                                                                    _13664 = mem[64]
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 26
                                                                    idx = 0
                                                                    while idx < 26:
                                                                        mem[idx + _13664 + 68] = mem[_13549 + idx + 32]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    mem[_13664 + 94] = 0
                                                                    revert with memory
                                                                      from mem[64]
                                                                       len _13664 + -mem[64] + 100
                                                                _13965 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_13965] = 26
                                                                mem[_13965 + 32] = 'SafeMath: division by zero'
                                                                if _13054:
                                                                    if t > !(0 / _13055 / _13054):
                                                                        revert with 0, 17
                                                                    if t + (0 / _13055 / _13054) < t:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    if idx == -1:
                                                                        revert with 0, 17
                                                                    idx = idx + 1
                                                                    t = t + (0 / _13055 / _13054)
                                                                    continue 
                                                                _14148 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _14148 + 68] = mem[_13965 + idx + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_14148 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _14148 + -mem[64] + 100
                                                            if mem[_12681 + 96] + mem[_12681 + 128] and mem[_12681] > -1 / mem[_12681 + 96] + mem[_12681 + 128]:
                                                                revert with 0, 17
                                                            if not mem[_12681 + 96] + mem[_12681 + 128]:
                                                                revert with 0, 18
                                                            if (mem[_12681 + 96] * mem[_12681]) + (mem[_12681 + 128] * mem[_12681]) / mem[_12681 + 96] + mem[_12681 + 128] != mem[_12681]:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            if not (mem[_12681 + 96] * mem[_12681]) + (mem[_12681 + 128] * mem[_12681]):
                                                                _13806 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_13806] = 26
                                                                mem[_13806 + 32] = 'SafeMath: division by zero'
                                                                if not _13055:
                                                                    _13964 = mem[64]
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 26
                                                                    idx = 0
                                                                    while idx < 26:
                                                                        mem[idx + _13964 + 68] = mem[_13806 + idx + 32]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    mem[_13964 + 94] = 0
                                                                    revert with memory
                                                                      from mem[64]
                                                                       len _13964 + -mem[64] + 100
                                                                _14450 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_14450] = 26
                                                                mem[_14450 + 32] = 'SafeMath: division by zero'
                                                                if _13054:
                                                                    if t > !(0 / _13055 / _13054):
                                                                        revert with 0, 17
                                                                    if t + (0 / _13055 / _13054) < t:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    if idx == -1:
                                                                        revert with 0, 17
                                                                    idx = idx + 1
                                                                    t = t + (0 / _13055 / _13054)
                                                                    continue 
                                                                _14642 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _14642 + 68] = mem[_14450 + idx + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_14642 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _14642 + -mem[64] + 100
                                                            if (mem[_12681 + 96] * mem[_12681]) + (mem[_12681 + 128] * mem[_12681]) and mem[_6999 + 64] > -1 / (mem[_12681 + 96] * mem[_12681]) + (mem[_12681 + 128] * mem[_12681]):
                                                                revert with 0, 17
                                                            if not (mem[_12681 + 96] * mem[_12681]) + (mem[_12681 + 128] * mem[_12681]):
                                                                revert with 0, 18
                                                            if (mem[_12681 + 96] * mem[_12681] * mem[_6999 + 64]) + (mem[_12681 + 128] * mem[_12681] * mem[_6999 + 64]) / (mem[_12681 + 96] * mem[_12681]) + (mem[_12681 + 128] * mem[_12681]) != mem[_6999 + 64]:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            _14321 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_14321] = 26
                                                            mem[_14321 + 32] = 'SafeMath: division by zero'
                                                            if not _13055:
                                                                _14449 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _14449 + 68] = mem[_14321 + idx + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_14449 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _14449 + -mem[64] + 100
                                                            _14927 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_14927] = 26
                                                            mem[_14927 + 32] = 'SafeMath: division by zero'
                                                            if _13054:
                                                                if t > !((_13059 * _13057 * _13056) + (_13058 * _13057 * _13056) / _13055 / _13054):
                                                                    revert with 0, 17
                                                                if t + ((_13059 * _13057 * _13056) + (_13058 * _13057 * _13056) / _13055 / _13054) < t:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                if idx == -1:
                                                                    revert with 0, 17
                                                                idx = idx + 1
                                                                t = t + ((_13059 * _13057 * _13056) + (_13058 * _13057 * _13056) / _13055 / _13054)
                                                                continue 
                                                            _15094 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _15094 + 68] = mem[_14927 + idx + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_15094 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _15094 + -mem[64] + 100
                                                        if _6548 - s > !t:
                                                            revert with 0, 17
                                                        if t < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if mem[(4 * ceil32(return_data.size)) + 1760] > !(_6548 - s + t):
                                                            revert with 0, 17
                                                        if mem[(4 * ceil32(return_data.size)) + 1760] + _6548 - s + t < mem[(4 * ceil32(return_data.size)) + 1760]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if sub_f4a8f345 > !(mem[(4 * ceil32(return_data.size)) + 1760] + _6548 - s + t):
                                                            revert with 0, 17
                                                        if sub_f4a8f345 + mem[(4 * ceil32(return_data.size)) + 1760] + _6548 - s + t < sub_f4a8f345:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        sub_f4a8f345 = sub_f4a8f345 + mem[(4 * ceil32(return_data.size)) + 1760] + _6548 - s + t
                                                else:
                                                    idx = mem[(6 * ceil32(return_data.size)) + 2272]
                                                    s = 0
                                                    while idx < ext_call.return_data[192] + ext_call.return_data[224]:
                                                        staticcall sub_413c05c6Address.0x8ce1d9e4 with:
                                                                gas gas_remaining wei
                                                               args idx
                                                        mem[mem[64] len 160] = ext_call.return_data[0 len 160]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _6509 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 160
                                                        _6571 = mem[64]
                                                        if mem[64] + 160 > test266151307() or mem[64] + 160 < mem[64]:
                                                            revert with 0, 65
                                                        mem[64] = mem[64] + 160
                                                        mem[_6571] = mem[_6509]
                                                        mem[_6571 + 32] = mem[_6509 + 32]
                                                        mem[_6571 + 64] = mem[_6509 + 64]
                                                        mem[_6571 + 96] = mem[_6509 + 96]
                                                        mem[_6571 + 128] = mem[_6509 + 128]
                                                        _6714 = mem[_6571 + 64]
                                                        _6715 = mem[_6571 + 32]
                                                        _6716 = mem[(6 * ceil32(return_data.size)) + 2144]
                                                        _6717 = mem[_6571]
                                                        _6718 = mem[_6571 + 128]
                                                        _6719 = mem[_6571 + 96]
                                                        if mem[_6571 + 96] > !mem[_6571 + 128]:
                                                            revert with 0, 17
                                                        if mem[_6571 + 96] + mem[_6571 + 128] < mem[_6571 + 96]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if not mem[_6571 + 96] + mem[_6571 + 128]:
                                                            _7073 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_7073] = 26
                                                            mem[_7073 + 32] = 'SafeMath: division by zero'
                                                            if not _6715:
                                                                _7146 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _7146 + 68] = mem[_7073 + idx + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_7146 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _7146 + -mem[64] + 100
                                                            _7424 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_7424] = 26
                                                            mem[_7424 + 32] = 'SafeMath: division by zero'
                                                            if _6714:
                                                                if s > !(0 / _6715 / _6714):
                                                                    revert with 0, 17
                                                                if s + (0 / _6715 / _6714) < s:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                if idx == -1:
                                                                    revert with 0, 17
                                                                idx = idx + 1
                                                                s = s + (0 / _6715 / _6714)
                                                                continue 
                                                            _7550 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _7550 + 68] = mem[_7424 + idx + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_7550 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _7550 + -mem[64] + 100
                                                        if mem[_6571 + 96] + mem[_6571 + 128] and mem[_6571] > -1 / mem[_6571 + 96] + mem[_6571 + 128]:
                                                            revert with 0, 17
                                                        if not mem[_6571 + 96] + mem[_6571 + 128]:
                                                            revert with 0, 18
                                                        if (mem[_6571 + 96] * mem[_6571]) + (mem[_6571 + 128] * mem[_6571]) / mem[_6571 + 96] + mem[_6571 + 128] != mem[_6571]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        if not (mem[_6571 + 96] * mem[_6571]) + (mem[_6571 + 128] * mem[_6571]):
                                                            _7273 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_7273] = 26
                                                            mem[_7273 + 32] = 'SafeMath: division by zero'
                                                            if not _6715:
                                                                _7423 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _7423 + 68] = mem[_7273 + idx + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_7423 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _7423 + -mem[64] + 100
                                                            _7744 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_7744] = 26
                                                            mem[_7744 + 32] = 'SafeMath: division by zero'
                                                            if _6714:
                                                                if s > !(0 / _6715 / _6714):
                                                                    revert with 0, 17
                                                                if s + (0 / _6715 / _6714) < s:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                if idx == -1:
                                                                    revert with 0, 17
                                                                idx = idx + 1
                                                                s = s + (0 / _6715 / _6714)
                                                                continue 
                                                            _7878 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _7878 + 68] = mem[_7744 + idx + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_7878 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _7878 + -mem[64] + 100
                                                        if (mem[_6571 + 96] * mem[_6571]) + (mem[_6571 + 128] * mem[_6571]) and mem[(6 * ceil32(return_data.size)) + 2144] > -1 / (mem[_6571 + 96] * mem[_6571]) + (mem[_6571 + 128] * mem[_6571]):
                                                            revert with 0, 17
                                                        if not (mem[_6571 + 96] * mem[_6571]) + (mem[_6571 + 128] * mem[_6571]):
                                                            revert with 0, 18
                                                        if (mem[_6571 + 96] * mem[_6571] * mem[(6 * ceil32(return_data.size)) + 2144]) + (mem[_6571 + 128] * mem[_6571] * mem[(6 * ceil32(return_data.size)) + 2144]) / (mem[_6571 + 96] * mem[_6571]) + (mem[_6571 + 128] * mem[_6571]) != mem[(6 * ceil32(return_data.size)) + 2144]:
                                                            revert with 0, 'SafeMath: multiplication overflow'
                                                        _7660 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_7660] = 26
                                                        mem[_7660 + 32] = 'SafeMath: division by zero'
                                                        if not _6715:
                                                            _7743 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _7743 + 68] = mem[_7660 + idx + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_7743 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _7743 + -mem[64] + 100
                                                        _8040 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_8040] = 26
                                                        mem[_8040 + 32] = 'SafeMath: division by zero'
                                                        if _6714:
                                                            if s > !((_6719 * _6717 * _6716) + (_6718 * _6717 * _6716) / _6715 / _6714):
                                                                revert with 0, 17
                                                            if s + ((_6719 * _6717 * _6716) + (_6718 * _6717 * _6716) / _6715 / _6714) < s:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            if idx == -1:
                                                                revert with 0, 17
                                                            idx = idx + 1
                                                            s = s + ((_6719 * _6717 * _6716) + (_6718 * _6717 * _6716) / _6715 / _6714)
                                                            continue 
                                                        _8122 = mem[64]
                                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                        mem[mem[64] + 4] = 32
                                                        mem[mem[64] + 36] = 26
                                                        idx = 0
                                                        while idx < 26:
                                                            mem[idx + _8122 + 68] = mem[_8040 + idx + 32]
                                                            idx = idx + 32
                                                            continue 
                                                        mem[_8122 + 94] = 0
                                                        revert with memory
                                                          from mem[64]
                                                           len _8122 + -mem[64] + 100
                                                    if s >= mem[(4 * ceil32(return_data.size)) + 1888]:
                                                        _6549 = mem[(4 * ceil32(return_data.size)) + 1728]
                                                        staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                                                                gas gas_remaining wei
                                                               args address(arg1), Mask(128, 128, mem[(4 * ceil32(return_data.size)) + 1728])
                                                        mem[mem[64] len 352] = ext_call.return_data[0 len 352]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _6805 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 352
                                                        _6840 = mem[64]
                                                        if mem[64] + 352 < mem[64] or mem[64] + 352 > test266151307():
                                                            revert with 0, 65
                                                        mem[64] = mem[64] + 352
                                                        require mem[_6805] == Mask(128, 128, mem[_6805])
                                                        mem[_6840] = mem[_6805]
                                                        mem[_6840 + 32] = mem[_6805 + 32]
                                                        mem[_6840 + 64] = mem[_6805 + 64]
                                                        mem[_6840 + 96] = mem[_6805 + 96]
                                                        require mem[_6805 + 128] < 5
                                                        mem[_6840 + 128] = mem[_6805 + 128]
                                                        mem[_6840 + 160] = mem[_6805 + 160]
                                                        mem[_6840 + 192] = mem[_6805 + 192]
                                                        mem[_6840 + 224] = mem[_6805 + 224]
                                                        mem[_6840 + 256] = mem[_6805 + 256]
                                                        mem[_6840 + 288] = mem[_6805 + 288]
                                                        mem[_6840 + 320] = mem[_6805 + 320]
                                                        if Mask(128, 128, mem[_6840]) != Mask(128, 128, _6549):
                                                            revert with 0, 'Address does not contain stake with provided id'
                                                        idx = mem[_6840 + 192]
                                                        s = 0
                                                        while idx < ext_call.return_data[192] + ext_call.return_data[224]:
                                                            staticcall sub_413c05c6Address.0x8ce1d9e4 with:
                                                                    gas gas_remaining wei
                                                                   args idx
                                                            mem[mem[64] len 160] = ext_call.return_data[0 len 160]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _12605 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 160
                                                            _12689 = mem[64]
                                                            if mem[64] + 160 > test266151307() or mem[64] + 160 < mem[64]:
                                                                revert with 0, 65
                                                            mem[64] = mem[64] + 160
                                                            mem[_12689] = mem[_12605]
                                                            mem[_12689 + 32] = mem[_12605 + 32]
                                                            mem[_12689 + 64] = mem[_12605 + 64]
                                                            mem[_12689 + 96] = mem[_12605 + 96]
                                                            mem[_12689 + 128] = mem[_12605 + 128]
                                                            _13060 = mem[_12689 + 64]
                                                            _13061 = mem[_12689 + 32]
                                                            _13062 = mem[_6840 + 64]
                                                            _13063 = mem[_12689]
                                                            _13064 = mem[_12689 + 128]
                                                            _13065 = mem[_12689 + 96]
                                                            if mem[_12689 + 96] > !mem[_12689 + 128]:
                                                                revert with 0, 17
                                                            if mem[_12689 + 96] + mem[_12689 + 128] < mem[_12689 + 96]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            if not mem[_12689 + 96] + mem[_12689 + 128]:
                                                                _13551 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_13551] = 26
                                                                mem[_13551 + 32] = 'SafeMath: division by zero'
                                                                if not _13061:
                                                                    _13665 = mem[64]
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 26
                                                                    idx = 0
                                                                    while idx < 26:
                                                                        mem[idx + _13665 + 68] = mem[_13551 + idx + 32]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    mem[_13665 + 94] = 0
                                                                    revert with memory
                                                                      from mem[64]
                                                                       len _13665 + -mem[64] + 100
                                                                _13967 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_13967] = 26
                                                                mem[_13967 + 32] = 'SafeMath: division by zero'
                                                                if _13060:
                                                                    if s > !(0 / _13061 / _13060):
                                                                        revert with 0, 17
                                                                    if s + (0 / _13061 / _13060) < s:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    if idx == -1:
                                                                        revert with 0, 17
                                                                    idx = idx + 1
                                                                    s = s + (0 / _13061 / _13060)
                                                                    continue 
                                                                _14152 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _14152 + 68] = mem[_13967 + idx + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_14152 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _14152 + -mem[64] + 100
                                                            if mem[_12689 + 96] + mem[_12689 + 128] and mem[_12689] > -1 / mem[_12689 + 96] + mem[_12689 + 128]:
                                                                revert with 0, 17
                                                            if not mem[_12689 + 96] + mem[_12689 + 128]:
                                                                revert with 0, 18
                                                            if (mem[_12689 + 96] * mem[_12689]) + (mem[_12689 + 128] * mem[_12689]) / mem[_12689 + 96] + mem[_12689 + 128] != mem[_12689]:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            if not (mem[_12689 + 96] * mem[_12689]) + (mem[_12689 + 128] * mem[_12689]):
                                                                _13808 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_13808] = 26
                                                                mem[_13808 + 32] = 'SafeMath: division by zero'
                                                                if not _13061:
                                                                    _13966 = mem[64]
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 26
                                                                    idx = 0
                                                                    while idx < 26:
                                                                        mem[idx + _13966 + 68] = mem[_13808 + idx + 32]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    mem[_13966 + 94] = 0
                                                                    revert with memory
                                                                      from mem[64]
                                                                       len _13966 + -mem[64] + 100
                                                                _14453 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_14453] = 26
                                                                mem[_14453 + 32] = 'SafeMath: division by zero'
                                                                if _13060:
                                                                    if s > !(0 / _13061 / _13060):
                                                                        revert with 0, 17
                                                                    if s + (0 / _13061 / _13060) < s:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    if idx == -1:
                                                                        revert with 0, 17
                                                                    idx = idx + 1
                                                                    s = s + (0 / _13061 / _13060)
                                                                    continue 
                                                                _14645 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _14645 + 68] = mem[_14453 + idx + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_14645 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _14645 + -mem[64] + 100
                                                            if (mem[_12689 + 96] * mem[_12689]) + (mem[_12689 + 128] * mem[_12689]) and mem[_6840 + 64] > -1 / (mem[_12689 + 96] * mem[_12689]) + (mem[_12689 + 128] * mem[_12689]):
                                                                revert with 0, 17
                                                            if not (mem[_12689 + 96] * mem[_12689]) + (mem[_12689 + 128] * mem[_12689]):
                                                                revert with 0, 18
                                                            if (mem[_12689 + 96] * mem[_12689] * mem[_6840 + 64]) + (mem[_12689 + 128] * mem[_12689] * mem[_6840 + 64]) / (mem[_12689 + 96] * mem[_12689]) + (mem[_12689 + 128] * mem[_12689]) != mem[_6840 + 64]:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            _14324 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_14324] = 26
                                                            mem[_14324 + 32] = 'SafeMath: division by zero'
                                                            if not _13061:
                                                                _14452 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _14452 + 68] = mem[_14324 + idx + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_14452 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _14452 + -mem[64] + 100
                                                            _14930 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_14930] = 26
                                                            mem[_14930 + 32] = 'SafeMath: division by zero'
                                                            if _13060:
                                                                if s > !((_13065 * _13063 * _13062) + (_13064 * _13063 * _13062) / _13061 / _13060):
                                                                    revert with 0, 17
                                                                if s + ((_13065 * _13063 * _13062) + (_13064 * _13063 * _13062) / _13061 / _13060) < s:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                if idx == -1:
                                                                    revert with 0, 17
                                                                idx = idx + 1
                                                                s = s + ((_13065 * _13063 * _13062) + (_13064 * _13063 * _13062) / _13061 / _13060)
                                                                continue 
                                                            _15096 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _15096 + 68] = mem[_14930 + idx + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_15096 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _15096 + -mem[64] + 100
                                                        if mem[(4 * ceil32(return_data.size)) + 1760] > !s:
                                                            revert with 0, 17
                                                        if mem[(4 * ceil32(return_data.size)) + 1760] + s < mem[(4 * ceil32(return_data.size)) + 1760]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if sub_f4a8f345 > !(mem[(4 * ceil32(return_data.size)) + 1760] + s):
                                                            revert with 0, 17
                                                        if sub_f4a8f345 + mem[(4 * ceil32(return_data.size)) + 1760] + s < sub_f4a8f345:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        sub_f4a8f345 = sub_f4a8f345 + mem[(4 * ceil32(return_data.size)) + 1760] + s
                                                    else:
                                                        _6550 = mem[(4 * ceil32(return_data.size)) + 1888]
                                                        _6570 = mem[64]
                                                        mem[64] = mem[64] + 64
                                                        mem[_6570] = 30
                                                        mem[_6570 + 32] = 'SafeMath: subtraction overflow'
                                                        if s > _6550:
                                                            revert with 0, 'SafeMath: subtraction overflow', 0
                                                        if _6550 < s:
                                                            revert with 0, 17
                                                        _6867 = mem[(4 * ceil32(return_data.size)) + 1728]
                                                        staticcall sub_413c05c6Address.stakes(address arg1, bytes16 arg2) with:
                                                                gas gas_remaining wei
                                                               args address(arg1), Mask(128, 128, mem[(4 * ceil32(return_data.size)) + 1728])
                                                        mem[mem[64] len 352] = ext_call.return_data[0 len 352]
                                                        if not ext_call.success:
                                                            revert with ext_call.return_data[0 len return_data.size]
                                                        _6959 = mem[64]
                                                        mem[64] = mem[64] + ceil32(return_data.size)
                                                        require return_data.size >= 352
                                                        _7001 = mem[64]
                                                        if mem[64] + 352 < mem[64] or mem[64] + 352 > test266151307():
                                                            revert with 0, 65
                                                        mem[64] = mem[64] + 352
                                                        require mem[_6959] == Mask(128, 128, mem[_6959])
                                                        mem[_7001] = mem[_6959]
                                                        mem[_7001 + 32] = mem[_6959 + 32]
                                                        mem[_7001 + 64] = mem[_6959 + 64]
                                                        mem[_7001 + 96] = mem[_6959 + 96]
                                                        require mem[_6959 + 128] < 5
                                                        mem[_7001 + 128] = mem[_6959 + 128]
                                                        mem[_7001 + 160] = mem[_6959 + 160]
                                                        mem[_7001 + 192] = mem[_6959 + 192]
                                                        mem[_7001 + 224] = mem[_6959 + 224]
                                                        mem[_7001 + 256] = mem[_6959 + 256]
                                                        mem[_7001 + 288] = mem[_6959 + 288]
                                                        mem[_7001 + 320] = mem[_6959 + 320]
                                                        if Mask(128, 128, mem[_7001]) != Mask(128, 128, _6867):
                                                            revert with 0, 'Address does not contain stake with provided id'
                                                        idx = mem[_7001 + 192]
                                                        t = 0
                                                        while idx < ext_call.return_data[192] + ext_call.return_data[224]:
                                                            staticcall sub_413c05c6Address.0x8ce1d9e4 with:
                                                                    gas gas_remaining wei
                                                                   args idx
                                                            mem[mem[64] len 160] = ext_call.return_data[0 len 160]
                                                            if not ext_call.success:
                                                                revert with ext_call.return_data[0 len return_data.size]
                                                            _12607 = mem[64]
                                                            mem[64] = mem[64] + ceil32(return_data.size)
                                                            require return_data.size >= 160
                                                            _12690 = mem[64]
                                                            if mem[64] + 160 > test266151307() or mem[64] + 160 < mem[64]:
                                                                revert with 0, 65
                                                            mem[64] = mem[64] + 160
                                                            mem[_12690] = mem[_12607]
                                                            mem[_12690 + 32] = mem[_12607 + 32]
                                                            mem[_12690 + 64] = mem[_12607 + 64]
                                                            mem[_12690 + 96] = mem[_12607 + 96]
                                                            mem[_12690 + 128] = mem[_12607 + 128]
                                                            _13066 = mem[_12690 + 64]
                                                            _13067 = mem[_12690 + 32]
                                                            _13068 = mem[_7001 + 64]
                                                            _13069 = mem[_12690]
                                                            _13070 = mem[_12690 + 128]
                                                            _13071 = mem[_12690 + 96]
                                                            if mem[_12690 + 96] > !mem[_12690 + 128]:
                                                                revert with 0, 17
                                                            if mem[_12690 + 96] + mem[_12690 + 128] < mem[_12690 + 96]:
                                                                revert with 0, 'SafeMath: addition overflow'
                                                            if not mem[_12690 + 96] + mem[_12690 + 128]:
                                                                _13553 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_13553] = 26
                                                                mem[_13553 + 32] = 'SafeMath: division by zero'
                                                                if not _13067:
                                                                    _13667 = mem[64]
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 26
                                                                    idx = 0
                                                                    while idx < 26:
                                                                        mem[idx + _13667 + 68] = mem[_13553 + idx + 32]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    mem[_13667 + 94] = 0
                                                                    revert with memory
                                                                      from mem[64]
                                                                       len _13667 + -mem[64] + 100
                                                                _13969 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_13969] = 26
                                                                mem[_13969 + 32] = 'SafeMath: division by zero'
                                                                if _13066:
                                                                    if t > !(0 / _13067 / _13066):
                                                                        revert with 0, 17
                                                                    if t + (0 / _13067 / _13066) < t:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    if idx == -1:
                                                                        revert with 0, 17
                                                                    idx = idx + 1
                                                                    t = t + (0 / _13067 / _13066)
                                                                    continue 
                                                                _14156 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _14156 + 68] = mem[_13969 + idx + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_14156 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _14156 + -mem[64] + 100
                                                            if mem[_12690 + 96] + mem[_12690 + 128] and mem[_12690] > -1 / mem[_12690 + 96] + mem[_12690 + 128]:
                                                                revert with 0, 17
                                                            if not mem[_12690 + 96] + mem[_12690 + 128]:
                                                                revert with 0, 18
                                                            if (mem[_12690 + 96] * mem[_12690]) + (mem[_12690 + 128] * mem[_12690]) / mem[_12690 + 96] + mem[_12690 + 128] != mem[_12690]:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            if not (mem[_12690 + 96] * mem[_12690]) + (mem[_12690 + 128] * mem[_12690]):
                                                                _13810 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_13810] = 26
                                                                mem[_13810 + 32] = 'SafeMath: division by zero'
                                                                if not _13067:
                                                                    _13968 = mem[64]
                                                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                    mem[mem[64] + 4] = 32
                                                                    mem[mem[64] + 36] = 26
                                                                    idx = 0
                                                                    while idx < 26:
                                                                        mem[idx + _13968 + 68] = mem[_13810 + idx + 32]
                                                                        idx = idx + 32
                                                                        continue 
                                                                    mem[_13968 + 94] = 0
                                                                    revert with memory
                                                                      from mem[64]
                                                                       len _13968 + -mem[64] + 100
                                                                _14456 = mem[64]
                                                                mem[64] = mem[64] + 64
                                                                mem[_14456] = 26
                                                                mem[_14456 + 32] = 'SafeMath: division by zero'
                                                                if _13066:
                                                                    if t > !(0 / _13067 / _13066):
                                                                        revert with 0, 17
                                                                    if t + (0 / _13067 / _13066) < t:
                                                                        revert with 0, 'SafeMath: addition overflow'
                                                                    if idx == -1:
                                                                        revert with 0, 17
                                                                    idx = idx + 1
                                                                    t = t + (0 / _13067 / _13066)
                                                                    continue 
                                                                _14648 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _14648 + 68] = mem[_14456 + idx + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_14648 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _14648 + -mem[64] + 100
                                                            if (mem[_12690 + 96] * mem[_12690]) + (mem[_12690 + 128] * mem[_12690]) and mem[_7001 + 64] > -1 / (mem[_12690 + 96] * mem[_12690]) + (mem[_12690 + 128] * mem[_12690]):
                                                                revert with 0, 17
                                                            if not (mem[_12690 + 96] * mem[_12690]) + (mem[_12690 + 128] * mem[_12690]):
                                                                revert with 0, 18
                                                            if (mem[_12690 + 96] * mem[_12690] * mem[_7001 + 64]) + (mem[_12690 + 128] * mem[_12690] * mem[_7001 + 64]) / (mem[_12690 + 96] * mem[_12690]) + (mem[_12690 + 128] * mem[_12690]) != mem[_7001 + 64]:
                                                                revert with 0, 'SafeMath: multiplication overflow'
                                                            _14327 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_14327] = 26
                                                            mem[_14327 + 32] = 'SafeMath: division by zero'
                                                            if not _13067:
                                                                _14455 = mem[64]
                                                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                                mem[mem[64] + 4] = 32
                                                                mem[mem[64] + 36] = 26
                                                                idx = 0
                                                                while idx < 26:
                                                                    mem[idx + _14455 + 68] = mem[_14327 + idx + 32]
                                                                    idx = idx + 32
                                                                    continue 
                                                                mem[_14455 + 94] = 0
                                                                revert with memory
                                                                  from mem[64]
                                                                   len _14455 + -mem[64] + 100
                                                            _14933 = mem[64]
                                                            mem[64] = mem[64] + 64
                                                            mem[_14933] = 26
                                                            mem[_14933 + 32] = 'SafeMath: division by zero'
                                                            if _13066:
                                                                if t > !((_13071 * _13069 * _13068) + (_13070 * _13069 * _13068) / _13067 / _13066):
                                                                    revert with 0, 17
                                                                if t + ((_13071 * _13069 * _13068) + (_13070 * _13069 * _13068) / _13067 / _13066) < t:
                                                                    revert with 0, 'SafeMath: addition overflow'
                                                                if idx == -1:
                                                                    revert with 0, 17
                                                                idx = idx + 1
                                                                t = t + ((_13071 * _13069 * _13068) + (_13070 * _13069 * _13068) / _13067 / _13066)
                                                                continue 
                                                            _15098 = mem[64]
                                                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                                            mem[mem[64] + 4] = 32
                                                            mem[mem[64] + 36] = 26
                                                            idx = 0
                                                            while idx < 26:
                                                                mem[idx + _15098 + 68] = mem[_14933 + idx + 32]
                                                                idx = idx + 32
                                                                continue 
                                                            mem[_15098 + 94] = 0
                                                            revert with memory
                                                              from mem[64]
                                                               len _15098 + -mem[64] + 100
                                                        if _6550 - s > !t:
                                                            revert with 0, 17
                                                        if t < 0:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if mem[(4 * ceil32(return_data.size)) + 1760] > !(_6550 - s + t):
                                                            revert with 0, 17
                                                        if mem[(4 * ceil32(return_data.size)) + 1760] + _6550 - s + t < mem[(4 * ceil32(return_data.size)) + 1760]:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        if sub_f4a8f345 > !(mem[(4 * ceil32(return_data.size)) + 1760] + _6550 - s + t):
                                                            revert with 0, 17
                                                        if sub_f4a8f345 + mem[(4 * ceil32(return_data.size)) + 1760] + _6550 - s + t < sub_f4a8f345:
                                                            revert with 0, 'SafeMath: addition overflow'
                                                        sub_f4a8f345 = sub_f4a8f345 + mem[(4 * ceil32(return_data.size)) + 1760] + _6550 - s + t
}



}

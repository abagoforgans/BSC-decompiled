contract main {




// =====================  Runtime code  =====================


#
#  - transferFrom(address arg1, address arg2, uint256 arg3)
#  - transfer(address arg1, uint256 arg2)
#  - _fallback()
#
address owner;
mapping of uint256 stor1;
mapping of uint256 stor2;
mapping of uint256 allowance;
mapping of uint8 stor4;
mapping of uint8 stor5;
mapping of uint8 stor6;
mapping of uint8 stor7;
mapping of uint8 stor8;
array of address stor9;
uint256 totalSupply;
uint256 stor11;
uint256 totalFees;
array of struct stor13;
array of struct stor14;
uint8 decimals;
uint256 stor16;
uint256 stor17;
uint256 stor18;
uint256 stor19;
uint256 stor22;
uint256 stor23;
uint256 stor24;
uint256 stor25;
uint256 stor27;
uint256 stor28;
uint256 stor29;
uint256 stor30;
uint256 stor32;
uint256 stor33;
uint256 stor34;
uint256 stor35;
address sub_c66b7968Address;
address devAddAddress;
address sub_19eff2b9Address;
address uniswapV2PairAddress;
uint256 _maxTxAmount;
uint256 stor43;
uint256 stor44;
uint256 stor45;
uint8 buyBackEnabled;
uint8 swapAndLiquifyEnabled;

function totalFees() {
    return totalFees
}

function totalSupply() {
    return totalSupply
}

function sub_19eff2b9(?) {
    return sub_19eff2b9Address
}

function decimals() {
    return decimals
}

function uniswapV2Pair() {
    return uniswapV2PairAddress
}

function swapAndLiquifyEnabled() {
    return bool(swapAndLiquifyEnabled)
}

function isExcludedFromFee(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    return bool(stor6[address(arg1)])
}

function buyBackEnabled() {
    return bool(buyBackEnabled)
}

function _maxTxAmount() {
    return _maxTxAmount
}

function isExcludedFromReward(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    return bool(stor8[address(arg1)])
}

function owner() {
    return owner
}

function sub_a8417ff6(?) {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    return bool(stor5[arg1])
}

function automatedMarketMakerPairs(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    return bool(stor4[arg1])
}

function sub_c66b7968(?) {
    return sub_c66b7968Address
}

function isExcludedFromLimit(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    return bool(stor7[address(arg1)])
}

function allowance(address arg1, address arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 == arg2
    return allowance[address(arg1)][address(arg2)]
}

function DevAdd() {
    return devAddAddress
}

function renounceOwnership() {
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    emit OwnershipTransferred(owner, owner);
}

function sub_0a7f25d2(?) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    stor28 = arg1
}

function sub_16168ada(?) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    stor27 = arg1
}

function sub_2564c2b9(?) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    stor32 = arg1
}

function sub_5e98b801(?) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    stor29 = arg1
}

function sub_788c05e0(?) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    stor18 = arg1
}

function sub_83f68e34(?) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    stor34 = arg1
}

function sub_9be98fc3(?) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    stor16 = arg1
}

function sub_a0cc3d9a(?) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    stor23 = arg1
}

function sub_b1a5d081(?) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    stor33 = arg1
}

function sub_b633fabd(?) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    stor17 = arg1
}

function sub_c289c4e2(?) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    stor22 = arg1
}

function sub_d62e9728(?) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    stor43 = arg1
}

function sub_d7f75d39(?) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    stor24 = arg1
}

function setBuyBack(uint256 arg1) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    stor45 = arg1
}

function setMaxTx(uint256 arg1) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    _maxTxAmount = arg1
}

function setWalletLimit(uint256 arg1) {
    require calldata.size - 4 >= 32
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    stor44 = arg1
}

function sub_2e10d8c7(?) {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    stor7[address(arg1)] = 1
}

function sub_96e42f4c(?) {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    stor5[address(arg1)] = 0
}

function sub_9b81411f(?) {
    require calldata.size - 4 >= 32
    require arg1 == address(arg1)
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    stor5[address(arg1)] = 1
}

function includeInFee(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    stor6[address(arg1)] = 0
}

function excludeFromFee(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    stor6[address(arg1)] = 1
}

function includeInLimit(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    stor7[address(arg1)] = 0
}

function setMarketingAdd(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    sub_c66b7968Address = arg1
}

function setBuyBackEnabled(bool arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    buyBackEnabled = uint8(arg1)
}

function setSwapAndLiquifyEnabled(bool arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    swapAndLiquifyEnabled = uint8(arg1)
    emit SwapAndLiquifyEnabledUpdated(arg1);
}

function rescue() {
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    call owner with:
       value eth.balance(this.address) wei
         gas 2300 * is_zero(value) wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
}

function transferOwnership(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Ownable: new owner is the zero address'
    owner = arg1
    emit OwnershipTransferred(owner, arg1);
}

function approve(address arg1, uint256 arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    if not msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: approve from the zero address'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: approve to the zero address'
    allowance[address(msg.sender)][address(arg1)] = arg2
    emit Approval(arg2, msg.sender, arg1);
    return 1
}

function decreaseAllowance(address arg1, uint256 arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    if arg2 > allowance[msg.sender][address(arg1)]:
        revert with 0, 32, 37, 0x6542455032303a2064656372656173656420616c6c6f77616e63652062656c6f77207a6572, mem[165 len 27] >> 40, 0
    if allowance[msg.sender][address(arg1)] < arg2:
        revert with 0, 17
    if not msg.sender:
        revert with 0, 'BEP20: approve from the zero address'
    if not arg1:
        revert with 0, 'BEP20: approve to the zero address'
    allowance[address(msg.sender)][address(arg1)] = allowance[msg.sender][address(arg1)] - arg2
    emit Approval((allowance[msg.sender][address(arg1)] - arg2), msg.sender, arg1);
    return 1
}

function setAutomatedMarketMakerPair(address arg1, bool arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    require arg2 == arg2
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if uniswapV2PairAddress == arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    'Brain: The PancakeSwap pair cannot be removed from automatedMarketMakerPairs'
    if arg2 == bool(stor4[address(arg1)]):
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 
                    'Brain: Automated market maker pair is already set to that value'
    stor4[address(arg1)] = uint8(arg2)
    emit SetAutomatedMarketMakerPair(arg1, arg2);
}

function increaseAllowance(address arg1, uint256 arg2) {
    require calldata.size - 4 >= 64
    require arg1 == arg1
    if allowance[msg.sender][address(arg1)] > !arg2:
        revert with 0, 17
    if allowance[msg.sender][address(arg1)] + arg2 < allowance[msg.sender][address(arg1)]:
        revert with 0, 'SafeMath: addition overflow'
    if not msg.sender:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: approve from the zero address'
    if not arg1:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'BEP20: approve to the zero address'
    allowance[address(msg.sender)][address(arg1)] = allowance[msg.sender][address(arg1)] + arg2
    emit Approval((allowance[msg.sender][address(arg1)] + arg2), msg.sender, arg1);
    return 1
}

function includeInReward(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if not stor8[address(arg1)]:
        revert with 0, 'Account is already excluded'
    idx = 0
    while idx < stor9.length:
        mem[0] = 9
        if stor9[idx] != arg1:
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            continue 
        if stor9.length < 1:
            revert with 0, 17
        if stor9.length - 1 >= stor9.length:
            revert with 0, 50
        if idx >= stor9.length:
            revert with 0, 50
        stor9[idx] = stor9[stor9.length]
        stor2[address(arg1)] = 0
        stor8[address(arg1)] = 0
        if not stor9.length:
            revert with 0, 49
        stor9[stor9.length] = 0
        stor9.length--
}

function setRouter(address arg1) {
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    require ext_code.size(arg1)
    staticcall arg1.factory() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    require ext_code.size(arg1)
    staticcall arg1.WETH() with:
            gas gas_remaining wei
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    require ext_code.size(address(ext_call.return_data[0]))
    call address(ext_call.return_data[0]).createPair(address arg1, address arg2) with:
         gas gas_remaining wei
        args address(this.address), address(ext_call.return_data[0])
    if not ext_call.success:
        revert with ext_call.return_data[0 len return_data.size]
    require return_data.size >= 32
    require ext_call.return_data[0] == ext_call.return_data[12 len 20]
    uniswapV2PairAddress = ext_call.return_data[12 len 20]
    sub_19eff2b9Address = arg1
}

function name() {
    if bool(stor13.length):
        if bool(stor13.length) == uint255(stor13.length) * 0.5 < 32:
            revert with 0, 34
        if bool(stor13.length):
            if bool(stor13.length) == uint255(stor13.length) * 0.5 < 32:
                revert with 0, 34
            if Mask(256, -1, stor13.length):
                if 31 < uint255(stor13.length) * 0.5:
                    mem[128] = uint256(stor13.field_0)
                    idx = 128
                    s = 0
                    while (uint255(stor13.length) * 0.5) + 96 > idx:
                        mem[idx + 32] = stor13[s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, stor13.length), data=mem[128 len ceil32(uint255(stor13.length) * 0.5)])
                mem[128] = 256 * stor13.length.field_8
        else:
            if bool(stor13.length) == stor13.length.field_1 < 32:
                revert with 0, 34
            if stor13.length.field_1:
                if 31 < stor13.length.field_1:
                    mem[128] = uint256(stor13.field_0)
                    idx = 128
                    s = 0
                    while stor13.length.field_1 + 96 > idx:
                        mem[idx + 32] = stor13[s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, stor13.length), data=mem[128 len ceil32(uint255(stor13.length) * 0.5)])
                mem[128] = 256 * stor13.length.field_8
        mem[ceil32(uint255(stor13.length) * 0.5) + 192 len ceil32(uint255(stor13.length) * 0.5)] = mem[128 len ceil32(uint255(stor13.length) * 0.5)]
        if ceil32(uint255(stor13.length) * 0.5) > uint255(stor13.length) * 0.5:
            mem[ceil32(uint255(stor13.length) * 0.5) + (uint255(stor13.length) * 0.5) + 192] = 0
        return Array(len=2 * Mask(256, -1, stor13.length), data=mem[128 len ceil32(uint255(stor13.length) * 0.5)], mem[(2 * ceil32(uint255(stor13.length) * 0.5)) + 192 len 2 * ceil32(uint255(stor13.length) * 0.5)]), 
    if bool(stor13.length) == stor13.length.field_1 < 32:
        revert with 0, 34
    if bool(stor13.length):
        if bool(stor13.length) == uint255(stor13.length) * 0.5 < 32:
            revert with 0, 34
        if Mask(256, -1, stor13.length):
            if 31 < uint255(stor13.length) * 0.5:
                mem[128] = uint256(stor13.field_0)
                idx = 128
                s = 0
                while (uint255(stor13.length) * 0.5) + 96 > idx:
                    mem[idx + 32] = stor13[s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=stor13.length % 128, data=mem[128 len ceil32(stor13.length.field_1)])
            mem[128] = 256 * stor13.length.field_8
    else:
        if bool(stor13.length) == stor13.length.field_1 < 32:
            revert with 0, 34
        if stor13.length.field_1:
            if 31 < stor13.length.field_1:
                mem[128] = uint256(stor13.field_0)
                idx = 128
                s = 0
                while stor13.length.field_1 + 96 > idx:
                    mem[idx + 32] = stor13[s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=stor13.length % 128, data=mem[128 len ceil32(stor13.length.field_1)])
            mem[128] = 256 * stor13.length.field_8
    mem[ceil32(stor13.length.field_1) + 192 len ceil32(stor13.length.field_1)] = mem[128 len ceil32(stor13.length.field_1)]
    if ceil32(stor13.length.field_1) > stor13.length.field_1:
        mem[ceil32(stor13.length.field_1) + stor13.length.field_1 + 192] = 0
    return Array(len=stor13.length % 128, data=mem[128 len ceil32(stor13.length.field_1)], mem[(2 * ceil32(stor13.length.field_1)) + 192 len 2 * ceil32(stor13.length.field_1)]), 
}

function symbol() {
    if bool(stor14.length):
        if bool(stor14.length) == uint255(stor14.length) * 0.5 < 32:
            revert with 0, 34
        if bool(stor14.length):
            if bool(stor14.length) == uint255(stor14.length) * 0.5 < 32:
                revert with 0, 34
            if Mask(256, -1, stor14.length):
                if 31 < uint255(stor14.length) * 0.5:
                    mem[128] = uint256(stor14.field_0)
                    idx = 128
                    s = 0
                    while (uint255(stor14.length) * 0.5) + 96 > idx:
                        mem[idx + 32] = stor14[s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, stor14.length), data=mem[128 len ceil32(uint255(stor14.length) * 0.5)])
                mem[128] = 256 * stor14.length.field_8
        else:
            if bool(stor14.length) == stor14.length.field_1 < 32:
                revert with 0, 34
            if stor14.length.field_1:
                if 31 < stor14.length.field_1:
                    mem[128] = uint256(stor14.field_0)
                    idx = 128
                    s = 0
                    while stor14.length.field_1 + 96 > idx:
                        mem[idx + 32] = stor14[s].field_256
                        idx = idx + 32
                        s = s + 1
                        continue 
                    return Array(len=2 * Mask(256, -1, stor14.length), data=mem[128 len ceil32(uint255(stor14.length) * 0.5)])
                mem[128] = 256 * stor14.length.field_8
        mem[ceil32(uint255(stor14.length) * 0.5) + 192 len ceil32(uint255(stor14.length) * 0.5)] = mem[128 len ceil32(uint255(stor14.length) * 0.5)]
        if ceil32(uint255(stor14.length) * 0.5) > uint255(stor14.length) * 0.5:
            mem[ceil32(uint255(stor14.length) * 0.5) + (uint255(stor14.length) * 0.5) + 192] = 0
        return Array(len=2 * Mask(256, -1, stor14.length), data=mem[128 len ceil32(uint255(stor14.length) * 0.5)], mem[(2 * ceil32(uint255(stor14.length) * 0.5)) + 192 len 2 * ceil32(uint255(stor14.length) * 0.5)]), 
    if bool(stor14.length) == stor14.length.field_1 < 32:
        revert with 0, 34
    if bool(stor14.length):
        if bool(stor14.length) == uint255(stor14.length) * 0.5 < 32:
            revert with 0, 34
        if Mask(256, -1, stor14.length):
            if 31 < uint255(stor14.length) * 0.5:
                mem[128] = uint256(stor14.field_0)
                idx = 128
                s = 0
                while (uint255(stor14.length) * 0.5) + 96 > idx:
                    mem[idx + 32] = stor14[s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=stor14.length % 128, data=mem[128 len ceil32(stor14.length.field_1)])
            mem[128] = 256 * stor14.length.field_8
    else:
        if bool(stor14.length) == stor14.length.field_1 < 32:
            revert with 0, 34
        if stor14.length.field_1:
            if 31 < stor14.length.field_1:
                mem[128] = uint256(stor14.field_0)
                idx = 128
                s = 0
                while stor14.length.field_1 + 96 > idx:
                    mem[idx + 32] = stor14[s].field_256
                    idx = idx + 32
                    s = s + 1
                    continue 
                return Array(len=stor14.length % 128, data=mem[128 len ceil32(stor14.length.field_1)])
            mem[128] = 256 * stor14.length.field_8
    mem[ceil32(stor14.length.field_1) + 192 len ceil32(stor14.length.field_1)] = mem[128 len ceil32(stor14.length.field_1)]
    if ceil32(stor14.length.field_1) > stor14.length.field_1:
        mem[ceil32(stor14.length.field_1) + stor14.length.field_1 + 192] = 0
    return Array(len=stor14.length % 128, data=mem[128 len ceil32(stor14.length.field_1)], mem[(2 * ceil32(stor14.length.field_1)) + 192 len 2 * ceil32(stor14.length.field_1)]), 
}

function tokenFromReflection(uint256 arg1) payable {
    mem[64] = 96
    require not msg.value
    require calldata.size - 4 >= 32
    if arg1 > stor11:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Amount must be less than total reflections'
    idx = 0
    s = totalSupply
    t = stor11
    while idx < stor9.length:
        mem[0] = stor9[idx]
        mem[32] = 1
        if stor1[stor9[idx]] > t:
            _92 = mem[64]
            mem[64] = mem[64] + 64
            mem[_92] = 26
            mem[_92 + 32] = 'SafeMath: division by zero'
            if not totalSupply:
                _96 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _96 + 68] = mem[idx + _92 + 32]
                    idx = idx + 32
                    continue 
                mem[_96 + 94] = 0
                revert with memory
                  from mem[64]
                   len _96 + -mem[64] + 100
            _117 = mem[64]
            mem[64] = mem[64] + 64
            mem[_117] = 26
            mem[_117 + 32] = 'SafeMath: division by zero'
            if stor11 / totalSupply:
                return (arg1 / stor11 / totalSupply)
            _126 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _126 + 68] = mem[idx + _117 + 32]
                idx = idx + 32
                continue 
            mem[_126 + 94] = 0
            revert with memory
              from mem[64]
               len _126 + -mem[64] + 100
        if idx >= stor9.length:
            revert with 0, 50
        mem[0] = stor9[idx]
        mem[32] = 2
        if stor2[stor9[idx]] > s:
            _98 = mem[64]
            mem[64] = mem[64] + 64
            mem[_98] = 26
            mem[_98 + 32] = 'SafeMath: division by zero'
            if not totalSupply:
                _103 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _103 + 68] = mem[idx + _98 + 32]
                    idx = idx + 32
                    continue 
                mem[_103 + 94] = 0
                revert with memory
                  from mem[64]
                   len _103 + -mem[64] + 100
            _128 = mem[64]
            mem[64] = mem[64] + 64
            mem[_128] = 26
            mem[_128 + 32] = 'SafeMath: division by zero'
            if stor11 / totalSupply:
                return (arg1 / stor11 / totalSupply)
            _133 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _133 + 68] = mem[idx + _128 + 32]
                idx = idx + 32
                continue 
            mem[_133 + 94] = 0
            revert with memory
              from mem[64]
               len _133 + -mem[64] + 100
        if idx >= stor9.length:
            revert with 0, 50
        mem[0] = stor9[idx]
        mem[32] = 1
        _97 = mem[64]
        mem[64] = mem[64] + 64
        mem[_97] = 30
        mem[_97 + 32] = 'SafeMath: subtraction overflow'
        if stor1[stor9[idx]] > t:
            _102 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[idx + _102 + 68] = mem[idx + _97 + 32]
                idx = idx + 32
                continue 
            mem[_102 + 98] = 0
            revert with memory
              from mem[64]
               len _102 + -mem[64] + 100
        if t < stor1[stor9[idx]]:
            revert with 0, 17
        if idx >= stor9.length:
            revert with 0, 50
        mem[0] = stor9[idx]
        mem[32] = 2
        _127 = mem[64]
        mem[64] = mem[64] + 64
        mem[_127] = 30
        mem[_127 + 32] = 'SafeMath: subtraction overflow'
        if stor2[stor9[idx]] <= s:
            if s < stor2[stor9[idx]]:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s - stor2[stor9[idx]]
            t = t - stor1[stor9[idx]]
            continue 
        _132 = mem[64]
        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 32
        mem[mem[64] + 36] = 30
        idx = 0
        while idx < 30:
            mem[idx + _132 + 68] = mem[idx + _127 + 32]
            idx = idx + 32
            continue 
        mem[_132 + 98] = 0
        revert with memory
          from mem[64]
           len _132 + -mem[64] + 100
    if not totalSupply:
        revert with 0, 'SafeMath: division by zero', 0
    if t >= stor11 / totalSupply:
        if not s:
            revert with 0, 'SafeMath: division by zero', 0
        if not t / s:
            revert with 0, 'SafeMath: division by zero', 0
        return (arg1 / t / s)
    if not totalSupply:
        revert with 0, 'SafeMath: division by zero', 0
    if not stor11 / totalSupply:
        revert with 0, 'SafeMath: division by zero', 0
    return (arg1 / stor11 / totalSupply)
}

function balanceOf(address arg1) payable {
    mem[64] = 96
    require not msg.value
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if stor8[address(arg1)]:
        return stor2[address(arg1)]
    mem[0] = arg1
    mem[32] = 1
    if stor1[address(arg1)] > stor11:
        revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Amount must be less than total reflections'
    idx = 0
    s = totalSupply
    t = stor11
    while idx < stor9.length:
        mem[0] = stor9[idx]
        mem[32] = 1
        if stor1[stor9[idx]] > t:
            _97 = mem[64]
            mem[64] = mem[64] + 64
            mem[_97] = 26
            mem[_97 + 32] = 'SafeMath: division by zero'
            if not totalSupply:
                _101 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _101 + 68] = mem[idx + _97 + 32]
                    idx = idx + 32
                    continue 
                mem[_101 + 94] = 0
                revert with memory
                  from mem[64]
                   len _101 + -mem[64] + 100
            _122 = mem[64]
            mem[64] = mem[64] + 64
            mem[_122] = 26
            mem[_122 + 32] = 'SafeMath: division by zero'
            if stor11 / totalSupply:
                return (stor1[address(arg1)] / stor11 / totalSupply)
            _131 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _131 + 68] = mem[idx + _122 + 32]
                idx = idx + 32
                continue 
            mem[_131 + 94] = 0
            revert with memory
              from mem[64]
               len _131 + -mem[64] + 100
        if idx >= stor9.length:
            revert with 0, 50
        mem[0] = stor9[idx]
        mem[32] = 2
        if stor2[stor9[idx]] > s:
            _103 = mem[64]
            mem[64] = mem[64] + 64
            mem[_103] = 26
            mem[_103 + 32] = 'SafeMath: division by zero'
            if not totalSupply:
                _108 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _108 + 68] = mem[idx + _103 + 32]
                    idx = idx + 32
                    continue 
                mem[_108 + 94] = 0
                revert with memory
                  from mem[64]
                   len _108 + -mem[64] + 100
            _133 = mem[64]
            mem[64] = mem[64] + 64
            mem[_133] = 26
            mem[_133 + 32] = 'SafeMath: division by zero'
            if stor11 / totalSupply:
                return (stor1[address(arg1)] / stor11 / totalSupply)
            _138 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 26
            idx = 0
            while idx < 26:
                mem[idx + _138 + 68] = mem[idx + _133 + 32]
                idx = idx + 32
                continue 
            mem[_138 + 94] = 0
            revert with memory
              from mem[64]
               len _138 + -mem[64] + 100
        if idx >= stor9.length:
            revert with 0, 50
        mem[0] = stor9[idx]
        mem[32] = 1
        _102 = mem[64]
        mem[64] = mem[64] + 64
        mem[_102] = 30
        mem[_102 + 32] = 'SafeMath: subtraction overflow'
        if stor1[stor9[idx]] > t:
            _107 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[idx + _107 + 68] = mem[idx + _102 + 32]
                idx = idx + 32
                continue 
            mem[_107 + 98] = 0
            revert with memory
              from mem[64]
               len _107 + -mem[64] + 100
        if t < stor1[stor9[idx]]:
            revert with 0, 17
        if idx >= stor9.length:
            revert with 0, 50
        mem[0] = stor9[idx]
        mem[32] = 2
        _132 = mem[64]
        mem[64] = mem[64] + 64
        mem[_132] = 30
        mem[_132 + 32] = 'SafeMath: subtraction overflow'
        if stor2[stor9[idx]] <= s:
            if s < stor2[stor9[idx]]:
                revert with 0, 17
            if idx == -1:
                revert with 0, 17
            idx = idx + 1
            s = s - stor2[stor9[idx]]
            t = t - stor1[stor9[idx]]
            continue 
        _137 = mem[64]
        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
        mem[mem[64] + 4] = 32
        mem[mem[64] + 36] = 30
        idx = 0
        while idx < 30:
            mem[idx + _137 + 68] = mem[idx + _132 + 32]
            idx = idx + 32
            continue 
        mem[_137 + 98] = 0
        revert with memory
          from mem[64]
           len _137 + -mem[64] + 100
    if not totalSupply:
        revert with 0, 'SafeMath: division by zero', 0
    if t >= stor11 / totalSupply:
        if not s:
            revert with 0, 'SafeMath: division by zero', 0
        if not t / s:
            revert with 0, 'SafeMath: division by zero', 0
        return (stor1[address(arg1)] / t / s)
    if not totalSupply:
        revert with 0, 'SafeMath: division by zero', 0
    if not stor11 / totalSupply:
        revert with 0, 'SafeMath: division by zero', 0
    return (stor1[address(arg1)] / stor11 / totalSupply)
}

function blacklist(address arg1) payable {
    mem[64] = 96
    require not msg.value
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if stor8[address(arg1)]:
        revert with 0, 'Account is already excluded'
    if stor1[address(arg1)]:
        mem[0] = arg1
        mem[32] = 1
        if stor1[address(arg1)] > stor11:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Amount must be less than total reflections'
        idx = 0
        s = totalSupply
        t = stor11
        while idx < stor9.length:
            mem[0] = stor9[idx]
            mem[32] = 1
            if stor1[stor9[idx]] > t:
                _100 = mem[64]
                mem[64] = mem[64] + 64
                mem[_100] = 26
                mem[_100 + 32] = 'SafeMath: division by zero'
                if not totalSupply:
                    _104 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _104 + 68] = mem[idx + _100 + 32]
                        idx = idx + 32
                        continue 
                    mem[_104 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _104 + -mem[64] + 100
                _125 = mem[64]
                mem[64] = mem[64] + 64
                mem[_125] = 26
                mem[_125 + 32] = 'SafeMath: division by zero'
                if stor11 / totalSupply:
                    stor2[address(arg1)] = stor1[address(arg1)] / stor11 / totalSupply
                    stor8[address(arg1)] = 1
                    stor9.length++
                    stor9[stor9.length] = arg1
                _134 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _134 + 68] = mem[idx + _125 + 32]
                    idx = idx + 32
                    continue 
                mem[_134 + 94] = 0
                revert with memory
                  from mem[64]
                   len _134 + -mem[64] + 100
            if idx >= stor9.length:
                revert with 0, 50
            mem[0] = stor9[idx]
            mem[32] = 2
            if stor2[stor9[idx]] > s:
                _106 = mem[64]
                mem[64] = mem[64] + 64
                mem[_106] = 26
                mem[_106 + 32] = 'SafeMath: division by zero'
                if not totalSupply:
                    _111 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _111 + 68] = mem[idx + _106 + 32]
                        idx = idx + 32
                        continue 
                    mem[_111 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _111 + -mem[64] + 100
                _136 = mem[64]
                mem[64] = mem[64] + 64
                mem[_136] = 26
                mem[_136 + 32] = 'SafeMath: division by zero'
                if stor11 / totalSupply:
                    stor2[address(arg1)] = stor1[address(arg1)] / stor11 / totalSupply
                    stor8[address(arg1)] = 1
                    stor9.length++
                    stor9[stor9.length] = arg1
                _141 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _141 + 68] = mem[idx + _136 + 32]
                    idx = idx + 32
                    continue 
                mem[_141 + 94] = 0
                revert with memory
                  from mem[64]
                   len _141 + -mem[64] + 100
            if idx >= stor9.length:
                revert with 0, 50
            mem[0] = stor9[idx]
            mem[32] = 1
            _105 = mem[64]
            mem[64] = mem[64] + 64
            mem[_105] = 30
            mem[_105 + 32] = 'SafeMath: subtraction overflow'
            if stor1[stor9[idx]] > t:
                _110 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _110 + 68] = mem[idx + _105 + 32]
                    idx = idx + 32
                    continue 
                mem[_110 + 98] = 0
                revert with memory
                  from mem[64]
                   len _110 + -mem[64] + 100
            if t < stor1[stor9[idx]]:
                revert with 0, 17
            if idx >= stor9.length:
                revert with 0, 50
            mem[0] = stor9[idx]
            mem[32] = 2
            _135 = mem[64]
            mem[64] = mem[64] + 64
            mem[_135] = 30
            mem[_135 + 32] = 'SafeMath: subtraction overflow'
            if stor2[stor9[idx]] <= s:
                if s < stor2[stor9[idx]]:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s - stor2[stor9[idx]]
                t = t - stor1[stor9[idx]]
                continue 
            _140 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[idx + _140 + 68] = mem[idx + _135 + 32]
                idx = idx + 32
                continue 
            mem[_140 + 98] = 0
            revert with memory
              from mem[64]
               len _140 + -mem[64] + 100
        if not totalSupply:
            revert with 0, 'SafeMath: division by zero', 0
        if t >= stor11 / totalSupply:
            if not s:
                revert with 0, 'SafeMath: division by zero', 0
            if not t / s:
                revert with 0, 'SafeMath: division by zero', 0
            stor2[address(arg1)] = stor1[address(arg1)] / t / s
        else:
            if not totalSupply:
                revert with 0, 'SafeMath: division by zero', 0
            if not stor11 / totalSupply:
                revert with 0, 'SafeMath: division by zero', 0
            stor2[address(arg1)] = stor1[address(arg1)] / stor11 / totalSupply
    stor8[address(arg1)] = 1
    stor9.length++
    stor9[stor9.length] = arg1
}

function excludeFromReward(address arg1) payable {
    mem[64] = 96
    require not msg.value
    require calldata.size - 4 >= 32
    require arg1 == arg1
    if owner != msg.sender:
        revert with 0, 'Ownable: caller is not the owner'
    if stor8[address(arg1)]:
        revert with 0, 'Account is already excluded'
    if stor1[address(arg1)]:
        mem[0] = arg1
        mem[32] = 1
        if stor1[address(arg1)] > stor11:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'Amount must be less than total reflections'
        idx = 0
        s = totalSupply
        t = stor11
        while idx < stor9.length:
            mem[0] = stor9[idx]
            mem[32] = 1
            if stor1[stor9[idx]] > t:
                _100 = mem[64]
                mem[64] = mem[64] + 64
                mem[_100] = 26
                mem[_100 + 32] = 'SafeMath: division by zero'
                if not totalSupply:
                    _104 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _104 + 68] = mem[idx + _100 + 32]
                        idx = idx + 32
                        continue 
                    mem[_104 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _104 + -mem[64] + 100
                _125 = mem[64]
                mem[64] = mem[64] + 64
                mem[_125] = 26
                mem[_125 + 32] = 'SafeMath: division by zero'
                if stor11 / totalSupply:
                    stor2[address(arg1)] = stor1[address(arg1)] / stor11 / totalSupply
                    stor8[address(arg1)] = 1
                    stor9.length++
                    stor9[stor9.length] = arg1
                _134 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _134 + 68] = mem[idx + _125 + 32]
                    idx = idx + 32
                    continue 
                mem[_134 + 94] = 0
                revert with memory
                  from mem[64]
                   len _134 + -mem[64] + 100
            if idx >= stor9.length:
                revert with 0, 50
            mem[0] = stor9[idx]
            mem[32] = 2
            if stor2[stor9[idx]] > s:
                _106 = mem[64]
                mem[64] = mem[64] + 64
                mem[_106] = 26
                mem[_106 + 32] = 'SafeMath: division by zero'
                if not totalSupply:
                    _111 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _111 + 68] = mem[idx + _106 + 32]
                        idx = idx + 32
                        continue 
                    mem[_111 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _111 + -mem[64] + 100
                _136 = mem[64]
                mem[64] = mem[64] + 64
                mem[_136] = 26
                mem[_136 + 32] = 'SafeMath: division by zero'
                if stor11 / totalSupply:
                    stor2[address(arg1)] = stor1[address(arg1)] / stor11 / totalSupply
                    stor8[address(arg1)] = 1
                    stor9.length++
                    stor9[stor9.length] = arg1
                _141 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 26
                idx = 0
                while idx < 26:
                    mem[idx + _141 + 68] = mem[idx + _136 + 32]
                    idx = idx + 32
                    continue 
                mem[_141 + 94] = 0
                revert with memory
                  from mem[64]
                   len _141 + -mem[64] + 100
            if idx >= stor9.length:
                revert with 0, 50
            mem[0] = stor9[idx]
            mem[32] = 1
            _105 = mem[64]
            mem[64] = mem[64] + 64
            mem[_105] = 30
            mem[_105 + 32] = 'SafeMath: subtraction overflow'
            if stor1[stor9[idx]] > t:
                _110 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _110 + 68] = mem[idx + _105 + 32]
                    idx = idx + 32
                    continue 
                mem[_110 + 98] = 0
                revert with memory
                  from mem[64]
                   len _110 + -mem[64] + 100
            if t < stor1[stor9[idx]]:
                revert with 0, 17
            if idx >= stor9.length:
                revert with 0, 50
            mem[0] = stor9[idx]
            mem[32] = 2
            _135 = mem[64]
            mem[64] = mem[64] + 64
            mem[_135] = 30
            mem[_135 + 32] = 'SafeMath: subtraction overflow'
            if stor2[stor9[idx]] <= s:
                if s < stor2[stor9[idx]]:
                    revert with 0, 17
                if idx == -1:
                    revert with 0, 17
                idx = idx + 1
                s = s - stor2[stor9[idx]]
                t = t - stor1[stor9[idx]]
                continue 
            _140 = mem[64]
            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
            mem[mem[64] + 4] = 32
            mem[mem[64] + 36] = 30
            idx = 0
            while idx < 30:
                mem[idx + _140 + 68] = mem[idx + _135 + 32]
                idx = idx + 32
                continue 
            mem[_140 + 98] = 0
            revert with memory
              from mem[64]
               len _140 + -mem[64] + 100
        if not totalSupply:
            revert with 0, 'SafeMath: division by zero', 0
        if t >= stor11 / totalSupply:
            if not s:
                revert with 0, 'SafeMath: division by zero', 0
            if not t / s:
                revert with 0, 'SafeMath: division by zero', 0
            stor2[address(arg1)] = stor1[address(arg1)] / t / s
        else:
            if not totalSupply:
                revert with 0, 'SafeMath: division by zero', 0
            if not stor11 / totalSupply:
                revert with 0, 'SafeMath: division by zero', 0
            stor2[address(arg1)] = stor1[address(arg1)] / stor11 / totalSupply
    stor8[address(arg1)] = 1
    stor9.length++
    stor9[stor9.length] = arg1
}

function reflectionFromToken(uint256 arg1, bool arg2) {
    require calldata.size - 4 >= 64
    require arg2 == arg2
    if arg1 > totalSupply:
        revert with 0, 'Amount must be less than supply'
    if arg2:
        if not arg1:
            mem[96] = 26
            mem[128] = 'SafeMath: division by zero'
            if not arg1:
                mem[160] = 26
                mem[192] = 'SafeMath: division by zero'
                if not arg1:
                    mem[224] = 26
                    mem[256] = 'SafeMath: division by zero'
                    if not arg1:
                        mem[288] = 26
                        mem[320] = 'SafeMath: division by zero'
                        mem[352] = 30
                        mem[384] = 'SafeMath: subtraction overflow'
                        if 0 > arg1:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 < 0:
                            revert with 0, 17
                        mem[416] = 30
                        mem[448] = 'SafeMath: subtraction overflow'
                        if 0 > arg1:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 < 0:
                            revert with 0, 17
                        mem[64] = 544
                        mem[480] = 30
                        mem[512] = 'SafeMath: subtraction overflow'
                        if 0 > arg1:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 < 0:
                            revert with 0, 17
                        idx = 0
                        s = totalSupply
                        t = stor11
                        while idx < stor9.length:
                            mem[0] = stor9[idx]
                            mem[32] = 1
                            if stor1[stor9[idx]] > t:
                                _11644 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11644] = 26
                                mem[_11644 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    _11802 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _11802 + 68] = mem[idx + _11644 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_11802 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _11802 + -mem[64] + 100
                                if not arg1:
                                    return 0
                                if arg1 and stor11 / totalSupply > -1 / arg1:
                                    revert with 0, 17
                                if not arg1:
                                    revert with 0, 18
                                if arg1 * stor11 / totalSupply / arg1 != stor11 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _13540 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13540] = 30
                                mem[_13540 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor11 / totalSupply:
                                    _13798 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _13798 + 68] = mem[idx + _13540 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_13798 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _13798 + -mem[64] + 100
                                if arg1 * stor11 / totalSupply < 0:
                                    revert with 0, 17
                                _14911 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14911] = 30
                                mem[_14911 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= arg1 * stor11 / totalSupply:
                                    if arg1 * stor11 / totalSupply < 0:
                                        revert with 0, 17
                                    return (arg1 * stor11 / totalSupply)
                                _15462 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _15462 + 68] = mem[idx + _14911 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15462 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _15462 + -mem[64] + 100
                            if idx >= stor9.length:
                                revert with 0, 50
                            mem[0] = stor9[idx]
                            mem[32] = 2
                            if stor2[stor9[idx]] <= s:
                                if idx >= stor9.length:
                                    revert with 0, 50
                                mem[0] = stor9[idx]
                                mem[32] = 1
                                _11803 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11803] = 30
                                mem[_11803 + 32] = 'SafeMath: subtraction overflow'
                                if stor1[stor9[idx]] > t:
                                    _11963 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _11963 + 68] = mem[idx + _11803 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_11963 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _11963 + -mem[64] + 100
                                if t < stor1[stor9[idx]]:
                                    revert with 0, 17
                                if idx >= stor9.length:
                                    revert with 0, 50
                                mem[0] = stor9[idx]
                                mem[32] = 2
                                _12668 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12668] = 30
                                mem[_12668 + 32] = 'SafeMath: subtraction overflow'
                                if stor2[stor9[idx]] <= s:
                                    if s < stor2[stor9[idx]]:
                                        revert with 0, 17
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s - stor2[stor9[idx]]
                                    t = t - stor1[stor9[idx]]
                                    continue 
                                _12764 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _12764 + 68] = mem[idx + _12668 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12764 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12764 + -mem[64] + 100
                            _11804 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11804] = 26
                            mem[_11804 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                _11964 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _11964 + 68] = mem[idx + _11804 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11964 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _11964 + -mem[64] + 100
                            if not arg1:
                                return 0
                            if arg1 and stor11 / totalSupply > -1 / arg1:
                                revert with 0, 17
                            if not arg1:
                                revert with 0, 18
                            if arg1 * stor11 / totalSupply / arg1 != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _13800 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13800] = 30
                            mem[_13800 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor11 / totalSupply:
                                _14029 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _14029 + 68] = mem[idx + _13800 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14029 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14029 + -mem[64] + 100
                            if arg1 * stor11 / totalSupply < 0:
                                revert with 0, 17
                            _15463 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15463] = 30
                            mem[_15463 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor11 / totalSupply:
                                if arg1 * stor11 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor11 / totalSupply)
                            _16084 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _16084 + 68] = mem[idx + _15463 + 32]
                                idx = idx + 32
                                continue 
                            mem[_16084 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _16084 + -mem[64] + 100
                    else:
                        if arg1 and stor35 > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor35 / arg1 != stor35:
                            revert with 0, 'SafeMath: multiplication overflow'
                        mem[288] = 26
                        mem[320] = 'SafeMath: division by zero'
                        mem[352] = 30
                        mem[384] = 'SafeMath: subtraction overflow'
                        if 0 > arg1:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 < 0:
                            revert with 0, 17
                        mem[416] = 30
                        mem[448] = 'SafeMath: subtraction overflow'
                        if 0 > arg1:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 < 0:
                            revert with 0, 17
                        mem[64] = 544
                        mem[480] = 30
                        mem[512] = 'SafeMath: subtraction overflow'
                        if arg1 * stor35 / 100 > arg1:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 < arg1 * stor35 / 100:
                            revert with 0, 17
                        idx = 0
                        s = totalSupply
                        t = stor11
                        while idx < stor9.length:
                            mem[0] = stor9[idx]
                            mem[32] = 1
                            if stor1[stor9[idx]] > t:
                                _11643 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11643] = 26
                                mem[_11643 + 32] = 'SafeMath: division by zero'
                                if not totalSupply:
                                    _11799 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 26
                                    idx = 0
                                    while idx < 26:
                                        mem[idx + _11799 + 68] = mem[idx + _11643 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_11799 + 94] = 0
                                    revert with memory
                                      from mem[64]
                                       len _11799 + -mem[64] + 100
                                if not arg1:
                                    return 0
                                if arg1 and stor11 / totalSupply > -1 / arg1:
                                    revert with 0, 17
                                if not arg1:
                                    revert with 0, 18
                                if arg1 * stor11 / totalSupply / arg1 != stor11 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _13537 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13537] = 30
                                mem[_13537 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor11 / totalSupply:
                                    _13795 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _13795 + 68] = mem[idx + _13537 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_13795 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _13795 + -mem[64] + 100
                                if arg1 * stor11 / totalSupply < 0:
                                    revert with 0, 17
                                _14905 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14905] = 30
                                mem[_14905 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= arg1 * stor11 / totalSupply:
                                    if arg1 * stor11 / totalSupply < 0:
                                        revert with 0, 17
                                    return (arg1 * stor11 / totalSupply)
                                _15459 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _15459 + 68] = mem[idx + _14905 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15459 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _15459 + -mem[64] + 100
                            if idx >= stor9.length:
                                revert with 0, 50
                            mem[0] = stor9[idx]
                            mem[32] = 2
                            if stor2[stor9[idx]] <= s:
                                if idx >= stor9.length:
                                    revert with 0, 50
                                mem[0] = stor9[idx]
                                mem[32] = 1
                                _11800 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_11800] = 30
                                mem[_11800 + 32] = 'SafeMath: subtraction overflow'
                                if stor1[stor9[idx]] > t:
                                    _11960 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _11960 + 68] = mem[idx + _11800 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_11960 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _11960 + -mem[64] + 100
                                if t < stor1[stor9[idx]]:
                                    revert with 0, 17
                                if idx >= stor9.length:
                                    revert with 0, 50
                                mem[0] = stor9[idx]
                                mem[32] = 2
                                _12665 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_12665] = 30
                                mem[_12665 + 32] = 'SafeMath: subtraction overflow'
                                if stor2[stor9[idx]] <= s:
                                    if s < stor2[stor9[idx]]:
                                        revert with 0, 17
                                    if idx == -1:
                                        revert with 0, 17
                                    idx = idx + 1
                                    s = s - stor2[stor9[idx]]
                                    t = t - stor1[stor9[idx]]
                                    continue 
                                _12761 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _12761 + 68] = mem[idx + _12665 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12761 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12761 + -mem[64] + 100
                            _11801 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11801] = 26
                            mem[_11801 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                _11961 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _11961 + 68] = mem[idx + _11801 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11961 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _11961 + -mem[64] + 100
                            if not arg1:
                                return 0
                            if arg1 and stor11 / totalSupply > -1 / arg1:
                                revert with 0, 17
                            if not arg1:
                                revert with 0, 18
                            if arg1 * stor11 / totalSupply / arg1 != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _13797 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13797] = 30
                            mem[_13797 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor11 / totalSupply:
                                _14027 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _14027 + 68] = mem[idx + _13797 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14027 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14027 + -mem[64] + 100
                            if arg1 * stor11 / totalSupply < 0:
                                revert with 0, 17
                            _15460 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15460] = 30
                            mem[_15460 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor11 / totalSupply:
                                if arg1 * stor11 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor11 / totalSupply)
                            _16083 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _16083 + 68] = mem[idx + _15460 + 32]
                                idx = idx + 32
                                continue 
                            mem[_16083 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _16083 + -mem[64] + 100
                    if not totalSupply:
                        revert with 0, 'SafeMath: division by zero', 0
                    if t >= stor11 / totalSupply:
                        if not s:
                            revert with 0, 'SafeMath: division by zero', 0
                        if not arg1:
                            return 0
                        if arg1 and t / s > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * t / s / arg1 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        return (arg1 * t / s)
                    if not totalSupply:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg1:
                        return 0
                    if arg1 and stor11 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor11 / totalSupply / arg1 != stor11 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 > arg1 * stor11 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor11 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor11 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor11 / totalSupply < 0:
                        revert with 0, 17
                    return (arg1 * stor11 / totalSupply)
                if arg1 and stor30 > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor30 / arg1 != stor30:
                    revert with 0, 'SafeMath: multiplication overflow'
                mem[224] = 26
                mem[256] = 'SafeMath: division by zero'
                if not arg1:
                    mem[288] = 26
                    mem[320] = 'SafeMath: division by zero'
                    if 0 > !(arg1 * stor30 / 100):
                        revert with 0, 17
                    if arg1 * stor30 / 100 < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[352] = 30
                    mem[384] = 'SafeMath: subtraction overflow'
                    if 0 > arg1:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 < 0:
                        revert with 0, 17
                    mem[416] = 30
                    mem[448] = 'SafeMath: subtraction overflow'
                    if arg1 * stor30 / 100 > arg1:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 < arg1 * stor30 / 100:
                        revert with 0, 17
                    mem[64] = 544
                    mem[480] = 30
                    mem[512] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 - (arg1 * stor30 / 100):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 - (arg1 * stor30 / 100) < 0:
                        revert with 0, 17
                    if 0 > !(arg1 * stor30 / 100):
                        revert with 0, 17
                    if arg1 * stor30 / 100 < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    idx = 0
                    s = totalSupply
                    t = stor11
                    while idx < stor9.length:
                        mem[0] = stor9[idx]
                        mem[32] = 1
                        if stor1[stor9[idx]] > t:
                            _11642 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11642] = 26
                            mem[_11642 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                _11796 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _11796 + 68] = mem[idx + _11642 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11796 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _11796 + -mem[64] + 100
                            if not arg1:
                                if not arg1 * stor30 / 100:
                                    return 0
                                if arg1 * stor30 / 100 and stor11 / totalSupply > -1 / arg1 * stor30 / 100:
                                    revert with 0, 17
                                if not arg1 * stor30 / 100:
                                    revert with 0, 18
                                if arg1 * stor30 / 100 * stor11 / totalSupply / arg1 * stor30 / 100 != stor11 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _13533 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13533] = 30
                                mem[_13533 + 32] = 'SafeMath: subtraction overflow'
                                _14899 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14899] = 30
                                mem[_14899 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * stor30 / 100 * stor11 / totalSupply <= 0:
                                    if 0 < arg1 * stor30 / 100 * stor11 / totalSupply:
                                        revert with 0, 17
                                    return (-1 * arg1 * stor30 / 100 * stor11 / totalSupply)
                                _15454 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _15454 + 68] = mem[idx + _14899 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15454 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _15454 + -mem[64] + 100
                            if arg1 and stor11 / totalSupply > -1 / arg1:
                                revert with 0, 17
                            if not arg1:
                                revert with 0, 18
                            if arg1 * stor11 / totalSupply / arg1 != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * stor30 / 100:
                                _13532 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13532] = 30
                                mem[_13532 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor11 / totalSupply:
                                    _13791 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _13791 + 68] = mem[idx + _13532 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_13791 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _13791 + -mem[64] + 100
                                if arg1 * stor11 / totalSupply < 0:
                                    revert with 0, 17
                                _14897 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14897] = 30
                                mem[_14897 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= arg1 * stor11 / totalSupply:
                                    if arg1 * stor11 / totalSupply < 0:
                                        revert with 0, 17
                                    return (arg1 * stor11 / totalSupply)
                                _15453 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _15453 + 68] = mem[idx + _14897 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15453 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _15453 + -mem[64] + 100
                            if arg1 * stor30 / 100 and stor11 / totalSupply > -1 / arg1 * stor30 / 100:
                                revert with 0, 17
                            if not arg1 * stor30 / 100:
                                revert with 0, 18
                            if arg1 * stor30 / 100 * stor11 / totalSupply / arg1 * stor30 / 100 != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _14419 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14419] = 30
                            mem[_14419 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor11 / totalSupply:
                                _14896 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _14896 + 68] = mem[idx + _14419 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14896 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14896 + -mem[64] + 100
                            if arg1 * stor11 / totalSupply < 0:
                                revert with 0, 17
                            _16812 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_16812] = 30
                            mem[_16812 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor30 / 100 * stor11 / totalSupply <= arg1 * stor11 / totalSupply:
                                if arg1 * stor11 / totalSupply < arg1 * stor30 / 100 * stor11 / totalSupply:
                                    revert with 0, 17
                                return ((arg1 * stor11 / totalSupply) - (arg1 * stor30 / 100 * stor11 / totalSupply))
                            _17627 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _17627 + 68] = mem[idx + _16812 + 32]
                                idx = idx + 32
                                continue 
                            mem[_17627 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _17627 + -mem[64] + 100
                        if idx >= stor9.length:
                            revert with 0, 50
                        mem[0] = stor9[idx]
                        mem[32] = 2
                        if stor2[stor9[idx]] <= s:
                            if idx >= stor9.length:
                                revert with 0, 50
                            mem[0] = stor9[idx]
                            mem[32] = 1
                            _11797 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11797] = 30
                            mem[_11797 + 32] = 'SafeMath: subtraction overflow'
                            if stor1[stor9[idx]] > t:
                                _11957 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11957 + 68] = mem[idx + _11797 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11957 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11957 + -mem[64] + 100
                            if t < stor1[stor9[idx]]:
                                revert with 0, 17
                            if idx >= stor9.length:
                                revert with 0, 50
                            mem[0] = stor9[idx]
                            mem[32] = 2
                            _12662 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12662] = 30
                            mem[_12662 + 32] = 'SafeMath: subtraction overflow'
                            if stor2[stor9[idx]] <= s:
                                if s < stor2[stor9[idx]]:
                                    revert with 0, 17
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s - stor2[stor9[idx]]
                                t = t - stor1[stor9[idx]]
                                continue 
                            _12758 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12758 + 68] = mem[idx + _12662 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12758 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12758 + -mem[64] + 100
                        _11798 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11798] = 26
                        mem[_11798 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _11958 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _11958 + 68] = mem[idx + _11798 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11958 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _11958 + -mem[64] + 100
                        if not arg1:
                            if not arg1 * stor30 / 100:
                                return 0
                            if arg1 * stor30 / 100 and stor11 / totalSupply > -1 / arg1 * stor30 / 100:
                                revert with 0, 17
                            if not arg1 * stor30 / 100:
                                revert with 0, 18
                            if arg1 * stor30 / 100 * stor11 / totalSupply / arg1 * stor30 / 100 != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _13794 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13794] = 30
                            mem[_13794 + 32] = 'SafeMath: subtraction overflow'
                            _15458 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15458] = 30
                            mem[_15458 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor30 / 100 * stor11 / totalSupply <= 0:
                                if 0 < arg1 * stor30 / 100 * stor11 / totalSupply:
                                    revert with 0, 17
                                return (-1 * arg1 * stor30 / 100 * stor11 / totalSupply)
                            _16082 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _16082 + 68] = mem[idx + _15458 + 32]
                                idx = idx + 32
                                continue 
                            mem[_16082 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _16082 + -mem[64] + 100
                        if arg1 and stor11 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor11 / totalSupply / arg1 != stor11 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor30 / 100:
                            _13793 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13793] = 30
                            mem[_13793 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor11 / totalSupply:
                                _14025 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _14025 + 68] = mem[idx + _13793 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14025 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14025 + -mem[64] + 100
                            if arg1 * stor11 / totalSupply < 0:
                                revert with 0, 17
                            _15456 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15456] = 30
                            mem[_15456 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor11 / totalSupply:
                                if arg1 * stor11 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor11 / totalSupply)
                            _16081 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _16081 + 68] = mem[idx + _15456 + 32]
                                idx = idx + 32
                                continue 
                            mem[_16081 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _16081 + -mem[64] + 100
                        if arg1 * stor30 / 100 and stor11 / totalSupply > -1 / arg1 * stor30 / 100:
                            revert with 0, 17
                        if not arg1 * stor30 / 100:
                            revert with 0, 18
                        if arg1 * stor30 / 100 * stor11 / totalSupply / arg1 * stor30 / 100 != stor11 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _14900 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14900] = 30
                        mem[_14900 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor11 / totalSupply:
                            _15455 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _15455 + 68] = mem[idx + _14900 + 32]
                                idx = idx + 32
                                continue 
                            mem[_15455 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _15455 + -mem[64] + 100
                        if arg1 * stor11 / totalSupply < 0:
                            revert with 0, 17
                        _17630 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_17630] = 30
                        mem[_17630 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor30 / 100 * stor11 / totalSupply <= arg1 * stor11 / totalSupply:
                            if arg1 * stor11 / totalSupply < arg1 * stor30 / 100 * stor11 / totalSupply:
                                revert with 0, 17
                            return ((arg1 * stor11 / totalSupply) - (arg1 * stor30 / 100 * stor11 / totalSupply))
                        _18350 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _18350 + 68] = mem[idx + _17630 + 32]
                            idx = idx + 32
                            continue 
                        mem[_18350 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _18350 + -mem[64] + 100
                else:
                    if arg1 and stor35 > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor35 / arg1 != stor35:
                        revert with 0, 'SafeMath: multiplication overflow'
                    mem[288] = 26
                    mem[320] = 'SafeMath: division by zero'
                    if 0 > !(arg1 * stor30 / 100):
                        revert with 0, 17
                    if arg1 * stor30 / 100 < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[352] = 30
                    mem[384] = 'SafeMath: subtraction overflow'
                    if 0 > arg1:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 < 0:
                        revert with 0, 17
                    mem[416] = 30
                    mem[448] = 'SafeMath: subtraction overflow'
                    if arg1 * stor30 / 100 > arg1:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 < arg1 * stor30 / 100:
                        revert with 0, 17
                    mem[64] = 544
                    mem[480] = 30
                    mem[512] = 'SafeMath: subtraction overflow'
                    if arg1 * stor35 / 100 > arg1 - (arg1 * stor30 / 100):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 - (arg1 * stor30 / 100) < arg1 * stor35 / 100:
                        revert with 0, 17
                    if 0 > !(arg1 * stor30 / 100):
                        revert with 0, 17
                    if arg1 * stor30 / 100 < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    idx = 0
                    s = totalSupply
                    t = stor11
                    while idx < stor9.length:
                        mem[0] = stor9[idx]
                        mem[32] = 1
                        if stor1[stor9[idx]] > t:
                            _11641 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11641] = 26
                            mem[_11641 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                _11793 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _11793 + 68] = mem[idx + _11641 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11793 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _11793 + -mem[64] + 100
                            if not arg1:
                                if not arg1 * stor30 / 100:
                                    return 0
                                if arg1 * stor30 / 100 and stor11 / totalSupply > -1 / arg1 * stor30 / 100:
                                    revert with 0, 17
                                if not arg1 * stor30 / 100:
                                    revert with 0, 18
                                if arg1 * stor30 / 100 * stor11 / totalSupply / arg1 * stor30 / 100 != stor11 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _13528 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13528] = 30
                                mem[_13528 + 32] = 'SafeMath: subtraction overflow'
                                _14890 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14890] = 30
                                mem[_14890 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * stor30 / 100 * stor11 / totalSupply <= 0:
                                    if 0 < arg1 * stor30 / 100 * stor11 / totalSupply:
                                        revert with 0, 17
                                    return (-1 * arg1 * stor30 / 100 * stor11 / totalSupply)
                                _15446 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _15446 + 68] = mem[idx + _14890 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15446 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _15446 + -mem[64] + 100
                            if arg1 and stor11 / totalSupply > -1 / arg1:
                                revert with 0, 17
                            if not arg1:
                                revert with 0, 18
                            if arg1 * stor11 / totalSupply / arg1 != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * stor30 / 100:
                                _13527 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13527] = 30
                                mem[_13527 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor11 / totalSupply:
                                    _13787 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _13787 + 68] = mem[idx + _13527 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_13787 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _13787 + -mem[64] + 100
                                if arg1 * stor11 / totalSupply < 0:
                                    revert with 0, 17
                                _14888 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14888] = 30
                                mem[_14888 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= arg1 * stor11 / totalSupply:
                                    if arg1 * stor11 / totalSupply < 0:
                                        revert with 0, 17
                                    return (arg1 * stor11 / totalSupply)
                                _15445 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _15445 + 68] = mem[idx + _14888 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15445 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _15445 + -mem[64] + 100
                            if arg1 * stor30 / 100 and stor11 / totalSupply > -1 / arg1 * stor30 / 100:
                                revert with 0, 17
                            if not arg1 * stor30 / 100:
                                revert with 0, 18
                            if arg1 * stor30 / 100 * stor11 / totalSupply / arg1 * stor30 / 100 != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _14413 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14413] = 30
                            mem[_14413 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor11 / totalSupply:
                                _14887 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _14887 + 68] = mem[idx + _14413 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14887 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14887 + -mem[64] + 100
                            if arg1 * stor11 / totalSupply < 0:
                                revert with 0, 17
                            _16801 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_16801] = 30
                            mem[_16801 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor30 / 100 * stor11 / totalSupply <= arg1 * stor11 / totalSupply:
                                if arg1 * stor11 / totalSupply < arg1 * stor30 / 100 * stor11 / totalSupply:
                                    revert with 0, 17
                                return ((arg1 * stor11 / totalSupply) - (arg1 * stor30 / 100 * stor11 / totalSupply))
                            _17617 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _17617 + 68] = mem[idx + _16801 + 32]
                                idx = idx + 32
                                continue 
                            mem[_17617 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _17617 + -mem[64] + 100
                        if idx >= stor9.length:
                            revert with 0, 50
                        mem[0] = stor9[idx]
                        mem[32] = 2
                        if stor2[stor9[idx]] <= s:
                            if idx >= stor9.length:
                                revert with 0, 50
                            mem[0] = stor9[idx]
                            mem[32] = 1
                            _11794 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11794] = 30
                            mem[_11794 + 32] = 'SafeMath: subtraction overflow'
                            if stor1[stor9[idx]] > t:
                                _11954 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11954 + 68] = mem[idx + _11794 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11954 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11954 + -mem[64] + 100
                            if t < stor1[stor9[idx]]:
                                revert with 0, 17
                            if idx >= stor9.length:
                                revert with 0, 50
                            mem[0] = stor9[idx]
                            mem[32] = 2
                            _12659 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12659] = 30
                            mem[_12659 + 32] = 'SafeMath: subtraction overflow'
                            if stor2[stor9[idx]] <= s:
                                if s < stor2[stor9[idx]]:
                                    revert with 0, 17
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s - stor2[stor9[idx]]
                                t = t - stor1[stor9[idx]]
                                continue 
                            _12755 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12755 + 68] = mem[idx + _12659 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12755 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12755 + -mem[64] + 100
                        _11795 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11795] = 26
                        mem[_11795 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _11955 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _11955 + 68] = mem[idx + _11795 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11955 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _11955 + -mem[64] + 100
                        if not arg1:
                            if not arg1 * stor30 / 100:
                                return 0
                            if arg1 * stor30 / 100 and stor11 / totalSupply > -1 / arg1 * stor30 / 100:
                                revert with 0, 17
                            if not arg1 * stor30 / 100:
                                revert with 0, 18
                            if arg1 * stor30 / 100 * stor11 / totalSupply / arg1 * stor30 / 100 != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _13790 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13790] = 30
                            mem[_13790 + 32] = 'SafeMath: subtraction overflow'
                            _15450 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15450] = 30
                            mem[_15450 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor30 / 100 * stor11 / totalSupply <= 0:
                                if 0 < arg1 * stor30 / 100 * stor11 / totalSupply:
                                    revert with 0, 17
                                return (-1 * arg1 * stor30 / 100 * stor11 / totalSupply)
                            _16078 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _16078 + 68] = mem[idx + _15450 + 32]
                                idx = idx + 32
                                continue 
                            mem[_16078 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _16078 + -mem[64] + 100
                        if arg1 and stor11 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor11 / totalSupply / arg1 != stor11 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor30 / 100:
                            _13789 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13789] = 30
                            mem[_13789 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor11 / totalSupply:
                                _14020 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _14020 + 68] = mem[idx + _13789 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14020 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14020 + -mem[64] + 100
                            if arg1 * stor11 / totalSupply < 0:
                                revert with 0, 17
                            _15448 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15448] = 30
                            mem[_15448 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor11 / totalSupply:
                                if arg1 * stor11 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor11 / totalSupply)
                            _16077 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _16077 + 68] = mem[idx + _15448 + 32]
                                idx = idx + 32
                                continue 
                            mem[_16077 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _16077 + -mem[64] + 100
                        if arg1 * stor30 / 100 and stor11 / totalSupply > -1 / arg1 * stor30 / 100:
                            revert with 0, 17
                        if not arg1 * stor30 / 100:
                            revert with 0, 18
                        if arg1 * stor30 / 100 * stor11 / totalSupply / arg1 * stor30 / 100 != stor11 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _14891 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14891] = 30
                        mem[_14891 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor11 / totalSupply:
                            _15447 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _15447 + 68] = mem[idx + _14891 + 32]
                                idx = idx + 32
                                continue 
                            mem[_15447 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _15447 + -mem[64] + 100
                        if arg1 * stor11 / totalSupply < 0:
                            revert with 0, 17
                        _17620 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_17620] = 30
                        mem[_17620 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor30 / 100 * stor11 / totalSupply <= arg1 * stor11 / totalSupply:
                            if arg1 * stor11 / totalSupply < arg1 * stor30 / 100 * stor11 / totalSupply:
                                revert with 0, 17
                            return ((arg1 * stor11 / totalSupply) - (arg1 * stor30 / 100 * stor11 / totalSupply))
                        _18347 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _18347 + 68] = mem[idx + _17620 + 32]
                            idx = idx + 32
                            continue 
                        mem[_18347 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _18347 + -mem[64] + 100
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if t >= stor11 / totalSupply:
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg1:
                        if not arg1 * stor30 / 100:
                            return 0
                        if arg1 * stor30 / 100 and t / s > -1 / arg1 * stor30 / 100:
                            revert with 0, 17
                        if not arg1 * stor30 / 100:
                            revert with 0, 18
                        if arg1 * stor30 / 100 * t / s / arg1 * stor30 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * stor30 / 100 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * stor30 / 100 * t / s:
                            revert with 0, 17
                        return (-1 * arg1 * stor30 / 100 * t / s)
                    if arg1 and t / s > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor30 / 100:
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        return (arg1 * t / s)
                    if arg1 * stor30 / 100 and t / s > -1 / arg1 * stor30 / 100:
                        revert with 0, 17
                    if not arg1 * stor30 / 100:
                        revert with 0, 18
                    if arg1 * stor30 / 100 * t / s / arg1 * stor30 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 0, 17
                    if arg1 * stor30 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * stor30 / 100 * t / s:
                        revert with 0, 17
                    return ((arg1 * t / s) - (arg1 * stor30 / 100 * t / s))
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if not arg1 * stor30 / 100:
                        return 0
                    if arg1 * stor30 / 100 and stor11 / totalSupply > -1 / arg1 * stor30 / 100:
                        revert with 0, 17
                    if not arg1 * stor30 / 100:
                        revert with 0, 18
                    if arg1 * stor30 / 100 * stor11 / totalSupply / arg1 * stor30 / 100 != stor11 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * stor30 / 100 * stor11 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * stor30 / 100 * stor11 / totalSupply:
                        revert with 0, 17
                    return (-1 * arg1 * stor30 / 100 * stor11 / totalSupply)
                if arg1 and stor11 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor11 / totalSupply / arg1 != stor11 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor30 / 100:
                    if 0 > arg1 * stor11 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor11 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor11 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor11 / totalSupply < 0:
                        revert with 0, 17
                    return (arg1 * stor11 / totalSupply)
                if arg1 * stor30 / 100 and stor11 / totalSupply > -1 / arg1 * stor30 / 100:
                    revert with 0, 17
                if not arg1 * stor30 / 100:
                    revert with 0, 18
                if arg1 * stor30 / 100 * stor11 / totalSupply / arg1 * stor30 / 100 != stor11 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 0 > arg1 * stor11 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor11 / totalSupply < 0:
                    revert with 0, 17
                if arg1 * stor30 / 100 * stor11 / totalSupply > arg1 * stor11 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor11 / totalSupply < arg1 * stor30 / 100 * stor11 / totalSupply:
                    revert with 0, 17
                return ((arg1 * stor11 / totalSupply) - (arg1 * stor30 / 100 * stor11 / totalSupply))
            if arg1 and stor25 > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * stor25 / arg1 != stor25:
                revert with 0, 'SafeMath: multiplication overflow'
            mem[160] = 26
            mem[192] = 'SafeMath: division by zero'
            if not arg1:
                mem[224] = 26
                mem[256] = 'SafeMath: division by zero'
                if not arg1:
                    mem[288] = 26
                    mem[320] = 'SafeMath: division by zero'
                    if arg1 * stor25 / 100 > -1:
                        revert with 0, 17
                    if arg1 * stor25 / 100 < arg1 * stor25 / 100:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[352] = 30
                    mem[384] = 'SafeMath: subtraction overflow'
                    if 0 > arg1:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 < 0:
                        revert with 0, 17
                    mem[416] = 30
                    mem[448] = 'SafeMath: subtraction overflow'
                    if arg1 * stor25 / 100 > arg1:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 < arg1 * stor25 / 100:
                        revert with 0, 17
                    mem[64] = 544
                    mem[480] = 30
                    mem[512] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 - (arg1 * stor25 / 100):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 - (arg1 * stor25 / 100) < 0:
                        revert with 0, 17
                    if arg1 * stor25 / 100 > -1:
                        revert with 0, 17
                    if arg1 * stor25 / 100 < arg1 * stor25 / 100:
                        revert with 0, 'SafeMath: addition overflow'
                    idx = 0
                    s = totalSupply
                    t = stor11
                    while idx < stor9.length:
                        mem[0] = stor9[idx]
                        mem[32] = 1
                        if stor1[stor9[idx]] > t:
                            _11640 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11640] = 26
                            mem[_11640 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                _11790 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _11790 + 68] = mem[idx + _11640 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11790 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _11790 + -mem[64] + 100
                            if not arg1:
                                if not arg1 * stor25 / 100:
                                    return 0
                                if arg1 * stor25 / 100 and stor11 / totalSupply > -1 / arg1 * stor25 / 100:
                                    revert with 0, 17
                                if not arg1 * stor25 / 100:
                                    revert with 0, 18
                                if arg1 * stor25 / 100 * stor11 / totalSupply / arg1 * stor25 / 100 != stor11 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _13523 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13523] = 30
                                mem[_13523 + 32] = 'SafeMath: subtraction overflow'
                                _14881 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14881] = 30
                                mem[_14881 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * stor25 / 100 * stor11 / totalSupply <= 0:
                                    if 0 < arg1 * stor25 / 100 * stor11 / totalSupply:
                                        revert with 0, 17
                                    return (-1 * arg1 * stor25 / 100 * stor11 / totalSupply)
                                _15438 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _15438 + 68] = mem[idx + _14881 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15438 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _15438 + -mem[64] + 100
                            if arg1 and stor11 / totalSupply > -1 / arg1:
                                revert with 0, 17
                            if not arg1:
                                revert with 0, 18
                            if arg1 * stor11 / totalSupply / arg1 != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * stor25 / 100:
                                _13522 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13522] = 30
                                mem[_13522 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor11 / totalSupply:
                                    _13783 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _13783 + 68] = mem[idx + _13522 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_13783 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _13783 + -mem[64] + 100
                                if arg1 * stor11 / totalSupply < 0:
                                    revert with 0, 17
                                _14879 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14879] = 30
                                mem[_14879 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= arg1 * stor11 / totalSupply:
                                    if arg1 * stor11 / totalSupply < 0:
                                        revert with 0, 17
                                    return (arg1 * stor11 / totalSupply)
                                _15437 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _15437 + 68] = mem[idx + _14879 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15437 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _15437 + -mem[64] + 100
                            if arg1 * stor25 / 100 and stor11 / totalSupply > -1 / arg1 * stor25 / 100:
                                revert with 0, 17
                            if not arg1 * stor25 / 100:
                                revert with 0, 18
                            if arg1 * stor25 / 100 * stor11 / totalSupply / arg1 * stor25 / 100 != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _14407 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14407] = 30
                            mem[_14407 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor11 / totalSupply:
                                _14878 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _14878 + 68] = mem[idx + _14407 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14878 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14878 + -mem[64] + 100
                            if arg1 * stor11 / totalSupply < 0:
                                revert with 0, 17
                            _16790 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_16790] = 30
                            mem[_16790 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor25 / 100 * stor11 / totalSupply <= arg1 * stor11 / totalSupply:
                                if arg1 * stor11 / totalSupply < arg1 * stor25 / 100 * stor11 / totalSupply:
                                    revert with 0, 17
                                return ((arg1 * stor11 / totalSupply) - (arg1 * stor25 / 100 * stor11 / totalSupply))
                            _17607 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _17607 + 68] = mem[idx + _16790 + 32]
                                idx = idx + 32
                                continue 
                            mem[_17607 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _17607 + -mem[64] + 100
                        if idx >= stor9.length:
                            revert with 0, 50
                        mem[0] = stor9[idx]
                        mem[32] = 2
                        if stor2[stor9[idx]] <= s:
                            if idx >= stor9.length:
                                revert with 0, 50
                            mem[0] = stor9[idx]
                            mem[32] = 1
                            _11791 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11791] = 30
                            mem[_11791 + 32] = 'SafeMath: subtraction overflow'
                            if stor1[stor9[idx]] > t:
                                _11951 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11951 + 68] = mem[idx + _11791 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11951 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11951 + -mem[64] + 100
                            if t < stor1[stor9[idx]]:
                                revert with 0, 17
                            if idx >= stor9.length:
                                revert with 0, 50
                            mem[0] = stor9[idx]
                            mem[32] = 2
                            _12656 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12656] = 30
                            mem[_12656 + 32] = 'SafeMath: subtraction overflow'
                            if stor2[stor9[idx]] <= s:
                                if s < stor2[stor9[idx]]:
                                    revert with 0, 17
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s - stor2[stor9[idx]]
                                t = t - stor1[stor9[idx]]
                                continue 
                            _12752 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12752 + 68] = mem[idx + _12656 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12752 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12752 + -mem[64] + 100
                        _11792 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11792] = 26
                        mem[_11792 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _11952 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _11952 + 68] = mem[idx + _11792 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11952 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _11952 + -mem[64] + 100
                        if not arg1:
                            if not arg1 * stor25 / 100:
                                return 0
                            if arg1 * stor25 / 100 and stor11 / totalSupply > -1 / arg1 * stor25 / 100:
                                revert with 0, 17
                            if not arg1 * stor25 / 100:
                                revert with 0, 18
                            if arg1 * stor25 / 100 * stor11 / totalSupply / arg1 * stor25 / 100 != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _13786 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13786] = 30
                            mem[_13786 + 32] = 'SafeMath: subtraction overflow'
                            _15442 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15442] = 30
                            mem[_15442 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor25 / 100 * stor11 / totalSupply <= 0:
                                if 0 < arg1 * stor25 / 100 * stor11 / totalSupply:
                                    revert with 0, 17
                                return (-1 * arg1 * stor25 / 100 * stor11 / totalSupply)
                            _16074 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _16074 + 68] = mem[idx + _15442 + 32]
                                idx = idx + 32
                                continue 
                            mem[_16074 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _16074 + -mem[64] + 100
                        if arg1 and stor11 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor11 / totalSupply / arg1 != stor11 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor25 / 100:
                            _13785 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13785] = 30
                            mem[_13785 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor11 / totalSupply:
                                _14015 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _14015 + 68] = mem[idx + _13785 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14015 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14015 + -mem[64] + 100
                            if arg1 * stor11 / totalSupply < 0:
                                revert with 0, 17
                            _15440 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15440] = 30
                            mem[_15440 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor11 / totalSupply:
                                if arg1 * stor11 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor11 / totalSupply)
                            _16073 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _16073 + 68] = mem[idx + _15440 + 32]
                                idx = idx + 32
                                continue 
                            mem[_16073 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _16073 + -mem[64] + 100
                        if arg1 * stor25 / 100 and stor11 / totalSupply > -1 / arg1 * stor25 / 100:
                            revert with 0, 17
                        if not arg1 * stor25 / 100:
                            revert with 0, 18
                        if arg1 * stor25 / 100 * stor11 / totalSupply / arg1 * stor25 / 100 != stor11 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _14882 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14882] = 30
                        mem[_14882 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor11 / totalSupply:
                            _15439 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _15439 + 68] = mem[idx + _14882 + 32]
                                idx = idx + 32
                                continue 
                            mem[_15439 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _15439 + -mem[64] + 100
                        if arg1 * stor11 / totalSupply < 0:
                            revert with 0, 17
                        _17610 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_17610] = 30
                        mem[_17610 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor25 / 100 * stor11 / totalSupply <= arg1 * stor11 / totalSupply:
                            if arg1 * stor11 / totalSupply < arg1 * stor25 / 100 * stor11 / totalSupply:
                                revert with 0, 17
                            return ((arg1 * stor11 / totalSupply) - (arg1 * stor25 / 100 * stor11 / totalSupply))
                        _18344 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _18344 + 68] = mem[idx + _17610 + 32]
                            idx = idx + 32
                            continue 
                        mem[_18344 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _18344 + -mem[64] + 100
                else:
                    if arg1 and stor35 > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor35 / arg1 != stor35:
                        revert with 0, 'SafeMath: multiplication overflow'
                    mem[288] = 26
                    mem[320] = 'SafeMath: division by zero'
                    if arg1 * stor25 / 100 > -1:
                        revert with 0, 17
                    if arg1 * stor25 / 100 < arg1 * stor25 / 100:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[352] = 30
                    mem[384] = 'SafeMath: subtraction overflow'
                    if 0 > arg1:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 < 0:
                        revert with 0, 17
                    mem[416] = 30
                    mem[448] = 'SafeMath: subtraction overflow'
                    if arg1 * stor25 / 100 > arg1:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 < arg1 * stor25 / 100:
                        revert with 0, 17
                    mem[64] = 544
                    mem[480] = 30
                    mem[512] = 'SafeMath: subtraction overflow'
                    if arg1 * stor35 / 100 > arg1 - (arg1 * stor25 / 100):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 - (arg1 * stor25 / 100) < arg1 * stor35 / 100:
                        revert with 0, 17
                    if arg1 * stor25 / 100 > -1:
                        revert with 0, 17
                    if arg1 * stor25 / 100 < arg1 * stor25 / 100:
                        revert with 0, 'SafeMath: addition overflow'
                    idx = 0
                    s = totalSupply
                    t = stor11
                    while idx < stor9.length:
                        mem[0] = stor9[idx]
                        mem[32] = 1
                        if stor1[stor9[idx]] > t:
                            _11639 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11639] = 26
                            mem[_11639 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                _11787 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _11787 + 68] = mem[idx + _11639 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11787 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _11787 + -mem[64] + 100
                            if not arg1:
                                if not arg1 * stor25 / 100:
                                    return 0
                                if arg1 * stor25 / 100 and stor11 / totalSupply > -1 / arg1 * stor25 / 100:
                                    revert with 0, 17
                                if not arg1 * stor25 / 100:
                                    revert with 0, 18
                                if arg1 * stor25 / 100 * stor11 / totalSupply / arg1 * stor25 / 100 != stor11 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _13518 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13518] = 30
                                mem[_13518 + 32] = 'SafeMath: subtraction overflow'
                                _14872 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14872] = 30
                                mem[_14872 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * stor25 / 100 * stor11 / totalSupply <= 0:
                                    if 0 < arg1 * stor25 / 100 * stor11 / totalSupply:
                                        revert with 0, 17
                                    return (-1 * arg1 * stor25 / 100 * stor11 / totalSupply)
                                _15430 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _15430 + 68] = mem[idx + _14872 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15430 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _15430 + -mem[64] + 100
                            if arg1 and stor11 / totalSupply > -1 / arg1:
                                revert with 0, 17
                            if not arg1:
                                revert with 0, 18
                            if arg1 * stor11 / totalSupply / arg1 != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * stor25 / 100:
                                _13517 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13517] = 30
                                mem[_13517 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor11 / totalSupply:
                                    _13779 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _13779 + 68] = mem[idx + _13517 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_13779 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _13779 + -mem[64] + 100
                                if arg1 * stor11 / totalSupply < 0:
                                    revert with 0, 17
                                _14870 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14870] = 30
                                mem[_14870 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= arg1 * stor11 / totalSupply:
                                    if arg1 * stor11 / totalSupply < 0:
                                        revert with 0, 17
                                    return (arg1 * stor11 / totalSupply)
                                _15429 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _15429 + 68] = mem[idx + _14870 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15429 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _15429 + -mem[64] + 100
                            if arg1 * stor25 / 100 and stor11 / totalSupply > -1 / arg1 * stor25 / 100:
                                revert with 0, 17
                            if not arg1 * stor25 / 100:
                                revert with 0, 18
                            if arg1 * stor25 / 100 * stor11 / totalSupply / arg1 * stor25 / 100 != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _14401 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14401] = 30
                            mem[_14401 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor11 / totalSupply:
                                _14869 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _14869 + 68] = mem[idx + _14401 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14869 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14869 + -mem[64] + 100
                            if arg1 * stor11 / totalSupply < 0:
                                revert with 0, 17
                            _16779 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_16779] = 30
                            mem[_16779 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor25 / 100 * stor11 / totalSupply <= arg1 * stor11 / totalSupply:
                                if arg1 * stor11 / totalSupply < arg1 * stor25 / 100 * stor11 / totalSupply:
                                    revert with 0, 17
                                return ((arg1 * stor11 / totalSupply) - (arg1 * stor25 / 100 * stor11 / totalSupply))
                            _17597 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _17597 + 68] = mem[idx + _16779 + 32]
                                idx = idx + 32
                                continue 
                            mem[_17597 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _17597 + -mem[64] + 100
                        if idx >= stor9.length:
                            revert with 0, 50
                        mem[0] = stor9[idx]
                        mem[32] = 2
                        if stor2[stor9[idx]] <= s:
                            if idx >= stor9.length:
                                revert with 0, 50
                            mem[0] = stor9[idx]
                            mem[32] = 1
                            _11788 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11788] = 30
                            mem[_11788 + 32] = 'SafeMath: subtraction overflow'
                            if stor1[stor9[idx]] > t:
                                _11948 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11948 + 68] = mem[idx + _11788 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11948 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11948 + -mem[64] + 100
                            if t < stor1[stor9[idx]]:
                                revert with 0, 17
                            if idx >= stor9.length:
                                revert with 0, 50
                            mem[0] = stor9[idx]
                            mem[32] = 2
                            _12653 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12653] = 30
                            mem[_12653 + 32] = 'SafeMath: subtraction overflow'
                            if stor2[stor9[idx]] <= s:
                                if s < stor2[stor9[idx]]:
                                    revert with 0, 17
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s - stor2[stor9[idx]]
                                t = t - stor1[stor9[idx]]
                                continue 
                            _12749 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12749 + 68] = mem[idx + _12653 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12749 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12749 + -mem[64] + 100
                        _11789 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11789] = 26
                        mem[_11789 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _11949 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _11949 + 68] = mem[idx + _11789 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11949 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _11949 + -mem[64] + 100
                        if not arg1:
                            if not arg1 * stor25 / 100:
                                return 0
                            if arg1 * stor25 / 100 and stor11 / totalSupply > -1 / arg1 * stor25 / 100:
                                revert with 0, 17
                            if not arg1 * stor25 / 100:
                                revert with 0, 18
                            if arg1 * stor25 / 100 * stor11 / totalSupply / arg1 * stor25 / 100 != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _13782 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13782] = 30
                            mem[_13782 + 32] = 'SafeMath: subtraction overflow'
                            _15434 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15434] = 30
                            mem[_15434 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor25 / 100 * stor11 / totalSupply <= 0:
                                if 0 < arg1 * stor25 / 100 * stor11 / totalSupply:
                                    revert with 0, 17
                                return (-1 * arg1 * stor25 / 100 * stor11 / totalSupply)
                            _16070 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _16070 + 68] = mem[idx + _15434 + 32]
                                idx = idx + 32
                                continue 
                            mem[_16070 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _16070 + -mem[64] + 100
                        if arg1 and stor11 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor11 / totalSupply / arg1 != stor11 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor25 / 100:
                            _13781 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13781] = 30
                            mem[_13781 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor11 / totalSupply:
                                _14010 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _14010 + 68] = mem[idx + _13781 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14010 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14010 + -mem[64] + 100
                            if arg1 * stor11 / totalSupply < 0:
                                revert with 0, 17
                            _15432 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15432] = 30
                            mem[_15432 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor11 / totalSupply:
                                if arg1 * stor11 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor11 / totalSupply)
                            _16069 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _16069 + 68] = mem[idx + _15432 + 32]
                                idx = idx + 32
                                continue 
                            mem[_16069 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _16069 + -mem[64] + 100
                        if arg1 * stor25 / 100 and stor11 / totalSupply > -1 / arg1 * stor25 / 100:
                            revert with 0, 17
                        if not arg1 * stor25 / 100:
                            revert with 0, 18
                        if arg1 * stor25 / 100 * stor11 / totalSupply / arg1 * stor25 / 100 != stor11 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _14873 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14873] = 30
                        mem[_14873 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor11 / totalSupply:
                            _15431 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _15431 + 68] = mem[idx + _14873 + 32]
                                idx = idx + 32
                                continue 
                            mem[_15431 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _15431 + -mem[64] + 100
                        if arg1 * stor11 / totalSupply < 0:
                            revert with 0, 17
                        _17600 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_17600] = 30
                        mem[_17600 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor25 / 100 * stor11 / totalSupply <= arg1 * stor11 / totalSupply:
                            if arg1 * stor11 / totalSupply < arg1 * stor25 / 100 * stor11 / totalSupply:
                                revert with 0, 17
                            return ((arg1 * stor11 / totalSupply) - (arg1 * stor25 / 100 * stor11 / totalSupply))
                        _18341 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _18341 + 68] = mem[idx + _17600 + 32]
                            idx = idx + 32
                            continue 
                        mem[_18341 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _18341 + -mem[64] + 100
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if t >= stor11 / totalSupply:
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg1:
                        if not arg1 * stor25 / 100:
                            return 0
                        if arg1 * stor25 / 100 and t / s > -1 / arg1 * stor25 / 100:
                            revert with 0, 17
                        if not arg1 * stor25 / 100:
                            revert with 0, 18
                        if arg1 * stor25 / 100 * t / s / arg1 * stor25 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * stor25 / 100 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * stor25 / 100 * t / s:
                            revert with 0, 17
                        return (-1 * arg1 * stor25 / 100 * t / s)
                    if arg1 and t / s > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor25 / 100:
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        return (arg1 * t / s)
                    if arg1 * stor25 / 100 and t / s > -1 / arg1 * stor25 / 100:
                        revert with 0, 17
                    if not arg1 * stor25 / 100:
                        revert with 0, 18
                    if arg1 * stor25 / 100 * t / s / arg1 * stor25 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 0, 17
                    if arg1 * stor25 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * stor25 / 100 * t / s:
                        revert with 0, 17
                    return ((arg1 * t / s) - (arg1 * stor25 / 100 * t / s))
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if not arg1 * stor25 / 100:
                        return 0
                    if arg1 * stor25 / 100 and stor11 / totalSupply > -1 / arg1 * stor25 / 100:
                        revert with 0, 17
                    if not arg1 * stor25 / 100:
                        revert with 0, 18
                    if arg1 * stor25 / 100 * stor11 / totalSupply / arg1 * stor25 / 100 != stor11 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * stor25 / 100 * stor11 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * stor25 / 100 * stor11 / totalSupply:
                        revert with 0, 17
                    return (-1 * arg1 * stor25 / 100 * stor11 / totalSupply)
                if arg1 and stor11 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor11 / totalSupply / arg1 != stor11 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor25 / 100:
                    if 0 > arg1 * stor11 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor11 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor11 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor11 / totalSupply < 0:
                        revert with 0, 17
                    return (arg1 * stor11 / totalSupply)
                if arg1 * stor25 / 100 and stor11 / totalSupply > -1 / arg1 * stor25 / 100:
                    revert with 0, 17
                if not arg1 * stor25 / 100:
                    revert with 0, 18
                if arg1 * stor25 / 100 * stor11 / totalSupply / arg1 * stor25 / 100 != stor11 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 0 > arg1 * stor11 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor11 / totalSupply < 0:
                    revert with 0, 17
                if arg1 * stor25 / 100 * stor11 / totalSupply > arg1 * stor11 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor11 / totalSupply < arg1 * stor25 / 100 * stor11 / totalSupply:
                    revert with 0, 17
                return ((arg1 * stor11 / totalSupply) - (arg1 * stor25 / 100 * stor11 / totalSupply))
            if arg1 and stor30 > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * stor30 / arg1 != stor30:
                revert with 0, 'SafeMath: multiplication overflow'
            mem[224] = 26
            mem[256] = 'SafeMath: division by zero'
            if not arg1:
                mem[288] = 26
                mem[320] = 'SafeMath: division by zero'
                if arg1 * stor25 / 100 > !(arg1 * stor30 / 100):
                    revert with 0, 17
                if (arg1 * stor25 / 100) + (arg1 * stor30 / 100) < arg1 * stor25 / 100:
                    revert with 0, 'SafeMath: addition overflow'
                mem[352] = 30
                mem[384] = 'SafeMath: subtraction overflow'
                if 0 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < 0:
                    revert with 0, 17
                mem[416] = 30
                mem[448] = 'SafeMath: subtraction overflow'
                if (arg1 * stor25 / 100) + (arg1 * stor30 / 100) > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                    revert with 0, 17
                mem[64] = 544
                mem[480] = 30
                mem[512] = 'SafeMath: subtraction overflow'
                if 0 > arg1 - (arg1 * stor25 / 100) - (arg1 * stor30 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * stor25 / 100) - (arg1 * stor30 / 100) < 0:
                    revert with 0, 17
                if arg1 * stor25 / 100 > !(arg1 * stor30 / 100):
                    revert with 0, 17
                if (arg1 * stor25 / 100) + (arg1 * stor30 / 100) < arg1 * stor25 / 100:
                    revert with 0, 'SafeMath: addition overflow'
                idx = 0
                s = totalSupply
                t = stor11
                while idx < stor9.length:
                    mem[0] = stor9[idx]
                    mem[32] = 1
                    if stor1[stor9[idx]] > t:
                        _11638 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11638] = 26
                        mem[_11638 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _11784 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _11784 + 68] = mem[idx + _11638 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11784 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _11784 + -mem[64] + 100
                        if not arg1:
                            if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                                return 0
                            if (arg1 * stor25 / 100) + (arg1 * stor30 / 100) and stor11 / totalSupply > -1 / (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                                revert with 0, 17
                            if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                                revert with 0, 18
                            if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) / (arg1 * stor25 / 100) + (arg1 * stor30 / 100) != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _13513 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13513] = 30
                            mem[_13513 + 32] = 'SafeMath: subtraction overflow'
                            _14863 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14863] = 30
                            mem[_14863 + 32] = 'SafeMath: subtraction overflow'
                            if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) <= 0:
                                if 0 < (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply):
                                    revert with 0, 17
                                return ((-1 * arg1 * stor25 / 100 * stor11 / totalSupply) - (arg1 * stor30 / 100 * stor11 / totalSupply))
                            _15422 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _15422 + 68] = mem[idx + _14863 + 32]
                                idx = idx + 32
                                continue 
                            mem[_15422 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _15422 + -mem[64] + 100
                        if arg1 and stor11 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor11 / totalSupply / arg1 != stor11 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                            _13512 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13512] = 30
                            mem[_13512 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor11 / totalSupply:
                                _13775 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _13775 + 68] = mem[idx + _13512 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13775 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13775 + -mem[64] + 100
                            if arg1 * stor11 / totalSupply < 0:
                                revert with 0, 17
                            _14861 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14861] = 30
                            mem[_14861 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor11 / totalSupply:
                                if arg1 * stor11 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor11 / totalSupply)
                            _15421 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _15421 + 68] = mem[idx + _14861 + 32]
                                idx = idx + 32
                                continue 
                            mem[_15421 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _15421 + -mem[64] + 100
                        if (arg1 * stor25 / 100) + (arg1 * stor30 / 100) and stor11 / totalSupply > -1 / (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                            revert with 0, 17
                        if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                            revert with 0, 18
                        if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) / (arg1 * stor25 / 100) + (arg1 * stor30 / 100) != stor11 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _14395 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14395] = 30
                        mem[_14395 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor11 / totalSupply:
                            _14860 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _14860 + 68] = mem[idx + _14395 + 32]
                                idx = idx + 32
                                continue 
                            mem[_14860 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _14860 + -mem[64] + 100
                        if arg1 * stor11 / totalSupply < 0:
                            revert with 0, 17
                        _16768 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_16768] = 30
                        mem[_16768 + 32] = 'SafeMath: subtraction overflow'
                        if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) <= arg1 * stor11 / totalSupply:
                            if arg1 * stor11 / totalSupply < (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply):
                                revert with 0, 17
                            return ((arg1 * stor11 / totalSupply) - (arg1 * stor25 / 100 * stor11 / totalSupply) - (arg1 * stor30 / 100 * stor11 / totalSupply))
                        _17587 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _17587 + 68] = mem[idx + _16768 + 32]
                            idx = idx + 32
                            continue 
                        mem[_17587 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _17587 + -mem[64] + 100
                    if idx >= stor9.length:
                        revert with 0, 50
                    mem[0] = stor9[idx]
                    mem[32] = 2
                    if stor2[stor9[idx]] <= s:
                        if idx >= stor9.length:
                            revert with 0, 50
                        mem[0] = stor9[idx]
                        mem[32] = 1
                        _11785 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11785] = 30
                        mem[_11785 + 32] = 'SafeMath: subtraction overflow'
                        if stor1[stor9[idx]] > t:
                            _11945 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11945 + 68] = mem[idx + _11785 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11945 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11945 + -mem[64] + 100
                        if t < stor1[stor9[idx]]:
                            revert with 0, 17
                        if idx >= stor9.length:
                            revert with 0, 50
                        mem[0] = stor9[idx]
                        mem[32] = 2
                        _12650 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12650] = 30
                        mem[_12650 + 32] = 'SafeMath: subtraction overflow'
                        if stor2[stor9[idx]] <= s:
                            if s < stor2[stor9[idx]]:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s - stor2[stor9[idx]]
                            t = t - stor1[stor9[idx]]
                            continue 
                        _12746 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _12746 + 68] = mem[idx + _12650 + 32]
                            idx = idx + 32
                            continue 
                        mem[_12746 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _12746 + -mem[64] + 100
                    _11786 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11786] = 26
                    mem[_11786 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _11946 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _11946 + 68] = mem[idx + _11786 + 32]
                            idx = idx + 32
                            continue 
                        mem[_11946 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _11946 + -mem[64] + 100
                    if not arg1:
                        if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                            return 0
                        if (arg1 * stor25 / 100) + (arg1 * stor30 / 100) and stor11 / totalSupply > -1 / (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                            revert with 0, 17
                        if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                            revert with 0, 18
                        if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) / (arg1 * stor25 / 100) + (arg1 * stor30 / 100) != stor11 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _13778 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13778] = 30
                        mem[_13778 + 32] = 'SafeMath: subtraction overflow'
                        _15426 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_15426] = 30
                        mem[_15426 + 32] = 'SafeMath: subtraction overflow'
                        if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) <= 0:
                            if 0 < (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply):
                                revert with 0, 17
                            return ((-1 * arg1 * stor25 / 100 * stor11 / totalSupply) - (arg1 * stor30 / 100 * stor11 / totalSupply))
                        _16066 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _16066 + 68] = mem[idx + _15426 + 32]
                            idx = idx + 32
                            continue 
                        mem[_16066 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _16066 + -mem[64] + 100
                    if arg1 and stor11 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor11 / totalSupply / arg1 != stor11 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                        _13777 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13777] = 30
                        mem[_13777 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor11 / totalSupply:
                            _14005 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _14005 + 68] = mem[idx + _13777 + 32]
                                idx = idx + 32
                                continue 
                            mem[_14005 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _14005 + -mem[64] + 100
                        if arg1 * stor11 / totalSupply < 0:
                            revert with 0, 17
                        _15424 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_15424] = 30
                        mem[_15424 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= arg1 * stor11 / totalSupply:
                            if arg1 * stor11 / totalSupply < 0:
                                revert with 0, 17
                            return (arg1 * stor11 / totalSupply)
                        _16065 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _16065 + 68] = mem[idx + _15424 + 32]
                            idx = idx + 32
                            continue 
                        mem[_16065 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _16065 + -mem[64] + 100
                    if (arg1 * stor25 / 100) + (arg1 * stor30 / 100) and stor11 / totalSupply > -1 / (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                        revert with 0, 17
                    if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                        revert with 0, 18
                    if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) / (arg1 * stor25 / 100) + (arg1 * stor30 / 100) != stor11 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _14864 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14864] = 30
                    mem[_14864 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor11 / totalSupply:
                        _15423 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _15423 + 68] = mem[idx + _14864 + 32]
                            idx = idx + 32
                            continue 
                        mem[_15423 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _15423 + -mem[64] + 100
                    if arg1 * stor11 / totalSupply < 0:
                        revert with 0, 17
                    _17590 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_17590] = 30
                    mem[_17590 + 32] = 'SafeMath: subtraction overflow'
                    if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) <= arg1 * stor11 / totalSupply:
                        if arg1 * stor11 / totalSupply < (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply):
                            revert with 0, 17
                        return ((arg1 * stor11 / totalSupply) - (arg1 * stor25 / 100 * stor11 / totalSupply) - (arg1 * stor30 / 100 * stor11 / totalSupply))
                    _18338 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _18338 + 68] = mem[idx + _17590 + 32]
                        idx = idx + 32
                        continue 
                    mem[_18338 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _18338 + -mem[64] + 100
            else:
                if arg1 and stor35 > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor35 / arg1 != stor35:
                    revert with 0, 'SafeMath: multiplication overflow'
                mem[288] = 26
                mem[320] = 'SafeMath: division by zero'
                if arg1 * stor25 / 100 > !(arg1 * stor30 / 100):
                    revert with 0, 17
                if (arg1 * stor25 / 100) + (arg1 * stor30 / 100) < arg1 * stor25 / 100:
                    revert with 0, 'SafeMath: addition overflow'
                mem[352] = 30
                mem[384] = 'SafeMath: subtraction overflow'
                if 0 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < 0:
                    revert with 0, 17
                mem[416] = 30
                mem[448] = 'SafeMath: subtraction overflow'
                if (arg1 * stor25 / 100) + (arg1 * stor30 / 100) > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                    revert with 0, 17
                mem[64] = 544
                mem[480] = 30
                mem[512] = 'SafeMath: subtraction overflow'
                if arg1 * stor35 / 100 > arg1 - (arg1 * stor25 / 100) - (arg1 * stor30 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * stor25 / 100) - (arg1 * stor30 / 100) < arg1 * stor35 / 100:
                    revert with 0, 17
                if arg1 * stor25 / 100 > !(arg1 * stor30 / 100):
                    revert with 0, 17
                if (arg1 * stor25 / 100) + (arg1 * stor30 / 100) < arg1 * stor25 / 100:
                    revert with 0, 'SafeMath: addition overflow'
                idx = 0
                s = totalSupply
                t = stor11
                while idx < stor9.length:
                    mem[0] = stor9[idx]
                    mem[32] = 1
                    if stor1[stor9[idx]] > t:
                        _11637 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11637] = 26
                        mem[_11637 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _11781 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _11781 + 68] = mem[idx + _11637 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11781 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _11781 + -mem[64] + 100
                        if not arg1:
                            if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                                return 0
                            if (arg1 * stor25 / 100) + (arg1 * stor30 / 100) and stor11 / totalSupply > -1 / (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                                revert with 0, 17
                            if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                                revert with 0, 18
                            if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) / (arg1 * stor25 / 100) + (arg1 * stor30 / 100) != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _13508 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13508] = 30
                            mem[_13508 + 32] = 'SafeMath: subtraction overflow'
                            _14854 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14854] = 30
                            mem[_14854 + 32] = 'SafeMath: subtraction overflow'
                            if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) <= 0:
                                if 0 < (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply):
                                    revert with 0, 17
                                return ((-1 * arg1 * stor25 / 100 * stor11 / totalSupply) - (arg1 * stor30 / 100 * stor11 / totalSupply))
                            _15414 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _15414 + 68] = mem[idx + _14854 + 32]
                                idx = idx + 32
                                continue 
                            mem[_15414 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _15414 + -mem[64] + 100
                        if arg1 and stor11 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor11 / totalSupply / arg1 != stor11 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                            _13507 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13507] = 30
                            mem[_13507 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor11 / totalSupply:
                                _13771 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _13771 + 68] = mem[idx + _13507 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13771 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13771 + -mem[64] + 100
                            if arg1 * stor11 / totalSupply < 0:
                                revert with 0, 17
                            _14852 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14852] = 30
                            mem[_14852 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor11 / totalSupply:
                                if arg1 * stor11 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor11 / totalSupply)
                            _15413 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _15413 + 68] = mem[idx + _14852 + 32]
                                idx = idx + 32
                                continue 
                            mem[_15413 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _15413 + -mem[64] + 100
                        if (arg1 * stor25 / 100) + (arg1 * stor30 / 100) and stor11 / totalSupply > -1 / (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                            revert with 0, 17
                        if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                            revert with 0, 18
                        if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) / (arg1 * stor25 / 100) + (arg1 * stor30 / 100) != stor11 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _14389 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14389] = 30
                        mem[_14389 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor11 / totalSupply:
                            _14851 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _14851 + 68] = mem[idx + _14389 + 32]
                                idx = idx + 32
                                continue 
                            mem[_14851 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _14851 + -mem[64] + 100
                        if arg1 * stor11 / totalSupply < 0:
                            revert with 0, 17
                        _16757 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_16757] = 30
                        mem[_16757 + 32] = 'SafeMath: subtraction overflow'
                        if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) <= arg1 * stor11 / totalSupply:
                            if arg1 * stor11 / totalSupply < (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply):
                                revert with 0, 17
                            return ((arg1 * stor11 / totalSupply) - (arg1 * stor25 / 100 * stor11 / totalSupply) - (arg1 * stor30 / 100 * stor11 / totalSupply))
                        _17577 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _17577 + 68] = mem[idx + _16757 + 32]
                            idx = idx + 32
                            continue 
                        mem[_17577 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _17577 + -mem[64] + 100
                    if idx >= stor9.length:
                        revert with 0, 50
                    mem[0] = stor9[idx]
                    mem[32] = 2
                    if stor2[stor9[idx]] <= s:
                        if idx >= stor9.length:
                            revert with 0, 50
                        mem[0] = stor9[idx]
                        mem[32] = 1
                        _11782 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11782] = 30
                        mem[_11782 + 32] = 'SafeMath: subtraction overflow'
                        if stor1[stor9[idx]] > t:
                            _11942 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11942 + 68] = mem[idx + _11782 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11942 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11942 + -mem[64] + 100
                        if t < stor1[stor9[idx]]:
                            revert with 0, 17
                        if idx >= stor9.length:
                            revert with 0, 50
                        mem[0] = stor9[idx]
                        mem[32] = 2
                        _12647 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12647] = 30
                        mem[_12647 + 32] = 'SafeMath: subtraction overflow'
                        if stor2[stor9[idx]] <= s:
                            if s < stor2[stor9[idx]]:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s - stor2[stor9[idx]]
                            t = t - stor1[stor9[idx]]
                            continue 
                        _12743 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _12743 + 68] = mem[idx + _12647 + 32]
                            idx = idx + 32
                            continue 
                        mem[_12743 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _12743 + -mem[64] + 100
                    _11783 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11783] = 26
                    mem[_11783 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _11943 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _11943 + 68] = mem[idx + _11783 + 32]
                            idx = idx + 32
                            continue 
                        mem[_11943 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _11943 + -mem[64] + 100
                    if not arg1:
                        if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                            return 0
                        if (arg1 * stor25 / 100) + (arg1 * stor30 / 100) and stor11 / totalSupply > -1 / (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                            revert with 0, 17
                        if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                            revert with 0, 18
                        if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) / (arg1 * stor25 / 100) + (arg1 * stor30 / 100) != stor11 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _13774 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13774] = 30
                        mem[_13774 + 32] = 'SafeMath: subtraction overflow'
                        _15418 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_15418] = 30
                        mem[_15418 + 32] = 'SafeMath: subtraction overflow'
                        if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) <= 0:
                            if 0 < (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply):
                                revert with 0, 17
                            return ((-1 * arg1 * stor25 / 100 * stor11 / totalSupply) - (arg1 * stor30 / 100 * stor11 / totalSupply))
                        _16062 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _16062 + 68] = mem[idx + _15418 + 32]
                            idx = idx + 32
                            continue 
                        mem[_16062 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _16062 + -mem[64] + 100
                    if arg1 and stor11 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor11 / totalSupply / arg1 != stor11 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                        _13773 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13773] = 30
                        mem[_13773 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor11 / totalSupply:
                            _14000 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _14000 + 68] = mem[idx + _13773 + 32]
                                idx = idx + 32
                                continue 
                            mem[_14000 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _14000 + -mem[64] + 100
                        if arg1 * stor11 / totalSupply < 0:
                            revert with 0, 17
                        _15416 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_15416] = 30
                        mem[_15416 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= arg1 * stor11 / totalSupply:
                            if arg1 * stor11 / totalSupply < 0:
                                revert with 0, 17
                            return (arg1 * stor11 / totalSupply)
                        _16061 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _16061 + 68] = mem[idx + _15416 + 32]
                            idx = idx + 32
                            continue 
                        mem[_16061 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _16061 + -mem[64] + 100
                    if (arg1 * stor25 / 100) + (arg1 * stor30 / 100) and stor11 / totalSupply > -1 / (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                        revert with 0, 17
                    if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                        revert with 0, 18
                    if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) / (arg1 * stor25 / 100) + (arg1 * stor30 / 100) != stor11 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _14855 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14855] = 30
                    mem[_14855 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor11 / totalSupply:
                        _15415 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _15415 + 68] = mem[idx + _14855 + 32]
                            idx = idx + 32
                            continue 
                        mem[_15415 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _15415 + -mem[64] + 100
                    if arg1 * stor11 / totalSupply < 0:
                        revert with 0, 17
                    _17580 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_17580] = 30
                    mem[_17580 + 32] = 'SafeMath: subtraction overflow'
                    if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) <= arg1 * stor11 / totalSupply:
                        if arg1 * stor11 / totalSupply < (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply):
                            revert with 0, 17
                        return ((arg1 * stor11 / totalSupply) - (arg1 * stor25 / 100 * stor11 / totalSupply) - (arg1 * stor30 / 100 * stor11 / totalSupply))
                    _18335 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _18335 + 68] = mem[idx + _17580 + 32]
                        idx = idx + 32
                        continue 
                    mem[_18335 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _18335 + -mem[64] + 100
            if not totalSupply:
                revert with 0, 'SafeMath: division by zero', 0
            if t >= stor11 / totalSupply:
                if not s:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                        return 0
                    if (arg1 * stor25 / 100) + (arg1 * stor30 / 100) and t / s > -1 / (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                        revert with 0, 17
                    if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                        revert with 0, 18
                    if (arg1 * stor25 / 100 * t / s) + (arg1 * stor30 / 100 * t / s) / (arg1 * stor25 / 100) + (arg1 * stor30 / 100) != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if (arg1 * stor25 / 100 * t / s) + (arg1 * stor30 / 100 * t / s) > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < (arg1 * stor25 / 100 * t / s) + (arg1 * stor30 / 100 * t / s):
                        revert with 0, 17
                    return ((-1 * arg1 * stor25 / 100 * t / s) - (arg1 * stor30 / 100 * t / s))
                if arg1 and t / s > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * t / s / arg1 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 0, 17
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 0, 17
                    return (arg1 * t / s)
                if (arg1 * stor25 / 100) + (arg1 * stor30 / 100) and t / s > -1 / (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                    revert with 0, 17
                if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                    revert with 0, 18
                if (arg1 * stor25 / 100 * t / s) + (arg1 * stor30 / 100 * t / s) / (arg1 * stor25 / 100) + (arg1 * stor30 / 100) != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 0 > arg1 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * t / s < 0:
                    revert with 0, 17
                if (arg1 * stor25 / 100 * t / s) + (arg1 * stor30 / 100 * t / s) > arg1 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * t / s < (arg1 * stor25 / 100 * t / s) + (arg1 * stor30 / 100 * t / s):
                    revert with 0, 17
                return ((arg1 * t / s) - (arg1 * stor25 / 100 * t / s) - (arg1 * stor30 / 100 * t / s))
            if not totalSupply:
                revert with 0, 'SafeMath: division by zero', 0
            if not arg1:
                if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                    return 0
                if (arg1 * stor25 / 100) + (arg1 * stor30 / 100) and stor11 / totalSupply > -1 / (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                    revert with 0, 17
                if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                    revert with 0, 18
                if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) / (arg1 * stor25 / 100) + (arg1 * stor30 / 100) != stor11 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) > 0:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if 0 < (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply):
                    revert with 0, 17
                return ((-1 * arg1 * stor25 / 100 * stor11 / totalSupply) - (arg1 * stor30 / 100 * stor11 / totalSupply))
            if arg1 and stor11 / totalSupply > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * stor11 / totalSupply / arg1 != stor11 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                if 0 > arg1 * stor11 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor11 / totalSupply < 0:
                    revert with 0, 17
                if 0 > arg1 * stor11 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor11 / totalSupply < 0:
                    revert with 0, 17
                return (arg1 * stor11 / totalSupply)
            if (arg1 * stor25 / 100) + (arg1 * stor30 / 100) and stor11 / totalSupply > -1 / (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                revert with 0, 17
            if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                revert with 0, 18
            if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) / (arg1 * stor25 / 100) + (arg1 * stor30 / 100) != stor11 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if 0 > arg1 * stor11 / totalSupply:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * stor11 / totalSupply < 0:
                revert with 0, 17
            if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) > arg1 * stor11 / totalSupply:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * stor11 / totalSupply < (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply):
                revert with 0, 17
            return ((arg1 * stor11 / totalSupply) - (arg1 * stor25 / 100 * stor11 / totalSupply) - (arg1 * stor30 / 100 * stor11 / totalSupply))
        if arg1 and stor19 > -1 / arg1:
            revert with 0, 17
        if not arg1:
            revert with 0, 18
        if arg1 * stor19 / arg1 != stor19:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
        mem[96] = 26
        mem[128] = 'SafeMath: division by zero'
        if not arg1:
            mem[160] = 26
            mem[192] = 'SafeMath: division by zero'
            if not arg1:
                mem[224] = 26
                mem[256] = 'SafeMath: division by zero'
                if not arg1:
                    mem[288] = 26
                    mem[320] = 'SafeMath: division by zero'
                    mem[352] = 30
                    mem[384] = 'SafeMath: subtraction overflow'
                    if arg1 * stor19 / 100 > arg1:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 < arg1 * stor19 / 100:
                        revert with 0, 17
                    mem[416] = 30
                    mem[448] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 - (arg1 * stor19 / 100):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 - (arg1 * stor19 / 100) < 0:
                        revert with 0, 17
                    mem[64] = 544
                    mem[480] = 30
                    mem[512] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 - (arg1 * stor19 / 100):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 - (arg1 * stor19 / 100) < 0:
                        revert with 0, 17
                    idx = 0
                    s = totalSupply
                    t = stor11
                    while idx < stor9.length:
                        mem[0] = stor9[idx]
                        mem[32] = 1
                        if stor1[stor9[idx]] > t:
                            _11636 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11636] = 26
                            mem[_11636 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                _11778 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _11778 + 68] = mem[idx + _11636 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11778 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _11778 + -mem[64] + 100
                            if not arg1:
                                if not arg1 * stor19 / 100:
                                    return 0
                                if arg1 * stor19 / 100 and stor11 / totalSupply > -1 / arg1 * stor19 / 100:
                                    revert with 0, 17
                                if not arg1 * stor19 / 100:
                                    revert with 0, 18
                                if arg1 * stor19 / 100 * stor11 / totalSupply / arg1 * stor19 / 100 != stor11 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _13504 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13504] = 30
                                mem[_13504 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * stor19 / 100 * stor11 / totalSupply > 0:
                                    _13766 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _13766 + 68] = mem[idx + _13504 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_13766 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _13766 + -mem[64] + 100
                                if 0 < arg1 * stor19 / 100 * stor11 / totalSupply:
                                    revert with 0, 17
                                _14844 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14844] = 30
                                mem[_14844 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * arg1 * stor19 / 100 * stor11 / totalSupply:
                                    if -1 * arg1 * stor19 / 100 * stor11 / totalSupply < 0:
                                        revert with 0, 17
                                    return (-1 * arg1 * stor19 / 100 * stor11 / totalSupply)
                                _15405 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _15405 + 68] = mem[idx + _14844 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15405 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _15405 + -mem[64] + 100
                            if arg1 and stor11 / totalSupply > -1 / arg1:
                                revert with 0, 17
                            if not arg1:
                                revert with 0, 18
                            if arg1 * stor11 / totalSupply / arg1 != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * stor19 / 100:
                                _13503 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13503] = 30
                                mem[_13503 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor11 / totalSupply:
                                    _13765 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _13765 + 68] = mem[idx + _13503 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_13765 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _13765 + -mem[64] + 100
                                if arg1 * stor11 / totalSupply < 0:
                                    revert with 0, 17
                                _14842 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14842] = 30
                                mem[_14842 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= arg1 * stor11 / totalSupply:
                                    if arg1 * stor11 / totalSupply < 0:
                                        revert with 0, 17
                                    return (arg1 * stor11 / totalSupply)
                                _15404 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _15404 + 68] = mem[idx + _14842 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15404 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _15404 + -mem[64] + 100
                            if arg1 * stor19 / 100 and stor11 / totalSupply > -1 / arg1 * stor19 / 100:
                                revert with 0, 17
                            if not arg1 * stor19 / 100:
                                revert with 0, 18
                            if arg1 * stor19 / 100 * stor11 / totalSupply / arg1 * stor19 / 100 != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _14384 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14384] = 30
                            mem[_14384 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor19 / 100 * stor11 / totalSupply > arg1 * stor11 / totalSupply:
                                _14841 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _14841 + 68] = mem[idx + _14384 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14841 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14841 + -mem[64] + 100
                            if arg1 * stor11 / totalSupply < arg1 * stor19 / 100 * stor11 / totalSupply:
                                revert with 0, 17
                            _16746 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_16746] = 30
                            mem[_16746 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply):
                                if (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply) < 0:
                                    revert with 0, 17
                                return ((arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply))
                            _17567 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _17567 + 68] = mem[idx + _16746 + 32]
                                idx = idx + 32
                                continue 
                            mem[_17567 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _17567 + -mem[64] + 100
                        if idx >= stor9.length:
                            revert with 0, 50
                        mem[0] = stor9[idx]
                        mem[32] = 2
                        if stor2[stor9[idx]] <= s:
                            if idx >= stor9.length:
                                revert with 0, 50
                            mem[0] = stor9[idx]
                            mem[32] = 1
                            _11779 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11779] = 30
                            mem[_11779 + 32] = 'SafeMath: subtraction overflow'
                            if stor1[stor9[idx]] > t:
                                _11939 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11939 + 68] = mem[idx + _11779 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11939 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11939 + -mem[64] + 100
                            if t < stor1[stor9[idx]]:
                                revert with 0, 17
                            if idx >= stor9.length:
                                revert with 0, 50
                            mem[0] = stor9[idx]
                            mem[32] = 2
                            _12644 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12644] = 30
                            mem[_12644 + 32] = 'SafeMath: subtraction overflow'
                            if stor2[stor9[idx]] <= s:
                                if s < stor2[stor9[idx]]:
                                    revert with 0, 17
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s - stor2[stor9[idx]]
                                t = t - stor1[stor9[idx]]
                                continue 
                            _12740 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12740 + 68] = mem[idx + _12644 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12740 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12740 + -mem[64] + 100
                        _11780 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11780] = 26
                        mem[_11780 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _11940 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _11940 + 68] = mem[idx + _11780 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11940 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _11940 + -mem[64] + 100
                        if not arg1:
                            if not arg1 * stor19 / 100:
                                return 0
                            if arg1 * stor19 / 100 and stor11 / totalSupply > -1 / arg1 * stor19 / 100:
                                revert with 0, 17
                            if not arg1 * stor19 / 100:
                                revert with 0, 18
                            if arg1 * stor19 / 100 * stor11 / totalSupply / arg1 * stor19 / 100 != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _13770 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13770] = 30
                            mem[_13770 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor19 / 100 * stor11 / totalSupply > 0:
                                _13995 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _13995 + 68] = mem[idx + _13770 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13995 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13995 + -mem[64] + 100
                            if 0 < arg1 * stor19 / 100 * stor11 / totalSupply:
                                revert with 0, 17
                            _15409 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15409] = 30
                            mem[_15409 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * stor19 / 100 * stor11 / totalSupply:
                                if -1 * arg1 * stor19 / 100 * stor11 / totalSupply < 0:
                                    revert with 0, 17
                                return (-1 * arg1 * stor19 / 100 * stor11 / totalSupply)
                            _16058 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _16058 + 68] = mem[idx + _15409 + 32]
                                idx = idx + 32
                                continue 
                            mem[_16058 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _16058 + -mem[64] + 100
                        if arg1 and stor11 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor11 / totalSupply / arg1 != stor11 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor19 / 100:
                            _13769 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13769] = 30
                            mem[_13769 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor11 / totalSupply:
                                _13994 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _13994 + 68] = mem[idx + _13769 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13994 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13994 + -mem[64] + 100
                            if arg1 * stor11 / totalSupply < 0:
                                revert with 0, 17
                            _15407 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15407] = 30
                            mem[_15407 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor11 / totalSupply:
                                if arg1 * stor11 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor11 / totalSupply)
                            _16057 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _16057 + 68] = mem[idx + _15407 + 32]
                                idx = idx + 32
                                continue 
                            mem[_16057 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _16057 + -mem[64] + 100
                        if arg1 * stor19 / 100 and stor11 / totalSupply > -1 / arg1 * stor19 / 100:
                            revert with 0, 17
                        if not arg1 * stor19 / 100:
                            revert with 0, 18
                        if arg1 * stor19 / 100 * stor11 / totalSupply / arg1 * stor19 / 100 != stor11 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _14846 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14846] = 30
                        mem[_14846 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor19 / 100 * stor11 / totalSupply > arg1 * stor11 / totalSupply:
                            _15406 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _15406 + 68] = mem[idx + _14846 + 32]
                                idx = idx + 32
                                continue 
                            mem[_15406 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _15406 + -mem[64] + 100
                        if arg1 * stor11 / totalSupply < arg1 * stor19 / 100 * stor11 / totalSupply:
                            revert with 0, 17
                        _17570 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_17570] = 30
                        mem[_17570 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply):
                            if (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply) < 0:
                                revert with 0, 17
                            return ((arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply))
                        _18332 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _18332 + 68] = mem[idx + _17570 + 32]
                            idx = idx + 32
                            continue 
                        mem[_18332 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _18332 + -mem[64] + 100
                else:
                    if arg1 and stor35 > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor35 / arg1 != stor35:
                        revert with 0, 'SafeMath: multiplication overflow'
                    mem[288] = 26
                    mem[320] = 'SafeMath: division by zero'
                    mem[352] = 30
                    mem[384] = 'SafeMath: subtraction overflow'
                    if arg1 * stor19 / 100 > arg1:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 < arg1 * stor19 / 100:
                        revert with 0, 17
                    mem[416] = 30
                    mem[448] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 - (arg1 * stor19 / 100):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 - (arg1 * stor19 / 100) < 0:
                        revert with 0, 17
                    mem[64] = 544
                    mem[480] = 30
                    mem[512] = 'SafeMath: subtraction overflow'
                    if arg1 * stor35 / 100 > arg1 - (arg1 * stor19 / 100):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 - (arg1 * stor19 / 100) < arg1 * stor35 / 100:
                        revert with 0, 17
                    idx = 0
                    s = totalSupply
                    t = stor11
                    while idx < stor9.length:
                        mem[0] = stor9[idx]
                        mem[32] = 1
                        if stor1[stor9[idx]] > t:
                            _11635 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11635] = 26
                            mem[_11635 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                _11775 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _11775 + 68] = mem[idx + _11635 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11775 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _11775 + -mem[64] + 100
                            if not arg1:
                                if not arg1 * stor19 / 100:
                                    return 0
                                if arg1 * stor19 / 100 and stor11 / totalSupply > -1 / arg1 * stor19 / 100:
                                    revert with 0, 17
                                if not arg1 * stor19 / 100:
                                    revert with 0, 18
                                if arg1 * stor19 / 100 * stor11 / totalSupply / arg1 * stor19 / 100 != stor11 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _13497 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13497] = 30
                                mem[_13497 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * stor19 / 100 * stor11 / totalSupply > 0:
                                    _13760 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _13760 + 68] = mem[idx + _13497 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_13760 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _13760 + -mem[64] + 100
                                if 0 < arg1 * stor19 / 100 * stor11 / totalSupply:
                                    revert with 0, 17
                                _14832 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14832] = 30
                                mem[_14832 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * arg1 * stor19 / 100 * stor11 / totalSupply:
                                    if -1 * arg1 * stor19 / 100 * stor11 / totalSupply < 0:
                                        revert with 0, 17
                                    return (-1 * arg1 * stor19 / 100 * stor11 / totalSupply)
                                _15398 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _15398 + 68] = mem[idx + _14832 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15398 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _15398 + -mem[64] + 100
                            if arg1 and stor11 / totalSupply > -1 / arg1:
                                revert with 0, 17
                            if not arg1:
                                revert with 0, 18
                            if arg1 * stor11 / totalSupply / arg1 != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * stor19 / 100:
                                _13496 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13496] = 30
                                mem[_13496 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor11 / totalSupply:
                                    _13759 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _13759 + 68] = mem[idx + _13496 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_13759 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _13759 + -mem[64] + 100
                                if arg1 * stor11 / totalSupply < 0:
                                    revert with 0, 17
                                _14830 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14830] = 30
                                mem[_14830 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= arg1 * stor11 / totalSupply:
                                    if arg1 * stor11 / totalSupply < 0:
                                        revert with 0, 17
                                    return (arg1 * stor11 / totalSupply)
                                _15397 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _15397 + 68] = mem[idx + _14830 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15397 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _15397 + -mem[64] + 100
                            if arg1 * stor19 / 100 and stor11 / totalSupply > -1 / arg1 * stor19 / 100:
                                revert with 0, 17
                            if not arg1 * stor19 / 100:
                                revert with 0, 18
                            if arg1 * stor19 / 100 * stor11 / totalSupply / arg1 * stor19 / 100 != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _14377 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14377] = 30
                            mem[_14377 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor19 / 100 * stor11 / totalSupply > arg1 * stor11 / totalSupply:
                                _14829 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _14829 + 68] = mem[idx + _14377 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14829 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14829 + -mem[64] + 100
                            if arg1 * stor11 / totalSupply < arg1 * stor19 / 100 * stor11 / totalSupply:
                                revert with 0, 17
                            _16733 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_16733] = 30
                            mem[_16733 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply):
                                if (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply) < 0:
                                    revert with 0, 17
                                return ((arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply))
                            _17557 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _17557 + 68] = mem[idx + _16733 + 32]
                                idx = idx + 32
                                continue 
                            mem[_17557 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _17557 + -mem[64] + 100
                        if idx >= stor9.length:
                            revert with 0, 50
                        mem[0] = stor9[idx]
                        mem[32] = 2
                        if stor2[stor9[idx]] <= s:
                            if idx >= stor9.length:
                                revert with 0, 50
                            mem[0] = stor9[idx]
                            mem[32] = 1
                            _11776 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11776] = 30
                            mem[_11776 + 32] = 'SafeMath: subtraction overflow'
                            if stor1[stor9[idx]] > t:
                                _11936 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11936 + 68] = mem[idx + _11776 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11936 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11936 + -mem[64] + 100
                            if t < stor1[stor9[idx]]:
                                revert with 0, 17
                            if idx >= stor9.length:
                                revert with 0, 50
                            mem[0] = stor9[idx]
                            mem[32] = 2
                            _12641 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12641] = 30
                            mem[_12641 + 32] = 'SafeMath: subtraction overflow'
                            if stor2[stor9[idx]] <= s:
                                if s < stor2[stor9[idx]]:
                                    revert with 0, 17
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s - stor2[stor9[idx]]
                                t = t - stor1[stor9[idx]]
                                continue 
                            _12737 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12737 + 68] = mem[idx + _12641 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12737 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12737 + -mem[64] + 100
                        _11777 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11777] = 26
                        mem[_11777 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _11937 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _11937 + 68] = mem[idx + _11777 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11937 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _11937 + -mem[64] + 100
                        if not arg1:
                            if not arg1 * stor19 / 100:
                                return 0
                            if arg1 * stor19 / 100 and stor11 / totalSupply > -1 / arg1 * stor19 / 100:
                                revert with 0, 17
                            if not arg1 * stor19 / 100:
                                revert with 0, 18
                            if arg1 * stor19 / 100 * stor11 / totalSupply / arg1 * stor19 / 100 != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _13764 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13764] = 30
                            mem[_13764 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor19 / 100 * stor11 / totalSupply > 0:
                                _13992 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _13992 + 68] = mem[idx + _13764 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13992 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13992 + -mem[64] + 100
                            if 0 < arg1 * stor19 / 100 * stor11 / totalSupply:
                                revert with 0, 17
                            _15402 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15402] = 30
                            mem[_15402 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * stor19 / 100 * stor11 / totalSupply:
                                if -1 * arg1 * stor19 / 100 * stor11 / totalSupply < 0:
                                    revert with 0, 17
                                return (-1 * arg1 * stor19 / 100 * stor11 / totalSupply)
                            _16054 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _16054 + 68] = mem[idx + _15402 + 32]
                                idx = idx + 32
                                continue 
                            mem[_16054 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _16054 + -mem[64] + 100
                        if arg1 and stor11 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor11 / totalSupply / arg1 != stor11 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor19 / 100:
                            _13763 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13763] = 30
                            mem[_13763 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor11 / totalSupply:
                                _13991 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _13991 + 68] = mem[idx + _13763 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13991 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13991 + -mem[64] + 100
                            if arg1 * stor11 / totalSupply < 0:
                                revert with 0, 17
                            _15400 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15400] = 30
                            mem[_15400 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor11 / totalSupply:
                                if arg1 * stor11 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor11 / totalSupply)
                            _16053 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _16053 + 68] = mem[idx + _15400 + 32]
                                idx = idx + 32
                                continue 
                            mem[_16053 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _16053 + -mem[64] + 100
                        if arg1 * stor19 / 100 and stor11 / totalSupply > -1 / arg1 * stor19 / 100:
                            revert with 0, 17
                        if not arg1 * stor19 / 100:
                            revert with 0, 18
                        if arg1 * stor19 / 100 * stor11 / totalSupply / arg1 * stor19 / 100 != stor11 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _14834 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14834] = 30
                        mem[_14834 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor19 / 100 * stor11 / totalSupply > arg1 * stor11 / totalSupply:
                            _15399 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _15399 + 68] = mem[idx + _14834 + 32]
                                idx = idx + 32
                                continue 
                            mem[_15399 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _15399 + -mem[64] + 100
                        if arg1 * stor11 / totalSupply < arg1 * stor19 / 100 * stor11 / totalSupply:
                            revert with 0, 17
                        _17560 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_17560] = 30
                        mem[_17560 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply):
                            if (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply) < 0:
                                revert with 0, 17
                            return ((arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply))
                        _18329 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _18329 + 68] = mem[idx + _17560 + 32]
                            idx = idx + 32
                            continue 
                        mem[_18329 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _18329 + -mem[64] + 100
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if t >= stor11 / totalSupply:
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg1:
                        if not arg1 * stor19 / 100:
                            return 0
                        if arg1 * stor19 / 100 and t / s > -1 / arg1 * stor19 / 100:
                            revert with 0, 17
                        if not arg1 * stor19 / 100:
                            revert with 0, 18
                        if arg1 * stor19 / 100 * t / s / arg1 * stor19 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * stor19 / 100 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * stor19 / 100 * t / s:
                            revert with 0, 17
                        if 0 > -1 * arg1 * stor19 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * stor19 / 100 * t / s < 0:
                            revert with 0, 17
                        return (-1 * arg1 * stor19 / 100 * t / s)
                    if arg1 and t / s > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor19 / 100:
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        return (arg1 * t / s)
                    if arg1 * stor19 / 100 and t / s > -1 / arg1 * stor19 / 100:
                        revert with 0, 17
                    if not arg1 * stor19 / 100:
                        revert with 0, 18
                    if arg1 * stor19 / 100 * t / s / arg1 * stor19 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * stor19 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * stor19 / 100 * t / s:
                        revert with 0, 17
                    if 0 > (arg1 * t / s) - (arg1 * stor19 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * stor19 / 100 * t / s) < 0:
                        revert with 0, 17
                    return ((arg1 * t / s) - (arg1 * stor19 / 100 * t / s))
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if not arg1 * stor19 / 100:
                        return 0
                    if arg1 * stor19 / 100 and stor11 / totalSupply > -1 / arg1 * stor19 / 100:
                        revert with 0, 17
                    if not arg1 * stor19 / 100:
                        revert with 0, 18
                    if arg1 * stor19 / 100 * stor11 / totalSupply / arg1 * stor19 / 100 != stor11 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * stor19 / 100 * stor11 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * stor19 / 100 * stor11 / totalSupply:
                        revert with 0, 17
                    if 0 > -1 * arg1 * stor19 / 100 * stor11 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * stor19 / 100 * stor11 / totalSupply < 0:
                        revert with 0, 17
                    return (-1 * arg1 * stor19 / 100 * stor11 / totalSupply)
                if arg1 and stor11 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor11 / totalSupply / arg1 != stor11 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor19 / 100:
                    if 0 > arg1 * stor11 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor11 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor11 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor11 / totalSupply < 0:
                        revert with 0, 17
                    return (arg1 * stor11 / totalSupply)
                if arg1 * stor19 / 100 and stor11 / totalSupply > -1 / arg1 * stor19 / 100:
                    revert with 0, 17
                if not arg1 * stor19 / 100:
                    revert with 0, 18
                if arg1 * stor19 / 100 * stor11 / totalSupply / arg1 * stor19 / 100 != stor11 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg1 * stor19 / 100 * stor11 / totalSupply > arg1 * stor11 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor11 / totalSupply < arg1 * stor19 / 100 * stor11 / totalSupply:
                    revert with 0, 17
                if 0 > (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply) < 0:
                    revert with 0, 17
                return ((arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply))
            if arg1 and stor30 > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * stor30 / arg1 != stor30:
                revert with 0, 'SafeMath: multiplication overflow'
            mem[224] = 26
            mem[256] = 'SafeMath: division by zero'
            if not arg1:
                mem[288] = 26
                mem[320] = 'SafeMath: division by zero'
                if 0 > !(arg1 * stor30 / 100):
                    revert with 0, 17
                if arg1 * stor30 / 100 < 0:
                    revert with 0, 'SafeMath: addition overflow'
                mem[352] = 30
                mem[384] = 'SafeMath: subtraction overflow'
                if arg1 * stor19 / 100 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < arg1 * stor19 / 100:
                    revert with 0, 17
                mem[416] = 30
                mem[448] = 'SafeMath: subtraction overflow'
                if arg1 * stor30 / 100 > arg1 - (arg1 * stor19 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * stor19 / 100) < arg1 * stor30 / 100:
                    revert with 0, 17
                mem[64] = 544
                mem[480] = 30
                mem[512] = 'SafeMath: subtraction overflow'
                if 0 > arg1 - (arg1 * stor19 / 100) - (arg1 * stor30 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * stor19 / 100) - (arg1 * stor30 / 100) < 0:
                    revert with 0, 17
                if 0 > !(arg1 * stor30 / 100):
                    revert with 0, 17
                if arg1 * stor30 / 100 < 0:
                    revert with 0, 'SafeMath: addition overflow'
                idx = 0
                s = totalSupply
                t = stor11
                while idx < stor9.length:
                    mem[0] = stor9[idx]
                    mem[32] = 1
                    if stor1[stor9[idx]] > t:
                        _11634 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11634] = 26
                        mem[_11634 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _11772 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _11772 + 68] = mem[idx + _11634 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11772 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _11772 + -mem[64] + 100
                        if not arg1:
                            if not arg1 * stor19 / 100:
                                if not arg1 * stor30 / 100:
                                    return 0
                                if arg1 * stor30 / 100 and stor11 / totalSupply > -1 / arg1 * stor30 / 100:
                                    revert with 0, 17
                                if not arg1 * stor30 / 100:
                                    revert with 0, 18
                                if arg1 * stor30 / 100 * stor11 / totalSupply / arg1 * stor30 / 100 != stor11 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _13489 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13489] = 30
                                mem[_13489 + 32] = 'SafeMath: subtraction overflow'
                                _14819 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14819] = 30
                                mem[_14819 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * stor30 / 100 * stor11 / totalSupply <= 0:
                                    if 0 < arg1 * stor30 / 100 * stor11 / totalSupply:
                                        revert with 0, 17
                                    return (-1 * arg1 * stor30 / 100 * stor11 / totalSupply)
                                _15388 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _15388 + 68] = mem[idx + _14819 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15388 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _15388 + -mem[64] + 100
                            if arg1 * stor19 / 100 and stor11 / totalSupply > -1 / arg1 * stor19 / 100:
                                revert with 0, 17
                            if not arg1 * stor19 / 100:
                                revert with 0, 18
                            if arg1 * stor19 / 100 * stor11 / totalSupply / arg1 * stor19 / 100 != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * stor30 / 100:
                                _13488 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13488] = 30
                                mem[_13488 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * stor19 / 100 * stor11 / totalSupply > 0:
                                    _13753 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _13753 + 68] = mem[idx + _13488 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_13753 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _13753 + -mem[64] + 100
                                if 0 < arg1 * stor19 / 100 * stor11 / totalSupply:
                                    revert with 0, 17
                                _14817 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14817] = 30
                                mem[_14817 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * arg1 * stor19 / 100 * stor11 / totalSupply:
                                    if -1 * arg1 * stor19 / 100 * stor11 / totalSupply < 0:
                                        revert with 0, 17
                                    return (-1 * arg1 * stor19 / 100 * stor11 / totalSupply)
                                _15387 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _15387 + 68] = mem[idx + _14817 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15387 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _15387 + -mem[64] + 100
                            if arg1 * stor30 / 100 and stor11 / totalSupply > -1 / arg1 * stor30 / 100:
                                revert with 0, 17
                            if not arg1 * stor30 / 100:
                                revert with 0, 18
                            if arg1 * stor30 / 100 * stor11 / totalSupply / arg1 * stor30 / 100 != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _14368 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14368] = 30
                            mem[_14368 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor19 / 100 * stor11 / totalSupply > 0:
                                _14816 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _14816 + 68] = mem[idx + _14368 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14816 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14816 + -mem[64] + 100
                            if 0 < arg1 * stor19 / 100 * stor11 / totalSupply:
                                revert with 0, 17
                            _16719 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_16719] = 30
                            mem[_16719 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor30 / 100 * stor11 / totalSupply <= -1 * arg1 * stor19 / 100 * stor11 / totalSupply:
                                if -1 * arg1 * stor19 / 100 * stor11 / totalSupply < arg1 * stor30 / 100 * stor11 / totalSupply:
                                    revert with 0, 17
                                return ((-1 * arg1 * stor19 / 100 * stor11 / totalSupply) - (arg1 * stor30 / 100 * stor11 / totalSupply))
                            _17542 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _17542 + 68] = mem[idx + _16719 + 32]
                                idx = idx + 32
                                continue 
                            mem[_17542 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _17542 + -mem[64] + 100
                        if arg1 and stor11 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor11 / totalSupply / arg1 != stor11 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor19 / 100:
                            if not arg1 * stor30 / 100:
                                _13487 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13487] = 30
                                mem[_13487 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor11 / totalSupply:
                                    _13752 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _13752 + 68] = mem[idx + _13487 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_13752 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _13752 + -mem[64] + 100
                                if arg1 * stor11 / totalSupply < 0:
                                    revert with 0, 17
                                _14814 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14814] = 30
                                mem[_14814 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= arg1 * stor11 / totalSupply:
                                    if arg1 * stor11 / totalSupply < 0:
                                        revert with 0, 17
                                    return (arg1 * stor11 / totalSupply)
                                _15386 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _15386 + 68] = mem[idx + _14814 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15386 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _15386 + -mem[64] + 100
                            if arg1 * stor30 / 100 and stor11 / totalSupply > -1 / arg1 * stor30 / 100:
                                revert with 0, 17
                            if not arg1 * stor30 / 100:
                                revert with 0, 18
                            if arg1 * stor30 / 100 * stor11 / totalSupply / arg1 * stor30 / 100 != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _14367 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14367] = 30
                            mem[_14367 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor11 / totalSupply:
                                _14813 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _14813 + 68] = mem[idx + _14367 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14813 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14813 + -mem[64] + 100
                            if arg1 * stor11 / totalSupply < 0:
                                revert with 0, 17
                            _16717 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_16717] = 30
                            mem[_16717 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor30 / 100 * stor11 / totalSupply <= arg1 * stor11 / totalSupply:
                                if arg1 * stor11 / totalSupply < arg1 * stor30 / 100 * stor11 / totalSupply:
                                    revert with 0, 17
                                return ((arg1 * stor11 / totalSupply) - (arg1 * stor30 / 100 * stor11 / totalSupply))
                            _17540 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _17540 + 68] = mem[idx + _16717 + 32]
                                idx = idx + 32
                                continue 
                            mem[_17540 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _17540 + -mem[64] + 100
                        if arg1 * stor19 / 100 and stor11 / totalSupply > -1 / arg1 * stor19 / 100:
                            revert with 0, 17
                        if not arg1 * stor19 / 100:
                            revert with 0, 18
                        if arg1 * stor19 / 100 * stor11 / totalSupply / arg1 * stor19 / 100 != stor11 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor30 / 100:
                            _14366 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14366] = 30
                            mem[_14366 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor19 / 100 * stor11 / totalSupply > arg1 * stor11 / totalSupply:
                                _14812 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _14812 + 68] = mem[idx + _14366 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14812 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14812 + -mem[64] + 100
                            if arg1 * stor11 / totalSupply < arg1 * stor19 / 100 * stor11 / totalSupply:
                                revert with 0, 17
                            _16715 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_16715] = 30
                            mem[_16715 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply):
                                if (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply) < 0:
                                    revert with 0, 17
                                return ((arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply))
                            _17539 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _17539 + 68] = mem[idx + _16715 + 32]
                                idx = idx + 32
                                continue 
                            mem[_17539 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _17539 + -mem[64] + 100
                        if arg1 * stor30 / 100 and stor11 / totalSupply > -1 / arg1 * stor30 / 100:
                            revert with 0, 17
                        if not arg1 * stor30 / 100:
                            revert with 0, 18
                        if arg1 * stor30 / 100 * stor11 / totalSupply / arg1 * stor30 / 100 != stor11 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _16046 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_16046] = 30
                        mem[_16046 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor19 / 100 * stor11 / totalSupply > arg1 * stor11 / totalSupply:
                            _16714 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _16714 + 68] = mem[idx + _16046 + 32]
                                idx = idx + 32
                                continue 
                            mem[_16714 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _16714 + -mem[64] + 100
                        if arg1 * stor11 / totalSupply < arg1 * stor19 / 100 * stor11 / totalSupply:
                            revert with 0, 17
                        _19062 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19062] = 30
                        mem[_19062 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor30 / 100 * stor11 / totalSupply <= (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply):
                            if (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply) < arg1 * stor30 / 100 * stor11 / totalSupply:
                                revert with 0, 17
                            return ((arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply) - (arg1 * stor30 / 100 * stor11 / totalSupply))
                        _19806 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _19806 + 68] = mem[idx + _19062 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19806 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _19806 + -mem[64] + 100
                    if idx >= stor9.length:
                        revert with 0, 50
                    mem[0] = stor9[idx]
                    mem[32] = 2
                    if stor2[stor9[idx]] <= s:
                        if idx >= stor9.length:
                            revert with 0, 50
                        mem[0] = stor9[idx]
                        mem[32] = 1
                        _11773 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11773] = 30
                        mem[_11773 + 32] = 'SafeMath: subtraction overflow'
                        if stor1[stor9[idx]] > t:
                            _11933 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11933 + 68] = mem[idx + _11773 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11933 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11933 + -mem[64] + 100
                        if t < stor1[stor9[idx]]:
                            revert with 0, 17
                        if idx >= stor9.length:
                            revert with 0, 50
                        mem[0] = stor9[idx]
                        mem[32] = 2
                        _12638 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12638] = 30
                        mem[_12638 + 32] = 'SafeMath: subtraction overflow'
                        if stor2[stor9[idx]] <= s:
                            if s < stor2[stor9[idx]]:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s - stor2[stor9[idx]]
                            t = t - stor1[stor9[idx]]
                            continue 
                        _12734 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _12734 + 68] = mem[idx + _12638 + 32]
                            idx = idx + 32
                            continue 
                        mem[_12734 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _12734 + -mem[64] + 100
                    _11774 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11774] = 26
                    mem[_11774 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _11934 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _11934 + 68] = mem[idx + _11774 + 32]
                            idx = idx + 32
                            continue 
                        mem[_11934 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _11934 + -mem[64] + 100
                    if not arg1:
                        if not arg1 * stor19 / 100:
                            if not arg1 * stor30 / 100:
                                return 0
                            if arg1 * stor30 / 100 and stor11 / totalSupply > -1 / arg1 * stor30 / 100:
                                revert with 0, 17
                            if not arg1 * stor30 / 100:
                                revert with 0, 18
                            if arg1 * stor30 / 100 * stor11 / totalSupply / arg1 * stor30 / 100 != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _13758 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13758] = 30
                            mem[_13758 + 32] = 'SafeMath: subtraction overflow'
                            _15396 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15396] = 30
                            mem[_15396 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor30 / 100 * stor11 / totalSupply <= 0:
                                if 0 < arg1 * stor30 / 100 * stor11 / totalSupply:
                                    revert with 0, 17
                                return (-1 * arg1 * stor30 / 100 * stor11 / totalSupply)
                            _16050 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _16050 + 68] = mem[idx + _15396 + 32]
                                idx = idx + 32
                                continue 
                            mem[_16050 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _16050 + -mem[64] + 100
                        if arg1 * stor19 / 100 and stor11 / totalSupply > -1 / arg1 * stor19 / 100:
                            revert with 0, 17
                        if not arg1 * stor19 / 100:
                            revert with 0, 18
                        if arg1 * stor19 / 100 * stor11 / totalSupply / arg1 * stor19 / 100 != stor11 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor30 / 100:
                            _13757 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13757] = 30
                            mem[_13757 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor19 / 100 * stor11 / totalSupply > 0:
                                _13989 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _13989 + 68] = mem[idx + _13757 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13989 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13989 + -mem[64] + 100
                            if 0 < arg1 * stor19 / 100 * stor11 / totalSupply:
                                revert with 0, 17
                            _15394 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15394] = 30
                            mem[_15394 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * stor19 / 100 * stor11 / totalSupply:
                                if -1 * arg1 * stor19 / 100 * stor11 / totalSupply < 0:
                                    revert with 0, 17
                                return (-1 * arg1 * stor19 / 100 * stor11 / totalSupply)
                            _16049 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _16049 + 68] = mem[idx + _15394 + 32]
                                idx = idx + 32
                                continue 
                            mem[_16049 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _16049 + -mem[64] + 100
                        if arg1 * stor30 / 100 and stor11 / totalSupply > -1 / arg1 * stor30 / 100:
                            revert with 0, 17
                        if not arg1 * stor30 / 100:
                            revert with 0, 18
                        if arg1 * stor30 / 100 * stor11 / totalSupply / arg1 * stor30 / 100 != stor11 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _14822 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14822] = 30
                        mem[_14822 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor19 / 100 * stor11 / totalSupply > 0:
                            _15393 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _15393 + 68] = mem[idx + _14822 + 32]
                                idx = idx + 32
                                continue 
                            mem[_15393 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _15393 + -mem[64] + 100
                        if 0 < arg1 * stor19 / 100 * stor11 / totalSupply:
                            revert with 0, 17
                        _17550 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_17550] = 30
                        mem[_17550 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor30 / 100 * stor11 / totalSupply <= -1 * arg1 * stor19 / 100 * stor11 / totalSupply:
                            if -1 * arg1 * stor19 / 100 * stor11 / totalSupply < arg1 * stor30 / 100 * stor11 / totalSupply:
                                revert with 0, 17
                            return ((-1 * arg1 * stor19 / 100 * stor11 / totalSupply) - (arg1 * stor30 / 100 * stor11 / totalSupply))
                        _18326 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _18326 + 68] = mem[idx + _17550 + 32]
                            idx = idx + 32
                            continue 
                        mem[_18326 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _18326 + -mem[64] + 100
                    if arg1 and stor11 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor11 / totalSupply / arg1 != stor11 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor19 / 100:
                        if not arg1 * stor30 / 100:
                            _13756 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13756] = 30
                            mem[_13756 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor11 / totalSupply:
                                _13988 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _13988 + 68] = mem[idx + _13756 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13988 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13988 + -mem[64] + 100
                            if arg1 * stor11 / totalSupply < 0:
                                revert with 0, 17
                            _15391 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15391] = 30
                            mem[_15391 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor11 / totalSupply:
                                if arg1 * stor11 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor11 / totalSupply)
                            _16048 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _16048 + 68] = mem[idx + _15391 + 32]
                                idx = idx + 32
                                continue 
                            mem[_16048 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _16048 + -mem[64] + 100
                        if arg1 * stor30 / 100 and stor11 / totalSupply > -1 / arg1 * stor30 / 100:
                            revert with 0, 17
                        if not arg1 * stor30 / 100:
                            revert with 0, 18
                        if arg1 * stor30 / 100 * stor11 / totalSupply / arg1 * stor30 / 100 != stor11 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _14821 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14821] = 30
                        mem[_14821 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor11 / totalSupply:
                            _15390 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _15390 + 68] = mem[idx + _14821 + 32]
                                idx = idx + 32
                                continue 
                            mem[_15390 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _15390 + -mem[64] + 100
                        if arg1 * stor11 / totalSupply < 0:
                            revert with 0, 17
                        _17548 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_17548] = 30
                        mem[_17548 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor30 / 100 * stor11 / totalSupply <= arg1 * stor11 / totalSupply:
                            if arg1 * stor11 / totalSupply < arg1 * stor30 / 100 * stor11 / totalSupply:
                                revert with 0, 17
                            return ((arg1 * stor11 / totalSupply) - (arg1 * stor30 / 100 * stor11 / totalSupply))
                        _18324 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _18324 + 68] = mem[idx + _17548 + 32]
                            idx = idx + 32
                            continue 
                        mem[_18324 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _18324 + -mem[64] + 100
                    if arg1 * stor19 / 100 and stor11 / totalSupply > -1 / arg1 * stor19 / 100:
                        revert with 0, 17
                    if not arg1 * stor19 / 100:
                        revert with 0, 18
                    if arg1 * stor19 / 100 * stor11 / totalSupply / arg1 * stor19 / 100 != stor11 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor30 / 100:
                        _14820 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14820] = 30
                        mem[_14820 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor19 / 100 * stor11 / totalSupply > arg1 * stor11 / totalSupply:
                            _15389 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _15389 + 68] = mem[idx + _14820 + 32]
                                idx = idx + 32
                                continue 
                            mem[_15389 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _15389 + -mem[64] + 100
                        if arg1 * stor11 / totalSupply < arg1 * stor19 / 100 * stor11 / totalSupply:
                            revert with 0, 17
                        _17546 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_17546] = 30
                        mem[_17546 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply):
                            if (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply) < 0:
                                revert with 0, 17
                            return ((arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply))
                        _18323 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _18323 + 68] = mem[idx + _17546 + 32]
                            idx = idx + 32
                            continue 
                        mem[_18323 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _18323 + -mem[64] + 100
                    if arg1 * stor30 / 100 and stor11 / totalSupply > -1 / arg1 * stor30 / 100:
                        revert with 0, 17
                    if not arg1 * stor30 / 100:
                        revert with 0, 18
                    if arg1 * stor30 / 100 * stor11 / totalSupply / arg1 * stor30 / 100 != stor11 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _16722 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_16722] = 30
                    mem[_16722 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor19 / 100 * stor11 / totalSupply > arg1 * stor11 / totalSupply:
                        _17545 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _17545 + 68] = mem[idx + _16722 + 32]
                            idx = idx + 32
                            continue 
                        mem[_17545 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _17545 + -mem[64] + 100
                    if arg1 * stor11 / totalSupply < arg1 * stor19 / 100 * stor11 / totalSupply:
                        revert with 0, 17
                    _19810 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_19810] = 30
                    mem[_19810 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor30 / 100 * stor11 / totalSupply <= (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply):
                        if (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply) < arg1 * stor30 / 100 * stor11 / totalSupply:
                            revert with 0, 17
                        return ((arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply) - (arg1 * stor30 / 100 * stor11 / totalSupply))
                    _20309 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _20309 + 68] = mem[idx + _19810 + 32]
                        idx = idx + 32
                        continue 
                    mem[_20309 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _20309 + -mem[64] + 100
            else:
                if arg1 and stor35 > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor35 / arg1 != stor35:
                    revert with 0, 'SafeMath: multiplication overflow'
                mem[288] = 26
                mem[320] = 'SafeMath: division by zero'
                if 0 > !(arg1 * stor30 / 100):
                    revert with 0, 17
                if arg1 * stor30 / 100 < 0:
                    revert with 0, 'SafeMath: addition overflow'
                mem[352] = 30
                mem[384] = 'SafeMath: subtraction overflow'
                if arg1 * stor19 / 100 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < arg1 * stor19 / 100:
                    revert with 0, 17
                mem[416] = 30
                mem[448] = 'SafeMath: subtraction overflow'
                if arg1 * stor30 / 100 > arg1 - (arg1 * stor19 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * stor19 / 100) < arg1 * stor30 / 100:
                    revert with 0, 17
                mem[64] = 544
                mem[480] = 30
                mem[512] = 'SafeMath: subtraction overflow'
                if arg1 * stor35 / 100 > arg1 - (arg1 * stor19 / 100) - (arg1 * stor30 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * stor19 / 100) - (arg1 * stor30 / 100) < arg1 * stor35 / 100:
                    revert with 0, 17
                if 0 > !(arg1 * stor30 / 100):
                    revert with 0, 17
                if arg1 * stor30 / 100 < 0:
                    revert with 0, 'SafeMath: addition overflow'
                idx = 0
                s = totalSupply
                t = stor11
                while idx < stor9.length:
                    mem[0] = stor9[idx]
                    mem[32] = 1
                    if stor1[stor9[idx]] > t:
                        _11633 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11633] = 26
                        mem[_11633 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _11769 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _11769 + 68] = mem[idx + _11633 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11769 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _11769 + -mem[64] + 100
                        if not arg1:
                            if not arg1 * stor19 / 100:
                                if not arg1 * stor30 / 100:
                                    return 0
                                if arg1 * stor30 / 100 and stor11 / totalSupply > -1 / arg1 * stor30 / 100:
                                    revert with 0, 17
                                if not arg1 * stor30 / 100:
                                    revert with 0, 18
                                if arg1 * stor30 / 100 * stor11 / totalSupply / arg1 * stor30 / 100 != stor11 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _13480 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13480] = 30
                                mem[_13480 + 32] = 'SafeMath: subtraction overflow'
                                _14802 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14802] = 30
                                mem[_14802 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * stor30 / 100 * stor11 / totalSupply <= 0:
                                    if 0 < arg1 * stor30 / 100 * stor11 / totalSupply:
                                        revert with 0, 17
                                    return (-1 * arg1 * stor30 / 100 * stor11 / totalSupply)
                                _15372 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _15372 + 68] = mem[idx + _14802 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15372 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _15372 + -mem[64] + 100
                            if arg1 * stor19 / 100 and stor11 / totalSupply > -1 / arg1 * stor19 / 100:
                                revert with 0, 17
                            if not arg1 * stor19 / 100:
                                revert with 0, 18
                            if arg1 * stor19 / 100 * stor11 / totalSupply / arg1 * stor19 / 100 != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * stor30 / 100:
                                _13479 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13479] = 30
                                mem[_13479 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * stor19 / 100 * stor11 / totalSupply > 0:
                                    _13746 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _13746 + 68] = mem[idx + _13479 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_13746 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _13746 + -mem[64] + 100
                                if 0 < arg1 * stor19 / 100 * stor11 / totalSupply:
                                    revert with 0, 17
                                _14800 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14800] = 30
                                mem[_14800 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * arg1 * stor19 / 100 * stor11 / totalSupply:
                                    if -1 * arg1 * stor19 / 100 * stor11 / totalSupply < 0:
                                        revert with 0, 17
                                    return (-1 * arg1 * stor19 / 100 * stor11 / totalSupply)
                                _15371 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _15371 + 68] = mem[idx + _14800 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15371 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _15371 + -mem[64] + 100
                            if arg1 * stor30 / 100 and stor11 / totalSupply > -1 / arg1 * stor30 / 100:
                                revert with 0, 17
                            if not arg1 * stor30 / 100:
                                revert with 0, 18
                            if arg1 * stor30 / 100 * stor11 / totalSupply / arg1 * stor30 / 100 != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _14355 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14355] = 30
                            mem[_14355 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor19 / 100 * stor11 / totalSupply > 0:
                                _14799 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _14799 + 68] = mem[idx + _14355 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14799 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14799 + -mem[64] + 100
                            if 0 < arg1 * stor19 / 100 * stor11 / totalSupply:
                                revert with 0, 17
                            _16694 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_16694] = 30
                            mem[_16694 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor30 / 100 * stor11 / totalSupply <= -1 * arg1 * stor19 / 100 * stor11 / totalSupply:
                                if -1 * arg1 * stor19 / 100 * stor11 / totalSupply < arg1 * stor30 / 100 * stor11 / totalSupply:
                                    revert with 0, 17
                                return ((-1 * arg1 * stor19 / 100 * stor11 / totalSupply) - (arg1 * stor30 / 100 * stor11 / totalSupply))
                            _17520 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _17520 + 68] = mem[idx + _16694 + 32]
                                idx = idx + 32
                                continue 
                            mem[_17520 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _17520 + -mem[64] + 100
                        if arg1 and stor11 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor11 / totalSupply / arg1 != stor11 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor19 / 100:
                            if not arg1 * stor30 / 100:
                                _13478 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13478] = 30
                                mem[_13478 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor11 / totalSupply:
                                    _13745 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _13745 + 68] = mem[idx + _13478 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_13745 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _13745 + -mem[64] + 100
                                if arg1 * stor11 / totalSupply < 0:
                                    revert with 0, 17
                                _14797 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14797] = 30
                                mem[_14797 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= arg1 * stor11 / totalSupply:
                                    if arg1 * stor11 / totalSupply < 0:
                                        revert with 0, 17
                                    return (arg1 * stor11 / totalSupply)
                                _15370 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _15370 + 68] = mem[idx + _14797 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15370 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _15370 + -mem[64] + 100
                            if arg1 * stor30 / 100 and stor11 / totalSupply > -1 / arg1 * stor30 / 100:
                                revert with 0, 17
                            if not arg1 * stor30 / 100:
                                revert with 0, 18
                            if arg1 * stor30 / 100 * stor11 / totalSupply / arg1 * stor30 / 100 != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _14354 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14354] = 30
                            mem[_14354 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor11 / totalSupply:
                                _14796 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _14796 + 68] = mem[idx + _14354 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14796 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14796 + -mem[64] + 100
                            if arg1 * stor11 / totalSupply < 0:
                                revert with 0, 17
                            _16692 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_16692] = 30
                            mem[_16692 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor30 / 100 * stor11 / totalSupply <= arg1 * stor11 / totalSupply:
                                if arg1 * stor11 / totalSupply < arg1 * stor30 / 100 * stor11 / totalSupply:
                                    revert with 0, 17
                                return ((arg1 * stor11 / totalSupply) - (arg1 * stor30 / 100 * stor11 / totalSupply))
                            _17518 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _17518 + 68] = mem[idx + _16692 + 32]
                                idx = idx + 32
                                continue 
                            mem[_17518 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _17518 + -mem[64] + 100
                        if arg1 * stor19 / 100 and stor11 / totalSupply > -1 / arg1 * stor19 / 100:
                            revert with 0, 17
                        if not arg1 * stor19 / 100:
                            revert with 0, 18
                        if arg1 * stor19 / 100 * stor11 / totalSupply / arg1 * stor19 / 100 != stor11 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor30 / 100:
                            _14353 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14353] = 30
                            mem[_14353 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor19 / 100 * stor11 / totalSupply > arg1 * stor11 / totalSupply:
                                _14795 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _14795 + 68] = mem[idx + _14353 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14795 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14795 + -mem[64] + 100
                            if arg1 * stor11 / totalSupply < arg1 * stor19 / 100 * stor11 / totalSupply:
                                revert with 0, 17
                            _16690 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_16690] = 30
                            mem[_16690 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply):
                                if (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply) < 0:
                                    revert with 0, 17
                                return ((arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply))
                            _17517 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _17517 + 68] = mem[idx + _16690 + 32]
                                idx = idx + 32
                                continue 
                            mem[_17517 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _17517 + -mem[64] + 100
                        if arg1 * stor30 / 100 and stor11 / totalSupply > -1 / arg1 * stor30 / 100:
                            revert with 0, 17
                        if not arg1 * stor30 / 100:
                            revert with 0, 18
                        if arg1 * stor30 / 100 * stor11 / totalSupply / arg1 * stor30 / 100 != stor11 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _16035 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_16035] = 30
                        mem[_16035 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor19 / 100 * stor11 / totalSupply > arg1 * stor11 / totalSupply:
                            _16689 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _16689 + 68] = mem[idx + _16035 + 32]
                                idx = idx + 32
                                continue 
                            mem[_16689 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _16689 + -mem[64] + 100
                        if arg1 * stor11 / totalSupply < arg1 * stor19 / 100 * stor11 / totalSupply:
                            revert with 0, 17
                        _19041 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19041] = 30
                        mem[_19041 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor30 / 100 * stor11 / totalSupply <= (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply):
                            if (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply) < arg1 * stor30 / 100 * stor11 / totalSupply:
                                revert with 0, 17
                            return ((arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply) - (arg1 * stor30 / 100 * stor11 / totalSupply))
                        _19785 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _19785 + 68] = mem[idx + _19041 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19785 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _19785 + -mem[64] + 100
                    if idx >= stor9.length:
                        revert with 0, 50
                    mem[0] = stor9[idx]
                    mem[32] = 2
                    if stor2[stor9[idx]] <= s:
                        if idx >= stor9.length:
                            revert with 0, 50
                        mem[0] = stor9[idx]
                        mem[32] = 1
                        _11770 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11770] = 30
                        mem[_11770 + 32] = 'SafeMath: subtraction overflow'
                        if stor1[stor9[idx]] > t:
                            _11930 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11930 + 68] = mem[idx + _11770 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11930 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11930 + -mem[64] + 100
                        if t < stor1[stor9[idx]]:
                            revert with 0, 17
                        if idx >= stor9.length:
                            revert with 0, 50
                        mem[0] = stor9[idx]
                        mem[32] = 2
                        _12635 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12635] = 30
                        mem[_12635 + 32] = 'SafeMath: subtraction overflow'
                        if stor2[stor9[idx]] <= s:
                            if s < stor2[stor9[idx]]:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s - stor2[stor9[idx]]
                            t = t - stor1[stor9[idx]]
                            continue 
                        _12731 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _12731 + 68] = mem[idx + _12635 + 32]
                            idx = idx + 32
                            continue 
                        mem[_12731 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _12731 + -mem[64] + 100
                    _11771 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11771] = 26
                    mem[_11771 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _11931 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _11931 + 68] = mem[idx + _11771 + 32]
                            idx = idx + 32
                            continue 
                        mem[_11931 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _11931 + -mem[64] + 100
                    if not arg1:
                        if not arg1 * stor19 / 100:
                            if not arg1 * stor30 / 100:
                                return 0
                            if arg1 * stor30 / 100 and stor11 / totalSupply > -1 / arg1 * stor30 / 100:
                                revert with 0, 17
                            if not arg1 * stor30 / 100:
                                revert with 0, 18
                            if arg1 * stor30 / 100 * stor11 / totalSupply / arg1 * stor30 / 100 != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _13751 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13751] = 30
                            mem[_13751 + 32] = 'SafeMath: subtraction overflow'
                            _15380 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15380] = 30
                            mem[_15380 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor30 / 100 * stor11 / totalSupply <= 0:
                                if 0 < arg1 * stor30 / 100 * stor11 / totalSupply:
                                    revert with 0, 17
                                return (-1 * arg1 * stor30 / 100 * stor11 / totalSupply)
                            _16039 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _16039 + 68] = mem[idx + _15380 + 32]
                                idx = idx + 32
                                continue 
                            mem[_16039 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _16039 + -mem[64] + 100
                        if arg1 * stor19 / 100 and stor11 / totalSupply > -1 / arg1 * stor19 / 100:
                            revert with 0, 17
                        if not arg1 * stor19 / 100:
                            revert with 0, 18
                        if arg1 * stor19 / 100 * stor11 / totalSupply / arg1 * stor19 / 100 != stor11 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor30 / 100:
                            _13750 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13750] = 30
                            mem[_13750 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor19 / 100 * stor11 / totalSupply > 0:
                                _13982 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _13982 + 68] = mem[idx + _13750 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13982 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13982 + -mem[64] + 100
                            if 0 < arg1 * stor19 / 100 * stor11 / totalSupply:
                                revert with 0, 17
                            _15378 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15378] = 30
                            mem[_15378 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * stor19 / 100 * stor11 / totalSupply:
                                if -1 * arg1 * stor19 / 100 * stor11 / totalSupply < 0:
                                    revert with 0, 17
                                return (-1 * arg1 * stor19 / 100 * stor11 / totalSupply)
                            _16038 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _16038 + 68] = mem[idx + _15378 + 32]
                                idx = idx + 32
                                continue 
                            mem[_16038 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _16038 + -mem[64] + 100
                        if arg1 * stor30 / 100 and stor11 / totalSupply > -1 / arg1 * stor30 / 100:
                            revert with 0, 17
                        if not arg1 * stor30 / 100:
                            revert with 0, 18
                        if arg1 * stor30 / 100 * stor11 / totalSupply / arg1 * stor30 / 100 != stor11 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _14805 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14805] = 30
                        mem[_14805 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor19 / 100 * stor11 / totalSupply > 0:
                            _15377 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _15377 + 68] = mem[idx + _14805 + 32]
                                idx = idx + 32
                                continue 
                            mem[_15377 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _15377 + -mem[64] + 100
                        if 0 < arg1 * stor19 / 100 * stor11 / totalSupply:
                            revert with 0, 17
                        _17528 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_17528] = 30
                        mem[_17528 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor30 / 100 * stor11 / totalSupply <= -1 * arg1 * stor19 / 100 * stor11 / totalSupply:
                            if -1 * arg1 * stor19 / 100 * stor11 / totalSupply < arg1 * stor30 / 100 * stor11 / totalSupply:
                                revert with 0, 17
                            return ((-1 * arg1 * stor19 / 100 * stor11 / totalSupply) - (arg1 * stor30 / 100 * stor11 / totalSupply))
                        _18318 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _18318 + 68] = mem[idx + _17528 + 32]
                            idx = idx + 32
                            continue 
                        mem[_18318 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _18318 + -mem[64] + 100
                    if arg1 and stor11 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor11 / totalSupply / arg1 != stor11 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor19 / 100:
                        if not arg1 * stor30 / 100:
                            _13749 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13749] = 30
                            mem[_13749 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor11 / totalSupply:
                                _13981 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _13981 + 68] = mem[idx + _13749 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13981 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13981 + -mem[64] + 100
                            if arg1 * stor11 / totalSupply < 0:
                                revert with 0, 17
                            _15375 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15375] = 30
                            mem[_15375 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor11 / totalSupply:
                                if arg1 * stor11 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor11 / totalSupply)
                            _16037 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _16037 + 68] = mem[idx + _15375 + 32]
                                idx = idx + 32
                                continue 
                            mem[_16037 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _16037 + -mem[64] + 100
                        if arg1 * stor30 / 100 and stor11 / totalSupply > -1 / arg1 * stor30 / 100:
                            revert with 0, 17
                        if not arg1 * stor30 / 100:
                            revert with 0, 18
                        if arg1 * stor30 / 100 * stor11 / totalSupply / arg1 * stor30 / 100 != stor11 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _14804 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14804] = 30
                        mem[_14804 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor11 / totalSupply:
                            _15374 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _15374 + 68] = mem[idx + _14804 + 32]
                                idx = idx + 32
                                continue 
                            mem[_15374 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _15374 + -mem[64] + 100
                        if arg1 * stor11 / totalSupply < 0:
                            revert with 0, 17
                        _17526 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_17526] = 30
                        mem[_17526 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor30 / 100 * stor11 / totalSupply <= arg1 * stor11 / totalSupply:
                            if arg1 * stor11 / totalSupply < arg1 * stor30 / 100 * stor11 / totalSupply:
                                revert with 0, 17
                            return ((arg1 * stor11 / totalSupply) - (arg1 * stor30 / 100 * stor11 / totalSupply))
                        _18316 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _18316 + 68] = mem[idx + _17526 + 32]
                            idx = idx + 32
                            continue 
                        mem[_18316 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _18316 + -mem[64] + 100
                    if arg1 * stor19 / 100 and stor11 / totalSupply > -1 / arg1 * stor19 / 100:
                        revert with 0, 17
                    if not arg1 * stor19 / 100:
                        revert with 0, 18
                    if arg1 * stor19 / 100 * stor11 / totalSupply / arg1 * stor19 / 100 != stor11 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor30 / 100:
                        _14803 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14803] = 30
                        mem[_14803 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor19 / 100 * stor11 / totalSupply > arg1 * stor11 / totalSupply:
                            _15373 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _15373 + 68] = mem[idx + _14803 + 32]
                                idx = idx + 32
                                continue 
                            mem[_15373 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _15373 + -mem[64] + 100
                        if arg1 * stor11 / totalSupply < arg1 * stor19 / 100 * stor11 / totalSupply:
                            revert with 0, 17
                        _17524 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_17524] = 30
                        mem[_17524 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply):
                            if (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply) < 0:
                                revert with 0, 17
                            return ((arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply))
                        _18315 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _18315 + 68] = mem[idx + _17524 + 32]
                            idx = idx + 32
                            continue 
                        mem[_18315 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _18315 + -mem[64] + 100
                    if arg1 * stor30 / 100 and stor11 / totalSupply > -1 / arg1 * stor30 / 100:
                        revert with 0, 17
                    if not arg1 * stor30 / 100:
                        revert with 0, 18
                    if arg1 * stor30 / 100 * stor11 / totalSupply / arg1 * stor30 / 100 != stor11 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _16697 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_16697] = 30
                    mem[_16697 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor19 / 100 * stor11 / totalSupply > arg1 * stor11 / totalSupply:
                        _17523 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _17523 + 68] = mem[idx + _16697 + 32]
                            idx = idx + 32
                            continue 
                        mem[_17523 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _17523 + -mem[64] + 100
                    if arg1 * stor11 / totalSupply < arg1 * stor19 / 100 * stor11 / totalSupply:
                        revert with 0, 17
                    _19789 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_19789] = 30
                    mem[_19789 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor30 / 100 * stor11 / totalSupply <= (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply):
                        if (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply) < arg1 * stor30 / 100 * stor11 / totalSupply:
                            revert with 0, 17
                        return ((arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply) - (arg1 * stor30 / 100 * stor11 / totalSupply))
                    _20305 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _20305 + 68] = mem[idx + _19789 + 32]
                        idx = idx + 32
                        continue 
                    mem[_20305 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _20305 + -mem[64] + 100
            if not totalSupply:
                revert with 0, 'SafeMath: division by zero', 0
            if t >= stor11 / totalSupply:
                if not s:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if not arg1 * stor19 / 100:
                        if not arg1 * stor30 / 100:
                            return 0
                        if arg1 * stor30 / 100 and t / s > -1 / arg1 * stor30 / 100:
                            revert with 0, 17
                        if not arg1 * stor30 / 100:
                            revert with 0, 18
                        if arg1 * stor30 / 100 * t / s / arg1 * stor30 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * stor30 / 100 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * stor30 / 100 * t / s:
                            revert with 0, 17
                        return (-1 * arg1 * stor30 / 100 * t / s)
                    if arg1 * stor19 / 100 and t / s > -1 / arg1 * stor19 / 100:
                        revert with 0, 17
                    if not arg1 * stor19 / 100:
                        revert with 0, 18
                    if arg1 * stor19 / 100 * t / s / arg1 * stor19 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor30 / 100:
                        if arg1 * stor19 / 100 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * stor19 / 100 * t / s:
                            revert with 0, 17
                        if 0 > -1 * arg1 * stor19 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * stor19 / 100 * t / s < 0:
                            revert with 0, 17
                        return (-1 * arg1 * stor19 / 100 * t / s)
                    if arg1 * stor30 / 100 and t / s > -1 / arg1 * stor30 / 100:
                        revert with 0, 17
                    if not arg1 * stor30 / 100:
                        revert with 0, 18
                    if arg1 * stor30 / 100 * t / s / arg1 * stor30 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * stor19 / 100 * t / s > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * stor19 / 100 * t / s:
                        revert with 0, 17
                    if arg1 * stor30 / 100 * t / s > -1 * arg1 * stor19 / 100 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * stor19 / 100 * t / s < arg1 * stor30 / 100 * t / s:
                        revert with 0, 17
                    return ((-1 * arg1 * stor19 / 100 * t / s) - (arg1 * stor30 / 100 * t / s))
                if arg1 and t / s > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * t / s / arg1 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor19 / 100:
                    if not arg1 * stor30 / 100:
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        return (arg1 * t / s)
                    if arg1 * stor30 / 100 and t / s > -1 / arg1 * stor30 / 100:
                        revert with 0, 17
                    if not arg1 * stor30 / 100:
                        revert with 0, 18
                    if arg1 * stor30 / 100 * t / s / arg1 * stor30 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 0, 17
                    if arg1 * stor30 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * stor30 / 100 * t / s:
                        revert with 0, 17
                    return ((arg1 * t / s) - (arg1 * stor30 / 100 * t / s))
                if arg1 * stor19 / 100 and t / s > -1 / arg1 * stor19 / 100:
                    revert with 0, 17
                if not arg1 * stor19 / 100:
                    revert with 0, 18
                if arg1 * stor19 / 100 * t / s / arg1 * stor19 / 100 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor30 / 100:
                    if arg1 * stor19 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * stor19 / 100 * t / s:
                        revert with 0, 17
                    if 0 > (arg1 * t / s) - (arg1 * stor19 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * stor19 / 100 * t / s) < 0:
                        revert with 0, 17
                    return ((arg1 * t / s) - (arg1 * stor19 / 100 * t / s))
                if arg1 * stor30 / 100 and t / s > -1 / arg1 * stor30 / 100:
                    revert with 0, 17
                if not arg1 * stor30 / 100:
                    revert with 0, 18
                if arg1 * stor30 / 100 * t / s / arg1 * stor30 / 100 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg1 * stor19 / 100 * t / s > arg1 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * t / s < arg1 * stor19 / 100 * t / s:
                    revert with 0, 17
                if arg1 * stor30 / 100 * t / s > (arg1 * t / s) - (arg1 * stor19 / 100 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * t / s) - (arg1 * stor19 / 100 * t / s) < arg1 * stor30 / 100 * t / s:
                    revert with 0, 17
                return ((arg1 * t / s) - (arg1 * stor19 / 100 * t / s) - (arg1 * stor30 / 100 * t / s))
            if not totalSupply:
                revert with 0, 'SafeMath: division by zero', 0
            if not arg1:
                if not arg1 * stor19 / 100:
                    if not arg1 * stor30 / 100:
                        return 0
                    if arg1 * stor30 / 100 and stor11 / totalSupply > -1 / arg1 * stor30 / 100:
                        revert with 0, 17
                    if not arg1 * stor30 / 100:
                        revert with 0, 18
                    if arg1 * stor30 / 100 * stor11 / totalSupply / arg1 * stor30 / 100 != stor11 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * stor30 / 100 * stor11 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * stor30 / 100 * stor11 / totalSupply:
                        revert with 0, 17
                    return (-1 * arg1 * stor30 / 100 * stor11 / totalSupply)
                if arg1 * stor19 / 100 and stor11 / totalSupply > -1 / arg1 * stor19 / 100:
                    revert with 0, 17
                if not arg1 * stor19 / 100:
                    revert with 0, 18
                if arg1 * stor19 / 100 * stor11 / totalSupply / arg1 * stor19 / 100 != stor11 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor30 / 100:
                    if arg1 * stor19 / 100 * stor11 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * stor19 / 100 * stor11 / totalSupply:
                        revert with 0, 17
                    if 0 > -1 * arg1 * stor19 / 100 * stor11 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * stor19 / 100 * stor11 / totalSupply < 0:
                        revert with 0, 17
                    return (-1 * arg1 * stor19 / 100 * stor11 / totalSupply)
                if arg1 * stor30 / 100 and stor11 / totalSupply > -1 / arg1 * stor30 / 100:
                    revert with 0, 17
                if not arg1 * stor30 / 100:
                    revert with 0, 18
                if arg1 * stor30 / 100 * stor11 / totalSupply / arg1 * stor30 / 100 != stor11 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg1 * stor19 / 100 * stor11 / totalSupply > 0:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if 0 < arg1 * stor19 / 100 * stor11 / totalSupply:
                    revert with 0, 17
                if arg1 * stor30 / 100 * stor11 / totalSupply > -1 * arg1 * stor19 / 100 * stor11 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if -1 * arg1 * stor19 / 100 * stor11 / totalSupply < arg1 * stor30 / 100 * stor11 / totalSupply:
                    revert with 0, 17
                return ((-1 * arg1 * stor19 / 100 * stor11 / totalSupply) - (arg1 * stor30 / 100 * stor11 / totalSupply))
            if arg1 and stor11 / totalSupply > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * stor11 / totalSupply / arg1 != stor11 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * stor19 / 100:
                if not arg1 * stor30 / 100:
                    if 0 > arg1 * stor11 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor11 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor11 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor11 / totalSupply < 0:
                        revert with 0, 17
                    return (arg1 * stor11 / totalSupply)
                if arg1 * stor30 / 100 and stor11 / totalSupply > -1 / arg1 * stor30 / 100:
                    revert with 0, 17
                if not arg1 * stor30 / 100:
                    revert with 0, 18
                if arg1 * stor30 / 100 * stor11 / totalSupply / arg1 * stor30 / 100 != stor11 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 0 > arg1 * stor11 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor11 / totalSupply < 0:
                    revert with 0, 17
                if arg1 * stor30 / 100 * stor11 / totalSupply > arg1 * stor11 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor11 / totalSupply < arg1 * stor30 / 100 * stor11 / totalSupply:
                    revert with 0, 17
                return ((arg1 * stor11 / totalSupply) - (arg1 * stor30 / 100 * stor11 / totalSupply))
            if arg1 * stor19 / 100 and stor11 / totalSupply > -1 / arg1 * stor19 / 100:
                revert with 0, 17
            if not arg1 * stor19 / 100:
                revert with 0, 18
            if arg1 * stor19 / 100 * stor11 / totalSupply / arg1 * stor19 / 100 != stor11 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * stor30 / 100:
                if arg1 * stor19 / 100 * stor11 / totalSupply > arg1 * stor11 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor11 / totalSupply < arg1 * stor19 / 100 * stor11 / totalSupply:
                    revert with 0, 17
                if 0 > (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply) < 0:
                    revert with 0, 17
                return ((arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply))
            if arg1 * stor30 / 100 and stor11 / totalSupply > -1 / arg1 * stor30 / 100:
                revert with 0, 17
            if not arg1 * stor30 / 100:
                revert with 0, 18
            if arg1 * stor30 / 100 * stor11 / totalSupply / arg1 * stor30 / 100 != stor11 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if arg1 * stor19 / 100 * stor11 / totalSupply > arg1 * stor11 / totalSupply:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * stor11 / totalSupply < arg1 * stor19 / 100 * stor11 / totalSupply:
                revert with 0, 17
            if arg1 * stor30 / 100 * stor11 / totalSupply > (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply) < arg1 * stor30 / 100 * stor11 / totalSupply:
                revert with 0, 17
            return ((arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply) - (arg1 * stor30 / 100 * stor11 / totalSupply))
        if arg1 and stor25 > -1 / arg1:
            revert with 0, 17
        if not arg1:
            revert with 0, 18
        if arg1 * stor25 / arg1 != stor25:
            revert with 0, 'SafeMath: multiplication overflow'
        mem[160] = 26
        mem[192] = 'SafeMath: division by zero'
        if not arg1:
            mem[224] = 26
            mem[256] = 'SafeMath: division by zero'
            if not arg1:
                mem[288] = 26
                mem[320] = 'SafeMath: division by zero'
                if arg1 * stor25 / 100 > -1:
                    revert with 0, 17
                if arg1 * stor25 / 100 < arg1 * stor25 / 100:
                    revert with 0, 'SafeMath: addition overflow'
                mem[352] = 30
                mem[384] = 'SafeMath: subtraction overflow'
                if arg1 * stor19 / 100 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < arg1 * stor19 / 100:
                    revert with 0, 17
                mem[416] = 30
                mem[448] = 'SafeMath: subtraction overflow'
                if arg1 * stor25 / 100 > arg1 - (arg1 * stor19 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * stor19 / 100) < arg1 * stor25 / 100:
                    revert with 0, 17
                mem[64] = 544
                mem[480] = 30
                mem[512] = 'SafeMath: subtraction overflow'
                if 0 > arg1 - (arg1 * stor19 / 100) - (arg1 * stor25 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * stor19 / 100) - (arg1 * stor25 / 100) < 0:
                    revert with 0, 17
                if arg1 * stor25 / 100 > -1:
                    revert with 0, 17
                if arg1 * stor25 / 100 < arg1 * stor25 / 100:
                    revert with 0, 'SafeMath: addition overflow'
                idx = 0
                s = totalSupply
                t = stor11
                while idx < stor9.length:
                    mem[0] = stor9[idx]
                    mem[32] = 1
                    if stor1[stor9[idx]] > t:
                        _11632 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11632] = 26
                        mem[_11632 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _11766 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _11766 + 68] = mem[idx + _11632 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11766 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _11766 + -mem[64] + 100
                        if not arg1:
                            if not arg1 * stor19 / 100:
                                if not arg1 * stor25 / 100:
                                    return 0
                                if arg1 * stor25 / 100 and stor11 / totalSupply > -1 / arg1 * stor25 / 100:
                                    revert with 0, 17
                                if not arg1 * stor25 / 100:
                                    revert with 0, 18
                                if arg1 * stor25 / 100 * stor11 / totalSupply / arg1 * stor25 / 100 != stor11 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _13471 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13471] = 30
                                mem[_13471 + 32] = 'SafeMath: subtraction overflow'
                                _14785 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14785] = 30
                                mem[_14785 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * stor25 / 100 * stor11 / totalSupply <= 0:
                                    if 0 < arg1 * stor25 / 100 * stor11 / totalSupply:
                                        revert with 0, 17
                                    return (-1 * arg1 * stor25 / 100 * stor11 / totalSupply)
                                _15356 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _15356 + 68] = mem[idx + _14785 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15356 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _15356 + -mem[64] + 100
                            if arg1 * stor19 / 100 and stor11 / totalSupply > -1 / arg1 * stor19 / 100:
                                revert with 0, 17
                            if not arg1 * stor19 / 100:
                                revert with 0, 18
                            if arg1 * stor19 / 100 * stor11 / totalSupply / arg1 * stor19 / 100 != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * stor25 / 100:
                                _13470 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13470] = 30
                                mem[_13470 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * stor19 / 100 * stor11 / totalSupply > 0:
                                    _13739 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _13739 + 68] = mem[idx + _13470 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_13739 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _13739 + -mem[64] + 100
                                if 0 < arg1 * stor19 / 100 * stor11 / totalSupply:
                                    revert with 0, 17
                                _14783 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14783] = 30
                                mem[_14783 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * arg1 * stor19 / 100 * stor11 / totalSupply:
                                    if -1 * arg1 * stor19 / 100 * stor11 / totalSupply < 0:
                                        revert with 0, 17
                                    return (-1 * arg1 * stor19 / 100 * stor11 / totalSupply)
                                _15355 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _15355 + 68] = mem[idx + _14783 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15355 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _15355 + -mem[64] + 100
                            if arg1 * stor25 / 100 and stor11 / totalSupply > -1 / arg1 * stor25 / 100:
                                revert with 0, 17
                            if not arg1 * stor25 / 100:
                                revert with 0, 18
                            if arg1 * stor25 / 100 * stor11 / totalSupply / arg1 * stor25 / 100 != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _14342 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14342] = 30
                            mem[_14342 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor19 / 100 * stor11 / totalSupply > 0:
                                _14782 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _14782 + 68] = mem[idx + _14342 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14782 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14782 + -mem[64] + 100
                            if 0 < arg1 * stor19 / 100 * stor11 / totalSupply:
                                revert with 0, 17
                            _16669 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_16669] = 30
                            mem[_16669 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor25 / 100 * stor11 / totalSupply <= -1 * arg1 * stor19 / 100 * stor11 / totalSupply:
                                if -1 * arg1 * stor19 / 100 * stor11 / totalSupply < arg1 * stor25 / 100 * stor11 / totalSupply:
                                    revert with 0, 17
                                return ((-1 * arg1 * stor19 / 100 * stor11 / totalSupply) - (arg1 * stor25 / 100 * stor11 / totalSupply))
                            _17498 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _17498 + 68] = mem[idx + _16669 + 32]
                                idx = idx + 32
                                continue 
                            mem[_17498 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _17498 + -mem[64] + 100
                        if arg1 and stor11 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor11 / totalSupply / arg1 != stor11 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor19 / 100:
                            if not arg1 * stor25 / 100:
                                _13469 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13469] = 30
                                mem[_13469 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor11 / totalSupply:
                                    _13738 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _13738 + 68] = mem[idx + _13469 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_13738 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _13738 + -mem[64] + 100
                                if arg1 * stor11 / totalSupply < 0:
                                    revert with 0, 17
                                _14780 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14780] = 30
                                mem[_14780 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= arg1 * stor11 / totalSupply:
                                    if arg1 * stor11 / totalSupply < 0:
                                        revert with 0, 17
                                    return (arg1 * stor11 / totalSupply)
                                _15354 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _15354 + 68] = mem[idx + _14780 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15354 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _15354 + -mem[64] + 100
                            if arg1 * stor25 / 100 and stor11 / totalSupply > -1 / arg1 * stor25 / 100:
                                revert with 0, 17
                            if not arg1 * stor25 / 100:
                                revert with 0, 18
                            if arg1 * stor25 / 100 * stor11 / totalSupply / arg1 * stor25 / 100 != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _14341 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14341] = 30
                            mem[_14341 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor11 / totalSupply:
                                _14779 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _14779 + 68] = mem[idx + _14341 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14779 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14779 + -mem[64] + 100
                            if arg1 * stor11 / totalSupply < 0:
                                revert with 0, 17
                            _16667 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_16667] = 30
                            mem[_16667 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor25 / 100 * stor11 / totalSupply <= arg1 * stor11 / totalSupply:
                                if arg1 * stor11 / totalSupply < arg1 * stor25 / 100 * stor11 / totalSupply:
                                    revert with 0, 17
                                return ((arg1 * stor11 / totalSupply) - (arg1 * stor25 / 100 * stor11 / totalSupply))
                            _17496 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _17496 + 68] = mem[idx + _16667 + 32]
                                idx = idx + 32
                                continue 
                            mem[_17496 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _17496 + -mem[64] + 100
                        if arg1 * stor19 / 100 and stor11 / totalSupply > -1 / arg1 * stor19 / 100:
                            revert with 0, 17
                        if not arg1 * stor19 / 100:
                            revert with 0, 18
                        if arg1 * stor19 / 100 * stor11 / totalSupply / arg1 * stor19 / 100 != stor11 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor25 / 100:
                            _14340 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14340] = 30
                            mem[_14340 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor19 / 100 * stor11 / totalSupply > arg1 * stor11 / totalSupply:
                                _14778 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _14778 + 68] = mem[idx + _14340 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14778 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14778 + -mem[64] + 100
                            if arg1 * stor11 / totalSupply < arg1 * stor19 / 100 * stor11 / totalSupply:
                                revert with 0, 17
                            _16665 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_16665] = 30
                            mem[_16665 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply):
                                if (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply) < 0:
                                    revert with 0, 17
                                return ((arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply))
                            _17495 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _17495 + 68] = mem[idx + _16665 + 32]
                                idx = idx + 32
                                continue 
                            mem[_17495 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _17495 + -mem[64] + 100
                        if arg1 * stor25 / 100 and stor11 / totalSupply > -1 / arg1 * stor25 / 100:
                            revert with 0, 17
                        if not arg1 * stor25 / 100:
                            revert with 0, 18
                        if arg1 * stor25 / 100 * stor11 / totalSupply / arg1 * stor25 / 100 != stor11 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _16024 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_16024] = 30
                        mem[_16024 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor19 / 100 * stor11 / totalSupply > arg1 * stor11 / totalSupply:
                            _16664 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _16664 + 68] = mem[idx + _16024 + 32]
                                idx = idx + 32
                                continue 
                            mem[_16664 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _16664 + -mem[64] + 100
                        if arg1 * stor11 / totalSupply < arg1 * stor19 / 100 * stor11 / totalSupply:
                            revert with 0, 17
                        _19020 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19020] = 30
                        mem[_19020 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor25 / 100 * stor11 / totalSupply <= (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply):
                            if (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply) < arg1 * stor25 / 100 * stor11 / totalSupply:
                                revert with 0, 17
                            return ((arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply) - (arg1 * stor25 / 100 * stor11 / totalSupply))
                        _19764 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _19764 + 68] = mem[idx + _19020 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19764 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _19764 + -mem[64] + 100
                    if idx >= stor9.length:
                        revert with 0, 50
                    mem[0] = stor9[idx]
                    mem[32] = 2
                    if stor2[stor9[idx]] <= s:
                        if idx >= stor9.length:
                            revert with 0, 50
                        mem[0] = stor9[idx]
                        mem[32] = 1
                        _11767 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11767] = 30
                        mem[_11767 + 32] = 'SafeMath: subtraction overflow'
                        if stor1[stor9[idx]] > t:
                            _11927 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11927 + 68] = mem[idx + _11767 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11927 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11927 + -mem[64] + 100
                        if t < stor1[stor9[idx]]:
                            revert with 0, 17
                        if idx >= stor9.length:
                            revert with 0, 50
                        mem[0] = stor9[idx]
                        mem[32] = 2
                        _12632 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12632] = 30
                        mem[_12632 + 32] = 'SafeMath: subtraction overflow'
                        if stor2[stor9[idx]] <= s:
                            if s < stor2[stor9[idx]]:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s - stor2[stor9[idx]]
                            t = t - stor1[stor9[idx]]
                            continue 
                        _12728 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _12728 + 68] = mem[idx + _12632 + 32]
                            idx = idx + 32
                            continue 
                        mem[_12728 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _12728 + -mem[64] + 100
                    _11768 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11768] = 26
                    mem[_11768 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _11928 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _11928 + 68] = mem[idx + _11768 + 32]
                            idx = idx + 32
                            continue 
                        mem[_11928 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _11928 + -mem[64] + 100
                    if not arg1:
                        if not arg1 * stor19 / 100:
                            if not arg1 * stor25 / 100:
                                return 0
                            if arg1 * stor25 / 100 and stor11 / totalSupply > -1 / arg1 * stor25 / 100:
                                revert with 0, 17
                            if not arg1 * stor25 / 100:
                                revert with 0, 18
                            if arg1 * stor25 / 100 * stor11 / totalSupply / arg1 * stor25 / 100 != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _13744 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13744] = 30
                            mem[_13744 + 32] = 'SafeMath: subtraction overflow'
                            _15364 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15364] = 30
                            mem[_15364 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor25 / 100 * stor11 / totalSupply <= 0:
                                if 0 < arg1 * stor25 / 100 * stor11 / totalSupply:
                                    revert with 0, 17
                                return (-1 * arg1 * stor25 / 100 * stor11 / totalSupply)
                            _16028 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _16028 + 68] = mem[idx + _15364 + 32]
                                idx = idx + 32
                                continue 
                            mem[_16028 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _16028 + -mem[64] + 100
                        if arg1 * stor19 / 100 and stor11 / totalSupply > -1 / arg1 * stor19 / 100:
                            revert with 0, 17
                        if not arg1 * stor19 / 100:
                            revert with 0, 18
                        if arg1 * stor19 / 100 * stor11 / totalSupply / arg1 * stor19 / 100 != stor11 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor25 / 100:
                            _13743 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13743] = 30
                            mem[_13743 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor19 / 100 * stor11 / totalSupply > 0:
                                _13975 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _13975 + 68] = mem[idx + _13743 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13975 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13975 + -mem[64] + 100
                            if 0 < arg1 * stor19 / 100 * stor11 / totalSupply:
                                revert with 0, 17
                            _15362 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15362] = 30
                            mem[_15362 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * stor19 / 100 * stor11 / totalSupply:
                                if -1 * arg1 * stor19 / 100 * stor11 / totalSupply < 0:
                                    revert with 0, 17
                                return (-1 * arg1 * stor19 / 100 * stor11 / totalSupply)
                            _16027 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _16027 + 68] = mem[idx + _15362 + 32]
                                idx = idx + 32
                                continue 
                            mem[_16027 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _16027 + -mem[64] + 100
                        if arg1 * stor25 / 100 and stor11 / totalSupply > -1 / arg1 * stor25 / 100:
                            revert with 0, 17
                        if not arg1 * stor25 / 100:
                            revert with 0, 18
                        if arg1 * stor25 / 100 * stor11 / totalSupply / arg1 * stor25 / 100 != stor11 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _14788 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14788] = 30
                        mem[_14788 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor19 / 100 * stor11 / totalSupply > 0:
                            _15361 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _15361 + 68] = mem[idx + _14788 + 32]
                                idx = idx + 32
                                continue 
                            mem[_15361 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _15361 + -mem[64] + 100
                        if 0 < arg1 * stor19 / 100 * stor11 / totalSupply:
                            revert with 0, 17
                        _17506 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_17506] = 30
                        mem[_17506 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor25 / 100 * stor11 / totalSupply <= -1 * arg1 * stor19 / 100 * stor11 / totalSupply:
                            if -1 * arg1 * stor19 / 100 * stor11 / totalSupply < arg1 * stor25 / 100 * stor11 / totalSupply:
                                revert with 0, 17
                            return ((-1 * arg1 * stor19 / 100 * stor11 / totalSupply) - (arg1 * stor25 / 100 * stor11 / totalSupply))
                        _18310 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _18310 + 68] = mem[idx + _17506 + 32]
                            idx = idx + 32
                            continue 
                        mem[_18310 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _18310 + -mem[64] + 100
                    if arg1 and stor11 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor11 / totalSupply / arg1 != stor11 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor19 / 100:
                        if not arg1 * stor25 / 100:
                            _13742 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13742] = 30
                            mem[_13742 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor11 / totalSupply:
                                _13974 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _13974 + 68] = mem[idx + _13742 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13974 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13974 + -mem[64] + 100
                            if arg1 * stor11 / totalSupply < 0:
                                revert with 0, 17
                            _15359 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15359] = 30
                            mem[_15359 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor11 / totalSupply:
                                if arg1 * stor11 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor11 / totalSupply)
                            _16026 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _16026 + 68] = mem[idx + _15359 + 32]
                                idx = idx + 32
                                continue 
                            mem[_16026 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _16026 + -mem[64] + 100
                        if arg1 * stor25 / 100 and stor11 / totalSupply > -1 / arg1 * stor25 / 100:
                            revert with 0, 17
                        if not arg1 * stor25 / 100:
                            revert with 0, 18
                        if arg1 * stor25 / 100 * stor11 / totalSupply / arg1 * stor25 / 100 != stor11 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _14787 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14787] = 30
                        mem[_14787 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor11 / totalSupply:
                            _15358 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _15358 + 68] = mem[idx + _14787 + 32]
                                idx = idx + 32
                                continue 
                            mem[_15358 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _15358 + -mem[64] + 100
                        if arg1 * stor11 / totalSupply < 0:
                            revert with 0, 17
                        _17504 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_17504] = 30
                        mem[_17504 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor25 / 100 * stor11 / totalSupply <= arg1 * stor11 / totalSupply:
                            if arg1 * stor11 / totalSupply < arg1 * stor25 / 100 * stor11 / totalSupply:
                                revert with 0, 17
                            return ((arg1 * stor11 / totalSupply) - (arg1 * stor25 / 100 * stor11 / totalSupply))
                        _18308 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _18308 + 68] = mem[idx + _17504 + 32]
                            idx = idx + 32
                            continue 
                        mem[_18308 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _18308 + -mem[64] + 100
                    if arg1 * stor19 / 100 and stor11 / totalSupply > -1 / arg1 * stor19 / 100:
                        revert with 0, 17
                    if not arg1 * stor19 / 100:
                        revert with 0, 18
                    if arg1 * stor19 / 100 * stor11 / totalSupply / arg1 * stor19 / 100 != stor11 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor25 / 100:
                        _14786 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14786] = 30
                        mem[_14786 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor19 / 100 * stor11 / totalSupply > arg1 * stor11 / totalSupply:
                            _15357 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _15357 + 68] = mem[idx + _14786 + 32]
                                idx = idx + 32
                                continue 
                            mem[_15357 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _15357 + -mem[64] + 100
                        if arg1 * stor11 / totalSupply < arg1 * stor19 / 100 * stor11 / totalSupply:
                            revert with 0, 17
                        _17502 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_17502] = 30
                        mem[_17502 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply):
                            if (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply) < 0:
                                revert with 0, 17
                            return ((arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply))
                        _18307 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _18307 + 68] = mem[idx + _17502 + 32]
                            idx = idx + 32
                            continue 
                        mem[_18307 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _18307 + -mem[64] + 100
                    if arg1 * stor25 / 100 and stor11 / totalSupply > -1 / arg1 * stor25 / 100:
                        revert with 0, 17
                    if not arg1 * stor25 / 100:
                        revert with 0, 18
                    if arg1 * stor25 / 100 * stor11 / totalSupply / arg1 * stor25 / 100 != stor11 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _16672 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_16672] = 30
                    mem[_16672 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor19 / 100 * stor11 / totalSupply > arg1 * stor11 / totalSupply:
                        _17501 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _17501 + 68] = mem[idx + _16672 + 32]
                            idx = idx + 32
                            continue 
                        mem[_17501 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _17501 + -mem[64] + 100
                    if arg1 * stor11 / totalSupply < arg1 * stor19 / 100 * stor11 / totalSupply:
                        revert with 0, 17
                    _19768 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_19768] = 30
                    mem[_19768 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor25 / 100 * stor11 / totalSupply <= (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply):
                        if (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply) < arg1 * stor25 / 100 * stor11 / totalSupply:
                            revert with 0, 17
                        return ((arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply) - (arg1 * stor25 / 100 * stor11 / totalSupply))
                    _20301 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _20301 + 68] = mem[idx + _19768 + 32]
                        idx = idx + 32
                        continue 
                    mem[_20301 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _20301 + -mem[64] + 100
            else:
                if arg1 and stor35 > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor35 / arg1 != stor35:
                    revert with 0, 'SafeMath: multiplication overflow'
                mem[288] = 26
                mem[320] = 'SafeMath: division by zero'
                if arg1 * stor25 / 100 > -1:
                    revert with 0, 17
                if arg1 * stor25 / 100 < arg1 * stor25 / 100:
                    revert with 0, 'SafeMath: addition overflow'
                mem[352] = 30
                mem[384] = 'SafeMath: subtraction overflow'
                if arg1 * stor19 / 100 > arg1:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 < arg1 * stor19 / 100:
                    revert with 0, 17
                mem[416] = 30
                mem[448] = 'SafeMath: subtraction overflow'
                if arg1 * stor25 / 100 > arg1 - (arg1 * stor19 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * stor19 / 100) < arg1 * stor25 / 100:
                    revert with 0, 17
                mem[64] = 544
                mem[480] = 30
                mem[512] = 'SafeMath: subtraction overflow'
                if arg1 * stor35 / 100 > arg1 - (arg1 * stor19 / 100) - (arg1 * stor25 / 100):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 - (arg1 * stor19 / 100) - (arg1 * stor25 / 100) < arg1 * stor35 / 100:
                    revert with 0, 17
                if arg1 * stor25 / 100 > -1:
                    revert with 0, 17
                if arg1 * stor25 / 100 < arg1 * stor25 / 100:
                    revert with 0, 'SafeMath: addition overflow'
                idx = 0
                s = totalSupply
                t = stor11
                while idx < stor9.length:
                    mem[0] = stor9[idx]
                    mem[32] = 1
                    if stor1[stor9[idx]] > t:
                        _11631 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11631] = 26
                        mem[_11631 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _11763 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _11763 + 68] = mem[idx + _11631 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11763 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _11763 + -mem[64] + 100
                        if not arg1:
                            if not arg1 * stor19 / 100:
                                if not arg1 * stor25 / 100:
                                    return 0
                                if arg1 * stor25 / 100 and stor11 / totalSupply > -1 / arg1 * stor25 / 100:
                                    revert with 0, 17
                                if not arg1 * stor25 / 100:
                                    revert with 0, 18
                                if arg1 * stor25 / 100 * stor11 / totalSupply / arg1 * stor25 / 100 != stor11 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _13462 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13462] = 30
                                mem[_13462 + 32] = 'SafeMath: subtraction overflow'
                                _14768 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14768] = 30
                                mem[_14768 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * stor25 / 100 * stor11 / totalSupply <= 0:
                                    if 0 < arg1 * stor25 / 100 * stor11 / totalSupply:
                                        revert with 0, 17
                                    return (-1 * arg1 * stor25 / 100 * stor11 / totalSupply)
                                _15340 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _15340 + 68] = mem[idx + _14768 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15340 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _15340 + -mem[64] + 100
                            if arg1 * stor19 / 100 and stor11 / totalSupply > -1 / arg1 * stor19 / 100:
                                revert with 0, 17
                            if not arg1 * stor19 / 100:
                                revert with 0, 18
                            if arg1 * stor19 / 100 * stor11 / totalSupply / arg1 * stor19 / 100 != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * stor25 / 100:
                                _13461 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13461] = 30
                                mem[_13461 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * stor19 / 100 * stor11 / totalSupply > 0:
                                    _13732 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _13732 + 68] = mem[idx + _13461 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_13732 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _13732 + -mem[64] + 100
                                if 0 < arg1 * stor19 / 100 * stor11 / totalSupply:
                                    revert with 0, 17
                                _14766 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14766] = 30
                                mem[_14766 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * arg1 * stor19 / 100 * stor11 / totalSupply:
                                    if -1 * arg1 * stor19 / 100 * stor11 / totalSupply < 0:
                                        revert with 0, 17
                                    return (-1 * arg1 * stor19 / 100 * stor11 / totalSupply)
                                _15339 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _15339 + 68] = mem[idx + _14766 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15339 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _15339 + -mem[64] + 100
                            if arg1 * stor25 / 100 and stor11 / totalSupply > -1 / arg1 * stor25 / 100:
                                revert with 0, 17
                            if not arg1 * stor25 / 100:
                                revert with 0, 18
                            if arg1 * stor25 / 100 * stor11 / totalSupply / arg1 * stor25 / 100 != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _14329 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14329] = 30
                            mem[_14329 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor19 / 100 * stor11 / totalSupply > 0:
                                _14765 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _14765 + 68] = mem[idx + _14329 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14765 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14765 + -mem[64] + 100
                            if 0 < arg1 * stor19 / 100 * stor11 / totalSupply:
                                revert with 0, 17
                            _16644 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_16644] = 30
                            mem[_16644 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor25 / 100 * stor11 / totalSupply <= -1 * arg1 * stor19 / 100 * stor11 / totalSupply:
                                if -1 * arg1 * stor19 / 100 * stor11 / totalSupply < arg1 * stor25 / 100 * stor11 / totalSupply:
                                    revert with 0, 17
                                return ((-1 * arg1 * stor19 / 100 * stor11 / totalSupply) - (arg1 * stor25 / 100 * stor11 / totalSupply))
                            _17476 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _17476 + 68] = mem[idx + _16644 + 32]
                                idx = idx + 32
                                continue 
                            mem[_17476 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _17476 + -mem[64] + 100
                        if arg1 and stor11 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor11 / totalSupply / arg1 != stor11 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor19 / 100:
                            if not arg1 * stor25 / 100:
                                _13460 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13460] = 30
                                mem[_13460 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor11 / totalSupply:
                                    _13731 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _13731 + 68] = mem[idx + _13460 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_13731 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _13731 + -mem[64] + 100
                                if arg1 * stor11 / totalSupply < 0:
                                    revert with 0, 17
                                _14763 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14763] = 30
                                mem[_14763 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= arg1 * stor11 / totalSupply:
                                    if arg1 * stor11 / totalSupply < 0:
                                        revert with 0, 17
                                    return (arg1 * stor11 / totalSupply)
                                _15338 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _15338 + 68] = mem[idx + _14763 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15338 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _15338 + -mem[64] + 100
                            if arg1 * stor25 / 100 and stor11 / totalSupply > -1 / arg1 * stor25 / 100:
                                revert with 0, 17
                            if not arg1 * stor25 / 100:
                                revert with 0, 18
                            if arg1 * stor25 / 100 * stor11 / totalSupply / arg1 * stor25 / 100 != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _14328 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14328] = 30
                            mem[_14328 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor11 / totalSupply:
                                _14762 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _14762 + 68] = mem[idx + _14328 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14762 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14762 + -mem[64] + 100
                            if arg1 * stor11 / totalSupply < 0:
                                revert with 0, 17
                            _16642 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_16642] = 30
                            mem[_16642 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor25 / 100 * stor11 / totalSupply <= arg1 * stor11 / totalSupply:
                                if arg1 * stor11 / totalSupply < arg1 * stor25 / 100 * stor11 / totalSupply:
                                    revert with 0, 17
                                return ((arg1 * stor11 / totalSupply) - (arg1 * stor25 / 100 * stor11 / totalSupply))
                            _17474 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _17474 + 68] = mem[idx + _16642 + 32]
                                idx = idx + 32
                                continue 
                            mem[_17474 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _17474 + -mem[64] + 100
                        if arg1 * stor19 / 100 and stor11 / totalSupply > -1 / arg1 * stor19 / 100:
                            revert with 0, 17
                        if not arg1 * stor19 / 100:
                            revert with 0, 18
                        if arg1 * stor19 / 100 * stor11 / totalSupply / arg1 * stor19 / 100 != stor11 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor25 / 100:
                            _14327 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14327] = 30
                            mem[_14327 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor19 / 100 * stor11 / totalSupply > arg1 * stor11 / totalSupply:
                                _14761 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _14761 + 68] = mem[idx + _14327 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14761 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14761 + -mem[64] + 100
                            if arg1 * stor11 / totalSupply < arg1 * stor19 / 100 * stor11 / totalSupply:
                                revert with 0, 17
                            _16640 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_16640] = 30
                            mem[_16640 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply):
                                if (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply) < 0:
                                    revert with 0, 17
                                return ((arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply))
                            _17473 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _17473 + 68] = mem[idx + _16640 + 32]
                                idx = idx + 32
                                continue 
                            mem[_17473 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _17473 + -mem[64] + 100
                        if arg1 * stor25 / 100 and stor11 / totalSupply > -1 / arg1 * stor25 / 100:
                            revert with 0, 17
                        if not arg1 * stor25 / 100:
                            revert with 0, 18
                        if arg1 * stor25 / 100 * stor11 / totalSupply / arg1 * stor25 / 100 != stor11 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _16013 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_16013] = 30
                        mem[_16013 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor19 / 100 * stor11 / totalSupply > arg1 * stor11 / totalSupply:
                            _16639 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _16639 + 68] = mem[idx + _16013 + 32]
                                idx = idx + 32
                                continue 
                            mem[_16639 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _16639 + -mem[64] + 100
                        if arg1 * stor11 / totalSupply < arg1 * stor19 / 100 * stor11 / totalSupply:
                            revert with 0, 17
                        _18999 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_18999] = 30
                        mem[_18999 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor25 / 100 * stor11 / totalSupply <= (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply):
                            if (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply) < arg1 * stor25 / 100 * stor11 / totalSupply:
                                revert with 0, 17
                            return ((arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply) - (arg1 * stor25 / 100 * stor11 / totalSupply))
                        _19743 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _19743 + 68] = mem[idx + _18999 + 32]
                            idx = idx + 32
                            continue 
                        mem[_19743 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _19743 + -mem[64] + 100
                    if idx >= stor9.length:
                        revert with 0, 50
                    mem[0] = stor9[idx]
                    mem[32] = 2
                    if stor2[stor9[idx]] <= s:
                        if idx >= stor9.length:
                            revert with 0, 50
                        mem[0] = stor9[idx]
                        mem[32] = 1
                        _11764 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11764] = 30
                        mem[_11764 + 32] = 'SafeMath: subtraction overflow'
                        if stor1[stor9[idx]] > t:
                            _11924 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _11924 + 68] = mem[idx + _11764 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11924 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _11924 + -mem[64] + 100
                        if t < stor1[stor9[idx]]:
                            revert with 0, 17
                        if idx >= stor9.length:
                            revert with 0, 50
                        mem[0] = stor9[idx]
                        mem[32] = 2
                        _12629 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_12629] = 30
                        mem[_12629 + 32] = 'SafeMath: subtraction overflow'
                        if stor2[stor9[idx]] <= s:
                            if s < stor2[stor9[idx]]:
                                revert with 0, 17
                            if idx == -1:
                                revert with 0, 17
                            idx = idx + 1
                            s = s - stor2[stor9[idx]]
                            t = t - stor1[stor9[idx]]
                            continue 
                        _12725 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _12725 + 68] = mem[idx + _12629 + 32]
                            idx = idx + 32
                            continue 
                        mem[_12725 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _12725 + -mem[64] + 100
                    _11765 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11765] = 26
                    mem[_11765 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _11925 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _11925 + 68] = mem[idx + _11765 + 32]
                            idx = idx + 32
                            continue 
                        mem[_11925 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _11925 + -mem[64] + 100
                    if not arg1:
                        if not arg1 * stor19 / 100:
                            if not arg1 * stor25 / 100:
                                return 0
                            if arg1 * stor25 / 100 and stor11 / totalSupply > -1 / arg1 * stor25 / 100:
                                revert with 0, 17
                            if not arg1 * stor25 / 100:
                                revert with 0, 18
                            if arg1 * stor25 / 100 * stor11 / totalSupply / arg1 * stor25 / 100 != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _13737 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13737] = 30
                            mem[_13737 + 32] = 'SafeMath: subtraction overflow'
                            _15348 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15348] = 30
                            mem[_15348 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor25 / 100 * stor11 / totalSupply <= 0:
                                if 0 < arg1 * stor25 / 100 * stor11 / totalSupply:
                                    revert with 0, 17
                                return (-1 * arg1 * stor25 / 100 * stor11 / totalSupply)
                            _16017 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _16017 + 68] = mem[idx + _15348 + 32]
                                idx = idx + 32
                                continue 
                            mem[_16017 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _16017 + -mem[64] + 100
                        if arg1 * stor19 / 100 and stor11 / totalSupply > -1 / arg1 * stor19 / 100:
                            revert with 0, 17
                        if not arg1 * stor19 / 100:
                            revert with 0, 18
                        if arg1 * stor19 / 100 * stor11 / totalSupply / arg1 * stor19 / 100 != stor11 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor25 / 100:
                            _13736 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13736] = 30
                            mem[_13736 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor19 / 100 * stor11 / totalSupply > 0:
                                _13968 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _13968 + 68] = mem[idx + _13736 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13968 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13968 + -mem[64] + 100
                            if 0 < arg1 * stor19 / 100 * stor11 / totalSupply:
                                revert with 0, 17
                            _15346 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15346] = 30
                            mem[_15346 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * stor19 / 100 * stor11 / totalSupply:
                                if -1 * arg1 * stor19 / 100 * stor11 / totalSupply < 0:
                                    revert with 0, 17
                                return (-1 * arg1 * stor19 / 100 * stor11 / totalSupply)
                            _16016 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _16016 + 68] = mem[idx + _15346 + 32]
                                idx = idx + 32
                                continue 
                            mem[_16016 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _16016 + -mem[64] + 100
                        if arg1 * stor25 / 100 and stor11 / totalSupply > -1 / arg1 * stor25 / 100:
                            revert with 0, 17
                        if not arg1 * stor25 / 100:
                            revert with 0, 18
                        if arg1 * stor25 / 100 * stor11 / totalSupply / arg1 * stor25 / 100 != stor11 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _14771 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14771] = 30
                        mem[_14771 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor19 / 100 * stor11 / totalSupply > 0:
                            _15345 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _15345 + 68] = mem[idx + _14771 + 32]
                                idx = idx + 32
                                continue 
                            mem[_15345 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _15345 + -mem[64] + 100
                        if 0 < arg1 * stor19 / 100 * stor11 / totalSupply:
                            revert with 0, 17
                        _17484 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_17484] = 30
                        mem[_17484 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor25 / 100 * stor11 / totalSupply <= -1 * arg1 * stor19 / 100 * stor11 / totalSupply:
                            if -1 * arg1 * stor19 / 100 * stor11 / totalSupply < arg1 * stor25 / 100 * stor11 / totalSupply:
                                revert with 0, 17
                            return ((-1 * arg1 * stor19 / 100 * stor11 / totalSupply) - (arg1 * stor25 / 100 * stor11 / totalSupply))
                        _18302 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _18302 + 68] = mem[idx + _17484 + 32]
                            idx = idx + 32
                            continue 
                        mem[_18302 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _18302 + -mem[64] + 100
                    if arg1 and stor11 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor11 / totalSupply / arg1 != stor11 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor19 / 100:
                        if not arg1 * stor25 / 100:
                            _13735 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13735] = 30
                            mem[_13735 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor11 / totalSupply:
                                _13967 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _13967 + 68] = mem[idx + _13735 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13967 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13967 + -mem[64] + 100
                            if arg1 * stor11 / totalSupply < 0:
                                revert with 0, 17
                            _15343 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15343] = 30
                            mem[_15343 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor11 / totalSupply:
                                if arg1 * stor11 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor11 / totalSupply)
                            _16015 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _16015 + 68] = mem[idx + _15343 + 32]
                                idx = idx + 32
                                continue 
                            mem[_16015 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _16015 + -mem[64] + 100
                        if arg1 * stor25 / 100 and stor11 / totalSupply > -1 / arg1 * stor25 / 100:
                            revert with 0, 17
                        if not arg1 * stor25 / 100:
                            revert with 0, 18
                        if arg1 * stor25 / 100 * stor11 / totalSupply / arg1 * stor25 / 100 != stor11 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _14770 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14770] = 30
                        mem[_14770 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor11 / totalSupply:
                            _15342 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _15342 + 68] = mem[idx + _14770 + 32]
                                idx = idx + 32
                                continue 
                            mem[_15342 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _15342 + -mem[64] + 100
                        if arg1 * stor11 / totalSupply < 0:
                            revert with 0, 17
                        _17482 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_17482] = 30
                        mem[_17482 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor25 / 100 * stor11 / totalSupply <= arg1 * stor11 / totalSupply:
                            if arg1 * stor11 / totalSupply < arg1 * stor25 / 100 * stor11 / totalSupply:
                                revert with 0, 17
                            return ((arg1 * stor11 / totalSupply) - (arg1 * stor25 / 100 * stor11 / totalSupply))
                        _18300 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _18300 + 68] = mem[idx + _17482 + 32]
                            idx = idx + 32
                            continue 
                        mem[_18300 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _18300 + -mem[64] + 100
                    if arg1 * stor19 / 100 and stor11 / totalSupply > -1 / arg1 * stor19 / 100:
                        revert with 0, 17
                    if not arg1 * stor19 / 100:
                        revert with 0, 18
                    if arg1 * stor19 / 100 * stor11 / totalSupply / arg1 * stor19 / 100 != stor11 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor25 / 100:
                        _14769 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14769] = 30
                        mem[_14769 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor19 / 100 * stor11 / totalSupply > arg1 * stor11 / totalSupply:
                            _15341 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _15341 + 68] = mem[idx + _14769 + 32]
                                idx = idx + 32
                                continue 
                            mem[_15341 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _15341 + -mem[64] + 100
                        if arg1 * stor11 / totalSupply < arg1 * stor19 / 100 * stor11 / totalSupply:
                            revert with 0, 17
                        _17480 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_17480] = 30
                        mem[_17480 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply):
                            if (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply) < 0:
                                revert with 0, 17
                            return ((arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply))
                        _18299 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _18299 + 68] = mem[idx + _17480 + 32]
                            idx = idx + 32
                            continue 
                        mem[_18299 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _18299 + -mem[64] + 100
                    if arg1 * stor25 / 100 and stor11 / totalSupply > -1 / arg1 * stor25 / 100:
                        revert with 0, 17
                    if not arg1 * stor25 / 100:
                        revert with 0, 18
                    if arg1 * stor25 / 100 * stor11 / totalSupply / arg1 * stor25 / 100 != stor11 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _16647 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_16647] = 30
                    mem[_16647 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor19 / 100 * stor11 / totalSupply > arg1 * stor11 / totalSupply:
                        _17479 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _17479 + 68] = mem[idx + _16647 + 32]
                            idx = idx + 32
                            continue 
                        mem[_17479 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _17479 + -mem[64] + 100
                    if arg1 * stor11 / totalSupply < arg1 * stor19 / 100 * stor11 / totalSupply:
                        revert with 0, 17
                    _19747 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_19747] = 30
                    mem[_19747 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor25 / 100 * stor11 / totalSupply <= (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply):
                        if (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply) < arg1 * stor25 / 100 * stor11 / totalSupply:
                            revert with 0, 17
                        return ((arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply) - (arg1 * stor25 / 100 * stor11 / totalSupply))
                    _20297 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _20297 + 68] = mem[idx + _19747 + 32]
                        idx = idx + 32
                        continue 
                    mem[_20297 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _20297 + -mem[64] + 100
            if not totalSupply:
                revert with 0, 'SafeMath: division by zero', 0
            if t >= stor11 / totalSupply:
                if not s:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if not arg1 * stor19 / 100:
                        if not arg1 * stor25 / 100:
                            return 0
                        if arg1 * stor25 / 100 and t / s > -1 / arg1 * stor25 / 100:
                            revert with 0, 17
                        if not arg1 * stor25 / 100:
                            revert with 0, 18
                        if arg1 * stor25 / 100 * t / s / arg1 * stor25 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * stor25 / 100 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * stor25 / 100 * t / s:
                            revert with 0, 17
                        return (-1 * arg1 * stor25 / 100 * t / s)
                    if arg1 * stor19 / 100 and t / s > -1 / arg1 * stor19 / 100:
                        revert with 0, 17
                    if not arg1 * stor19 / 100:
                        revert with 0, 18
                    if arg1 * stor19 / 100 * t / s / arg1 * stor19 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor25 / 100:
                        if arg1 * stor19 / 100 * t / s > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * stor19 / 100 * t / s:
                            revert with 0, 17
                        if 0 > -1 * arg1 * stor19 / 100 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * stor19 / 100 * t / s < 0:
                            revert with 0, 17
                        return (-1 * arg1 * stor19 / 100 * t / s)
                    if arg1 * stor25 / 100 and t / s > -1 / arg1 * stor25 / 100:
                        revert with 0, 17
                    if not arg1 * stor25 / 100:
                        revert with 0, 18
                    if arg1 * stor25 / 100 * t / s / arg1 * stor25 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * stor19 / 100 * t / s > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * stor19 / 100 * t / s:
                        revert with 0, 17
                    if arg1 * stor25 / 100 * t / s > -1 * arg1 * stor19 / 100 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * stor19 / 100 * t / s < arg1 * stor25 / 100 * t / s:
                        revert with 0, 17
                    return ((-1 * arg1 * stor19 / 100 * t / s) - (arg1 * stor25 / 100 * t / s))
                if arg1 and t / s > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * t / s / arg1 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor19 / 100:
                    if not arg1 * stor25 / 100:
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        return (arg1 * t / s)
                    if arg1 * stor25 / 100 and t / s > -1 / arg1 * stor25 / 100:
                        revert with 0, 17
                    if not arg1 * stor25 / 100:
                        revert with 0, 18
                    if arg1 * stor25 / 100 * t / s / arg1 * stor25 / 100 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 0, 17
                    if arg1 * stor25 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * stor25 / 100 * t / s:
                        revert with 0, 17
                    return ((arg1 * t / s) - (arg1 * stor25 / 100 * t / s))
                if arg1 * stor19 / 100 and t / s > -1 / arg1 * stor19 / 100:
                    revert with 0, 17
                if not arg1 * stor19 / 100:
                    revert with 0, 18
                if arg1 * stor19 / 100 * t / s / arg1 * stor19 / 100 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor25 / 100:
                    if arg1 * stor19 / 100 * t / s > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < arg1 * stor19 / 100 * t / s:
                        revert with 0, 17
                    if 0 > (arg1 * t / s) - (arg1 * stor19 / 100 * t / s):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * t / s) - (arg1 * stor19 / 100 * t / s) < 0:
                        revert with 0, 17
                    return ((arg1 * t / s) - (arg1 * stor19 / 100 * t / s))
                if arg1 * stor25 / 100 and t / s > -1 / arg1 * stor25 / 100:
                    revert with 0, 17
                if not arg1 * stor25 / 100:
                    revert with 0, 18
                if arg1 * stor25 / 100 * t / s / arg1 * stor25 / 100 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg1 * stor19 / 100 * t / s > arg1 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * t / s < arg1 * stor19 / 100 * t / s:
                    revert with 0, 17
                if arg1 * stor25 / 100 * t / s > (arg1 * t / s) - (arg1 * stor19 / 100 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * t / s) - (arg1 * stor19 / 100 * t / s) < arg1 * stor25 / 100 * t / s:
                    revert with 0, 17
                return ((arg1 * t / s) - (arg1 * stor19 / 100 * t / s) - (arg1 * stor25 / 100 * t / s))
            if not totalSupply:
                revert with 0, 'SafeMath: division by zero', 0
            if not arg1:
                if not arg1 * stor19 / 100:
                    if not arg1 * stor25 / 100:
                        return 0
                    if arg1 * stor25 / 100 and stor11 / totalSupply > -1 / arg1 * stor25 / 100:
                        revert with 0, 17
                    if not arg1 * stor25 / 100:
                        revert with 0, 18
                    if arg1 * stor25 / 100 * stor11 / totalSupply / arg1 * stor25 / 100 != stor11 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * stor25 / 100 * stor11 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * stor25 / 100 * stor11 / totalSupply:
                        revert with 0, 17
                    return (-1 * arg1 * stor25 / 100 * stor11 / totalSupply)
                if arg1 * stor19 / 100 and stor11 / totalSupply > -1 / arg1 * stor19 / 100:
                    revert with 0, 17
                if not arg1 * stor19 / 100:
                    revert with 0, 18
                if arg1 * stor19 / 100 * stor11 / totalSupply / arg1 * stor19 / 100 != stor11 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor25 / 100:
                    if arg1 * stor19 / 100 * stor11 / totalSupply > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * stor19 / 100 * stor11 / totalSupply:
                        revert with 0, 17
                    if 0 > -1 * arg1 * stor19 / 100 * stor11 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * stor19 / 100 * stor11 / totalSupply < 0:
                        revert with 0, 17
                    return (-1 * arg1 * stor19 / 100 * stor11 / totalSupply)
                if arg1 * stor25 / 100 and stor11 / totalSupply > -1 / arg1 * stor25 / 100:
                    revert with 0, 17
                if not arg1 * stor25 / 100:
                    revert with 0, 18
                if arg1 * stor25 / 100 * stor11 / totalSupply / arg1 * stor25 / 100 != stor11 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg1 * stor19 / 100 * stor11 / totalSupply > 0:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if 0 < arg1 * stor19 / 100 * stor11 / totalSupply:
                    revert with 0, 17
                if arg1 * stor25 / 100 * stor11 / totalSupply > -1 * arg1 * stor19 / 100 * stor11 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if -1 * arg1 * stor19 / 100 * stor11 / totalSupply < arg1 * stor25 / 100 * stor11 / totalSupply:
                    revert with 0, 17
                return ((-1 * arg1 * stor19 / 100 * stor11 / totalSupply) - (arg1 * stor25 / 100 * stor11 / totalSupply))
            if arg1 and stor11 / totalSupply > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * stor11 / totalSupply / arg1 != stor11 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * stor19 / 100:
                if not arg1 * stor25 / 100:
                    if 0 > arg1 * stor11 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor11 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor11 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor11 / totalSupply < 0:
                        revert with 0, 17
                    return (arg1 * stor11 / totalSupply)
                if arg1 * stor25 / 100 and stor11 / totalSupply > -1 / arg1 * stor25 / 100:
                    revert with 0, 17
                if not arg1 * stor25 / 100:
                    revert with 0, 18
                if arg1 * stor25 / 100 * stor11 / totalSupply / arg1 * stor25 / 100 != stor11 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 0 > arg1 * stor11 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor11 / totalSupply < 0:
                    revert with 0, 17
                if arg1 * stor25 / 100 * stor11 / totalSupply > arg1 * stor11 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor11 / totalSupply < arg1 * stor25 / 100 * stor11 / totalSupply:
                    revert with 0, 17
                return ((arg1 * stor11 / totalSupply) - (arg1 * stor25 / 100 * stor11 / totalSupply))
            if arg1 * stor19 / 100 and stor11 / totalSupply > -1 / arg1 * stor19 / 100:
                revert with 0, 17
            if not arg1 * stor19 / 100:
                revert with 0, 18
            if arg1 * stor19 / 100 * stor11 / totalSupply / arg1 * stor19 / 100 != stor11 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * stor25 / 100:
                if arg1 * stor19 / 100 * stor11 / totalSupply > arg1 * stor11 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor11 / totalSupply < arg1 * stor19 / 100 * stor11 / totalSupply:
                    revert with 0, 17
                if 0 > (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply) < 0:
                    revert with 0, 17
                return ((arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply))
            if arg1 * stor25 / 100 and stor11 / totalSupply > -1 / arg1 * stor25 / 100:
                revert with 0, 17
            if not arg1 * stor25 / 100:
                revert with 0, 18
            if arg1 * stor25 / 100 * stor11 / totalSupply / arg1 * stor25 / 100 != stor11 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if arg1 * stor19 / 100 * stor11 / totalSupply > arg1 * stor11 / totalSupply:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * stor11 / totalSupply < arg1 * stor19 / 100 * stor11 / totalSupply:
                revert with 0, 17
            if arg1 * stor25 / 100 * stor11 / totalSupply > (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply) < arg1 * stor25 / 100 * stor11 / totalSupply:
                revert with 0, 17
            return ((arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply) - (arg1 * stor25 / 100 * stor11 / totalSupply))
        if arg1 and stor30 > -1 / arg1:
            revert with 0, 17
        if not arg1:
            revert with 0, 18
        if arg1 * stor30 / arg1 != stor30:
            revert with 0, 'SafeMath: multiplication overflow'
        mem[224] = 26
        mem[256] = 'SafeMath: division by zero'
        if not arg1:
            mem[288] = 26
            mem[320] = 'SafeMath: division by zero'
            if arg1 * stor25 / 100 > !(arg1 * stor30 / 100):
                revert with 0, 17
            if (arg1 * stor25 / 100) + (arg1 * stor30 / 100) < arg1 * stor25 / 100:
                revert with 0, 'SafeMath: addition overflow'
            mem[352] = 30
            mem[384] = 'SafeMath: subtraction overflow'
            if arg1 * stor19 / 100 > arg1:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 < arg1 * stor19 / 100:
                revert with 0, 17
            mem[416] = 30
            mem[448] = 'SafeMath: subtraction overflow'
            if (arg1 * stor25 / 100) + (arg1 * stor30 / 100) > arg1 - (arg1 * stor19 / 100):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 - (arg1 * stor19 / 100) < (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                revert with 0, 17
            mem[64] = 544
            mem[480] = 30
            mem[512] = 'SafeMath: subtraction overflow'
            if 0 > arg1 - (arg1 * stor19 / 100) - (arg1 * stor25 / 100) - (arg1 * stor30 / 100):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 - (arg1 * stor19 / 100) - (arg1 * stor25 / 100) - (arg1 * stor30 / 100) < 0:
                revert with 0, 17
            if arg1 * stor25 / 100 > !(arg1 * stor30 / 100):
                revert with 0, 17
            if (arg1 * stor25 / 100) + (arg1 * stor30 / 100) < arg1 * stor25 / 100:
                revert with 0, 'SafeMath: addition overflow'
            idx = 0
            s = totalSupply
            t = stor11
            while idx < stor9.length:
                mem[0] = stor9[idx]
                mem[32] = 1
                if stor1[stor9[idx]] > t:
                    _11630 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11630] = 26
                    mem[_11630 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _11760 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _11760 + 68] = mem[idx + _11630 + 32]
                            idx = idx + 32
                            continue 
                        mem[_11760 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _11760 + -mem[64] + 100
                    if not arg1:
                        if not arg1 * stor19 / 100:
                            if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                                return 0
                            if (arg1 * stor25 / 100) + (arg1 * stor30 / 100) and stor11 / totalSupply > -1 / (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                                revert with 0, 17
                            if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                                revert with 0, 18
                            if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) / (arg1 * stor25 / 100) + (arg1 * stor30 / 100) != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _13453 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13453] = 30
                            mem[_13453 + 32] = 'SafeMath: subtraction overflow'
                            _14751 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14751] = 30
                            mem[_14751 + 32] = 'SafeMath: subtraction overflow'
                            if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) <= 0:
                                if 0 < (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply):
                                    revert with 0, 17
                                return ((-1 * arg1 * stor25 / 100 * stor11 / totalSupply) - (arg1 * stor30 / 100 * stor11 / totalSupply))
                            _15324 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _15324 + 68] = mem[idx + _14751 + 32]
                                idx = idx + 32
                                continue 
                            mem[_15324 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _15324 + -mem[64] + 100
                        if arg1 * stor19 / 100 and stor11 / totalSupply > -1 / arg1 * stor19 / 100:
                            revert with 0, 17
                        if not arg1 * stor19 / 100:
                            revert with 0, 18
                        if arg1 * stor19 / 100 * stor11 / totalSupply / arg1 * stor19 / 100 != stor11 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                            _13452 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13452] = 30
                            mem[_13452 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor19 / 100 * stor11 / totalSupply > 0:
                                _13725 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _13725 + 68] = mem[idx + _13452 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13725 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13725 + -mem[64] + 100
                            if 0 < arg1 * stor19 / 100 * stor11 / totalSupply:
                                revert with 0, 17
                            _14749 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14749] = 30
                            mem[_14749 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * stor19 / 100 * stor11 / totalSupply:
                                if -1 * arg1 * stor19 / 100 * stor11 / totalSupply < 0:
                                    revert with 0, 17
                                return (-1 * arg1 * stor19 / 100 * stor11 / totalSupply)
                            _15323 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _15323 + 68] = mem[idx + _14749 + 32]
                                idx = idx + 32
                                continue 
                            mem[_15323 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _15323 + -mem[64] + 100
                        if (arg1 * stor25 / 100) + (arg1 * stor30 / 100) and stor11 / totalSupply > -1 / (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                            revert with 0, 17
                        if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                            revert with 0, 18
                        if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) / (arg1 * stor25 / 100) + (arg1 * stor30 / 100) != stor11 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _14316 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14316] = 30
                        mem[_14316 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor19 / 100 * stor11 / totalSupply > 0:
                            _14748 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _14748 + 68] = mem[idx + _14316 + 32]
                                idx = idx + 32
                                continue 
                            mem[_14748 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _14748 + -mem[64] + 100
                        if 0 < arg1 * stor19 / 100 * stor11 / totalSupply:
                            revert with 0, 17
                        _16619 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_16619] = 30
                        mem[_16619 + 32] = 'SafeMath: subtraction overflow'
                        if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) <= -1 * arg1 * stor19 / 100 * stor11 / totalSupply:
                            if -1 * arg1 * stor19 / 100 * stor11 / totalSupply < (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply):
                                revert with 0, 17
                            return ((-1 * arg1 * stor19 / 100 * stor11 / totalSupply) - (arg1 * stor25 / 100 * stor11 / totalSupply) - (arg1 * stor30 / 100 * stor11 / totalSupply))
                        _17454 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _17454 + 68] = mem[idx + _16619 + 32]
                            idx = idx + 32
                            continue 
                        mem[_17454 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _17454 + -mem[64] + 100
                    if arg1 and stor11 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor11 / totalSupply / arg1 != stor11 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor19 / 100:
                        if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                            _13451 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13451] = 30
                            mem[_13451 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor11 / totalSupply:
                                _13724 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _13724 + 68] = mem[idx + _13451 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13724 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13724 + -mem[64] + 100
                            if arg1 * stor11 / totalSupply < 0:
                                revert with 0, 17
                            _14746 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14746] = 30
                            mem[_14746 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor11 / totalSupply:
                                if arg1 * stor11 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor11 / totalSupply)
                            _15322 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _15322 + 68] = mem[idx + _14746 + 32]
                                idx = idx + 32
                                continue 
                            mem[_15322 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _15322 + -mem[64] + 100
                        if (arg1 * stor25 / 100) + (arg1 * stor30 / 100) and stor11 / totalSupply > -1 / (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                            revert with 0, 17
                        if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                            revert with 0, 18
                        if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) / (arg1 * stor25 / 100) + (arg1 * stor30 / 100) != stor11 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _14315 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14315] = 30
                        mem[_14315 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor11 / totalSupply:
                            _14745 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _14745 + 68] = mem[idx + _14315 + 32]
                                idx = idx + 32
                                continue 
                            mem[_14745 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _14745 + -mem[64] + 100
                        if arg1 * stor11 / totalSupply < 0:
                            revert with 0, 17
                        _16617 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_16617] = 30
                        mem[_16617 + 32] = 'SafeMath: subtraction overflow'
                        if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) <= arg1 * stor11 / totalSupply:
                            if arg1 * stor11 / totalSupply < (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply):
                                revert with 0, 17
                            return ((arg1 * stor11 / totalSupply) - (arg1 * stor25 / 100 * stor11 / totalSupply) - (arg1 * stor30 / 100 * stor11 / totalSupply))
                        _17452 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _17452 + 68] = mem[idx + _16617 + 32]
                            idx = idx + 32
                            continue 
                        mem[_17452 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _17452 + -mem[64] + 100
                    if arg1 * stor19 / 100 and stor11 / totalSupply > -1 / arg1 * stor19 / 100:
                        revert with 0, 17
                    if not arg1 * stor19 / 100:
                        revert with 0, 18
                    if arg1 * stor19 / 100 * stor11 / totalSupply / arg1 * stor19 / 100 != stor11 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                        _14314 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14314] = 30
                        mem[_14314 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor19 / 100 * stor11 / totalSupply > arg1 * stor11 / totalSupply:
                            _14744 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _14744 + 68] = mem[idx + _14314 + 32]
                                idx = idx + 32
                                continue 
                            mem[_14744 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _14744 + -mem[64] + 100
                        if arg1 * stor11 / totalSupply < arg1 * stor19 / 100 * stor11 / totalSupply:
                            revert with 0, 17
                        _16615 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_16615] = 30
                        mem[_16615 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply):
                            if (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply) < 0:
                                revert with 0, 17
                            return ((arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply))
                        _17451 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _17451 + 68] = mem[idx + _16615 + 32]
                            idx = idx + 32
                            continue 
                        mem[_17451 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _17451 + -mem[64] + 100
                    if (arg1 * stor25 / 100) + (arg1 * stor30 / 100) and stor11 / totalSupply > -1 / (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                        revert with 0, 17
                    if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                        revert with 0, 18
                    if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) / (arg1 * stor25 / 100) + (arg1 * stor30 / 100) != stor11 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _16002 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_16002] = 30
                    mem[_16002 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor19 / 100 * stor11 / totalSupply > arg1 * stor11 / totalSupply:
                        _16614 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _16614 + 68] = mem[idx + _16002 + 32]
                            idx = idx + 32
                            continue 
                        mem[_16614 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _16614 + -mem[64] + 100
                    if arg1 * stor11 / totalSupply < arg1 * stor19 / 100 * stor11 / totalSupply:
                        revert with 0, 17
                    _18978 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_18978] = 30
                    mem[_18978 + 32] = 'SafeMath: subtraction overflow'
                    if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) <= (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply):
                        if (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply) < (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply):
                            revert with 0, 17
                        return ((arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply) - (arg1 * stor25 / 100 * stor11 / totalSupply) - (arg1 * stor30 / 100 * stor11 / totalSupply))
                    _19722 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _19722 + 68] = mem[idx + _18978 + 32]
                        idx = idx + 32
                        continue 
                    mem[_19722 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _19722 + -mem[64] + 100
                if idx >= stor9.length:
                    revert with 0, 50
                mem[0] = stor9[idx]
                mem[32] = 2
                if stor2[stor9[idx]] <= s:
                    if idx >= stor9.length:
                        revert with 0, 50
                    mem[0] = stor9[idx]
                    mem[32] = 1
                    _11761 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11761] = 30
                    mem[_11761 + 32] = 'SafeMath: subtraction overflow'
                    if stor1[stor9[idx]] > t:
                        _11921 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _11921 + 68] = mem[idx + _11761 + 32]
                            idx = idx + 32
                            continue 
                        mem[_11921 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _11921 + -mem[64] + 100
                    if t < stor1[stor9[idx]]:
                        revert with 0, 17
                    if idx >= stor9.length:
                        revert with 0, 50
                    mem[0] = stor9[idx]
                    mem[32] = 2
                    _12626 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12626] = 30
                    mem[_12626 + 32] = 'SafeMath: subtraction overflow'
                    if stor2[stor9[idx]] <= s:
                        if s < stor2[stor9[idx]]:
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s - stor2[stor9[idx]]
                        t = t - stor1[stor9[idx]]
                        continue 
                    _12722 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _12722 + 68] = mem[idx + _12626 + 32]
                        idx = idx + 32
                        continue 
                    mem[_12722 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _12722 + -mem[64] + 100
                _11762 = mem[64]
                mem[64] = mem[64] + 64
                mem[_11762] = 26
                mem[_11762 + 32] = 'SafeMath: division by zero'
                if not totalSupply:
                    _11922 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _11922 + 68] = mem[idx + _11762 + 32]
                        idx = idx + 32
                        continue 
                    mem[_11922 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _11922 + -mem[64] + 100
                if not arg1:
                    if not arg1 * stor19 / 100:
                        if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                            return 0
                        if (arg1 * stor25 / 100) + (arg1 * stor30 / 100) and stor11 / totalSupply > -1 / (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                            revert with 0, 17
                        if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                            revert with 0, 18
                        if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) / (arg1 * stor25 / 100) + (arg1 * stor30 / 100) != stor11 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _13730 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13730] = 30
                        mem[_13730 + 32] = 'SafeMath: subtraction overflow'
                        _15332 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_15332] = 30
                        mem[_15332 + 32] = 'SafeMath: subtraction overflow'
                        if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) <= 0:
                            if 0 < (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply):
                                revert with 0, 17
                            return ((-1 * arg1 * stor25 / 100 * stor11 / totalSupply) - (arg1 * stor30 / 100 * stor11 / totalSupply))
                        _16006 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _16006 + 68] = mem[idx + _15332 + 32]
                            idx = idx + 32
                            continue 
                        mem[_16006 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _16006 + -mem[64] + 100
                    if arg1 * stor19 / 100 and stor11 / totalSupply > -1 / arg1 * stor19 / 100:
                        revert with 0, 17
                    if not arg1 * stor19 / 100:
                        revert with 0, 18
                    if arg1 * stor19 / 100 * stor11 / totalSupply / arg1 * stor19 / 100 != stor11 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                        _13729 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13729] = 30
                        mem[_13729 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor19 / 100 * stor11 / totalSupply > 0:
                            _13961 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13961 + 68] = mem[idx + _13729 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13961 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13961 + -mem[64] + 100
                        if 0 < arg1 * stor19 / 100 * stor11 / totalSupply:
                            revert with 0, 17
                        _15330 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_15330] = 30
                        mem[_15330 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= -1 * arg1 * stor19 / 100 * stor11 / totalSupply:
                            if -1 * arg1 * stor19 / 100 * stor11 / totalSupply < 0:
                                revert with 0, 17
                            return (-1 * arg1 * stor19 / 100 * stor11 / totalSupply)
                        _16005 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _16005 + 68] = mem[idx + _15330 + 32]
                            idx = idx + 32
                            continue 
                        mem[_16005 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _16005 + -mem[64] + 100
                    if (arg1 * stor25 / 100) + (arg1 * stor30 / 100) and stor11 / totalSupply > -1 / (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                        revert with 0, 17
                    if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                        revert with 0, 18
                    if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) / (arg1 * stor25 / 100) + (arg1 * stor30 / 100) != stor11 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _14754 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14754] = 30
                    mem[_14754 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor19 / 100 * stor11 / totalSupply > 0:
                        _15329 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _15329 + 68] = mem[idx + _14754 + 32]
                            idx = idx + 32
                            continue 
                        mem[_15329 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _15329 + -mem[64] + 100
                    if 0 < arg1 * stor19 / 100 * stor11 / totalSupply:
                        revert with 0, 17
                    _17462 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_17462] = 30
                    mem[_17462 + 32] = 'SafeMath: subtraction overflow'
                    if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) <= -1 * arg1 * stor19 / 100 * stor11 / totalSupply:
                        if -1 * arg1 * stor19 / 100 * stor11 / totalSupply < (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply):
                            revert with 0, 17
                        return ((-1 * arg1 * stor19 / 100 * stor11 / totalSupply) - (arg1 * stor25 / 100 * stor11 / totalSupply) - (arg1 * stor30 / 100 * stor11 / totalSupply))
                    _18294 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _18294 + 68] = mem[idx + _17462 + 32]
                        idx = idx + 32
                        continue 
                    mem[_18294 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _18294 + -mem[64] + 100
                if arg1 and stor11 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor11 / totalSupply / arg1 != stor11 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor19 / 100:
                    if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                        _13728 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13728] = 30
                        mem[_13728 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor11 / totalSupply:
                            _13960 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13960 + 68] = mem[idx + _13728 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13960 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13960 + -mem[64] + 100
                        if arg1 * stor11 / totalSupply < 0:
                            revert with 0, 17
                        _15327 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_15327] = 30
                        mem[_15327 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= arg1 * stor11 / totalSupply:
                            if arg1 * stor11 / totalSupply < 0:
                                revert with 0, 17
                            return (arg1 * stor11 / totalSupply)
                        _16004 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _16004 + 68] = mem[idx + _15327 + 32]
                            idx = idx + 32
                            continue 
                        mem[_16004 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _16004 + -mem[64] + 100
                    if (arg1 * stor25 / 100) + (arg1 * stor30 / 100) and stor11 / totalSupply > -1 / (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                        revert with 0, 17
                    if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                        revert with 0, 18
                    if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) / (arg1 * stor25 / 100) + (arg1 * stor30 / 100) != stor11 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _14753 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14753] = 30
                    mem[_14753 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor11 / totalSupply:
                        _15326 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _15326 + 68] = mem[idx + _14753 + 32]
                            idx = idx + 32
                            continue 
                        mem[_15326 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _15326 + -mem[64] + 100
                    if arg1 * stor11 / totalSupply < 0:
                        revert with 0, 17
                    _17460 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_17460] = 30
                    mem[_17460 + 32] = 'SafeMath: subtraction overflow'
                    if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) <= arg1 * stor11 / totalSupply:
                        if arg1 * stor11 / totalSupply < (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply):
                            revert with 0, 17
                        return ((arg1 * stor11 / totalSupply) - (arg1 * stor25 / 100 * stor11 / totalSupply) - (arg1 * stor30 / 100 * stor11 / totalSupply))
                    _18292 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _18292 + 68] = mem[idx + _17460 + 32]
                        idx = idx + 32
                        continue 
                    mem[_18292 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _18292 + -mem[64] + 100
                if arg1 * stor19 / 100 and stor11 / totalSupply > -1 / arg1 * stor19 / 100:
                    revert with 0, 17
                if not arg1 * stor19 / 100:
                    revert with 0, 18
                if arg1 * stor19 / 100 * stor11 / totalSupply / arg1 * stor19 / 100 != stor11 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                    _14752 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14752] = 30
                    mem[_14752 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor19 / 100 * stor11 / totalSupply > arg1 * stor11 / totalSupply:
                        _15325 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _15325 + 68] = mem[idx + _14752 + 32]
                            idx = idx + 32
                            continue 
                        mem[_15325 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _15325 + -mem[64] + 100
                    if arg1 * stor11 / totalSupply < arg1 * stor19 / 100 * stor11 / totalSupply:
                        revert with 0, 17
                    _17458 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_17458] = 30
                    mem[_17458 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply):
                        if (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply) < 0:
                            revert with 0, 17
                        return ((arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply))
                    _18291 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _18291 + 68] = mem[idx + _17458 + 32]
                        idx = idx + 32
                        continue 
                    mem[_18291 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _18291 + -mem[64] + 100
                if (arg1 * stor25 / 100) + (arg1 * stor30 / 100) and stor11 / totalSupply > -1 / (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                    revert with 0, 17
                if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                    revert with 0, 18
                if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) / (arg1 * stor25 / 100) + (arg1 * stor30 / 100) != stor11 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                _16622 = mem[64]
                mem[64] = mem[64] + 64
                mem[_16622] = 30
                mem[_16622 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * stor19 / 100 * stor11 / totalSupply > arg1 * stor11 / totalSupply:
                    _17457 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _17457 + 68] = mem[idx + _16622 + 32]
                        idx = idx + 32
                        continue 
                    mem[_17457 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _17457 + -mem[64] + 100
                if arg1 * stor11 / totalSupply < arg1 * stor19 / 100 * stor11 / totalSupply:
                    revert with 0, 17
                _19726 = mem[64]
                mem[64] = mem[64] + 64
                mem[_19726] = 30
                mem[_19726 + 32] = 'SafeMath: subtraction overflow'
                if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) <= (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply):
                    if (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply) < (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply):
                        revert with 0, 17
                    return ((arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply) - (arg1 * stor25 / 100 * stor11 / totalSupply) - (arg1 * stor30 / 100 * stor11 / totalSupply))
                _20293 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _20293 + 68] = mem[idx + _19726 + 32]
                    idx = idx + 32
                    continue 
                mem[_20293 + 98] = 0
                revert with memory
                  from mem[64]
                   len _20293 + -mem[64] + 100
        else:
            if arg1 and stor35 > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * stor35 / arg1 != stor35:
                revert with 0, 'SafeMath: multiplication overflow'
            mem[288] = 26
            mem[320] = 'SafeMath: division by zero'
            if arg1 * stor25 / 100 > !(arg1 * stor30 / 100):
                revert with 0, 17
            if (arg1 * stor25 / 100) + (arg1 * stor30 / 100) < arg1 * stor25 / 100:
                revert with 0, 'SafeMath: addition overflow'
            mem[352] = 30
            mem[384] = 'SafeMath: subtraction overflow'
            if arg1 * stor19 / 100 > arg1:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 < arg1 * stor19 / 100:
                revert with 0, 17
            mem[416] = 30
            mem[448] = 'SafeMath: subtraction overflow'
            if (arg1 * stor25 / 100) + (arg1 * stor30 / 100) > arg1 - (arg1 * stor19 / 100):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 - (arg1 * stor19 / 100) < (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                revert with 0, 17
            mem[64] = 544
            mem[480] = 30
            mem[512] = 'SafeMath: subtraction overflow'
            if arg1 * stor35 / 100 > arg1 - (arg1 * stor19 / 100) - (arg1 * stor25 / 100) - (arg1 * stor30 / 100):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 - (arg1 * stor19 / 100) - (arg1 * stor25 / 100) - (arg1 * stor30 / 100) < arg1 * stor35 / 100:
                revert with 0, 17
            if arg1 * stor25 / 100 > !(arg1 * stor30 / 100):
                revert with 0, 17
            if (arg1 * stor25 / 100) + (arg1 * stor30 / 100) < arg1 * stor25 / 100:
                revert with 0, 'SafeMath: addition overflow'
            idx = 0
            s = totalSupply
            t = stor11
            while idx < stor9.length:
                mem[0] = stor9[idx]
                mem[32] = 1
                if stor1[stor9[idx]] > t:
                    _11629 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11629] = 26
                    mem[_11629 + 32] = 'SafeMath: division by zero'
                    if not totalSupply:
                        _11757 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 26
                        idx = 0
                        while idx < 26:
                            mem[idx + _11757 + 68] = mem[idx + _11629 + 32]
                            idx = idx + 32
                            continue 
                        mem[_11757 + 94] = 0
                        revert with memory
                          from mem[64]
                           len _11757 + -mem[64] + 100
                    if not arg1:
                        if not arg1 * stor19 / 100:
                            if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                                return 0
                            if (arg1 * stor25 / 100) + (arg1 * stor30 / 100) and stor11 / totalSupply > -1 / (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                                revert with 0, 17
                            if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                                revert with 0, 18
                            if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) / (arg1 * stor25 / 100) + (arg1 * stor30 / 100) != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _13444 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13444] = 30
                            mem[_13444 + 32] = 'SafeMath: subtraction overflow'
                            _14734 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14734] = 30
                            mem[_14734 + 32] = 'SafeMath: subtraction overflow'
                            if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) <= 0:
                                if 0 < (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply):
                                    revert with 0, 17
                                return ((-1 * arg1 * stor25 / 100 * stor11 / totalSupply) - (arg1 * stor30 / 100 * stor11 / totalSupply))
                            _15308 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _15308 + 68] = mem[idx + _14734 + 32]
                                idx = idx + 32
                                continue 
                            mem[_15308 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _15308 + -mem[64] + 100
                        if arg1 * stor19 / 100 and stor11 / totalSupply > -1 / arg1 * stor19 / 100:
                            revert with 0, 17
                        if not arg1 * stor19 / 100:
                            revert with 0, 18
                        if arg1 * stor19 / 100 * stor11 / totalSupply / arg1 * stor19 / 100 != stor11 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                            _13443 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13443] = 30
                            mem[_13443 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor19 / 100 * stor11 / totalSupply > 0:
                                _13718 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _13718 + 68] = mem[idx + _13443 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13718 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13718 + -mem[64] + 100
                            if 0 < arg1 * stor19 / 100 * stor11 / totalSupply:
                                revert with 0, 17
                            _14732 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14732] = 30
                            mem[_14732 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * stor19 / 100 * stor11 / totalSupply:
                                if -1 * arg1 * stor19 / 100 * stor11 / totalSupply < 0:
                                    revert with 0, 17
                                return (-1 * arg1 * stor19 / 100 * stor11 / totalSupply)
                            _15307 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _15307 + 68] = mem[idx + _14732 + 32]
                                idx = idx + 32
                                continue 
                            mem[_15307 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _15307 + -mem[64] + 100
                        if (arg1 * stor25 / 100) + (arg1 * stor30 / 100) and stor11 / totalSupply > -1 / (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                            revert with 0, 17
                        if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                            revert with 0, 18
                        if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) / (arg1 * stor25 / 100) + (arg1 * stor30 / 100) != stor11 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _14303 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14303] = 30
                        mem[_14303 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor19 / 100 * stor11 / totalSupply > 0:
                            _14731 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _14731 + 68] = mem[idx + _14303 + 32]
                                idx = idx + 32
                                continue 
                            mem[_14731 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _14731 + -mem[64] + 100
                        if 0 < arg1 * stor19 / 100 * stor11 / totalSupply:
                            revert with 0, 17
                        _16594 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_16594] = 30
                        mem[_16594 + 32] = 'SafeMath: subtraction overflow'
                        if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) <= -1 * arg1 * stor19 / 100 * stor11 / totalSupply:
                            if -1 * arg1 * stor19 / 100 * stor11 / totalSupply < (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply):
                                revert with 0, 17
                            return ((-1 * arg1 * stor19 / 100 * stor11 / totalSupply) - (arg1 * stor25 / 100 * stor11 / totalSupply) - (arg1 * stor30 / 100 * stor11 / totalSupply))
                        _17432 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _17432 + 68] = mem[idx + _16594 + 32]
                            idx = idx + 32
                            continue 
                        mem[_17432 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _17432 + -mem[64] + 100
                    if arg1 and stor11 / totalSupply > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor11 / totalSupply / arg1 != stor11 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor19 / 100:
                        if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                            _13442 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13442] = 30
                            mem[_13442 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor11 / totalSupply:
                                _13717 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _13717 + 68] = mem[idx + _13442 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13717 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13717 + -mem[64] + 100
                            if arg1 * stor11 / totalSupply < 0:
                                revert with 0, 17
                            _14729 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14729] = 30
                            mem[_14729 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor11 / totalSupply:
                                if arg1 * stor11 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor11 / totalSupply)
                            _15306 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _15306 + 68] = mem[idx + _14729 + 32]
                                idx = idx + 32
                                continue 
                            mem[_15306 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _15306 + -mem[64] + 100
                        if (arg1 * stor25 / 100) + (arg1 * stor30 / 100) and stor11 / totalSupply > -1 / (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                            revert with 0, 17
                        if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                            revert with 0, 18
                        if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) / (arg1 * stor25 / 100) + (arg1 * stor30 / 100) != stor11 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _14302 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14302] = 30
                        mem[_14302 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor11 / totalSupply:
                            _14728 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _14728 + 68] = mem[idx + _14302 + 32]
                                idx = idx + 32
                                continue 
                            mem[_14728 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _14728 + -mem[64] + 100
                        if arg1 * stor11 / totalSupply < 0:
                            revert with 0, 17
                        _16592 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_16592] = 30
                        mem[_16592 + 32] = 'SafeMath: subtraction overflow'
                        if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) <= arg1 * stor11 / totalSupply:
                            if arg1 * stor11 / totalSupply < (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply):
                                revert with 0, 17
                            return ((arg1 * stor11 / totalSupply) - (arg1 * stor25 / 100 * stor11 / totalSupply) - (arg1 * stor30 / 100 * stor11 / totalSupply))
                        _17430 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _17430 + 68] = mem[idx + _16592 + 32]
                            idx = idx + 32
                            continue 
                        mem[_17430 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _17430 + -mem[64] + 100
                    if arg1 * stor19 / 100 and stor11 / totalSupply > -1 / arg1 * stor19 / 100:
                        revert with 0, 17
                    if not arg1 * stor19 / 100:
                        revert with 0, 18
                    if arg1 * stor19 / 100 * stor11 / totalSupply / arg1 * stor19 / 100 != stor11 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                        _14301 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_14301] = 30
                        mem[_14301 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor19 / 100 * stor11 / totalSupply > arg1 * stor11 / totalSupply:
                            _14727 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _14727 + 68] = mem[idx + _14301 + 32]
                                idx = idx + 32
                                continue 
                            mem[_14727 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _14727 + -mem[64] + 100
                        if arg1 * stor11 / totalSupply < arg1 * stor19 / 100 * stor11 / totalSupply:
                            revert with 0, 17
                        _16590 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_16590] = 30
                        mem[_16590 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply):
                            if (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply) < 0:
                                revert with 0, 17
                            return ((arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply))
                        _17429 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _17429 + 68] = mem[idx + _16590 + 32]
                            idx = idx + 32
                            continue 
                        mem[_17429 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _17429 + -mem[64] + 100
                    if (arg1 * stor25 / 100) + (arg1 * stor30 / 100) and stor11 / totalSupply > -1 / (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                        revert with 0, 17
                    if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                        revert with 0, 18
                    if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) / (arg1 * stor25 / 100) + (arg1 * stor30 / 100) != stor11 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _15991 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_15991] = 30
                    mem[_15991 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor19 / 100 * stor11 / totalSupply > arg1 * stor11 / totalSupply:
                        _16589 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _16589 + 68] = mem[idx + _15991 + 32]
                            idx = idx + 32
                            continue 
                        mem[_16589 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _16589 + -mem[64] + 100
                    if arg1 * stor11 / totalSupply < arg1 * stor19 / 100 * stor11 / totalSupply:
                        revert with 0, 17
                    _18957 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_18957] = 30
                    mem[_18957 + 32] = 'SafeMath: subtraction overflow'
                    if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) <= (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply):
                        if (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply) < (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply):
                            revert with 0, 17
                        return ((arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply) - (arg1 * stor25 / 100 * stor11 / totalSupply) - (arg1 * stor30 / 100 * stor11 / totalSupply))
                    _19701 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _19701 + 68] = mem[idx + _18957 + 32]
                        idx = idx + 32
                        continue 
                    mem[_19701 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _19701 + -mem[64] + 100
                if idx >= stor9.length:
                    revert with 0, 50
                mem[0] = stor9[idx]
                mem[32] = 2
                if stor2[stor9[idx]] <= s:
                    if idx >= stor9.length:
                        revert with 0, 50
                    mem[0] = stor9[idx]
                    mem[32] = 1
                    _11758 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_11758] = 30
                    mem[_11758 + 32] = 'SafeMath: subtraction overflow'
                    if stor1[stor9[idx]] > t:
                        _11918 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _11918 + 68] = mem[idx + _11758 + 32]
                            idx = idx + 32
                            continue 
                        mem[_11918 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _11918 + -mem[64] + 100
                    if t < stor1[stor9[idx]]:
                        revert with 0, 17
                    if idx >= stor9.length:
                        revert with 0, 50
                    mem[0] = stor9[idx]
                    mem[32] = 2
                    _12623 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_12623] = 30
                    mem[_12623 + 32] = 'SafeMath: subtraction overflow'
                    if stor2[stor9[idx]] <= s:
                        if s < stor2[stor9[idx]]:
                            revert with 0, 17
                        if idx == -1:
                            revert with 0, 17
                        idx = idx + 1
                        s = s - stor2[stor9[idx]]
                        t = t - stor1[stor9[idx]]
                        continue 
                    _12719 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _12719 + 68] = mem[idx + _12623 + 32]
                        idx = idx + 32
                        continue 
                    mem[_12719 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _12719 + -mem[64] + 100
                _11759 = mem[64]
                mem[64] = mem[64] + 64
                mem[_11759] = 26
                mem[_11759 + 32] = 'SafeMath: division by zero'
                if not totalSupply:
                    _11919 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 26
                    idx = 0
                    while idx < 26:
                        mem[idx + _11919 + 68] = mem[idx + _11759 + 32]
                        idx = idx + 32
                        continue 
                    mem[_11919 + 94] = 0
                    revert with memory
                      from mem[64]
                       len _11919 + -mem[64] + 100
                if not arg1:
                    if not arg1 * stor19 / 100:
                        if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                            return 0
                        if (arg1 * stor25 / 100) + (arg1 * stor30 / 100) and stor11 / totalSupply > -1 / (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                            revert with 0, 17
                        if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                            revert with 0, 18
                        if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) / (arg1 * stor25 / 100) + (arg1 * stor30 / 100) != stor11 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _13723 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13723] = 30
                        mem[_13723 + 32] = 'SafeMath: subtraction overflow'
                        _15316 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_15316] = 30
                        mem[_15316 + 32] = 'SafeMath: subtraction overflow'
                        if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) <= 0:
                            if 0 < (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply):
                                revert with 0, 17
                            return ((-1 * arg1 * stor25 / 100 * stor11 / totalSupply) - (arg1 * stor30 / 100 * stor11 / totalSupply))
                        _15995 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _15995 + 68] = mem[idx + _15316 + 32]
                            idx = idx + 32
                            continue 
                        mem[_15995 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _15995 + -mem[64] + 100
                    if arg1 * stor19 / 100 and stor11 / totalSupply > -1 / arg1 * stor19 / 100:
                        revert with 0, 17
                    if not arg1 * stor19 / 100:
                        revert with 0, 18
                    if arg1 * stor19 / 100 * stor11 / totalSupply / arg1 * stor19 / 100 != stor11 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                        _13722 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13722] = 30
                        mem[_13722 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor19 / 100 * stor11 / totalSupply > 0:
                            _13954 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13954 + 68] = mem[idx + _13722 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13954 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13954 + -mem[64] + 100
                        if 0 < arg1 * stor19 / 100 * stor11 / totalSupply:
                            revert with 0, 17
                        _15314 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_15314] = 30
                        mem[_15314 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= -1 * arg1 * stor19 / 100 * stor11 / totalSupply:
                            if -1 * arg1 * stor19 / 100 * stor11 / totalSupply < 0:
                                revert with 0, 17
                            return (-1 * arg1 * stor19 / 100 * stor11 / totalSupply)
                        _15994 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _15994 + 68] = mem[idx + _15314 + 32]
                            idx = idx + 32
                            continue 
                        mem[_15994 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _15994 + -mem[64] + 100
                    if (arg1 * stor25 / 100) + (arg1 * stor30 / 100) and stor11 / totalSupply > -1 / (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                        revert with 0, 17
                    if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                        revert with 0, 18
                    if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) / (arg1 * stor25 / 100) + (arg1 * stor30 / 100) != stor11 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _14737 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14737] = 30
                    mem[_14737 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor19 / 100 * stor11 / totalSupply > 0:
                        _15313 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _15313 + 68] = mem[idx + _14737 + 32]
                            idx = idx + 32
                            continue 
                        mem[_15313 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _15313 + -mem[64] + 100
                    if 0 < arg1 * stor19 / 100 * stor11 / totalSupply:
                        revert with 0, 17
                    _17440 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_17440] = 30
                    mem[_17440 + 32] = 'SafeMath: subtraction overflow'
                    if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) <= -1 * arg1 * stor19 / 100 * stor11 / totalSupply:
                        if -1 * arg1 * stor19 / 100 * stor11 / totalSupply < (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply):
                            revert with 0, 17
                        return ((-1 * arg1 * stor19 / 100 * stor11 / totalSupply) - (arg1 * stor25 / 100 * stor11 / totalSupply) - (arg1 * stor30 / 100 * stor11 / totalSupply))
                    _18286 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _18286 + 68] = mem[idx + _17440 + 32]
                        idx = idx + 32
                        continue 
                    mem[_18286 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _18286 + -mem[64] + 100
                if arg1 and stor11 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor11 / totalSupply / arg1 != stor11 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor19 / 100:
                    if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                        _13721 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13721] = 30
                        mem[_13721 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor11 / totalSupply:
                            _13953 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _13953 + 68] = mem[idx + _13721 + 32]
                                idx = idx + 32
                                continue 
                            mem[_13953 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _13953 + -mem[64] + 100
                        if arg1 * stor11 / totalSupply < 0:
                            revert with 0, 17
                        _15311 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_15311] = 30
                        mem[_15311 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= arg1 * stor11 / totalSupply:
                            if arg1 * stor11 / totalSupply < 0:
                                revert with 0, 17
                            return (arg1 * stor11 / totalSupply)
                        _15993 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _15993 + 68] = mem[idx + _15311 + 32]
                            idx = idx + 32
                            continue 
                        mem[_15993 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _15993 + -mem[64] + 100
                    if (arg1 * stor25 / 100) + (arg1 * stor30 / 100) and stor11 / totalSupply > -1 / (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                        revert with 0, 17
                    if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                        revert with 0, 18
                    if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) / (arg1 * stor25 / 100) + (arg1 * stor30 / 100) != stor11 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    _14736 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14736] = 30
                    mem[_14736 + 32] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 * stor11 / totalSupply:
                        _15310 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _15310 + 68] = mem[idx + _14736 + 32]
                            idx = idx + 32
                            continue 
                        mem[_15310 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _15310 + -mem[64] + 100
                    if arg1 * stor11 / totalSupply < 0:
                        revert with 0, 17
                    _17438 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_17438] = 30
                    mem[_17438 + 32] = 'SafeMath: subtraction overflow'
                    if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) <= arg1 * stor11 / totalSupply:
                        if arg1 * stor11 / totalSupply < (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply):
                            revert with 0, 17
                        return ((arg1 * stor11 / totalSupply) - (arg1 * stor25 / 100 * stor11 / totalSupply) - (arg1 * stor30 / 100 * stor11 / totalSupply))
                    _18284 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _18284 + 68] = mem[idx + _17438 + 32]
                        idx = idx + 32
                        continue 
                    mem[_18284 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _18284 + -mem[64] + 100
                if arg1 * stor19 / 100 and stor11 / totalSupply > -1 / arg1 * stor19 / 100:
                    revert with 0, 17
                if not arg1 * stor19 / 100:
                    revert with 0, 18
                if arg1 * stor19 / 100 * stor11 / totalSupply / arg1 * stor19 / 100 != stor11 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                    _14735 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_14735] = 30
                    mem[_14735 + 32] = 'SafeMath: subtraction overflow'
                    if arg1 * stor19 / 100 * stor11 / totalSupply > arg1 * stor11 / totalSupply:
                        _15309 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _15309 + 68] = mem[idx + _14735 + 32]
                            idx = idx + 32
                            continue 
                        mem[_15309 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _15309 + -mem[64] + 100
                    if arg1 * stor11 / totalSupply < arg1 * stor19 / 100 * stor11 / totalSupply:
                        revert with 0, 17
                    _17436 = mem[64]
                    mem[64] = mem[64] + 64
                    mem[_17436] = 30
                    mem[_17436 + 32] = 'SafeMath: subtraction overflow'
                    if 0 <= (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply):
                        if (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply) < 0:
                            revert with 0, 17
                        return ((arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply))
                    _18283 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _18283 + 68] = mem[idx + _17436 + 32]
                        idx = idx + 32
                        continue 
                    mem[_18283 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _18283 + -mem[64] + 100
                if (arg1 * stor25 / 100) + (arg1 * stor30 / 100) and stor11 / totalSupply > -1 / (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                    revert with 0, 17
                if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                    revert with 0, 18
                if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) / (arg1 * stor25 / 100) + (arg1 * stor30 / 100) != stor11 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                _16597 = mem[64]
                mem[64] = mem[64] + 64
                mem[_16597] = 30
                mem[_16597 + 32] = 'SafeMath: subtraction overflow'
                if arg1 * stor19 / 100 * stor11 / totalSupply > arg1 * stor11 / totalSupply:
                    _17435 = mem[64]
                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                    mem[mem[64] + 4] = 32
                    mem[mem[64] + 36] = 30
                    idx = 0
                    while idx < 30:
                        mem[idx + _17435 + 68] = mem[idx + _16597 + 32]
                        idx = idx + 32
                        continue 
                    mem[_17435 + 98] = 0
                    revert with memory
                      from mem[64]
                       len _17435 + -mem[64] + 100
                if arg1 * stor11 / totalSupply < arg1 * stor19 / 100 * stor11 / totalSupply:
                    revert with 0, 17
                _19705 = mem[64]
                mem[64] = mem[64] + 64
                mem[_19705] = 30
                mem[_19705 + 32] = 'SafeMath: subtraction overflow'
                if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) <= (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply):
                    if (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply) < (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply):
                        revert with 0, 17
                    return ((arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply) - (arg1 * stor25 / 100 * stor11 / totalSupply) - (arg1 * stor30 / 100 * stor11 / totalSupply))
                _20289 = mem[64]
                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                mem[mem[64] + 4] = 32
                mem[mem[64] + 36] = 30
                idx = 0
                while idx < 30:
                    mem[idx + _20289 + 68] = mem[idx + _19705 + 32]
                    idx = idx + 32
                    continue 
                mem[_20289 + 98] = 0
                revert with memory
                  from mem[64]
                   len _20289 + -mem[64] + 100
        if not totalSupply:
            revert with 0, 'SafeMath: division by zero', 0
        if t >= stor11 / totalSupply:
            if not s:
                revert with 0, 'SafeMath: division by zero', 0
            if not arg1:
                if not arg1 * stor19 / 100:
                    if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                        return 0
                    if (arg1 * stor25 / 100) + (arg1 * stor30 / 100) and t / s > -1 / (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                        revert with 0, 17
                    if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                        revert with 0, 18
                    if (arg1 * stor25 / 100 * t / s) + (arg1 * stor30 / 100 * t / s) / (arg1 * stor25 / 100) + (arg1 * stor30 / 100) != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if (arg1 * stor25 / 100 * t / s) + (arg1 * stor30 / 100 * t / s) > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < (arg1 * stor25 / 100 * t / s) + (arg1 * stor30 / 100 * t / s):
                        revert with 0, 17
                    return ((-1 * arg1 * stor25 / 100 * t / s) - (arg1 * stor30 / 100 * t / s))
                if arg1 * stor19 / 100 and t / s > -1 / arg1 * stor19 / 100:
                    revert with 0, 17
                if not arg1 * stor19 / 100:
                    revert with 0, 18
                if arg1 * stor19 / 100 * t / s / arg1 * stor19 / 100 != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                    if arg1 * stor19 / 100 * t / s > 0:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if 0 < arg1 * stor19 / 100 * t / s:
                        revert with 0, 17
                    if 0 > -1 * arg1 * stor19 / 100 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if -1 * arg1 * stor19 / 100 * t / s < 0:
                        revert with 0, 17
                    return (-1 * arg1 * stor19 / 100 * t / s)
                if (arg1 * stor25 / 100) + (arg1 * stor30 / 100) and t / s > -1 / (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                    revert with 0, 17
                if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                    revert with 0, 18
                if (arg1 * stor25 / 100 * t / s) + (arg1 * stor30 / 100 * t / s) / (arg1 * stor25 / 100) + (arg1 * stor30 / 100) != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if arg1 * stor19 / 100 * t / s > 0:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if 0 < arg1 * stor19 / 100 * t / s:
                    revert with 0, 17
                if (arg1 * stor25 / 100 * t / s) + (arg1 * stor30 / 100 * t / s) > -1 * arg1 * stor19 / 100 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if -1 * arg1 * stor19 / 100 * t / s < (arg1 * stor25 / 100 * t / s) + (arg1 * stor30 / 100 * t / s):
                    revert with 0, 17
                return ((-1 * arg1 * stor19 / 100 * t / s) - (arg1 * stor25 / 100 * t / s) - (arg1 * stor30 / 100 * t / s))
            if arg1 and t / s > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * t / s / arg1 != t / s:
                revert with 0, 'SafeMath: multiplication overflow'
            if not arg1 * stor19 / 100:
                if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 0, 17
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 0, 17
                    return (arg1 * t / s)
                if (arg1 * stor25 / 100) + (arg1 * stor30 / 100) and t / s > -1 / (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                    revert with 0, 17
                if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                    revert with 0, 18
                if (arg1 * stor25 / 100 * t / s) + (arg1 * stor30 / 100 * t / s) / (arg1 * stor25 / 100) + (arg1 * stor30 / 100) != t / s:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 0 > arg1 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * t / s < 0:
                    revert with 0, 17
                if (arg1 * stor25 / 100 * t / s) + (arg1 * stor30 / 100 * t / s) > arg1 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * t / s < (arg1 * stor25 / 100 * t / s) + (arg1 * stor30 / 100 * t / s):
                    revert with 0, 17
                return ((arg1 * t / s) - (arg1 * stor25 / 100 * t / s) - (arg1 * stor30 / 100 * t / s))
            if arg1 * stor19 / 100 and t / s > -1 / arg1 * stor19 / 100:
                revert with 0, 17
            if not arg1 * stor19 / 100:
                revert with 0, 18
            if arg1 * stor19 / 100 * t / s / arg1 * stor19 / 100 != t / s:
                revert with 0, 'SafeMath: multiplication overflow'
            if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                if arg1 * stor19 / 100 * t / s > arg1 * t / s:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * t / s < arg1 * stor19 / 100 * t / s:
                    revert with 0, 17
                if 0 > (arg1 * t / s) - (arg1 * stor19 / 100 * t / s):
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if (arg1 * t / s) - (arg1 * stor19 / 100 * t / s) < 0:
                    revert with 0, 17
                return ((arg1 * t / s) - (arg1 * stor19 / 100 * t / s))
            if (arg1 * stor25 / 100) + (arg1 * stor30 / 100) and t / s > -1 / (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                revert with 0, 17
            if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                revert with 0, 18
            if (arg1 * stor25 / 100 * t / s) + (arg1 * stor30 / 100 * t / s) / (arg1 * stor25 / 100) + (arg1 * stor30 / 100) != t / s:
                revert with 0, 'SafeMath: multiplication overflow'
            if arg1 * stor19 / 100 * t / s > arg1 * t / s:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * t / s < arg1 * stor19 / 100 * t / s:
                revert with 0, 17
            if (arg1 * stor25 / 100 * t / s) + (arg1 * stor30 / 100 * t / s) > (arg1 * t / s) - (arg1 * stor19 / 100 * t / s):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * t / s) - (arg1 * stor19 / 100 * t / s) < (arg1 * stor25 / 100 * t / s) + (arg1 * stor30 / 100 * t / s):
                revert with 0, 17
            return ((arg1 * t / s) - (arg1 * stor19 / 100 * t / s) - (arg1 * stor25 / 100 * t / s) - (arg1 * stor30 / 100 * t / s))
        if not totalSupply:
            revert with 0, 'SafeMath: division by zero', 0
        if not arg1:
            if not arg1 * stor19 / 100:
                if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                    return 0
                if (arg1 * stor25 / 100) + (arg1 * stor30 / 100) and stor11 / totalSupply > -1 / (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                    revert with 0, 17
                if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                    revert with 0, 18
                if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) / (arg1 * stor25 / 100) + (arg1 * stor30 / 100) != stor11 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) > 0:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if 0 < (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply):
                    revert with 0, 17
                return ((-1 * arg1 * stor25 / 100 * stor11 / totalSupply) - (arg1 * stor30 / 100 * stor11 / totalSupply))
            if arg1 * stor19 / 100 and stor11 / totalSupply > -1 / arg1 * stor19 / 100:
                revert with 0, 17
            if not arg1 * stor19 / 100:
                revert with 0, 18
            if arg1 * stor19 / 100 * stor11 / totalSupply / arg1 * stor19 / 100 != stor11 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                if arg1 * stor19 / 100 * stor11 / totalSupply > 0:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if 0 < arg1 * stor19 / 100 * stor11 / totalSupply:
                    revert with 0, 17
                if 0 > -1 * arg1 * stor19 / 100 * stor11 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if -1 * arg1 * stor19 / 100 * stor11 / totalSupply < 0:
                    revert with 0, 17
                return (-1 * arg1 * stor19 / 100 * stor11 / totalSupply)
            if (arg1 * stor25 / 100) + (arg1 * stor30 / 100) and stor11 / totalSupply > -1 / (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                revert with 0, 17
            if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                revert with 0, 18
            if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) / (arg1 * stor25 / 100) + (arg1 * stor30 / 100) != stor11 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if arg1 * stor19 / 100 * stor11 / totalSupply > 0:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if 0 < arg1 * stor19 / 100 * stor11 / totalSupply:
                revert with 0, 17
            if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) > -1 * arg1 * stor19 / 100 * stor11 / totalSupply:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if -1 * arg1 * stor19 / 100 * stor11 / totalSupply < (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply):
                revert with 0, 17
            return ((-1 * arg1 * stor19 / 100 * stor11 / totalSupply) - (arg1 * stor25 / 100 * stor11 / totalSupply) - (arg1 * stor30 / 100 * stor11 / totalSupply))
        if arg1 and stor11 / totalSupply > -1 / arg1:
            revert with 0, 17
        if not arg1:
            revert with 0, 18
        if arg1 * stor11 / totalSupply / arg1 != stor11 / totalSupply:
            revert with 0, 'SafeMath: multiplication overflow'
        if not arg1 * stor19 / 100:
            if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                if 0 > arg1 * stor11 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor11 / totalSupply < 0:
                    revert with 0, 17
                if 0 > arg1 * stor11 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor11 / totalSupply < 0:
                    revert with 0, 17
                return (arg1 * stor11 / totalSupply)
            if (arg1 * stor25 / 100) + (arg1 * stor30 / 100) and stor11 / totalSupply > -1 / (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                revert with 0, 17
            if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                revert with 0, 18
            if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) / (arg1 * stor25 / 100) + (arg1 * stor30 / 100) != stor11 / totalSupply:
                revert with 0, 'SafeMath: multiplication overflow'
            if 0 > arg1 * stor11 / totalSupply:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * stor11 / totalSupply < 0:
                revert with 0, 17
            if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) > arg1 * stor11 / totalSupply:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * stor11 / totalSupply < (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply):
                revert with 0, 17
            return ((arg1 * stor11 / totalSupply) - (arg1 * stor25 / 100 * stor11 / totalSupply) - (arg1 * stor30 / 100 * stor11 / totalSupply))
        if arg1 * stor19 / 100 and stor11 / totalSupply > -1 / arg1 * stor19 / 100:
            revert with 0, 17
        if not arg1 * stor19 / 100:
            revert with 0, 18
        if arg1 * stor19 / 100 * stor11 / totalSupply / arg1 * stor19 / 100 != stor11 / totalSupply:
            revert with 0, 'SafeMath: multiplication overflow'
        if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
            if arg1 * stor19 / 100 * stor11 / totalSupply > arg1 * stor11 / totalSupply:
                revert with 0, 'SafeMath: subtraction overflow', 0
            if arg1 * stor11 / totalSupply < arg1 * stor19 / 100 * stor11 / totalSupply:
                revert with 0, 17
            if 0 > (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply):
                revert with 0, 'SafeMath: subtraction overflow', 0
            if (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply) < 0:
                revert with 0, 17
            return ((arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply))
        if (arg1 * stor25 / 100) + (arg1 * stor30 / 100) and stor11 / totalSupply > -1 / (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
            revert with 0, 17
        if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
            revert with 0, 18
        if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) / (arg1 * stor25 / 100) + (arg1 * stor30 / 100) != stor11 / totalSupply:
            revert with 0, 'SafeMath: multiplication overflow'
        if arg1 * stor19 / 100 * stor11 / totalSupply > arg1 * stor11 / totalSupply:
            revert with 0, 'SafeMath: subtraction overflow', 0
        if arg1 * stor11 / totalSupply < arg1 * stor19 / 100 * stor11 / totalSupply:
            revert with 0, 17
        if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) > (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply):
            revert with 0, 'SafeMath: subtraction overflow', 0
        if (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply) < (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply):
            revert with 0, 17
        return ((arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply) - (arg1 * stor25 / 100 * stor11 / totalSupply) - (arg1 * stor30 / 100 * stor11 / totalSupply))
    if not arg1:
        mem[96] = 26
        mem[128] = 'SafeMath: division by zero'
        if not arg1:
            mem[160] = 26
            mem[192] = 'SafeMath: division by zero'
            if not arg1:
                mem[224] = 26
                mem[256] = 'SafeMath: division by zero'
                if not arg1:
                    mem[288] = 26
                    mem[320] = 'SafeMath: division by zero'
                    mem[352] = 30
                    mem[384] = 'SafeMath: subtraction overflow'
                    if 0 > arg1:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 < 0:
                        revert with 0, 17
                    mem[416] = 30
                    mem[448] = 'SafeMath: subtraction overflow'
                    if 0 > arg1:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 < 0:
                        revert with 0, 17
                    mem[64] = 544
                    mem[480] = 30
                    mem[512] = 'SafeMath: subtraction overflow'
                    if 0 > arg1:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 < 0:
                        revert with 0, 17
                    idx = 0
                    s = totalSupply
                    t = stor11
                    while idx < stor9.length:
                        mem[0] = stor9[idx]
                        mem[32] = 1
                        if stor1[stor9[idx]] > t:
                            _11660 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11660] = 26
                            mem[_11660 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                _11850 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _11850 + 68] = mem[idx + _11660 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11850 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _11850 + -mem[64] + 100
                            if not arg1:
                                return 0
                            if arg1 and stor11 / totalSupply > -1 / arg1:
                                revert with 0, 17
                            if not arg1:
                                revert with 0, 18
                            if arg1 * stor11 / totalSupply / arg1 != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _13644 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13644] = 30
                            mem[_13644 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor11 / totalSupply:
                                _13882 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _13882 + 68] = mem[idx + _13644 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13882 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13882 + -mem[64] + 100
                            if arg1 * stor11 / totalSupply < 0:
                                revert with 0, 17
                            _15103 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15103] = 30
                            mem[_15103 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor11 / totalSupply:
                                if arg1 * stor11 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor11 / totalSupply)
                            _15626 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _15626 + 68] = mem[idx + _15103 + 32]
                                idx = idx + 32
                                continue 
                            mem[_15626 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _15626 + -mem[64] + 100
                        if idx >= stor9.length:
                            revert with 0, 50
                        mem[0] = stor9[idx]
                        mem[32] = 2
                        if stor2[stor9[idx]] <= s:
                            if idx >= stor9.length:
                                revert with 0, 50
                            mem[0] = stor9[idx]
                            mem[32] = 1
                            _11851 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11851] = 30
                            mem[_11851 + 32] = 'SafeMath: subtraction overflow'
                            if stor1[stor9[idx]] > t:
                                _12011 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _12011 + 68] = mem[idx + _11851 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12011 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12011 + -mem[64] + 100
                            if t < stor1[stor9[idx]]:
                                revert with 0, 17
                            if idx >= stor9.length:
                                revert with 0, 50
                            mem[0] = stor9[idx]
                            mem[32] = 2
                            _12716 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12716] = 30
                            mem[_12716 + 32] = 'SafeMath: subtraction overflow'
                            if stor2[stor9[idx]] <= s:
                                if s < stor2[stor9[idx]]:
                                    revert with 0, 17
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s - stor2[stor9[idx]]
                                t = t - stor1[stor9[idx]]
                                continue 
                            _12812 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12812 + 68] = mem[idx + _12716 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12812 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12812 + -mem[64] + 100
                        _11852 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11852] = 26
                        mem[_11852 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _12012 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _12012 + 68] = mem[idx + _11852 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12012 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _12012 + -mem[64] + 100
                        if not arg1:
                            return 0
                        if arg1 and stor11 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor11 / totalSupply / arg1 != stor11 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _13884 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13884] = 30
                        mem[_13884 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor11 / totalSupply:
                            _14111 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _14111 + 68] = mem[idx + _13884 + 32]
                                idx = idx + 32
                                continue 
                            mem[_14111 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _14111 + -mem[64] + 100
                        if arg1 * stor11 / totalSupply < 0:
                            revert with 0, 17
                        _15627 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_15627] = 30
                        mem[_15627 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= arg1 * stor11 / totalSupply:
                            if arg1 * stor11 / totalSupply < 0:
                                revert with 0, 17
                            return (arg1 * stor11 / totalSupply)
                        _16184 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _16184 + 68] = mem[idx + _15627 + 32]
                            idx = idx + 32
                            continue 
                        mem[_16184 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _16184 + -mem[64] + 100
                else:
                    if arg1 and stor35 > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor35 / arg1 != stor35:
                        revert with 0, 'SafeMath: multiplication overflow'
                    mem[288] = 26
                    mem[320] = 'SafeMath: division by zero'
                    mem[352] = 30
                    mem[384] = 'SafeMath: subtraction overflow'
                    if 0 > arg1:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 < 0:
                        revert with 0, 17
                    mem[416] = 30
                    mem[448] = 'SafeMath: subtraction overflow'
                    if 0 > arg1:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 < 0:
                        revert with 0, 17
                    mem[64] = 544
                    mem[480] = 30
                    mem[512] = 'SafeMath: subtraction overflow'
                    if arg1 * stor35 / 100 > arg1:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 < arg1 * stor35 / 100:
                        revert with 0, 17
                    idx = 0
                    s = totalSupply
                    t = stor11
                    while idx < stor9.length:
                        mem[0] = stor9[idx]
                        mem[32] = 1
                        if stor1[stor9[idx]] > t:
                            _11659 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11659] = 26
                            mem[_11659 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                _11847 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _11847 + 68] = mem[idx + _11659 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11847 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _11847 + -mem[64] + 100
                            if not arg1:
                                return 0
                            if arg1 and stor11 / totalSupply > -1 / arg1:
                                revert with 0, 17
                            if not arg1:
                                revert with 0, 18
                            if arg1 * stor11 / totalSupply / arg1 != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _13641 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13641] = 30
                            mem[_13641 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor11 / totalSupply:
                                _13879 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _13879 + 68] = mem[idx + _13641 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_13879 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _13879 + -mem[64] + 100
                            if arg1 * stor11 / totalSupply < 0:
                                revert with 0, 17
                            _15097 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15097] = 30
                            mem[_15097 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor11 / totalSupply:
                                if arg1 * stor11 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor11 / totalSupply)
                            _15623 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _15623 + 68] = mem[idx + _15097 + 32]
                                idx = idx + 32
                                continue 
                            mem[_15623 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _15623 + -mem[64] + 100
                        if idx >= stor9.length:
                            revert with 0, 50
                        mem[0] = stor9[idx]
                        mem[32] = 2
                        if stor2[stor9[idx]] <= s:
                            if idx >= stor9.length:
                                revert with 0, 50
                            mem[0] = stor9[idx]
                            mem[32] = 1
                            _11848 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11848] = 30
                            mem[_11848 + 32] = 'SafeMath: subtraction overflow'
                            if stor1[stor9[idx]] > t:
                                _12008 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _12008 + 68] = mem[idx + _11848 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12008 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12008 + -mem[64] + 100
                            if t < stor1[stor9[idx]]:
                                revert with 0, 17
                            if idx >= stor9.length:
                                revert with 0, 50
                            mem[0] = stor9[idx]
                            mem[32] = 2
                            _12713 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12713] = 30
                            mem[_12713 + 32] = 'SafeMath: subtraction overflow'
                            if stor2[stor9[idx]] <= s:
                                if s < stor2[stor9[idx]]:
                                    revert with 0, 17
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s - stor2[stor9[idx]]
                                t = t - stor1[stor9[idx]]
                                continue 
                            _12809 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12809 + 68] = mem[idx + _12713 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12809 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12809 + -mem[64] + 100
                        _11849 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11849] = 26
                        mem[_11849 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _12009 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _12009 + 68] = mem[idx + _11849 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12009 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _12009 + -mem[64] + 100
                        if not arg1:
                            return 0
                        if arg1 and stor11 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor11 / totalSupply / arg1 != stor11 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _13881 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_13881] = 30
                        mem[_13881 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor11 / totalSupply:
                            _14109 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _14109 + 68] = mem[idx + _13881 + 32]
                                idx = idx + 32
                                continue 
                            mem[_14109 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _14109 + -mem[64] + 100
                        if arg1 * stor11 / totalSupply < 0:
                            revert with 0, 17
                        _15624 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_15624] = 30
                        mem[_15624 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= arg1 * stor11 / totalSupply:
                            if arg1 * stor11 / totalSupply < 0:
                                revert with 0, 17
                            return (arg1 * stor11 / totalSupply)
                        _16183 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _16183 + 68] = mem[idx + _15624 + 32]
                            idx = idx + 32
                            continue 
                        mem[_16183 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _16183 + -mem[64] + 100
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if t >= stor11 / totalSupply:
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg1:
                        return 0
                    if arg1 and t / s > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 0, 17
                    if 0 > arg1 * t / s:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * t / s < 0:
                        revert with 0, 17
                    return (arg1 * t / s)
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    return 0
                if arg1 and stor11 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor11 / totalSupply / arg1 != stor11 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if 0 > arg1 * stor11 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor11 / totalSupply < 0:
                    revert with 0, 17
                if 0 > arg1 * stor11 / totalSupply:
                    revert with 0, 'SafeMath: subtraction overflow', 0
                if arg1 * stor11 / totalSupply < 0:
                    revert with 0, 17
            else:
                if arg1 and stor30 > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor30 / arg1 != stor30:
                    revert with 0, 'SafeMath: multiplication overflow'
                mem[224] = 26
                mem[256] = 'SafeMath: division by zero'
                if not arg1:
                    mem[288] = 26
                    mem[320] = 'SafeMath: division by zero'
                    if 0 > !(arg1 * stor30 / 100):
                        revert with 0, 17
                    if arg1 * stor30 / 100 < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[352] = 30
                    mem[384] = 'SafeMath: subtraction overflow'
                    if 0 > arg1:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 < 0:
                        revert with 0, 17
                    mem[416] = 30
                    mem[448] = 'SafeMath: subtraction overflow'
                    if arg1 * stor30 / 100 > arg1:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 < arg1 * stor30 / 100:
                        revert with 0, 17
                    mem[64] = 544
                    mem[480] = 30
                    mem[512] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 - (arg1 * stor30 / 100):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 - (arg1 * stor30 / 100) < 0:
                        revert with 0, 17
                    if 0 > !(arg1 * stor30 / 100):
                        revert with 0, 17
                    if arg1 * stor30 / 100 < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    idx = 0
                    s = totalSupply
                    t = stor11
                    while idx < stor9.length:
                        mem[0] = stor9[idx]
                        mem[32] = 1
                        if stor1[stor9[idx]] > t:
                            _11658 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11658] = 26
                            mem[_11658 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                _11844 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _11844 + 68] = mem[idx + _11658 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11844 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _11844 + -mem[64] + 100
                            if not arg1:
                                if not arg1 * stor30 / 100:
                                    return 0
                                if arg1 * stor30 / 100 and stor11 / totalSupply > -1 / arg1 * stor30 / 100:
                                    revert with 0, 17
                                if not arg1 * stor30 / 100:
                                    revert with 0, 18
                                if arg1 * stor30 / 100 * stor11 / totalSupply / arg1 * stor30 / 100 != stor11 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _13637 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13637] = 30
                                mem[_13637 + 32] = 'SafeMath: subtraction overflow'
                                _15091 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15091] = 30
                                mem[_15091 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * stor30 / 100 * stor11 / totalSupply <= 0:
                                    if 0 < arg1 * stor30 / 100 * stor11 / totalSupply:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _15618 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _15618 + 68] = mem[idx + _15091 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15618 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _15618 + -mem[64] + 100
                            if arg1 and stor11 / totalSupply > -1 / arg1:
                                revert with 0, 17
                            if not arg1:
                                revert with 0, 18
                            if arg1 * stor11 / totalSupply / arg1 != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * stor30 / 100:
                                _13636 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13636] = 30
                                mem[_13636 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor11 / totalSupply:
                                    _13875 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _13875 + 68] = mem[idx + _13636 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_13875 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _13875 + -mem[64] + 100
                                if arg1 * stor11 / totalSupply < 0:
                                    revert with 0, 17
                                _15089 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15089] = 30
                                mem[_15089 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= arg1 * stor11 / totalSupply:
                                    if arg1 * stor11 / totalSupply < 0:
                                        revert with 0, 17
                                    return (arg1 * stor11 / totalSupply)
                                _15617 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _15617 + 68] = mem[idx + _15089 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15617 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _15617 + -mem[64] + 100
                            if arg1 * stor30 / 100 and stor11 / totalSupply > -1 / arg1 * stor30 / 100:
                                revert with 0, 17
                            if not arg1 * stor30 / 100:
                                revert with 0, 18
                            if arg1 * stor30 / 100 * stor11 / totalSupply / arg1 * stor30 / 100 != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _14551 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14551] = 30
                            mem[_14551 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor11 / totalSupply:
                                _15088 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _15088 + 68] = mem[idx + _14551 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15088 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _15088 + -mem[64] + 100
                            if arg1 * stor11 / totalSupply < 0:
                                revert with 0, 17
                            _17064 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_17064] = 30
                            mem[_17064 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor30 / 100 * stor11 / totalSupply <= arg1 * stor11 / totalSupply:
                                if arg1 * stor11 / totalSupply < arg1 * stor30 / 100 * stor11 / totalSupply:
                                    revert with 0, 17
                                return (arg1 * stor11 / totalSupply)
                            _17847 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _17847 + 68] = mem[idx + _17064 + 32]
                                idx = idx + 32
                                continue 
                            mem[_17847 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _17847 + -mem[64] + 100
                        if idx >= stor9.length:
                            revert with 0, 50
                        mem[0] = stor9[idx]
                        mem[32] = 2
                        if stor2[stor9[idx]] <= s:
                            if idx >= stor9.length:
                                revert with 0, 50
                            mem[0] = stor9[idx]
                            mem[32] = 1
                            _11845 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11845] = 30
                            mem[_11845 + 32] = 'SafeMath: subtraction overflow'
                            if stor1[stor9[idx]] > t:
                                _12005 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _12005 + 68] = mem[idx + _11845 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12005 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12005 + -mem[64] + 100
                            if t < stor1[stor9[idx]]:
                                revert with 0, 17
                            if idx >= stor9.length:
                                revert with 0, 50
                            mem[0] = stor9[idx]
                            mem[32] = 2
                            _12710 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12710] = 30
                            mem[_12710 + 32] = 'SafeMath: subtraction overflow'
                            if stor2[stor9[idx]] <= s:
                                if s < stor2[stor9[idx]]:
                                    revert with 0, 17
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s - stor2[stor9[idx]]
                                t = t - stor1[stor9[idx]]
                                continue 
                            _12806 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12806 + 68] = mem[idx + _12710 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12806 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12806 + -mem[64] + 100
                        _11846 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11846] = 26
                        mem[_11846 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _12006 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _12006 + 68] = mem[idx + _11846 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12006 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _12006 + -mem[64] + 100
                        if not arg1:
                            if not arg1 * stor30 / 100:
                                return 0
                            if arg1 * stor30 / 100 and stor11 / totalSupply > -1 / arg1 * stor30 / 100:
                                revert with 0, 17
                            if not arg1 * stor30 / 100:
                                revert with 0, 18
                            if arg1 * stor30 / 100 * stor11 / totalSupply / arg1 * stor30 / 100 != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _13878 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13878] = 30
                            mem[_13878 + 32] = 'SafeMath: subtraction overflow'
                            _15622 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15622] = 30
                            mem[_15622 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor30 / 100 * stor11 / totalSupply <= 0:
                                if 0 < arg1 * stor30 / 100 * stor11 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _16182 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _16182 + 68] = mem[idx + _15622 + 32]
                                idx = idx + 32
                                continue 
                            mem[_16182 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _16182 + -mem[64] + 100
                        if arg1 and stor11 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor11 / totalSupply / arg1 != stor11 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor30 / 100:
                            _13877 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13877] = 30
                            mem[_13877 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor11 / totalSupply:
                                _14107 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _14107 + 68] = mem[idx + _13877 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14107 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14107 + -mem[64] + 100
                            if arg1 * stor11 / totalSupply < 0:
                                revert with 0, 17
                            _15620 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15620] = 30
                            mem[_15620 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor11 / totalSupply:
                                if arg1 * stor11 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor11 / totalSupply)
                            _16181 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _16181 + 68] = mem[idx + _15620 + 32]
                                idx = idx + 32
                                continue 
                            mem[_16181 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _16181 + -mem[64] + 100
                        if arg1 * stor30 / 100 and stor11 / totalSupply > -1 / arg1 * stor30 / 100:
                            revert with 0, 17
                        if not arg1 * stor30 / 100:
                            revert with 0, 18
                        if arg1 * stor30 / 100 * stor11 / totalSupply / arg1 * stor30 / 100 != stor11 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _15092 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_15092] = 30
                        mem[_15092 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor11 / totalSupply:
                            _15619 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _15619 + 68] = mem[idx + _15092 + 32]
                                idx = idx + 32
                                continue 
                            mem[_15619 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _15619 + -mem[64] + 100
                        if arg1 * stor11 / totalSupply < 0:
                            revert with 0, 17
                        _17850 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_17850] = 30
                        mem[_17850 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor30 / 100 * stor11 / totalSupply <= arg1 * stor11 / totalSupply:
                            if arg1 * stor11 / totalSupply < arg1 * stor30 / 100 * stor11 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor11 / totalSupply)
                        _18424 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _18424 + 68] = mem[idx + _17850 + 32]
                            idx = idx + 32
                            continue 
                        mem[_18424 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _18424 + -mem[64] + 100
                else:
                    if arg1 and stor35 > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor35 / arg1 != stor35:
                        revert with 0, 'SafeMath: multiplication overflow'
                    mem[288] = 26
                    mem[320] = 'SafeMath: division by zero'
                    if 0 > !(arg1 * stor30 / 100):
                        revert with 0, 17
                    if arg1 * stor30 / 100 < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[352] = 30
                    mem[384] = 'SafeMath: subtraction overflow'
                    if 0 > arg1:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 < 0:
                        revert with 0, 17
                    mem[416] = 30
                    mem[448] = 'SafeMath: subtraction overflow'
                    if arg1 * stor30 / 100 > arg1:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 < arg1 * stor30 / 100:
                        revert with 0, 17
                    mem[64] = 544
                    mem[480] = 30
                    mem[512] = 'SafeMath: subtraction overflow'
                    if arg1 * stor35 / 100 > arg1 - (arg1 * stor30 / 100):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 - (arg1 * stor30 / 100) < arg1 * stor35 / 100:
                        revert with 0, 17
                    if 0 > !(arg1 * stor30 / 100):
                        revert with 0, 17
                    if arg1 * stor30 / 100 < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    idx = 0
                    s = totalSupply
                    t = stor11
                    while idx < stor9.length:
                        mem[0] = stor9[idx]
                        mem[32] = 1
                        if stor1[stor9[idx]] > t:
                            _11657 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11657] = 26
                            mem[_11657 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                _11841 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _11841 + 68] = mem[idx + _11657 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11841 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _11841 + -mem[64] + 100
                            if not arg1:
                                if not arg1 * stor30 / 100:
                                    return 0
                                if arg1 * stor30 / 100 and stor11 / totalSupply > -1 / arg1 * stor30 / 100:
                                    revert with 0, 17
                                if not arg1 * stor30 / 100:
                                    revert with 0, 18
                                if arg1 * stor30 / 100 * stor11 / totalSupply / arg1 * stor30 / 100 != stor11 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _13632 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13632] = 30
                                mem[_13632 + 32] = 'SafeMath: subtraction overflow'
                                _15082 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15082] = 30
                                mem[_15082 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * stor30 / 100 * stor11 / totalSupply <= 0:
                                    if 0 < arg1 * stor30 / 100 * stor11 / totalSupply:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _15610 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _15610 + 68] = mem[idx + _15082 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15610 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _15610 + -mem[64] + 100
                            if arg1 and stor11 / totalSupply > -1 / arg1:
                                revert with 0, 17
                            if not arg1:
                                revert with 0, 18
                            if arg1 * stor11 / totalSupply / arg1 != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * stor30 / 100:
                                _13631 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13631] = 30
                                mem[_13631 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor11 / totalSupply:
                                    _13871 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _13871 + 68] = mem[idx + _13631 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_13871 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _13871 + -mem[64] + 100
                                if arg1 * stor11 / totalSupply < 0:
                                    revert with 0, 17
                                _15080 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15080] = 30
                                mem[_15080 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= arg1 * stor11 / totalSupply:
                                    if arg1 * stor11 / totalSupply < 0:
                                        revert with 0, 17
                                    return (arg1 * stor11 / totalSupply)
                                _15609 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _15609 + 68] = mem[idx + _15080 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15609 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _15609 + -mem[64] + 100
                            if arg1 * stor30 / 100 and stor11 / totalSupply > -1 / arg1 * stor30 / 100:
                                revert with 0, 17
                            if not arg1 * stor30 / 100:
                                revert with 0, 18
                            if arg1 * stor30 / 100 * stor11 / totalSupply / arg1 * stor30 / 100 != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _14545 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14545] = 30
                            mem[_14545 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor11 / totalSupply:
                                _15079 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _15079 + 68] = mem[idx + _14545 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15079 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _15079 + -mem[64] + 100
                            if arg1 * stor11 / totalSupply < 0:
                                revert with 0, 17
                            _17053 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_17053] = 30
                            mem[_17053 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor30 / 100 * stor11 / totalSupply <= arg1 * stor11 / totalSupply:
                                if arg1 * stor11 / totalSupply < arg1 * stor30 / 100 * stor11 / totalSupply:
                                    revert with 0, 17
                                return (arg1 * stor11 / totalSupply)
                            _17837 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _17837 + 68] = mem[idx + _17053 + 32]
                                idx = idx + 32
                                continue 
                            mem[_17837 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _17837 + -mem[64] + 100
                        if idx >= stor9.length:
                            revert with 0, 50
                        mem[0] = stor9[idx]
                        mem[32] = 2
                        if stor2[stor9[idx]] <= s:
                            if idx >= stor9.length:
                                revert with 0, 50
                            mem[0] = stor9[idx]
                            mem[32] = 1
                            _11842 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11842] = 30
                            mem[_11842 + 32] = 'SafeMath: subtraction overflow'
                            if stor1[stor9[idx]] > t:
                                _12002 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _12002 + 68] = mem[idx + _11842 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_12002 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _12002 + -mem[64] + 100
                            if t < stor1[stor9[idx]]:
                                revert with 0, 17
                            if idx >= stor9.length:
                                revert with 0, 50
                            mem[0] = stor9[idx]
                            mem[32] = 2
                            _12707 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12707] = 30
                            mem[_12707 + 32] = 'SafeMath: subtraction overflow'
                            if stor2[stor9[idx]] <= s:
                                if s < stor2[stor9[idx]]:
                                    revert with 0, 17
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s - stor2[stor9[idx]]
                                t = t - stor1[stor9[idx]]
                                continue 
                            _12803 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12803 + 68] = mem[idx + _12707 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12803 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12803 + -mem[64] + 100
                        _11843 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11843] = 26
                        mem[_11843 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _12003 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _12003 + 68] = mem[idx + _11843 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12003 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _12003 + -mem[64] + 100
                        if not arg1:
                            if not arg1 * stor30 / 100:
                                return 0
                            if arg1 * stor30 / 100 and stor11 / totalSupply > -1 / arg1 * stor30 / 100:
                                revert with 0, 17
                            if not arg1 * stor30 / 100:
                                revert with 0, 18
                            if arg1 * stor30 / 100 * stor11 / totalSupply / arg1 * stor30 / 100 != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _13874 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13874] = 30
                            mem[_13874 + 32] = 'SafeMath: subtraction overflow'
                            _15614 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15614] = 30
                            mem[_15614 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor30 / 100 * stor11 / totalSupply <= 0:
                                if 0 < arg1 * stor30 / 100 * stor11 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _16178 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _16178 + 68] = mem[idx + _15614 + 32]
                                idx = idx + 32
                                continue 
                            mem[_16178 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _16178 + -mem[64] + 100
                        if arg1 and stor11 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor11 / totalSupply / arg1 != stor11 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor30 / 100:
                            _13873 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13873] = 30
                            mem[_13873 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor11 / totalSupply:
                                _14102 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _14102 + 68] = mem[idx + _13873 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14102 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14102 + -mem[64] + 100
                            if arg1 * stor11 / totalSupply < 0:
                                revert with 0, 17
                            _15612 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15612] = 30
                            mem[_15612 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor11 / totalSupply:
                                if arg1 * stor11 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor11 / totalSupply)
                            _16177 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _16177 + 68] = mem[idx + _15612 + 32]
                                idx = idx + 32
                                continue 
                            mem[_16177 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _16177 + -mem[64] + 100
                        if arg1 * stor30 / 100 and stor11 / totalSupply > -1 / arg1 * stor30 / 100:
                            revert with 0, 17
                        if not arg1 * stor30 / 100:
                            revert with 0, 18
                        if arg1 * stor30 / 100 * stor11 / totalSupply / arg1 * stor30 / 100 != stor11 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _15083 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_15083] = 30
                        mem[_15083 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor11 / totalSupply:
                            _15611 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _15611 + 68] = mem[idx + _15083 + 32]
                                idx = idx + 32
                                continue 
                            mem[_15611 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _15611 + -mem[64] + 100
                        if arg1 * stor11 / totalSupply < 0:
                            revert with 0, 17
                        _17840 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_17840] = 30
                        mem[_17840 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor30 / 100 * stor11 / totalSupply <= arg1 * stor11 / totalSupply:
                            if arg1 * stor11 / totalSupply < arg1 * stor30 / 100 * stor11 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor11 / totalSupply)
                        _18421 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _18421 + 68] = mem[idx + _17840 + 32]
                            idx = idx + 32
                            continue 
                        mem[_18421 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _18421 + -mem[64] + 100
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if t >= stor11 / totalSupply:
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg1:
                        if arg1 * stor30 / 100:
                            if arg1 * stor30 / 100 and t / s > -1 / arg1 * stor30 / 100:
                                revert with 0, 17
                            if not arg1 * stor30 / 100:
                                revert with 0, 18
                            if arg1 * stor30 / 100 * t / s / arg1 * stor30 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * stor30 / 100 * t / s > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * stor30 / 100 * t / s:
                                revert with 0, 17
                            else:
                                return 0
                        else:
                            return 0
                    if arg1 and t / s > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor30 / 100:
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                    else:
                        if arg1 * stor30 / 100 and t / s > -1 / arg1 * stor30 / 100:
                            revert with 0, 17
                        if not arg1 * stor30 / 100:
                            revert with 0, 18
                        if arg1 * stor30 / 100 * t / s / arg1 * stor30 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if arg1 * stor30 / 100 * t / s > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < arg1 * stor30 / 100 * t / s:
                            revert with 0, 17
                    return (arg1 * t / s)
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if arg1 * stor30 / 100:
                        if arg1 * stor30 / 100 and stor11 / totalSupply > -1 / arg1 * stor30 / 100:
                            revert with 0, 17
                        if not arg1 * stor30 / 100:
                            revert with 0, 18
                        if arg1 * stor30 / 100 * stor11 / totalSupply / arg1 * stor30 / 100 != stor11 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * stor30 / 100 * stor11 / totalSupply > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * stor30 / 100 * stor11 / totalSupply:
                            revert with 0, 17
                        else:
                            return 0
                    else:
                        return 0
                if arg1 and stor11 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor11 / totalSupply / arg1 != stor11 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor30 / 100:
                    if 0 > arg1 * stor11 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor11 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor11 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor11 / totalSupply < 0:
                        revert with 0, 17
                else:
                    if arg1 * stor30 / 100 and stor11 / totalSupply > -1 / arg1 * stor30 / 100:
                        revert with 0, 17
                    if not arg1 * stor30 / 100:
                        revert with 0, 18
                    if arg1 * stor30 / 100 * stor11 / totalSupply / arg1 * stor30 / 100 != stor11 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 > arg1 * stor11 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor11 / totalSupply < 0:
                        revert with 0, 17
                    if arg1 * stor30 / 100 * stor11 / totalSupply > arg1 * stor11 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor11 / totalSupply < arg1 * stor30 / 100 * stor11 / totalSupply:
                        revert with 0, 17
        else:
            if arg1 and stor25 > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * stor25 / arg1 != stor25:
                revert with 0, 'SafeMath: multiplication overflow'
            mem[160] = 26
            mem[192] = 'SafeMath: division by zero'
            if not arg1:
                mem[224] = 26
                mem[256] = 'SafeMath: division by zero'
                if not arg1:
                    mem[288] = 26
                    mem[320] = 'SafeMath: division by zero'
                    if arg1 * stor25 / 100 > -1:
                        revert with 0, 17
                    if arg1 * stor25 / 100 < arg1 * stor25 / 100:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[352] = 30
                    mem[384] = 'SafeMath: subtraction overflow'
                    if 0 > arg1:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 < 0:
                        revert with 0, 17
                    mem[416] = 30
                    mem[448] = 'SafeMath: subtraction overflow'
                    if arg1 * stor25 / 100 > arg1:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 < arg1 * stor25 / 100:
                        revert with 0, 17
                    mem[64] = 544
                    mem[480] = 30
                    mem[512] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 - (arg1 * stor25 / 100):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 - (arg1 * stor25 / 100) < 0:
                        revert with 0, 17
                    if arg1 * stor25 / 100 > -1:
                        revert with 0, 17
                    if arg1 * stor25 / 100 < arg1 * stor25 / 100:
                        revert with 0, 'SafeMath: addition overflow'
                    idx = 0
                    s = totalSupply
                    t = stor11
                    while idx < stor9.length:
                        mem[0] = stor9[idx]
                        mem[32] = 1
                        if stor1[stor9[idx]] > t:
                            _11656 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11656] = 26
                            mem[_11656 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                _11838 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _11838 + 68] = mem[idx + _11656 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11838 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _11838 + -mem[64] + 100
                            if not arg1:
                                if not arg1 * stor25 / 100:
                                    return 0
                                if arg1 * stor25 / 100 and stor11 / totalSupply > -1 / arg1 * stor25 / 100:
                                    revert with 0, 17
                                if not arg1 * stor25 / 100:
                                    revert with 0, 18
                                if arg1 * stor25 / 100 * stor11 / totalSupply / arg1 * stor25 / 100 != stor11 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _13627 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13627] = 30
                                mem[_13627 + 32] = 'SafeMath: subtraction overflow'
                                _15073 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15073] = 30
                                mem[_15073 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * stor25 / 100 * stor11 / totalSupply <= 0:
                                    if 0 < arg1 * stor25 / 100 * stor11 / totalSupply:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _15602 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _15602 + 68] = mem[idx + _15073 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15602 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _15602 + -mem[64] + 100
                            if arg1 and stor11 / totalSupply > -1 / arg1:
                                revert with 0, 17
                            if not arg1:
                                revert with 0, 18
                            if arg1 * stor11 / totalSupply / arg1 != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * stor25 / 100:
                                _13626 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13626] = 30
                                mem[_13626 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor11 / totalSupply:
                                    _13867 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _13867 + 68] = mem[idx + _13626 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_13867 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _13867 + -mem[64] + 100
                                if arg1 * stor11 / totalSupply < 0:
                                    revert with 0, 17
                                _15071 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15071] = 30
                                mem[_15071 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= arg1 * stor11 / totalSupply:
                                    if arg1 * stor11 / totalSupply < 0:
                                        revert with 0, 17
                                    return (arg1 * stor11 / totalSupply)
                                _15601 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _15601 + 68] = mem[idx + _15071 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15601 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _15601 + -mem[64] + 100
                            if arg1 * stor25 / 100 and stor11 / totalSupply > -1 / arg1 * stor25 / 100:
                                revert with 0, 17
                            if not arg1 * stor25 / 100:
                                revert with 0, 18
                            if arg1 * stor25 / 100 * stor11 / totalSupply / arg1 * stor25 / 100 != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _14539 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14539] = 30
                            mem[_14539 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor11 / totalSupply:
                                _15070 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _15070 + 68] = mem[idx + _14539 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15070 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _15070 + -mem[64] + 100
                            if arg1 * stor11 / totalSupply < 0:
                                revert with 0, 17
                            _17042 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_17042] = 30
                            mem[_17042 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor25 / 100 * stor11 / totalSupply <= arg1 * stor11 / totalSupply:
                                if arg1 * stor11 / totalSupply < arg1 * stor25 / 100 * stor11 / totalSupply:
                                    revert with 0, 17
                                return (arg1 * stor11 / totalSupply)
                            _17827 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _17827 + 68] = mem[idx + _17042 + 32]
                                idx = idx + 32
                                continue 
                            mem[_17827 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _17827 + -mem[64] + 100
                        if idx >= stor9.length:
                            revert with 0, 50
                        mem[0] = stor9[idx]
                        mem[32] = 2
                        if stor2[stor9[idx]] <= s:
                            if idx >= stor9.length:
                                revert with 0, 50
                            mem[0] = stor9[idx]
                            mem[32] = 1
                            _11839 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11839] = 30
                            mem[_11839 + 32] = 'SafeMath: subtraction overflow'
                            if stor1[stor9[idx]] > t:
                                _11999 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11999 + 68] = mem[idx + _11839 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11999 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11999 + -mem[64] + 100
                            if t < stor1[stor9[idx]]:
                                revert with 0, 17
                            if idx >= stor9.length:
                                revert with 0, 50
                            mem[0] = stor9[idx]
                            mem[32] = 2
                            _12704 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12704] = 30
                            mem[_12704 + 32] = 'SafeMath: subtraction overflow'
                            if stor2[stor9[idx]] <= s:
                                if s < stor2[stor9[idx]]:
                                    revert with 0, 17
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s - stor2[stor9[idx]]
                                t = t - stor1[stor9[idx]]
                                continue 
                            _12800 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12800 + 68] = mem[idx + _12704 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12800 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12800 + -mem[64] + 100
                        _11840 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11840] = 26
                        mem[_11840 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _12000 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _12000 + 68] = mem[idx + _11840 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12000 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _12000 + -mem[64] + 100
                        if not arg1:
                            if not arg1 * stor25 / 100:
                                return 0
                            if arg1 * stor25 / 100 and stor11 / totalSupply > -1 / arg1 * stor25 / 100:
                                revert with 0, 17
                            if not arg1 * stor25 / 100:
                                revert with 0, 18
                            if arg1 * stor25 / 100 * stor11 / totalSupply / arg1 * stor25 / 100 != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _13870 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13870] = 30
                            mem[_13870 + 32] = 'SafeMath: subtraction overflow'
                            _15606 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15606] = 30
                            mem[_15606 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor25 / 100 * stor11 / totalSupply <= 0:
                                if 0 < arg1 * stor25 / 100 * stor11 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _16174 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _16174 + 68] = mem[idx + _15606 + 32]
                                idx = idx + 32
                                continue 
                            mem[_16174 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _16174 + -mem[64] + 100
                        if arg1 and stor11 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor11 / totalSupply / arg1 != stor11 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor25 / 100:
                            _13869 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13869] = 30
                            mem[_13869 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor11 / totalSupply:
                                _14097 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _14097 + 68] = mem[idx + _13869 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14097 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14097 + -mem[64] + 100
                            if arg1 * stor11 / totalSupply < 0:
                                revert with 0, 17
                            _15604 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15604] = 30
                            mem[_15604 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor11 / totalSupply:
                                if arg1 * stor11 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor11 / totalSupply)
                            _16173 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _16173 + 68] = mem[idx + _15604 + 32]
                                idx = idx + 32
                                continue 
                            mem[_16173 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _16173 + -mem[64] + 100
                        if arg1 * stor25 / 100 and stor11 / totalSupply > -1 / arg1 * stor25 / 100:
                            revert with 0, 17
                        if not arg1 * stor25 / 100:
                            revert with 0, 18
                        if arg1 * stor25 / 100 * stor11 / totalSupply / arg1 * stor25 / 100 != stor11 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _15074 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_15074] = 30
                        mem[_15074 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor11 / totalSupply:
                            _15603 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _15603 + 68] = mem[idx + _15074 + 32]
                                idx = idx + 32
                                continue 
                            mem[_15603 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _15603 + -mem[64] + 100
                        if arg1 * stor11 / totalSupply < 0:
                            revert with 0, 17
                        _17830 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_17830] = 30
                        mem[_17830 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor25 / 100 * stor11 / totalSupply <= arg1 * stor11 / totalSupply:
                            if arg1 * stor11 / totalSupply < arg1 * stor25 / 100 * stor11 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor11 / totalSupply)
                        _18418 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _18418 + 68] = mem[idx + _17830 + 32]
                            idx = idx + 32
                            continue 
                        mem[_18418 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _18418 + -mem[64] + 100
                else:
                    if arg1 and stor35 > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor35 / arg1 != stor35:
                        revert with 0, 'SafeMath: multiplication overflow'
                    mem[288] = 26
                    mem[320] = 'SafeMath: division by zero'
                    if arg1 * stor25 / 100 > -1:
                        revert with 0, 17
                    if arg1 * stor25 / 100 < arg1 * stor25 / 100:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[352] = 30
                    mem[384] = 'SafeMath: subtraction overflow'
                    if 0 > arg1:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 < 0:
                        revert with 0, 17
                    mem[416] = 30
                    mem[448] = 'SafeMath: subtraction overflow'
                    if arg1 * stor25 / 100 > arg1:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 < arg1 * stor25 / 100:
                        revert with 0, 17
                    mem[64] = 544
                    mem[480] = 30
                    mem[512] = 'SafeMath: subtraction overflow'
                    if arg1 * stor35 / 100 > arg1 - (arg1 * stor25 / 100):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 - (arg1 * stor25 / 100) < arg1 * stor35 / 100:
                        revert with 0, 17
                    if arg1 * stor25 / 100 > -1:
                        revert with 0, 17
                    if arg1 * stor25 / 100 < arg1 * stor25 / 100:
                        revert with 0, 'SafeMath: addition overflow'
                    idx = 0
                    s = totalSupply
                    t = stor11
                    while idx < stor9.length:
                        mem[0] = stor9[idx]
                        mem[32] = 1
                        if stor1[stor9[idx]] > t:
                            _11655 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11655] = 26
                            mem[_11655 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                _11835 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _11835 + 68] = mem[idx + _11655 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11835 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _11835 + -mem[64] + 100
                            if not arg1:
                                if not arg1 * stor25 / 100:
                                    return 0
                                if arg1 * stor25 / 100 and stor11 / totalSupply > -1 / arg1 * stor25 / 100:
                                    revert with 0, 17
                                if not arg1 * stor25 / 100:
                                    revert with 0, 18
                                if arg1 * stor25 / 100 * stor11 / totalSupply / arg1 * stor25 / 100 != stor11 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _13622 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13622] = 30
                                mem[_13622 + 32] = 'SafeMath: subtraction overflow'
                                _15064 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15064] = 30
                                mem[_15064 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * stor25 / 100 * stor11 / totalSupply <= 0:
                                    if 0 < arg1 * stor25 / 100 * stor11 / totalSupply:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _15594 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _15594 + 68] = mem[idx + _15064 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15594 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _15594 + -mem[64] + 100
                            if arg1 and stor11 / totalSupply > -1 / arg1:
                                revert with 0, 17
                            if not arg1:
                                revert with 0, 18
                            if arg1 * stor11 / totalSupply / arg1 != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * stor25 / 100:
                                _13621 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13621] = 30
                                mem[_13621 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor11 / totalSupply:
                                    _13863 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _13863 + 68] = mem[idx + _13621 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_13863 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _13863 + -mem[64] + 100
                                if arg1 * stor11 / totalSupply < 0:
                                    revert with 0, 17
                                _15062 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15062] = 30
                                mem[_15062 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= arg1 * stor11 / totalSupply:
                                    if arg1 * stor11 / totalSupply < 0:
                                        revert with 0, 17
                                    return (arg1 * stor11 / totalSupply)
                                _15593 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _15593 + 68] = mem[idx + _15062 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15593 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _15593 + -mem[64] + 100
                            if arg1 * stor25 / 100 and stor11 / totalSupply > -1 / arg1 * stor25 / 100:
                                revert with 0, 17
                            if not arg1 * stor25 / 100:
                                revert with 0, 18
                            if arg1 * stor25 / 100 * stor11 / totalSupply / arg1 * stor25 / 100 != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _14533 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14533] = 30
                            mem[_14533 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor11 / totalSupply:
                                _15061 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _15061 + 68] = mem[idx + _14533 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15061 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _15061 + -mem[64] + 100
                            if arg1 * stor11 / totalSupply < 0:
                                revert with 0, 17
                            _17031 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_17031] = 30
                            mem[_17031 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor25 / 100 * stor11 / totalSupply <= arg1 * stor11 / totalSupply:
                                if arg1 * stor11 / totalSupply < arg1 * stor25 / 100 * stor11 / totalSupply:
                                    revert with 0, 17
                                return (arg1 * stor11 / totalSupply)
                            _17817 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _17817 + 68] = mem[idx + _17031 + 32]
                                idx = idx + 32
                                continue 
                            mem[_17817 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _17817 + -mem[64] + 100
                        if idx >= stor9.length:
                            revert with 0, 50
                        mem[0] = stor9[idx]
                        mem[32] = 2
                        if stor2[stor9[idx]] <= s:
                            if idx >= stor9.length:
                                revert with 0, 50
                            mem[0] = stor9[idx]
                            mem[32] = 1
                            _11836 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11836] = 30
                            mem[_11836 + 32] = 'SafeMath: subtraction overflow'
                            if stor1[stor9[idx]] > t:
                                _11996 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11996 + 68] = mem[idx + _11836 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11996 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11996 + -mem[64] + 100
                            if t < stor1[stor9[idx]]:
                                revert with 0, 17
                            if idx >= stor9.length:
                                revert with 0, 50
                            mem[0] = stor9[idx]
                            mem[32] = 2
                            _12701 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12701] = 30
                            mem[_12701 + 32] = 'SafeMath: subtraction overflow'
                            if stor2[stor9[idx]] <= s:
                                if s < stor2[stor9[idx]]:
                                    revert with 0, 17
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s - stor2[stor9[idx]]
                                t = t - stor1[stor9[idx]]
                                continue 
                            _12797 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12797 + 68] = mem[idx + _12701 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12797 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12797 + -mem[64] + 100
                        _11837 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11837] = 26
                        mem[_11837 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _11997 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _11997 + 68] = mem[idx + _11837 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11997 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _11997 + -mem[64] + 100
                        if not arg1:
                            if not arg1 * stor25 / 100:
                                return 0
                            if arg1 * stor25 / 100 and stor11 / totalSupply > -1 / arg1 * stor25 / 100:
                                revert with 0, 17
                            if not arg1 * stor25 / 100:
                                revert with 0, 18
                            if arg1 * stor25 / 100 * stor11 / totalSupply / arg1 * stor25 / 100 != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _13866 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13866] = 30
                            mem[_13866 + 32] = 'SafeMath: subtraction overflow'
                            _15598 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15598] = 30
                            mem[_15598 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor25 / 100 * stor11 / totalSupply <= 0:
                                if 0 < arg1 * stor25 / 100 * stor11 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _16170 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _16170 + 68] = mem[idx + _15598 + 32]
                                idx = idx + 32
                                continue 
                            mem[_16170 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _16170 + -mem[64] + 100
                        if arg1 and stor11 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor11 / totalSupply / arg1 != stor11 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor25 / 100:
                            _13865 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13865] = 30
                            mem[_13865 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor11 / totalSupply:
                                _14092 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _14092 + 68] = mem[idx + _13865 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14092 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14092 + -mem[64] + 100
                            if arg1 * stor11 / totalSupply < 0:
                                revert with 0, 17
                            _15596 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15596] = 30
                            mem[_15596 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor11 / totalSupply:
                                if arg1 * stor11 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor11 / totalSupply)
                            _16169 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _16169 + 68] = mem[idx + _15596 + 32]
                                idx = idx + 32
                                continue 
                            mem[_16169 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _16169 + -mem[64] + 100
                        if arg1 * stor25 / 100 and stor11 / totalSupply > -1 / arg1 * stor25 / 100:
                            revert with 0, 17
                        if not arg1 * stor25 / 100:
                            revert with 0, 18
                        if arg1 * stor25 / 100 * stor11 / totalSupply / arg1 * stor25 / 100 != stor11 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _15065 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_15065] = 30
                        mem[_15065 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor11 / totalSupply:
                            _15595 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _15595 + 68] = mem[idx + _15065 + 32]
                                idx = idx + 32
                                continue 
                            mem[_15595 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _15595 + -mem[64] + 100
                        if arg1 * stor11 / totalSupply < 0:
                            revert with 0, 17
                        _17820 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_17820] = 30
                        mem[_17820 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor25 / 100 * stor11 / totalSupply <= arg1 * stor11 / totalSupply:
                            if arg1 * stor11 / totalSupply < arg1 * stor25 / 100 * stor11 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor11 / totalSupply)
                        _18415 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _18415 + 68] = mem[idx + _17820 + 32]
                            idx = idx + 32
                            continue 
                        mem[_18415 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _18415 + -mem[64] + 100
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if t >= stor11 / totalSupply:
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg1:
                        if arg1 * stor25 / 100:
                            if arg1 * stor25 / 100 and t / s > -1 / arg1 * stor25 / 100:
                                revert with 0, 17
                            if not arg1 * stor25 / 100:
                                revert with 0, 18
                            if arg1 * stor25 / 100 * t / s / arg1 * stor25 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * stor25 / 100 * t / s > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * stor25 / 100 * t / s:
                                revert with 0, 17
                            else:
                                return 0
                        else:
                            return 0
                    if arg1 and t / s > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor25 / 100:
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                    else:
                        if arg1 * stor25 / 100 and t / s > -1 / arg1 * stor25 / 100:
                            revert with 0, 17
                        if not arg1 * stor25 / 100:
                            revert with 0, 18
                        if arg1 * stor25 / 100 * t / s / arg1 * stor25 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if arg1 * stor25 / 100 * t / s > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < arg1 * stor25 / 100 * t / s:
                            revert with 0, 17
                    return (arg1 * t / s)
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if arg1 * stor25 / 100:
                        if arg1 * stor25 / 100 and stor11 / totalSupply > -1 / arg1 * stor25 / 100:
                            revert with 0, 17
                        if not arg1 * stor25 / 100:
                            revert with 0, 18
                        if arg1 * stor25 / 100 * stor11 / totalSupply / arg1 * stor25 / 100 != stor11 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * stor25 / 100 * stor11 / totalSupply > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * stor25 / 100 * stor11 / totalSupply:
                            revert with 0, 17
                        else:
                            return 0
                    else:
                        return 0
                if arg1 and stor11 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor11 / totalSupply / arg1 != stor11 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor25 / 100:
                    if 0 > arg1 * stor11 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor11 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor11 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor11 / totalSupply < 0:
                        revert with 0, 17
                else:
                    if arg1 * stor25 / 100 and stor11 / totalSupply > -1 / arg1 * stor25 / 100:
                        revert with 0, 17
                    if not arg1 * stor25 / 100:
                        revert with 0, 18
                    if arg1 * stor25 / 100 * stor11 / totalSupply / arg1 * stor25 / 100 != stor11 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 > arg1 * stor11 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor11 / totalSupply < 0:
                        revert with 0, 17
                    if arg1 * stor25 / 100 * stor11 / totalSupply > arg1 * stor11 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor11 / totalSupply < arg1 * stor25 / 100 * stor11 / totalSupply:
                        revert with 0, 17
            else:
                if arg1 and stor30 > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor30 / arg1 != stor30:
                    revert with 0, 'SafeMath: multiplication overflow'
                mem[224] = 26
                mem[256] = 'SafeMath: division by zero'
                if not arg1:
                    mem[288] = 26
                    mem[320] = 'SafeMath: division by zero'
                    if arg1 * stor25 / 100 > !(arg1 * stor30 / 100):
                        revert with 0, 17
                    if (arg1 * stor25 / 100) + (arg1 * stor30 / 100) < arg1 * stor25 / 100:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[352] = 30
                    mem[384] = 'SafeMath: subtraction overflow'
                    if 0 > arg1:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 < 0:
                        revert with 0, 17
                    mem[416] = 30
                    mem[448] = 'SafeMath: subtraction overflow'
                    if (arg1 * stor25 / 100) + (arg1 * stor30 / 100) > arg1:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 < (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                        revert with 0, 17
                    mem[64] = 544
                    mem[480] = 30
                    mem[512] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 - (arg1 * stor25 / 100) - (arg1 * stor30 / 100):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 - (arg1 * stor25 / 100) - (arg1 * stor30 / 100) < 0:
                        revert with 0, 17
                    if arg1 * stor25 / 100 > !(arg1 * stor30 / 100):
                        revert with 0, 17
                    if (arg1 * stor25 / 100) + (arg1 * stor30 / 100) < arg1 * stor25 / 100:
                        revert with 0, 'SafeMath: addition overflow'
                    idx = 0
                    s = totalSupply
                    t = stor11
                    while idx < stor9.length:
                        mem[0] = stor9[idx]
                        mem[32] = 1
                        if stor1[stor9[idx]] > t:
                            _11654 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11654] = 26
                            mem[_11654 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                _11832 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _11832 + 68] = mem[idx + _11654 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11832 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _11832 + -mem[64] + 100
                            if not arg1:
                                if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                                    return 0
                                if (arg1 * stor25 / 100) + (arg1 * stor30 / 100) and stor11 / totalSupply > -1 / (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                                    revert with 0, 17
                                if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                                    revert with 0, 18
                                if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) / (arg1 * stor25 / 100) + (arg1 * stor30 / 100) != stor11 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _13617 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13617] = 30
                                mem[_13617 + 32] = 'SafeMath: subtraction overflow'
                                _15055 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15055] = 30
                                mem[_15055 + 32] = 'SafeMath: subtraction overflow'
                                if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) <= 0:
                                    if 0 < (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply):
                                        revert with 0, 17
                                    else:
                                        return 0
                                _15586 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _15586 + 68] = mem[idx + _15055 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15586 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _15586 + -mem[64] + 100
                            if arg1 and stor11 / totalSupply > -1 / arg1:
                                revert with 0, 17
                            if not arg1:
                                revert with 0, 18
                            if arg1 * stor11 / totalSupply / arg1 != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                                _13616 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13616] = 30
                                mem[_13616 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor11 / totalSupply:
                                    _13859 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _13859 + 68] = mem[idx + _13616 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_13859 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _13859 + -mem[64] + 100
                                if arg1 * stor11 / totalSupply < 0:
                                    revert with 0, 17
                                _15053 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15053] = 30
                                mem[_15053 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= arg1 * stor11 / totalSupply:
                                    if arg1 * stor11 / totalSupply < 0:
                                        revert with 0, 17
                                    return (arg1 * stor11 / totalSupply)
                                _15585 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _15585 + 68] = mem[idx + _15053 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15585 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _15585 + -mem[64] + 100
                            if (arg1 * stor25 / 100) + (arg1 * stor30 / 100) and stor11 / totalSupply > -1 / (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                                revert with 0, 17
                            if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                                revert with 0, 18
                            if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) / (arg1 * stor25 / 100) + (arg1 * stor30 / 100) != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _14527 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14527] = 30
                            mem[_14527 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor11 / totalSupply:
                                _15052 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _15052 + 68] = mem[idx + _14527 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15052 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _15052 + -mem[64] + 100
                            if arg1 * stor11 / totalSupply < 0:
                                revert with 0, 17
                            _17020 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_17020] = 30
                            mem[_17020 + 32] = 'SafeMath: subtraction overflow'
                            if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) <= arg1 * stor11 / totalSupply:
                                if arg1 * stor11 / totalSupply < (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply):
                                    revert with 0, 17
                                return (arg1 * stor11 / totalSupply)
                            _17807 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _17807 + 68] = mem[idx + _17020 + 32]
                                idx = idx + 32
                                continue 
                            mem[_17807 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _17807 + -mem[64] + 100
                        if idx >= stor9.length:
                            revert with 0, 50
                        mem[0] = stor9[idx]
                        mem[32] = 2
                        if stor2[stor9[idx]] <= s:
                            if idx >= stor9.length:
                                revert with 0, 50
                            mem[0] = stor9[idx]
                            mem[32] = 1
                            _11833 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11833] = 30
                            mem[_11833 + 32] = 'SafeMath: subtraction overflow'
                            if stor1[stor9[idx]] > t:
                                _11993 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11993 + 68] = mem[idx + _11833 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11993 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11993 + -mem[64] + 100
                            if t < stor1[stor9[idx]]:
                                revert with 0, 17
                            if idx >= stor9.length:
                                revert with 0, 50
                            mem[0] = stor9[idx]
                            mem[32] = 2
                            _12698 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12698] = 30
                            mem[_12698 + 32] = 'SafeMath: subtraction overflow'
                            if stor2[stor9[idx]] <= s:
                                if s < stor2[stor9[idx]]:
                                    revert with 0, 17
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s - stor2[stor9[idx]]
                                t = t - stor1[stor9[idx]]
                                continue 
                            _12794 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12794 + 68] = mem[idx + _12698 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12794 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12794 + -mem[64] + 100
                        _11834 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11834] = 26
                        mem[_11834 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _11994 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _11994 + 68] = mem[idx + _11834 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11994 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _11994 + -mem[64] + 100
                        if not arg1:
                            if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                                return 0
                            if (arg1 * stor25 / 100) + (arg1 * stor30 / 100) and stor11 / totalSupply > -1 / (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                                revert with 0, 17
                            if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                                revert with 0, 18
                            if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) / (arg1 * stor25 / 100) + (arg1 * stor30 / 100) != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _13862 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13862] = 30
                            mem[_13862 + 32] = 'SafeMath: subtraction overflow'
                            _15590 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15590] = 30
                            mem[_15590 + 32] = 'SafeMath: subtraction overflow'
                            if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) <= 0:
                                if 0 < (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply):
                                    revert with 0, 17
                                else:
                                    return 0
                            _16166 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _16166 + 68] = mem[idx + _15590 + 32]
                                idx = idx + 32
                                continue 
                            mem[_16166 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _16166 + -mem[64] + 100
                        if arg1 and stor11 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor11 / totalSupply / arg1 != stor11 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                            _13861 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13861] = 30
                            mem[_13861 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor11 / totalSupply:
                                _14087 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _14087 + 68] = mem[idx + _13861 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14087 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14087 + -mem[64] + 100
                            if arg1 * stor11 / totalSupply < 0:
                                revert with 0, 17
                            _15588 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15588] = 30
                            mem[_15588 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor11 / totalSupply:
                                if arg1 * stor11 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor11 / totalSupply)
                            _16165 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _16165 + 68] = mem[idx + _15588 + 32]
                                idx = idx + 32
                                continue 
                            mem[_16165 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _16165 + -mem[64] + 100
                        if (arg1 * stor25 / 100) + (arg1 * stor30 / 100) and stor11 / totalSupply > -1 / (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                            revert with 0, 17
                        if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                            revert with 0, 18
                        if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) / (arg1 * stor25 / 100) + (arg1 * stor30 / 100) != stor11 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _15056 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_15056] = 30
                        mem[_15056 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor11 / totalSupply:
                            _15587 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _15587 + 68] = mem[idx + _15056 + 32]
                                idx = idx + 32
                                continue 
                            mem[_15587 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _15587 + -mem[64] + 100
                        if arg1 * stor11 / totalSupply < 0:
                            revert with 0, 17
                        _17810 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_17810] = 30
                        mem[_17810 + 32] = 'SafeMath: subtraction overflow'
                        if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) <= arg1 * stor11 / totalSupply:
                            if arg1 * stor11 / totalSupply < (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply):
                                revert with 0, 17
                            return (arg1 * stor11 / totalSupply)
                        _18412 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _18412 + 68] = mem[idx + _17810 + 32]
                            idx = idx + 32
                            continue 
                        mem[_18412 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _18412 + -mem[64] + 100
                else:
                    if arg1 and stor35 > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor35 / arg1 != stor35:
                        revert with 0, 'SafeMath: multiplication overflow'
                    mem[288] = 26
                    mem[320] = 'SafeMath: division by zero'
                    if arg1 * stor25 / 100 > !(arg1 * stor30 / 100):
                        revert with 0, 17
                    if (arg1 * stor25 / 100) + (arg1 * stor30 / 100) < arg1 * stor25 / 100:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[352] = 30
                    mem[384] = 'SafeMath: subtraction overflow'
                    if 0 > arg1:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 < 0:
                        revert with 0, 17
                    mem[416] = 30
                    mem[448] = 'SafeMath: subtraction overflow'
                    if (arg1 * stor25 / 100) + (arg1 * stor30 / 100) > arg1:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 < (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                        revert with 0, 17
                    mem[64] = 544
                    mem[480] = 30
                    mem[512] = 'SafeMath: subtraction overflow'
                    if arg1 * stor35 / 100 > arg1 - (arg1 * stor25 / 100) - (arg1 * stor30 / 100):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 - (arg1 * stor25 / 100) - (arg1 * stor30 / 100) < arg1 * stor35 / 100:
                        revert with 0, 17
                    if arg1 * stor25 / 100 > !(arg1 * stor30 / 100):
                        revert with 0, 17
                    if (arg1 * stor25 / 100) + (arg1 * stor30 / 100) < arg1 * stor25 / 100:
                        revert with 0, 'SafeMath: addition overflow'
                    idx = 0
                    s = totalSupply
                    t = stor11
                    while idx < stor9.length:
                        mem[0] = stor9[idx]
                        mem[32] = 1
                        if stor1[stor9[idx]] > t:
                            _11653 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11653] = 26
                            mem[_11653 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                _11829 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _11829 + 68] = mem[idx + _11653 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11829 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _11829 + -mem[64] + 100
                            if not arg1:
                                if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                                    return 0
                                if (arg1 * stor25 / 100) + (arg1 * stor30 / 100) and stor11 / totalSupply > -1 / (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                                    revert with 0, 17
                                if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                                    revert with 0, 18
                                if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) / (arg1 * stor25 / 100) + (arg1 * stor30 / 100) != stor11 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _13612 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13612] = 30
                                mem[_13612 + 32] = 'SafeMath: subtraction overflow'
                                _15046 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15046] = 30
                                mem[_15046 + 32] = 'SafeMath: subtraction overflow'
                                if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) <= 0:
                                    if 0 < (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply):
                                        revert with 0, 17
                                    else:
                                        return 0
                                _15578 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _15578 + 68] = mem[idx + _15046 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15578 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _15578 + -mem[64] + 100
                            if arg1 and stor11 / totalSupply > -1 / arg1:
                                revert with 0, 17
                            if not arg1:
                                revert with 0, 18
                            if arg1 * stor11 / totalSupply / arg1 != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                                _13611 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13611] = 30
                                mem[_13611 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor11 / totalSupply:
                                    _13855 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _13855 + 68] = mem[idx + _13611 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_13855 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _13855 + -mem[64] + 100
                                if arg1 * stor11 / totalSupply < 0:
                                    revert with 0, 17
                                _15044 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15044] = 30
                                mem[_15044 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= arg1 * stor11 / totalSupply:
                                    if arg1 * stor11 / totalSupply < 0:
                                        revert with 0, 17
                                    return (arg1 * stor11 / totalSupply)
                                _15577 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _15577 + 68] = mem[idx + _15044 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15577 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _15577 + -mem[64] + 100
                            if (arg1 * stor25 / 100) + (arg1 * stor30 / 100) and stor11 / totalSupply > -1 / (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                                revert with 0, 17
                            if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                                revert with 0, 18
                            if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) / (arg1 * stor25 / 100) + (arg1 * stor30 / 100) != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _14521 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14521] = 30
                            mem[_14521 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor11 / totalSupply:
                                _15043 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _15043 + 68] = mem[idx + _14521 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15043 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _15043 + -mem[64] + 100
                            if arg1 * stor11 / totalSupply < 0:
                                revert with 0, 17
                            _17009 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_17009] = 30
                            mem[_17009 + 32] = 'SafeMath: subtraction overflow'
                            if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) <= arg1 * stor11 / totalSupply:
                                if arg1 * stor11 / totalSupply < (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply):
                                    revert with 0, 17
                                return (arg1 * stor11 / totalSupply)
                            _17797 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _17797 + 68] = mem[idx + _17009 + 32]
                                idx = idx + 32
                                continue 
                            mem[_17797 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _17797 + -mem[64] + 100
                        if idx >= stor9.length:
                            revert with 0, 50
                        mem[0] = stor9[idx]
                        mem[32] = 2
                        if stor2[stor9[idx]] <= s:
                            if idx >= stor9.length:
                                revert with 0, 50
                            mem[0] = stor9[idx]
                            mem[32] = 1
                            _11830 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11830] = 30
                            mem[_11830 + 32] = 'SafeMath: subtraction overflow'
                            if stor1[stor9[idx]] > t:
                                _11990 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11990 + 68] = mem[idx + _11830 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11990 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11990 + -mem[64] + 100
                            if t < stor1[stor9[idx]]:
                                revert with 0, 17
                            if idx >= stor9.length:
                                revert with 0, 50
                            mem[0] = stor9[idx]
                            mem[32] = 2
                            _12695 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12695] = 30
                            mem[_12695 + 32] = 'SafeMath: subtraction overflow'
                            if stor2[stor9[idx]] <= s:
                                if s < stor2[stor9[idx]]:
                                    revert with 0, 17
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s - stor2[stor9[idx]]
                                t = t - stor1[stor9[idx]]
                                continue 
                            _12791 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12791 + 68] = mem[idx + _12695 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12791 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12791 + -mem[64] + 100
                        _11831 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11831] = 26
                        mem[_11831 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _11991 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _11991 + 68] = mem[idx + _11831 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11991 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _11991 + -mem[64] + 100
                        if not arg1:
                            if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                                return 0
                            if (arg1 * stor25 / 100) + (arg1 * stor30 / 100) and stor11 / totalSupply > -1 / (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                                revert with 0, 17
                            if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                                revert with 0, 18
                            if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) / (arg1 * stor25 / 100) + (arg1 * stor30 / 100) != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _13858 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13858] = 30
                            mem[_13858 + 32] = 'SafeMath: subtraction overflow'
                            _15582 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15582] = 30
                            mem[_15582 + 32] = 'SafeMath: subtraction overflow'
                            if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) <= 0:
                                if 0 < (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply):
                                    revert with 0, 17
                                else:
                                    return 0
                            _16162 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _16162 + 68] = mem[idx + _15582 + 32]
                                idx = idx + 32
                                continue 
                            mem[_16162 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _16162 + -mem[64] + 100
                        if arg1 and stor11 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor11 / totalSupply / arg1 != stor11 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                            _13857 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13857] = 30
                            mem[_13857 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor11 / totalSupply:
                                _14082 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _14082 + 68] = mem[idx + _13857 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14082 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14082 + -mem[64] + 100
                            if arg1 * stor11 / totalSupply < 0:
                                revert with 0, 17
                            _15580 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15580] = 30
                            mem[_15580 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor11 / totalSupply:
                                if arg1 * stor11 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor11 / totalSupply)
                            _16161 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _16161 + 68] = mem[idx + _15580 + 32]
                                idx = idx + 32
                                continue 
                            mem[_16161 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _16161 + -mem[64] + 100
                        if (arg1 * stor25 / 100) + (arg1 * stor30 / 100) and stor11 / totalSupply > -1 / (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                            revert with 0, 17
                        if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                            revert with 0, 18
                        if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) / (arg1 * stor25 / 100) + (arg1 * stor30 / 100) != stor11 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _15047 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_15047] = 30
                        mem[_15047 + 32] = 'SafeMath: subtraction overflow'
                        if 0 > arg1 * stor11 / totalSupply:
                            _15579 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _15579 + 68] = mem[idx + _15047 + 32]
                                idx = idx + 32
                                continue 
                            mem[_15579 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _15579 + -mem[64] + 100
                        if arg1 * stor11 / totalSupply < 0:
                            revert with 0, 17
                        _17800 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_17800] = 30
                        mem[_17800 + 32] = 'SafeMath: subtraction overflow'
                        if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) <= arg1 * stor11 / totalSupply:
                            if arg1 * stor11 / totalSupply < (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply):
                                revert with 0, 17
                            return (arg1 * stor11 / totalSupply)
                        _18409 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _18409 + 68] = mem[idx + _17800 + 32]
                            idx = idx + 32
                            continue 
                        mem[_18409 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _18409 + -mem[64] + 100
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if t >= stor11 / totalSupply:
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg1:
                        if (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                            if (arg1 * stor25 / 100) + (arg1 * stor30 / 100) and t / s > -1 / (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                                revert with 0, 17
                            if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                                revert with 0, 18
                            if (arg1 * stor25 / 100 * t / s) + (arg1 * stor30 / 100 * t / s) / (arg1 * stor25 / 100) + (arg1 * stor30 / 100) != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if (arg1 * stor25 / 100 * t / s) + (arg1 * stor30 / 100 * t / s) > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < (arg1 * stor25 / 100 * t / s) + (arg1 * stor30 / 100 * t / s):
                                revert with 0, 17
                            else:
                                return 0
                        else:
                            return 0
                    if arg1 and t / s > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                    else:
                        if (arg1 * stor25 / 100) + (arg1 * stor30 / 100) and t / s > -1 / (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                            revert with 0, 17
                        if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                            revert with 0, 18
                        if (arg1 * stor25 / 100 * t / s) + (arg1 * stor30 / 100 * t / s) / (arg1 * stor25 / 100) + (arg1 * stor30 / 100) != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if (arg1 * stor25 / 100 * t / s) + (arg1 * stor30 / 100 * t / s) > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < (arg1 * stor25 / 100 * t / s) + (arg1 * stor30 / 100 * t / s):
                            revert with 0, 17
                    return (arg1 * t / s)
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                        if (arg1 * stor25 / 100) + (arg1 * stor30 / 100) and stor11 / totalSupply > -1 / (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                            revert with 0, 17
                        if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                            revert with 0, 18
                        if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) / (arg1 * stor25 / 100) + (arg1 * stor30 / 100) != stor11 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply):
                            revert with 0, 17
                        else:
                            return 0
                    else:
                        return 0
                if arg1 and stor11 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor11 / totalSupply / arg1 != stor11 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                    if 0 > arg1 * stor11 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor11 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor11 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor11 / totalSupply < 0:
                        revert with 0, 17
                else:
                    if (arg1 * stor25 / 100) + (arg1 * stor30 / 100) and stor11 / totalSupply > -1 / (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                        revert with 0, 17
                    if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                        revert with 0, 18
                    if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) / (arg1 * stor25 / 100) + (arg1 * stor30 / 100) != stor11 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if 0 > arg1 * stor11 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor11 / totalSupply < 0:
                        revert with 0, 17
                    if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) > arg1 * stor11 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor11 / totalSupply < (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply):
                        revert with 0, 17
    else:
        if arg1 and stor19 > -1 / arg1:
            revert with 0, 17
        if not arg1:
            revert with 0, 18
        if arg1 * stor19 / arg1 != stor19:
            revert with 0x8c379a000000000000000000000000000000000000000000000000000000000, 'SafeMath: multiplication overflow'
        mem[96] = 26
        mem[128] = 'SafeMath: division by zero'
        if not arg1:
            mem[160] = 26
            mem[192] = 'SafeMath: division by zero'
            if not arg1:
                mem[224] = 26
                mem[256] = 'SafeMath: division by zero'
                if not arg1:
                    mem[288] = 26
                    mem[320] = 'SafeMath: division by zero'
                    mem[352] = 30
                    mem[384] = 'SafeMath: subtraction overflow'
                    if arg1 * stor19 / 100 > arg1:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 < arg1 * stor19 / 100:
                        revert with 0, 17
                    mem[416] = 30
                    mem[448] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 - (arg1 * stor19 / 100):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 - (arg1 * stor19 / 100) < 0:
                        revert with 0, 17
                    mem[64] = 544
                    mem[480] = 30
                    mem[512] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 - (arg1 * stor19 / 100):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 - (arg1 * stor19 / 100) < 0:
                        revert with 0, 17
                    idx = 0
                    s = totalSupply
                    t = stor11
                    while idx < stor9.length:
                        mem[0] = stor9[idx]
                        mem[32] = 1
                        if stor1[stor9[idx]] > t:
                            _11652 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11652] = 26
                            mem[_11652 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                _11826 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _11826 + 68] = mem[idx + _11652 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11826 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _11826 + -mem[64] + 100
                            if not arg1:
                                if not arg1 * stor19 / 100:
                                    return 0
                                if arg1 * stor19 / 100 and stor11 / totalSupply > -1 / arg1 * stor19 / 100:
                                    revert with 0, 17
                                if not arg1 * stor19 / 100:
                                    revert with 0, 18
                                if arg1 * stor19 / 100 * stor11 / totalSupply / arg1 * stor19 / 100 != stor11 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _13608 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13608] = 30
                                mem[_13608 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * stor19 / 100 * stor11 / totalSupply > 0:
                                    _13850 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _13850 + 68] = mem[idx + _13608 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_13850 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _13850 + -mem[64] + 100
                                if 0 < arg1 * stor19 / 100 * stor11 / totalSupply:
                                    revert with 0, 17
                                _15036 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15036] = 30
                                mem[_15036 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * arg1 * stor19 / 100 * stor11 / totalSupply:
                                    if -1 * arg1 * stor19 / 100 * stor11 / totalSupply < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _15569 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _15569 + 68] = mem[idx + _15036 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15569 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _15569 + -mem[64] + 100
                            if arg1 and stor11 / totalSupply > -1 / arg1:
                                revert with 0, 17
                            if not arg1:
                                revert with 0, 18
                            if arg1 * stor11 / totalSupply / arg1 != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * stor19 / 100:
                                _13607 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13607] = 30
                                mem[_13607 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor11 / totalSupply:
                                    _13849 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _13849 + 68] = mem[idx + _13607 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_13849 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _13849 + -mem[64] + 100
                                if arg1 * stor11 / totalSupply < 0:
                                    revert with 0, 17
                                _15034 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15034] = 30
                                mem[_15034 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= arg1 * stor11 / totalSupply:
                                    if arg1 * stor11 / totalSupply < 0:
                                        revert with 0, 17
                                    return (arg1 * stor11 / totalSupply)
                                _15568 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _15568 + 68] = mem[idx + _15034 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15568 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _15568 + -mem[64] + 100
                            if arg1 * stor19 / 100 and stor11 / totalSupply > -1 / arg1 * stor19 / 100:
                                revert with 0, 17
                            if not arg1 * stor19 / 100:
                                revert with 0, 18
                            if arg1 * stor19 / 100 * stor11 / totalSupply / arg1 * stor19 / 100 != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _14516 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14516] = 30
                            mem[_14516 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor19 / 100 * stor11 / totalSupply > arg1 * stor11 / totalSupply:
                                _15033 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _15033 + 68] = mem[idx + _14516 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15033 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _15033 + -mem[64] + 100
                            if arg1 * stor11 / totalSupply < arg1 * stor19 / 100 * stor11 / totalSupply:
                                revert with 0, 17
                            _16998 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_16998] = 30
                            mem[_16998 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply):
                                if (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor11 / totalSupply)
                            _17787 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _17787 + 68] = mem[idx + _16998 + 32]
                                idx = idx + 32
                                continue 
                            mem[_17787 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _17787 + -mem[64] + 100
                        if idx >= stor9.length:
                            revert with 0, 50
                        mem[0] = stor9[idx]
                        mem[32] = 2
                        if stor2[stor9[idx]] <= s:
                            if idx >= stor9.length:
                                revert with 0, 50
                            mem[0] = stor9[idx]
                            mem[32] = 1
                            _11827 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11827] = 30
                            mem[_11827 + 32] = 'SafeMath: subtraction overflow'
                            if stor1[stor9[idx]] > t:
                                _11987 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11987 + 68] = mem[idx + _11827 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11987 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11987 + -mem[64] + 100
                            if t < stor1[stor9[idx]]:
                                revert with 0, 17
                            if idx >= stor9.length:
                                revert with 0, 50
                            mem[0] = stor9[idx]
                            mem[32] = 2
                            _12692 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12692] = 30
                            mem[_12692 + 32] = 'SafeMath: subtraction overflow'
                            if stor2[stor9[idx]] <= s:
                                if s < stor2[stor9[idx]]:
                                    revert with 0, 17
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s - stor2[stor9[idx]]
                                t = t - stor1[stor9[idx]]
                                continue 
                            _12788 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12788 + 68] = mem[idx + _12692 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12788 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12788 + -mem[64] + 100
                        _11828 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11828] = 26
                        mem[_11828 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _11988 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _11988 + 68] = mem[idx + _11828 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11988 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _11988 + -mem[64] + 100
                        if not arg1:
                            if not arg1 * stor19 / 100:
                                return 0
                            if arg1 * stor19 / 100 and stor11 / totalSupply > -1 / arg1 * stor19 / 100:
                                revert with 0, 17
                            if not arg1 * stor19 / 100:
                                revert with 0, 18
                            if arg1 * stor19 / 100 * stor11 / totalSupply / arg1 * stor19 / 100 != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _13854 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13854] = 30
                            mem[_13854 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor19 / 100 * stor11 / totalSupply > 0:
                                _14077 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _14077 + 68] = mem[idx + _13854 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14077 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14077 + -mem[64] + 100
                            if 0 < arg1 * stor19 / 100 * stor11 / totalSupply:
                                revert with 0, 17
                            _15573 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15573] = 30
                            mem[_15573 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * stor19 / 100 * stor11 / totalSupply:
                                if -1 * arg1 * stor19 / 100 * stor11 / totalSupply < 0:
                                    revert with 0, 17
                                else:
                                    return 0
                            _16158 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _16158 + 68] = mem[idx + _15573 + 32]
                                idx = idx + 32
                                continue 
                            mem[_16158 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _16158 + -mem[64] + 100
                        if arg1 and stor11 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor11 / totalSupply / arg1 != stor11 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor19 / 100:
                            _13853 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13853] = 30
                            mem[_13853 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor11 / totalSupply:
                                _14076 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _14076 + 68] = mem[idx + _13853 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14076 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14076 + -mem[64] + 100
                            if arg1 * stor11 / totalSupply < 0:
                                revert with 0, 17
                            _15571 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15571] = 30
                            mem[_15571 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor11 / totalSupply:
                                if arg1 * stor11 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor11 / totalSupply)
                            _16157 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _16157 + 68] = mem[idx + _15571 + 32]
                                idx = idx + 32
                                continue 
                            mem[_16157 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _16157 + -mem[64] + 100
                        if arg1 * stor19 / 100 and stor11 / totalSupply > -1 / arg1 * stor19 / 100:
                            revert with 0, 17
                        if not arg1 * stor19 / 100:
                            revert with 0, 18
                        if arg1 * stor19 / 100 * stor11 / totalSupply / arg1 * stor19 / 100 != stor11 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _15038 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_15038] = 30
                        mem[_15038 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor19 / 100 * stor11 / totalSupply > arg1 * stor11 / totalSupply:
                            _15570 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _15570 + 68] = mem[idx + _15038 + 32]
                                idx = idx + 32
                                continue 
                            mem[_15570 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _15570 + -mem[64] + 100
                        if arg1 * stor11 / totalSupply < arg1 * stor19 / 100 * stor11 / totalSupply:
                            revert with 0, 17
                        _17790 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_17790] = 30
                        mem[_17790 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply):
                            if (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply) < 0:
                                revert with 0, 17
                            return (arg1 * stor11 / totalSupply)
                        _18406 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _18406 + 68] = mem[idx + _17790 + 32]
                            idx = idx + 32
                            continue 
                        mem[_18406 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _18406 + -mem[64] + 100
                else:
                    if arg1 and stor35 > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor35 / arg1 != stor35:
                        revert with 0, 'SafeMath: multiplication overflow'
                    mem[288] = 26
                    mem[320] = 'SafeMath: division by zero'
                    mem[352] = 30
                    mem[384] = 'SafeMath: subtraction overflow'
                    if arg1 * stor19 / 100 > arg1:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 < arg1 * stor19 / 100:
                        revert with 0, 17
                    mem[416] = 30
                    mem[448] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 - (arg1 * stor19 / 100):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 - (arg1 * stor19 / 100) < 0:
                        revert with 0, 17
                    mem[64] = 544
                    mem[480] = 30
                    mem[512] = 'SafeMath: subtraction overflow'
                    if arg1 * stor35 / 100 > arg1 - (arg1 * stor19 / 100):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 - (arg1 * stor19 / 100) < arg1 * stor35 / 100:
                        revert with 0, 17
                    idx = 0
                    s = totalSupply
                    t = stor11
                    while idx < stor9.length:
                        mem[0] = stor9[idx]
                        mem[32] = 1
                        if stor1[stor9[idx]] > t:
                            _11651 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11651] = 26
                            mem[_11651 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                _11823 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _11823 + 68] = mem[idx + _11651 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11823 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _11823 + -mem[64] + 100
                            if not arg1:
                                if not arg1 * stor19 / 100:
                                    return 0
                                if arg1 * stor19 / 100 and stor11 / totalSupply > -1 / arg1 * stor19 / 100:
                                    revert with 0, 17
                                if not arg1 * stor19 / 100:
                                    revert with 0, 18
                                if arg1 * stor19 / 100 * stor11 / totalSupply / arg1 * stor19 / 100 != stor11 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _13601 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13601] = 30
                                mem[_13601 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * stor19 / 100 * stor11 / totalSupply > 0:
                                    _13844 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _13844 + 68] = mem[idx + _13601 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_13844 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _13844 + -mem[64] + 100
                                if 0 < arg1 * stor19 / 100 * stor11 / totalSupply:
                                    revert with 0, 17
                                _15024 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15024] = 30
                                mem[_15024 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * arg1 * stor19 / 100 * stor11 / totalSupply:
                                    if -1 * arg1 * stor19 / 100 * stor11 / totalSupply < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _15562 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _15562 + 68] = mem[idx + _15024 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15562 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _15562 + -mem[64] + 100
                            if arg1 and stor11 / totalSupply > -1 / arg1:
                                revert with 0, 17
                            if not arg1:
                                revert with 0, 18
                            if arg1 * stor11 / totalSupply / arg1 != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * stor19 / 100:
                                _13600 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13600] = 30
                                mem[_13600 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor11 / totalSupply:
                                    _13843 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _13843 + 68] = mem[idx + _13600 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_13843 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _13843 + -mem[64] + 100
                                if arg1 * stor11 / totalSupply < 0:
                                    revert with 0, 17
                                _15022 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15022] = 30
                                mem[_15022 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= arg1 * stor11 / totalSupply:
                                    if arg1 * stor11 / totalSupply < 0:
                                        revert with 0, 17
                                    return (arg1 * stor11 / totalSupply)
                                _15561 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _15561 + 68] = mem[idx + _15022 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15561 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _15561 + -mem[64] + 100
                            if arg1 * stor19 / 100 and stor11 / totalSupply > -1 / arg1 * stor19 / 100:
                                revert with 0, 17
                            if not arg1 * stor19 / 100:
                                revert with 0, 18
                            if arg1 * stor19 / 100 * stor11 / totalSupply / arg1 * stor19 / 100 != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _14509 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14509] = 30
                            mem[_14509 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor19 / 100 * stor11 / totalSupply > arg1 * stor11 / totalSupply:
                                _15021 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _15021 + 68] = mem[idx + _14509 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15021 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _15021 + -mem[64] + 100
                            if arg1 * stor11 / totalSupply < arg1 * stor19 / 100 * stor11 / totalSupply:
                                revert with 0, 17
                            _16985 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_16985] = 30
                            mem[_16985 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply):
                                if (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor11 / totalSupply)
                            _17777 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _17777 + 68] = mem[idx + _16985 + 32]
                                idx = idx + 32
                                continue 
                            mem[_17777 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _17777 + -mem[64] + 100
                        if idx >= stor9.length:
                            revert with 0, 50
                        mem[0] = stor9[idx]
                        mem[32] = 2
                        if stor2[stor9[idx]] <= s:
                            if idx >= stor9.length:
                                revert with 0, 50
                            mem[0] = stor9[idx]
                            mem[32] = 1
                            _11824 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11824] = 30
                            mem[_11824 + 32] = 'SafeMath: subtraction overflow'
                            if stor1[stor9[idx]] > t:
                                _11984 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11984 + 68] = mem[idx + _11824 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11984 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11984 + -mem[64] + 100
                            if t < stor1[stor9[idx]]:
                                revert with 0, 17
                            if idx >= stor9.length:
                                revert with 0, 50
                            mem[0] = stor9[idx]
                            mem[32] = 2
                            _12689 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12689] = 30
                            mem[_12689 + 32] = 'SafeMath: subtraction overflow'
                            if stor2[stor9[idx]] <= s:
                                if s < stor2[stor9[idx]]:
                                    revert with 0, 17
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s - stor2[stor9[idx]]
                                t = t - stor1[stor9[idx]]
                                continue 
                            _12785 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12785 + 68] = mem[idx + _12689 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12785 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12785 + -mem[64] + 100
                        _11825 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11825] = 26
                        mem[_11825 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _11985 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _11985 + 68] = mem[idx + _11825 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11985 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _11985 + -mem[64] + 100
                        if not arg1:
                            if not arg1 * stor19 / 100:
                                return 0
                            if arg1 * stor19 / 100 and stor11 / totalSupply > -1 / arg1 * stor19 / 100:
                                revert with 0, 17
                            if not arg1 * stor19 / 100:
                                revert with 0, 18
                            if arg1 * stor19 / 100 * stor11 / totalSupply / arg1 * stor19 / 100 != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _13848 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13848] = 30
                            mem[_13848 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor19 / 100 * stor11 / totalSupply > 0:
                                _14074 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _14074 + 68] = mem[idx + _13848 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14074 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14074 + -mem[64] + 100
                            if 0 < arg1 * stor19 / 100 * stor11 / totalSupply:
                                revert with 0, 17
                            _15566 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15566] = 30
                            mem[_15566 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= -1 * arg1 * stor19 / 100 * stor11 / totalSupply:
                                if -1 * arg1 * stor19 / 100 * stor11 / totalSupply < 0:
                                    revert with 0, 17
                                else:
                                    return 0
                            _16154 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _16154 + 68] = mem[idx + _15566 + 32]
                                idx = idx + 32
                                continue 
                            mem[_16154 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _16154 + -mem[64] + 100
                        if arg1 and stor11 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor11 / totalSupply / arg1 != stor11 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor19 / 100:
                            _13847 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_13847] = 30
                            mem[_13847 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor11 / totalSupply:
                                _14073 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _14073 + 68] = mem[idx + _13847 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_14073 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _14073 + -mem[64] + 100
                            if arg1 * stor11 / totalSupply < 0:
                                revert with 0, 17
                            _15564 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15564] = 30
                            mem[_15564 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= arg1 * stor11 / totalSupply:
                                if arg1 * stor11 / totalSupply < 0:
                                    revert with 0, 17
                                return (arg1 * stor11 / totalSupply)
                            _16153 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _16153 + 68] = mem[idx + _15564 + 32]
                                idx = idx + 32
                                continue 
                            mem[_16153 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _16153 + -mem[64] + 100
                        if arg1 * stor19 / 100 and stor11 / totalSupply > -1 / arg1 * stor19 / 100:
                            revert with 0, 17
                        if not arg1 * stor19 / 100:
                            revert with 0, 18
                        if arg1 * stor19 / 100 * stor11 / totalSupply / arg1 * stor19 / 100 != stor11 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _15026 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_15026] = 30
                        mem[_15026 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor19 / 100 * stor11 / totalSupply > arg1 * stor11 / totalSupply:
                            _15563 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _15563 + 68] = mem[idx + _15026 + 32]
                                idx = idx + 32
                                continue 
                            mem[_15563 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _15563 + -mem[64] + 100
                        if arg1 * stor11 / totalSupply < arg1 * stor19 / 100 * stor11 / totalSupply:
                            revert with 0, 17
                        _17780 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_17780] = 30
                        mem[_17780 + 32] = 'SafeMath: subtraction overflow'
                        if 0 <= (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply):
                            if (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply) < 0:
                                revert with 0, 17
                            return (arg1 * stor11 / totalSupply)
                        _18403 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _18403 + 68] = mem[idx + _17780 + 32]
                            idx = idx + 32
                            continue 
                        mem[_18403 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _18403 + -mem[64] + 100
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if t >= stor11 / totalSupply:
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg1:
                        if arg1 * stor19 / 100:
                            if arg1 * stor19 / 100 and t / s > -1 / arg1 * stor19 / 100:
                                revert with 0, 17
                            if not arg1 * stor19 / 100:
                                revert with 0, 18
                            if arg1 * stor19 / 100 * t / s / arg1 * stor19 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * stor19 / 100 * t / s > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * stor19 / 100 * t / s:
                                revert with 0, 17
                            if 0 > -1 * arg1 * stor19 / 100 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * stor19 / 100 * t / s < 0:
                                revert with 0, 17
                            else:
                                return 0
                        else:
                            return 0
                    if arg1 and t / s > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor19 / 100:
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                        if 0 > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < 0:
                            revert with 0, 17
                    else:
                        if arg1 * stor19 / 100 and t / s > -1 / arg1 * stor19 / 100:
                            revert with 0, 17
                        if not arg1 * stor19 / 100:
                            revert with 0, 18
                        if arg1 * stor19 / 100 * t / s / arg1 * stor19 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * stor19 / 100 * t / s > arg1 * t / s:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * t / s < arg1 * stor19 / 100 * t / s:
                            revert with 0, 17
                        if 0 > (arg1 * t / s) - (arg1 * stor19 / 100 * t / s):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * t / s) - (arg1 * stor19 / 100 * t / s) < 0:
                            revert with 0, 17
                    return (arg1 * t / s)
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if arg1 * stor19 / 100:
                        if arg1 * stor19 / 100 and stor11 / totalSupply > -1 / arg1 * stor19 / 100:
                            revert with 0, 17
                        if not arg1 * stor19 / 100:
                            revert with 0, 18
                        if arg1 * stor19 / 100 * stor11 / totalSupply / arg1 * stor19 / 100 != stor11 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * stor19 / 100 * stor11 / totalSupply > 0:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if 0 < arg1 * stor19 / 100 * stor11 / totalSupply:
                            revert with 0, 17
                        if 0 > -1 * arg1 * stor19 / 100 * stor11 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if -1 * arg1 * stor19 / 100 * stor11 / totalSupply < 0:
                            revert with 0, 17
                        else:
                            return 0
                    else:
                        return 0
                if arg1 and stor11 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor11 / totalSupply / arg1 != stor11 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor19 / 100:
                    if 0 > arg1 * stor11 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor11 / totalSupply < 0:
                        revert with 0, 17
                    if 0 > arg1 * stor11 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor11 / totalSupply < 0:
                        revert with 0, 17
                else:
                    if arg1 * stor19 / 100 and stor11 / totalSupply > -1 / arg1 * stor19 / 100:
                        revert with 0, 17
                    if not arg1 * stor19 / 100:
                        revert with 0, 18
                    if arg1 * stor19 / 100 * stor11 / totalSupply / arg1 * stor19 / 100 != stor11 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if arg1 * stor19 / 100 * stor11 / totalSupply > arg1 * stor11 / totalSupply:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 * stor11 / totalSupply < arg1 * stor19 / 100 * stor11 / totalSupply:
                        revert with 0, 17
                    if 0 > (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply) < 0:
                        revert with 0, 17
            else:
                if arg1 and stor30 > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor30 / arg1 != stor30:
                    revert with 0, 'SafeMath: multiplication overflow'
                mem[224] = 26
                mem[256] = 'SafeMath: division by zero'
                if not arg1:
                    mem[288] = 26
                    mem[320] = 'SafeMath: division by zero'
                    if 0 > !(arg1 * stor30 / 100):
                        revert with 0, 17
                    if arg1 * stor30 / 100 < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[352] = 30
                    mem[384] = 'SafeMath: subtraction overflow'
                    if arg1 * stor19 / 100 > arg1:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 < arg1 * stor19 / 100:
                        revert with 0, 17
                    mem[416] = 30
                    mem[448] = 'SafeMath: subtraction overflow'
                    if arg1 * stor30 / 100 > arg1 - (arg1 * stor19 / 100):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 - (arg1 * stor19 / 100) < arg1 * stor30 / 100:
                        revert with 0, 17
                    mem[64] = 544
                    mem[480] = 30
                    mem[512] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 - (arg1 * stor19 / 100) - (arg1 * stor30 / 100):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 - (arg1 * stor19 / 100) - (arg1 * stor30 / 100) < 0:
                        revert with 0, 17
                    if 0 > !(arg1 * stor30 / 100):
                        revert with 0, 17
                    if arg1 * stor30 / 100 < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    idx = 0
                    s = totalSupply
                    t = stor11
                    while idx < stor9.length:
                        mem[0] = stor9[idx]
                        mem[32] = 1
                        if stor1[stor9[idx]] > t:
                            _11650 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11650] = 26
                            mem[_11650 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                _11820 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _11820 + 68] = mem[idx + _11650 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11820 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _11820 + -mem[64] + 100
                            if not arg1:
                                if not arg1 * stor19 / 100:
                                    if not arg1 * stor30 / 100:
                                        return 0
                                    if arg1 * stor30 / 100 and stor11 / totalSupply > -1 / arg1 * stor30 / 100:
                                        revert with 0, 17
                                    if not arg1 * stor30 / 100:
                                        revert with 0, 18
                                    if arg1 * stor30 / 100 * stor11 / totalSupply / arg1 * stor30 / 100 != stor11 / totalSupply:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _13593 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13593] = 30
                                    mem[_13593 + 32] = 'SafeMath: subtraction overflow'
                                    _15011 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_15011] = 30
                                    mem[_15011 + 32] = 'SafeMath: subtraction overflow'
                                    if arg1 * stor30 / 100 * stor11 / totalSupply <= 0:
                                        if 0 < arg1 * stor30 / 100 * stor11 / totalSupply:
                                            revert with 0, 17
                                        else:
                                            return 0
                                    _15552 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _15552 + 68] = mem[idx + _15011 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_15552 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _15552 + -mem[64] + 100
                                if arg1 * stor19 / 100 and stor11 / totalSupply > -1 / arg1 * stor19 / 100:
                                    revert with 0, 17
                                if not arg1 * stor19 / 100:
                                    revert with 0, 18
                                if arg1 * stor19 / 100 * stor11 / totalSupply / arg1 * stor19 / 100 != stor11 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not arg1 * stor30 / 100:
                                    _13592 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13592] = 30
                                    mem[_13592 + 32] = 'SafeMath: subtraction overflow'
                                    if arg1 * stor19 / 100 * stor11 / totalSupply > 0:
                                        _13837 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _13837 + 68] = mem[idx + _13592 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13837 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _13837 + -mem[64] + 100
                                    if 0 < arg1 * stor19 / 100 * stor11 / totalSupply:
                                        revert with 0, 17
                                    _15009 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_15009] = 30
                                    mem[_15009 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= -1 * arg1 * stor19 / 100 * stor11 / totalSupply:
                                        if -1 * arg1 * stor19 / 100 * stor11 / totalSupply < 0:
                                            revert with 0, 17
                                        else:
                                            return 0
                                    _15551 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _15551 + 68] = mem[idx + _15009 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_15551 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _15551 + -mem[64] + 100
                                if arg1 * stor30 / 100 and stor11 / totalSupply > -1 / arg1 * stor30 / 100:
                                    revert with 0, 17
                                if not arg1 * stor30 / 100:
                                    revert with 0, 18
                                if arg1 * stor30 / 100 * stor11 / totalSupply / arg1 * stor30 / 100 != stor11 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _14500 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14500] = 30
                                mem[_14500 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * stor19 / 100 * stor11 / totalSupply > 0:
                                    _15008 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _15008 + 68] = mem[idx + _14500 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_15008 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _15008 + -mem[64] + 100
                                if 0 < arg1 * stor19 / 100 * stor11 / totalSupply:
                                    revert with 0, 17
                                _16971 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16971] = 30
                                mem[_16971 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * stor30 / 100 * stor11 / totalSupply <= -1 * arg1 * stor19 / 100 * stor11 / totalSupply:
                                    if -1 * arg1 * stor19 / 100 * stor11 / totalSupply < arg1 * stor30 / 100 * stor11 / totalSupply:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _17762 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _17762 + 68] = mem[idx + _16971 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_17762 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _17762 + -mem[64] + 100
                            if arg1 and stor11 / totalSupply > -1 / arg1:
                                revert with 0, 17
                            if not arg1:
                                revert with 0, 18
                            if arg1 * stor11 / totalSupply / arg1 != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * stor19 / 100:
                                if not arg1 * stor30 / 100:
                                    _13591 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13591] = 30
                                    mem[_13591 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg1 * stor11 / totalSupply:
                                        _13836 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _13836 + 68] = mem[idx + _13591 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13836 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _13836 + -mem[64] + 100
                                    if arg1 * stor11 / totalSupply < 0:
                                        revert with 0, 17
                                    _15006 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_15006] = 30
                                    mem[_15006 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= arg1 * stor11 / totalSupply:
                                        if arg1 * stor11 / totalSupply < 0:
                                            revert with 0, 17
                                        return (arg1 * stor11 / totalSupply)
                                    _15550 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _15550 + 68] = mem[idx + _15006 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_15550 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _15550 + -mem[64] + 100
                                if arg1 * stor30 / 100 and stor11 / totalSupply > -1 / arg1 * stor30 / 100:
                                    revert with 0, 17
                                if not arg1 * stor30 / 100:
                                    revert with 0, 18
                                if arg1 * stor30 / 100 * stor11 / totalSupply / arg1 * stor30 / 100 != stor11 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _14499 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14499] = 30
                                mem[_14499 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor11 / totalSupply:
                                    _15005 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _15005 + 68] = mem[idx + _14499 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_15005 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _15005 + -mem[64] + 100
                                if arg1 * stor11 / totalSupply < 0:
                                    revert with 0, 17
                                _16969 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16969] = 30
                                mem[_16969 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * stor30 / 100 * stor11 / totalSupply <= arg1 * stor11 / totalSupply:
                                    if arg1 * stor11 / totalSupply < arg1 * stor30 / 100 * stor11 / totalSupply:
                                        revert with 0, 17
                                    return (arg1 * stor11 / totalSupply)
                                _17760 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _17760 + 68] = mem[idx + _16969 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_17760 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _17760 + -mem[64] + 100
                            if arg1 * stor19 / 100 and stor11 / totalSupply > -1 / arg1 * stor19 / 100:
                                revert with 0, 17
                            if not arg1 * stor19 / 100:
                                revert with 0, 18
                            if arg1 * stor19 / 100 * stor11 / totalSupply / arg1 * stor19 / 100 != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * stor30 / 100:
                                _14498 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14498] = 30
                                mem[_14498 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * stor19 / 100 * stor11 / totalSupply > arg1 * stor11 / totalSupply:
                                    _15004 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _15004 + 68] = mem[idx + _14498 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_15004 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _15004 + -mem[64] + 100
                                if arg1 * stor11 / totalSupply < arg1 * stor19 / 100 * stor11 / totalSupply:
                                    revert with 0, 17
                                _16967 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16967] = 30
                                mem[_16967 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply):
                                    if (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply) < 0:
                                        revert with 0, 17
                                    return (arg1 * stor11 / totalSupply)
                                _17759 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _17759 + 68] = mem[idx + _16967 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_17759 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _17759 + -mem[64] + 100
                            if arg1 * stor30 / 100 and stor11 / totalSupply > -1 / arg1 * stor30 / 100:
                                revert with 0, 17
                            if not arg1 * stor30 / 100:
                                revert with 0, 18
                            if arg1 * stor30 / 100 * stor11 / totalSupply / arg1 * stor30 / 100 != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _16146 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_16146] = 30
                            mem[_16146 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor19 / 100 * stor11 / totalSupply > arg1 * stor11 / totalSupply:
                                _16966 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _16966 + 68] = mem[idx + _16146 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_16966 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _16966 + -mem[64] + 100
                            if arg1 * stor11 / totalSupply < arg1 * stor19 / 100 * stor11 / totalSupply:
                                revert with 0, 17
                            _19258 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_19258] = 30
                            mem[_19258 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor30 / 100 * stor11 / totalSupply <= (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply):
                                if (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply) < arg1 * stor30 / 100 * stor11 / totalSupply:
                                    revert with 0, 17
                                return (arg1 * stor11 / totalSupply)
                            _20010 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _20010 + 68] = mem[idx + _19258 + 32]
                                idx = idx + 32
                                continue 
                            mem[_20010 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _20010 + -mem[64] + 100
                        if idx >= stor9.length:
                            revert with 0, 50
                        mem[0] = stor9[idx]
                        mem[32] = 2
                        if stor2[stor9[idx]] <= s:
                            if idx >= stor9.length:
                                revert with 0, 50
                            mem[0] = stor9[idx]
                            mem[32] = 1
                            _11821 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11821] = 30
                            mem[_11821 + 32] = 'SafeMath: subtraction overflow'
                            if stor1[stor9[idx]] > t:
                                _11981 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11981 + 68] = mem[idx + _11821 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11981 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11981 + -mem[64] + 100
                            if t < stor1[stor9[idx]]:
                                revert with 0, 17
                            if idx >= stor9.length:
                                revert with 0, 50
                            mem[0] = stor9[idx]
                            mem[32] = 2
                            _12686 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12686] = 30
                            mem[_12686 + 32] = 'SafeMath: subtraction overflow'
                            if stor2[stor9[idx]] <= s:
                                if s < stor2[stor9[idx]]:
                                    revert with 0, 17
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s - stor2[stor9[idx]]
                                t = t - stor1[stor9[idx]]
                                continue 
                            _12782 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12782 + 68] = mem[idx + _12686 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12782 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12782 + -mem[64] + 100
                        _11822 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11822] = 26
                        mem[_11822 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _11982 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _11982 + 68] = mem[idx + _11822 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11982 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _11982 + -mem[64] + 100
                        if not arg1:
                            if not arg1 * stor19 / 100:
                                if not arg1 * stor30 / 100:
                                    return 0
                                if arg1 * stor30 / 100 and stor11 / totalSupply > -1 / arg1 * stor30 / 100:
                                    revert with 0, 17
                                if not arg1 * stor30 / 100:
                                    revert with 0, 18
                                if arg1 * stor30 / 100 * stor11 / totalSupply / arg1 * stor30 / 100 != stor11 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _13842 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13842] = 30
                                mem[_13842 + 32] = 'SafeMath: subtraction overflow'
                                _15560 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15560] = 30
                                mem[_15560 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * stor30 / 100 * stor11 / totalSupply <= 0:
                                    if 0 < arg1 * stor30 / 100 * stor11 / totalSupply:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _16150 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _16150 + 68] = mem[idx + _15560 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_16150 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _16150 + -mem[64] + 100
                            if arg1 * stor19 / 100 and stor11 / totalSupply > -1 / arg1 * stor19 / 100:
                                revert with 0, 17
                            if not arg1 * stor19 / 100:
                                revert with 0, 18
                            if arg1 * stor19 / 100 * stor11 / totalSupply / arg1 * stor19 / 100 != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * stor30 / 100:
                                _13841 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13841] = 30
                                mem[_13841 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * stor19 / 100 * stor11 / totalSupply > 0:
                                    _14071 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _14071 + 68] = mem[idx + _13841 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14071 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14071 + -mem[64] + 100
                                if 0 < arg1 * stor19 / 100 * stor11 / totalSupply:
                                    revert with 0, 17
                                _15558 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15558] = 30
                                mem[_15558 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * arg1 * stor19 / 100 * stor11 / totalSupply:
                                    if -1 * arg1 * stor19 / 100 * stor11 / totalSupply < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _16149 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _16149 + 68] = mem[idx + _15558 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_16149 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _16149 + -mem[64] + 100
                            if arg1 * stor30 / 100 and stor11 / totalSupply > -1 / arg1 * stor30 / 100:
                                revert with 0, 17
                            if not arg1 * stor30 / 100:
                                revert with 0, 18
                            if arg1 * stor30 / 100 * stor11 / totalSupply / arg1 * stor30 / 100 != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _15014 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15014] = 30
                            mem[_15014 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor19 / 100 * stor11 / totalSupply > 0:
                                _15557 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _15557 + 68] = mem[idx + _15014 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15557 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _15557 + -mem[64] + 100
                            if 0 < arg1 * stor19 / 100 * stor11 / totalSupply:
                                revert with 0, 17
                            _17770 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_17770] = 30
                            mem[_17770 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor30 / 100 * stor11 / totalSupply <= -1 * arg1 * stor19 / 100 * stor11 / totalSupply:
                                if -1 * arg1 * stor19 / 100 * stor11 / totalSupply < arg1 * stor30 / 100 * stor11 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _18400 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _18400 + 68] = mem[idx + _17770 + 32]
                                idx = idx + 32
                                continue 
                            mem[_18400 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _18400 + -mem[64] + 100
                        if arg1 and stor11 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor11 / totalSupply / arg1 != stor11 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor19 / 100:
                            if not arg1 * stor30 / 100:
                                _13840 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13840] = 30
                                mem[_13840 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor11 / totalSupply:
                                    _14070 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _14070 + 68] = mem[idx + _13840 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14070 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14070 + -mem[64] + 100
                                if arg1 * stor11 / totalSupply < 0:
                                    revert with 0, 17
                                _15555 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15555] = 30
                                mem[_15555 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= arg1 * stor11 / totalSupply:
                                    if arg1 * stor11 / totalSupply < 0:
                                        revert with 0, 17
                                    return (arg1 * stor11 / totalSupply)
                                _16148 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _16148 + 68] = mem[idx + _15555 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_16148 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _16148 + -mem[64] + 100
                            if arg1 * stor30 / 100 and stor11 / totalSupply > -1 / arg1 * stor30 / 100:
                                revert with 0, 17
                            if not arg1 * stor30 / 100:
                                revert with 0, 18
                            if arg1 * stor30 / 100 * stor11 / totalSupply / arg1 * stor30 / 100 != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _15013 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15013] = 30
                            mem[_15013 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor11 / totalSupply:
                                _15554 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _15554 + 68] = mem[idx + _15013 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15554 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _15554 + -mem[64] + 100
                            if arg1 * stor11 / totalSupply < 0:
                                revert with 0, 17
                            _17768 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_17768] = 30
                            mem[_17768 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor30 / 100 * stor11 / totalSupply <= arg1 * stor11 / totalSupply:
                                if arg1 * stor11 / totalSupply < arg1 * stor30 / 100 * stor11 / totalSupply:
                                    revert with 0, 17
                                return (arg1 * stor11 / totalSupply)
                            _18398 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _18398 + 68] = mem[idx + _17768 + 32]
                                idx = idx + 32
                                continue 
                            mem[_18398 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _18398 + -mem[64] + 100
                        if arg1 * stor19 / 100 and stor11 / totalSupply > -1 / arg1 * stor19 / 100:
                            revert with 0, 17
                        if not arg1 * stor19 / 100:
                            revert with 0, 18
                        if arg1 * stor19 / 100 * stor11 / totalSupply / arg1 * stor19 / 100 != stor11 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor30 / 100:
                            _15012 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_15012] = 30
                            mem[_15012 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor19 / 100 * stor11 / totalSupply > arg1 * stor11 / totalSupply:
                                _15553 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _15553 + 68] = mem[idx + _15012 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15553 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _15553 + -mem[64] + 100
                            if arg1 * stor11 / totalSupply < arg1 * stor19 / 100 * stor11 / totalSupply:
                                revert with 0, 17
                            _17766 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_17766] = 30
                            mem[_17766 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply):
                                if (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor11 / totalSupply)
                            _18397 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _18397 + 68] = mem[idx + _17766 + 32]
                                idx = idx + 32
                                continue 
                            mem[_18397 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _18397 + -mem[64] + 100
                        if arg1 * stor30 / 100 and stor11 / totalSupply > -1 / arg1 * stor30 / 100:
                            revert with 0, 17
                        if not arg1 * stor30 / 100:
                            revert with 0, 18
                        if arg1 * stor30 / 100 * stor11 / totalSupply / arg1 * stor30 / 100 != stor11 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _16974 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_16974] = 30
                        mem[_16974 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor19 / 100 * stor11 / totalSupply > arg1 * stor11 / totalSupply:
                            _17765 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _17765 + 68] = mem[idx + _16974 + 32]
                                idx = idx + 32
                                continue 
                            mem[_17765 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _17765 + -mem[64] + 100
                        if arg1 * stor11 / totalSupply < arg1 * stor19 / 100 * stor11 / totalSupply:
                            revert with 0, 17
                        _20014 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_20014] = 30
                        mem[_20014 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor30 / 100 * stor11 / totalSupply <= (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply):
                            if (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply) < arg1 * stor30 / 100 * stor11 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor11 / totalSupply)
                        _20341 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _20341 + 68] = mem[idx + _20014 + 32]
                            idx = idx + 32
                            continue 
                        mem[_20341 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _20341 + -mem[64] + 100
                else:
                    if arg1 and stor35 > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor35 / arg1 != stor35:
                        revert with 0, 'SafeMath: multiplication overflow'
                    mem[288] = 26
                    mem[320] = 'SafeMath: division by zero'
                    if 0 > !(arg1 * stor30 / 100):
                        revert with 0, 17
                    if arg1 * stor30 / 100 < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[352] = 30
                    mem[384] = 'SafeMath: subtraction overflow'
                    if arg1 * stor19 / 100 > arg1:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 < arg1 * stor19 / 100:
                        revert with 0, 17
                    mem[416] = 30
                    mem[448] = 'SafeMath: subtraction overflow'
                    if arg1 * stor30 / 100 > arg1 - (arg1 * stor19 / 100):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 - (arg1 * stor19 / 100) < arg1 * stor30 / 100:
                        revert with 0, 17
                    mem[64] = 544
                    mem[480] = 30
                    mem[512] = 'SafeMath: subtraction overflow'
                    if arg1 * stor35 / 100 > arg1 - (arg1 * stor19 / 100) - (arg1 * stor30 / 100):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 - (arg1 * stor19 / 100) - (arg1 * stor30 / 100) < arg1 * stor35 / 100:
                        revert with 0, 17
                    if 0 > !(arg1 * stor30 / 100):
                        revert with 0, 17
                    if arg1 * stor30 / 100 < 0:
                        revert with 0, 'SafeMath: addition overflow'
                    idx = 0
                    s = totalSupply
                    t = stor11
                    while idx < stor9.length:
                        mem[0] = stor9[idx]
                        mem[32] = 1
                        if stor1[stor9[idx]] > t:
                            _11649 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11649] = 26
                            mem[_11649 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                _11817 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _11817 + 68] = mem[idx + _11649 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11817 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _11817 + -mem[64] + 100
                            if not arg1:
                                if not arg1 * stor19 / 100:
                                    if not arg1 * stor30 / 100:
                                        return 0
                                    if arg1 * stor30 / 100 and stor11 / totalSupply > -1 / arg1 * stor30 / 100:
                                        revert with 0, 17
                                    if not arg1 * stor30 / 100:
                                        revert with 0, 18
                                    if arg1 * stor30 / 100 * stor11 / totalSupply / arg1 * stor30 / 100 != stor11 / totalSupply:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _13584 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13584] = 30
                                    mem[_13584 + 32] = 'SafeMath: subtraction overflow'
                                    _14994 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14994] = 30
                                    mem[_14994 + 32] = 'SafeMath: subtraction overflow'
                                    if arg1 * stor30 / 100 * stor11 / totalSupply <= 0:
                                        if 0 < arg1 * stor30 / 100 * stor11 / totalSupply:
                                            revert with 0, 17
                                        else:
                                            return 0
                                    _15536 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _15536 + 68] = mem[idx + _14994 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_15536 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _15536 + -mem[64] + 100
                                if arg1 * stor19 / 100 and stor11 / totalSupply > -1 / arg1 * stor19 / 100:
                                    revert with 0, 17
                                if not arg1 * stor19 / 100:
                                    revert with 0, 18
                                if arg1 * stor19 / 100 * stor11 / totalSupply / arg1 * stor19 / 100 != stor11 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not arg1 * stor30 / 100:
                                    _13583 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13583] = 30
                                    mem[_13583 + 32] = 'SafeMath: subtraction overflow'
                                    if arg1 * stor19 / 100 * stor11 / totalSupply > 0:
                                        _13830 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _13830 + 68] = mem[idx + _13583 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13830 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _13830 + -mem[64] + 100
                                    if 0 < arg1 * stor19 / 100 * stor11 / totalSupply:
                                        revert with 0, 17
                                    _14992 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14992] = 30
                                    mem[_14992 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= -1 * arg1 * stor19 / 100 * stor11 / totalSupply:
                                        if -1 * arg1 * stor19 / 100 * stor11 / totalSupply < 0:
                                            revert with 0, 17
                                        else:
                                            return 0
                                    _15535 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _15535 + 68] = mem[idx + _14992 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_15535 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _15535 + -mem[64] + 100
                                if arg1 * stor30 / 100 and stor11 / totalSupply > -1 / arg1 * stor30 / 100:
                                    revert with 0, 17
                                if not arg1 * stor30 / 100:
                                    revert with 0, 18
                                if arg1 * stor30 / 100 * stor11 / totalSupply / arg1 * stor30 / 100 != stor11 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _14487 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14487] = 30
                                mem[_14487 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * stor19 / 100 * stor11 / totalSupply > 0:
                                    _14991 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _14991 + 68] = mem[idx + _14487 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14991 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14991 + -mem[64] + 100
                                if 0 < arg1 * stor19 / 100 * stor11 / totalSupply:
                                    revert with 0, 17
                                _16946 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16946] = 30
                                mem[_16946 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * stor30 / 100 * stor11 / totalSupply <= -1 * arg1 * stor19 / 100 * stor11 / totalSupply:
                                    if -1 * arg1 * stor19 / 100 * stor11 / totalSupply < arg1 * stor30 / 100 * stor11 / totalSupply:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _17740 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _17740 + 68] = mem[idx + _16946 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_17740 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _17740 + -mem[64] + 100
                            if arg1 and stor11 / totalSupply > -1 / arg1:
                                revert with 0, 17
                            if not arg1:
                                revert with 0, 18
                            if arg1 * stor11 / totalSupply / arg1 != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * stor19 / 100:
                                if not arg1 * stor30 / 100:
                                    _13582 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13582] = 30
                                    mem[_13582 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg1 * stor11 / totalSupply:
                                        _13829 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _13829 + 68] = mem[idx + _13582 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13829 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _13829 + -mem[64] + 100
                                    if arg1 * stor11 / totalSupply < 0:
                                        revert with 0, 17
                                    _14989 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14989] = 30
                                    mem[_14989 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= arg1 * stor11 / totalSupply:
                                        if arg1 * stor11 / totalSupply < 0:
                                            revert with 0, 17
                                        return (arg1 * stor11 / totalSupply)
                                    _15534 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _15534 + 68] = mem[idx + _14989 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_15534 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _15534 + -mem[64] + 100
                                if arg1 * stor30 / 100 and stor11 / totalSupply > -1 / arg1 * stor30 / 100:
                                    revert with 0, 17
                                if not arg1 * stor30 / 100:
                                    revert with 0, 18
                                if arg1 * stor30 / 100 * stor11 / totalSupply / arg1 * stor30 / 100 != stor11 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _14486 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14486] = 30
                                mem[_14486 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor11 / totalSupply:
                                    _14988 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _14988 + 68] = mem[idx + _14486 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14988 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14988 + -mem[64] + 100
                                if arg1 * stor11 / totalSupply < 0:
                                    revert with 0, 17
                                _16944 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16944] = 30
                                mem[_16944 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * stor30 / 100 * stor11 / totalSupply <= arg1 * stor11 / totalSupply:
                                    if arg1 * stor11 / totalSupply < arg1 * stor30 / 100 * stor11 / totalSupply:
                                        revert with 0, 17
                                    return (arg1 * stor11 / totalSupply)
                                _17738 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _17738 + 68] = mem[idx + _16944 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_17738 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _17738 + -mem[64] + 100
                            if arg1 * stor19 / 100 and stor11 / totalSupply > -1 / arg1 * stor19 / 100:
                                revert with 0, 17
                            if not arg1 * stor19 / 100:
                                revert with 0, 18
                            if arg1 * stor19 / 100 * stor11 / totalSupply / arg1 * stor19 / 100 != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * stor30 / 100:
                                _14485 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14485] = 30
                                mem[_14485 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * stor19 / 100 * stor11 / totalSupply > arg1 * stor11 / totalSupply:
                                    _14987 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _14987 + 68] = mem[idx + _14485 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14987 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14987 + -mem[64] + 100
                                if arg1 * stor11 / totalSupply < arg1 * stor19 / 100 * stor11 / totalSupply:
                                    revert with 0, 17
                                _16942 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16942] = 30
                                mem[_16942 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply):
                                    if (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply) < 0:
                                        revert with 0, 17
                                    return (arg1 * stor11 / totalSupply)
                                _17737 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _17737 + 68] = mem[idx + _16942 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_17737 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _17737 + -mem[64] + 100
                            if arg1 * stor30 / 100 and stor11 / totalSupply > -1 / arg1 * stor30 / 100:
                                revert with 0, 17
                            if not arg1 * stor30 / 100:
                                revert with 0, 18
                            if arg1 * stor30 / 100 * stor11 / totalSupply / arg1 * stor30 / 100 != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _16135 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_16135] = 30
                            mem[_16135 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor19 / 100 * stor11 / totalSupply > arg1 * stor11 / totalSupply:
                                _16941 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _16941 + 68] = mem[idx + _16135 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_16941 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _16941 + -mem[64] + 100
                            if arg1 * stor11 / totalSupply < arg1 * stor19 / 100 * stor11 / totalSupply:
                                revert with 0, 17
                            _19237 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_19237] = 30
                            mem[_19237 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor30 / 100 * stor11 / totalSupply <= (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply):
                                if (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply) < arg1 * stor30 / 100 * stor11 / totalSupply:
                                    revert with 0, 17
                                return (arg1 * stor11 / totalSupply)
                            _19989 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _19989 + 68] = mem[idx + _19237 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19989 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _19989 + -mem[64] + 100
                        if idx >= stor9.length:
                            revert with 0, 50
                        mem[0] = stor9[idx]
                        mem[32] = 2
                        if stor2[stor9[idx]] <= s:
                            if idx >= stor9.length:
                                revert with 0, 50
                            mem[0] = stor9[idx]
                            mem[32] = 1
                            _11818 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11818] = 30
                            mem[_11818 + 32] = 'SafeMath: subtraction overflow'
                            if stor1[stor9[idx]] > t:
                                _11978 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11978 + 68] = mem[idx + _11818 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11978 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11978 + -mem[64] + 100
                            if t < stor1[stor9[idx]]:
                                revert with 0, 17
                            if idx >= stor9.length:
                                revert with 0, 50
                            mem[0] = stor9[idx]
                            mem[32] = 2
                            _12683 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12683] = 30
                            mem[_12683 + 32] = 'SafeMath: subtraction overflow'
                            if stor2[stor9[idx]] <= s:
                                if s < stor2[stor9[idx]]:
                                    revert with 0, 17
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s - stor2[stor9[idx]]
                                t = t - stor1[stor9[idx]]
                                continue 
                            _12779 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12779 + 68] = mem[idx + _12683 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12779 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12779 + -mem[64] + 100
                        _11819 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11819] = 26
                        mem[_11819 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _11979 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _11979 + 68] = mem[idx + _11819 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11979 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _11979 + -mem[64] + 100
                        if not arg1:
                            if not arg1 * stor19 / 100:
                                if not arg1 * stor30 / 100:
                                    return 0
                                if arg1 * stor30 / 100 and stor11 / totalSupply > -1 / arg1 * stor30 / 100:
                                    revert with 0, 17
                                if not arg1 * stor30 / 100:
                                    revert with 0, 18
                                if arg1 * stor30 / 100 * stor11 / totalSupply / arg1 * stor30 / 100 != stor11 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _13835 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13835] = 30
                                mem[_13835 + 32] = 'SafeMath: subtraction overflow'
                                _15544 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15544] = 30
                                mem[_15544 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * stor30 / 100 * stor11 / totalSupply <= 0:
                                    if 0 < arg1 * stor30 / 100 * stor11 / totalSupply:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _16139 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _16139 + 68] = mem[idx + _15544 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_16139 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _16139 + -mem[64] + 100
                            if arg1 * stor19 / 100 and stor11 / totalSupply > -1 / arg1 * stor19 / 100:
                                revert with 0, 17
                            if not arg1 * stor19 / 100:
                                revert with 0, 18
                            if arg1 * stor19 / 100 * stor11 / totalSupply / arg1 * stor19 / 100 != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * stor30 / 100:
                                _13834 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13834] = 30
                                mem[_13834 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * stor19 / 100 * stor11 / totalSupply > 0:
                                    _14064 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _14064 + 68] = mem[idx + _13834 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14064 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14064 + -mem[64] + 100
                                if 0 < arg1 * stor19 / 100 * stor11 / totalSupply:
                                    revert with 0, 17
                                _15542 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15542] = 30
                                mem[_15542 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * arg1 * stor19 / 100 * stor11 / totalSupply:
                                    if -1 * arg1 * stor19 / 100 * stor11 / totalSupply < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _16138 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _16138 + 68] = mem[idx + _15542 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_16138 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _16138 + -mem[64] + 100
                            if arg1 * stor30 / 100 and stor11 / totalSupply > -1 / arg1 * stor30 / 100:
                                revert with 0, 17
                            if not arg1 * stor30 / 100:
                                revert with 0, 18
                            if arg1 * stor30 / 100 * stor11 / totalSupply / arg1 * stor30 / 100 != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _14997 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14997] = 30
                            mem[_14997 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor19 / 100 * stor11 / totalSupply > 0:
                                _15541 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _15541 + 68] = mem[idx + _14997 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15541 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _15541 + -mem[64] + 100
                            if 0 < arg1 * stor19 / 100 * stor11 / totalSupply:
                                revert with 0, 17
                            _17748 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_17748] = 30
                            mem[_17748 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor30 / 100 * stor11 / totalSupply <= -1 * arg1 * stor19 / 100 * stor11 / totalSupply:
                                if -1 * arg1 * stor19 / 100 * stor11 / totalSupply < arg1 * stor30 / 100 * stor11 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _18392 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _18392 + 68] = mem[idx + _17748 + 32]
                                idx = idx + 32
                                continue 
                            mem[_18392 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _18392 + -mem[64] + 100
                        if arg1 and stor11 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor11 / totalSupply / arg1 != stor11 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor19 / 100:
                            if not arg1 * stor30 / 100:
                                _13833 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13833] = 30
                                mem[_13833 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor11 / totalSupply:
                                    _14063 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _14063 + 68] = mem[idx + _13833 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14063 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14063 + -mem[64] + 100
                                if arg1 * stor11 / totalSupply < 0:
                                    revert with 0, 17
                                _15539 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15539] = 30
                                mem[_15539 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= arg1 * stor11 / totalSupply:
                                    if arg1 * stor11 / totalSupply < 0:
                                        revert with 0, 17
                                    return (arg1 * stor11 / totalSupply)
                                _16137 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _16137 + 68] = mem[idx + _15539 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_16137 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _16137 + -mem[64] + 100
                            if arg1 * stor30 / 100 and stor11 / totalSupply > -1 / arg1 * stor30 / 100:
                                revert with 0, 17
                            if not arg1 * stor30 / 100:
                                revert with 0, 18
                            if arg1 * stor30 / 100 * stor11 / totalSupply / arg1 * stor30 / 100 != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _14996 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14996] = 30
                            mem[_14996 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor11 / totalSupply:
                                _15538 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _15538 + 68] = mem[idx + _14996 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15538 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _15538 + -mem[64] + 100
                            if arg1 * stor11 / totalSupply < 0:
                                revert with 0, 17
                            _17746 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_17746] = 30
                            mem[_17746 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor30 / 100 * stor11 / totalSupply <= arg1 * stor11 / totalSupply:
                                if arg1 * stor11 / totalSupply < arg1 * stor30 / 100 * stor11 / totalSupply:
                                    revert with 0, 17
                                return (arg1 * stor11 / totalSupply)
                            _18390 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _18390 + 68] = mem[idx + _17746 + 32]
                                idx = idx + 32
                                continue 
                            mem[_18390 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _18390 + -mem[64] + 100
                        if arg1 * stor19 / 100 and stor11 / totalSupply > -1 / arg1 * stor19 / 100:
                            revert with 0, 17
                        if not arg1 * stor19 / 100:
                            revert with 0, 18
                        if arg1 * stor19 / 100 * stor11 / totalSupply / arg1 * stor19 / 100 != stor11 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor30 / 100:
                            _14995 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14995] = 30
                            mem[_14995 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor19 / 100 * stor11 / totalSupply > arg1 * stor11 / totalSupply:
                                _15537 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _15537 + 68] = mem[idx + _14995 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15537 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _15537 + -mem[64] + 100
                            if arg1 * stor11 / totalSupply < arg1 * stor19 / 100 * stor11 / totalSupply:
                                revert with 0, 17
                            _17744 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_17744] = 30
                            mem[_17744 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply):
                                if (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor11 / totalSupply)
                            _18389 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _18389 + 68] = mem[idx + _17744 + 32]
                                idx = idx + 32
                                continue 
                            mem[_18389 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _18389 + -mem[64] + 100
                        if arg1 * stor30 / 100 and stor11 / totalSupply > -1 / arg1 * stor30 / 100:
                            revert with 0, 17
                        if not arg1 * stor30 / 100:
                            revert with 0, 18
                        if arg1 * stor30 / 100 * stor11 / totalSupply / arg1 * stor30 / 100 != stor11 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _16949 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_16949] = 30
                        mem[_16949 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor19 / 100 * stor11 / totalSupply > arg1 * stor11 / totalSupply:
                            _17743 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _17743 + 68] = mem[idx + _16949 + 32]
                                idx = idx + 32
                                continue 
                            mem[_17743 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _17743 + -mem[64] + 100
                        if arg1 * stor11 / totalSupply < arg1 * stor19 / 100 * stor11 / totalSupply:
                            revert with 0, 17
                        _19993 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19993] = 30
                        mem[_19993 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor30 / 100 * stor11 / totalSupply <= (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply):
                            if (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply) < arg1 * stor30 / 100 * stor11 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor11 / totalSupply)
                        _20337 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _20337 + 68] = mem[idx + _19993 + 32]
                            idx = idx + 32
                            continue 
                        mem[_20337 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _20337 + -mem[64] + 100
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if t >= stor11 / totalSupply:
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg1:
                        if not arg1 * stor19 / 100:
                            if arg1 * stor30 / 100:
                                if arg1 * stor30 / 100 and t / s > -1 / arg1 * stor30 / 100:
                                    revert with 0, 17
                                if not arg1 * stor30 / 100:
                                    revert with 0, 18
                                if arg1 * stor30 / 100 * t / s / arg1 * stor30 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * stor30 / 100 * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * stor30 / 100 * t / s:
                                    revert with 0, 17
                        else:
                            if arg1 * stor19 / 100 and t / s > -1 / arg1 * stor19 / 100:
                                revert with 0, 17
                            if not arg1 * stor19 / 100:
                                revert with 0, 18
                            if arg1 * stor19 / 100 * t / s / arg1 * stor19 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * stor30 / 100:
                                if arg1 * stor19 / 100 * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * stor19 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > -1 * arg1 * stor19 / 100 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * stor19 / 100 * t / s < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * stor30 / 100 and t / s > -1 / arg1 * stor30 / 100:
                                    revert with 0, 17
                                if not arg1 * stor30 / 100:
                                    revert with 0, 18
                                if arg1 * stor30 / 100 * t / s / arg1 * stor30 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * stor19 / 100 * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * stor19 / 100 * t / s:
                                    revert with 0, 17
                                if arg1 * stor30 / 100 * t / s > -1 * arg1 * stor19 / 100 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * stor19 / 100 * t / s < arg1 * stor30 / 100 * t / s:
                                    revert with 0, 17
                        return 0
                    if arg1 and t / s > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor19 / 100:
                        if not arg1 * stor30 / 100:
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                        else:
                            if arg1 * stor30 / 100 and t / s > -1 / arg1 * stor30 / 100:
                                revert with 0, 17
                            if not arg1 * stor30 / 100:
                                revert with 0, 18
                            if arg1 * stor30 / 100 * t / s / arg1 * stor30 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if arg1 * stor30 / 100 * t / s > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < arg1 * stor30 / 100 * t / s:
                                revert with 0, 17
                    else:
                        if arg1 * stor19 / 100 and t / s > -1 / arg1 * stor19 / 100:
                            revert with 0, 17
                        if not arg1 * stor19 / 100:
                            revert with 0, 18
                        if arg1 * stor19 / 100 * t / s / arg1 * stor19 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor30 / 100:
                            if arg1 * stor19 / 100 * t / s > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < arg1 * stor19 / 100 * t / s:
                                revert with 0, 17
                            if 0 > (arg1 * t / s) - (arg1 * stor19 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (arg1 * stor19 / 100 * t / s) < 0:
                                revert with 0, 17
                        else:
                            if arg1 * stor30 / 100 and t / s > -1 / arg1 * stor30 / 100:
                                revert with 0, 17
                            if not arg1 * stor30 / 100:
                                revert with 0, 18
                            if arg1 * stor30 / 100 * t / s / arg1 * stor30 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * stor19 / 100 * t / s > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < arg1 * stor19 / 100 * t / s:
                                revert with 0, 17
                            if arg1 * stor30 / 100 * t / s > (arg1 * t / s) - (arg1 * stor19 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (arg1 * stor19 / 100 * t / s) < arg1 * stor30 / 100 * t / s:
                                revert with 0, 17
                    return (arg1 * t / s)
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if not arg1 * stor19 / 100:
                        if arg1 * stor30 / 100:
                            if arg1 * stor30 / 100 and stor11 / totalSupply > -1 / arg1 * stor30 / 100:
                                revert with 0, 17
                            if not arg1 * stor30 / 100:
                                revert with 0, 18
                            if arg1 * stor30 / 100 * stor11 / totalSupply / arg1 * stor30 / 100 != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * stor30 / 100 * stor11 / totalSupply > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * stor30 / 100 * stor11 / totalSupply:
                                revert with 0, 17
                    else:
                        if arg1 * stor19 / 100 and stor11 / totalSupply > -1 / arg1 * stor19 / 100:
                            revert with 0, 17
                        if not arg1 * stor19 / 100:
                            revert with 0, 18
                        if arg1 * stor19 / 100 * stor11 / totalSupply / arg1 * stor19 / 100 != stor11 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor30 / 100:
                            if arg1 * stor19 / 100 * stor11 / totalSupply > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * stor19 / 100 * stor11 / totalSupply:
                                revert with 0, 17
                            if 0 > -1 * arg1 * stor19 / 100 * stor11 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * stor19 / 100 * stor11 / totalSupply < 0:
                                revert with 0, 17
                        else:
                            if arg1 * stor30 / 100 and stor11 / totalSupply > -1 / arg1 * stor30 / 100:
                                revert with 0, 17
                            if not arg1 * stor30 / 100:
                                revert with 0, 18
                            if arg1 * stor30 / 100 * stor11 / totalSupply / arg1 * stor30 / 100 != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * stor19 / 100 * stor11 / totalSupply > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * stor19 / 100 * stor11 / totalSupply:
                                revert with 0, 17
                            if arg1 * stor30 / 100 * stor11 / totalSupply > -1 * arg1 * stor19 / 100 * stor11 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * stor19 / 100 * stor11 / totalSupply < arg1 * stor30 / 100 * stor11 / totalSupply:
                                revert with 0, 17
                    return 0
                if arg1 and stor11 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor11 / totalSupply / arg1 != stor11 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor19 / 100:
                    if not arg1 * stor30 / 100:
                        if 0 > arg1 * stor11 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor11 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > arg1 * stor11 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor11 / totalSupply < 0:
                            revert with 0, 17
                    else:
                        if arg1 * stor30 / 100 and stor11 / totalSupply > -1 / arg1 * stor30 / 100:
                            revert with 0, 17
                        if not arg1 * stor30 / 100:
                            revert with 0, 18
                        if arg1 * stor30 / 100 * stor11 / totalSupply / arg1 * stor30 / 100 != stor11 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 > arg1 * stor11 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor11 / totalSupply < 0:
                            revert with 0, 17
                        if arg1 * stor30 / 100 * stor11 / totalSupply > arg1 * stor11 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor11 / totalSupply < arg1 * stor30 / 100 * stor11 / totalSupply:
                            revert with 0, 17
                else:
                    if arg1 * stor19 / 100 and stor11 / totalSupply > -1 / arg1 * stor19 / 100:
                        revert with 0, 17
                    if not arg1 * stor19 / 100:
                        revert with 0, 18
                    if arg1 * stor19 / 100 * stor11 / totalSupply / arg1 * stor19 / 100 != stor11 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor30 / 100:
                        if arg1 * stor19 / 100 * stor11 / totalSupply > arg1 * stor11 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor11 / totalSupply < arg1 * stor19 / 100 * stor11 / totalSupply:
                            revert with 0, 17
                        if 0 > (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply) < 0:
                            revert with 0, 17
                    else:
                        if arg1 * stor30 / 100 and stor11 / totalSupply > -1 / arg1 * stor30 / 100:
                            revert with 0, 17
                        if not arg1 * stor30 / 100:
                            revert with 0, 18
                        if arg1 * stor30 / 100 * stor11 / totalSupply / arg1 * stor30 / 100 != stor11 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * stor19 / 100 * stor11 / totalSupply > arg1 * stor11 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor11 / totalSupply < arg1 * stor19 / 100 * stor11 / totalSupply:
                            revert with 0, 17
                        if arg1 * stor30 / 100 * stor11 / totalSupply > (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply) < arg1 * stor30 / 100 * stor11 / totalSupply:
                            revert with 0, 17
        else:
            if arg1 and stor25 > -1 / arg1:
                revert with 0, 17
            if not arg1:
                revert with 0, 18
            if arg1 * stor25 / arg1 != stor25:
                revert with 0, 'SafeMath: multiplication overflow'
            mem[160] = 26
            mem[192] = 'SafeMath: division by zero'
            if not arg1:
                mem[224] = 26
                mem[256] = 'SafeMath: division by zero'
                if not arg1:
                    mem[288] = 26
                    mem[320] = 'SafeMath: division by zero'
                    if arg1 * stor25 / 100 > -1:
                        revert with 0, 17
                    if arg1 * stor25 / 100 < arg1 * stor25 / 100:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[352] = 30
                    mem[384] = 'SafeMath: subtraction overflow'
                    if arg1 * stor19 / 100 > arg1:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 < arg1 * stor19 / 100:
                        revert with 0, 17
                    mem[416] = 30
                    mem[448] = 'SafeMath: subtraction overflow'
                    if arg1 * stor25 / 100 > arg1 - (arg1 * stor19 / 100):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 - (arg1 * stor19 / 100) < arg1 * stor25 / 100:
                        revert with 0, 17
                    mem[64] = 544
                    mem[480] = 30
                    mem[512] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 - (arg1 * stor19 / 100) - (arg1 * stor25 / 100):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 - (arg1 * stor19 / 100) - (arg1 * stor25 / 100) < 0:
                        revert with 0, 17
                    if arg1 * stor25 / 100 > -1:
                        revert with 0, 17
                    if arg1 * stor25 / 100 < arg1 * stor25 / 100:
                        revert with 0, 'SafeMath: addition overflow'
                    idx = 0
                    s = totalSupply
                    t = stor11
                    while idx < stor9.length:
                        mem[0] = stor9[idx]
                        mem[32] = 1
                        if stor1[stor9[idx]] > t:
                            _11648 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11648] = 26
                            mem[_11648 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                _11814 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _11814 + 68] = mem[idx + _11648 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11814 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _11814 + -mem[64] + 100
                            if not arg1:
                                if not arg1 * stor19 / 100:
                                    if not arg1 * stor25 / 100:
                                        return 0
                                    if arg1 * stor25 / 100 and stor11 / totalSupply > -1 / arg1 * stor25 / 100:
                                        revert with 0, 17
                                    if not arg1 * stor25 / 100:
                                        revert with 0, 18
                                    if arg1 * stor25 / 100 * stor11 / totalSupply / arg1 * stor25 / 100 != stor11 / totalSupply:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _13575 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13575] = 30
                                    mem[_13575 + 32] = 'SafeMath: subtraction overflow'
                                    _14977 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14977] = 30
                                    mem[_14977 + 32] = 'SafeMath: subtraction overflow'
                                    if arg1 * stor25 / 100 * stor11 / totalSupply <= 0:
                                        if 0 < arg1 * stor25 / 100 * stor11 / totalSupply:
                                            revert with 0, 17
                                        else:
                                            return 0
                                    _15520 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _15520 + 68] = mem[idx + _14977 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_15520 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _15520 + -mem[64] + 100
                                if arg1 * stor19 / 100 and stor11 / totalSupply > -1 / arg1 * stor19 / 100:
                                    revert with 0, 17
                                if not arg1 * stor19 / 100:
                                    revert with 0, 18
                                if arg1 * stor19 / 100 * stor11 / totalSupply / arg1 * stor19 / 100 != stor11 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not arg1 * stor25 / 100:
                                    _13574 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13574] = 30
                                    mem[_13574 + 32] = 'SafeMath: subtraction overflow'
                                    if arg1 * stor19 / 100 * stor11 / totalSupply > 0:
                                        _13823 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _13823 + 68] = mem[idx + _13574 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13823 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _13823 + -mem[64] + 100
                                    if 0 < arg1 * stor19 / 100 * stor11 / totalSupply:
                                        revert with 0, 17
                                    _14975 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14975] = 30
                                    mem[_14975 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= -1 * arg1 * stor19 / 100 * stor11 / totalSupply:
                                        if -1 * arg1 * stor19 / 100 * stor11 / totalSupply < 0:
                                            revert with 0, 17
                                        else:
                                            return 0
                                    _15519 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _15519 + 68] = mem[idx + _14975 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_15519 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _15519 + -mem[64] + 100
                                if arg1 * stor25 / 100 and stor11 / totalSupply > -1 / arg1 * stor25 / 100:
                                    revert with 0, 17
                                if not arg1 * stor25 / 100:
                                    revert with 0, 18
                                if arg1 * stor25 / 100 * stor11 / totalSupply / arg1 * stor25 / 100 != stor11 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _14474 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14474] = 30
                                mem[_14474 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * stor19 / 100 * stor11 / totalSupply > 0:
                                    _14974 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _14974 + 68] = mem[idx + _14474 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14974 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14974 + -mem[64] + 100
                                if 0 < arg1 * stor19 / 100 * stor11 / totalSupply:
                                    revert with 0, 17
                                _16921 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16921] = 30
                                mem[_16921 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * stor25 / 100 * stor11 / totalSupply <= -1 * arg1 * stor19 / 100 * stor11 / totalSupply:
                                    if -1 * arg1 * stor19 / 100 * stor11 / totalSupply < arg1 * stor25 / 100 * stor11 / totalSupply:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _17718 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _17718 + 68] = mem[idx + _16921 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_17718 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _17718 + -mem[64] + 100
                            if arg1 and stor11 / totalSupply > -1 / arg1:
                                revert with 0, 17
                            if not arg1:
                                revert with 0, 18
                            if arg1 * stor11 / totalSupply / arg1 != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * stor19 / 100:
                                if not arg1 * stor25 / 100:
                                    _13573 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13573] = 30
                                    mem[_13573 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg1 * stor11 / totalSupply:
                                        _13822 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _13822 + 68] = mem[idx + _13573 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13822 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _13822 + -mem[64] + 100
                                    if arg1 * stor11 / totalSupply < 0:
                                        revert with 0, 17
                                    _14972 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14972] = 30
                                    mem[_14972 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= arg1 * stor11 / totalSupply:
                                        if arg1 * stor11 / totalSupply < 0:
                                            revert with 0, 17
                                        return (arg1 * stor11 / totalSupply)
                                    _15518 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _15518 + 68] = mem[idx + _14972 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_15518 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _15518 + -mem[64] + 100
                                if arg1 * stor25 / 100 and stor11 / totalSupply > -1 / arg1 * stor25 / 100:
                                    revert with 0, 17
                                if not arg1 * stor25 / 100:
                                    revert with 0, 18
                                if arg1 * stor25 / 100 * stor11 / totalSupply / arg1 * stor25 / 100 != stor11 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _14473 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14473] = 30
                                mem[_14473 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor11 / totalSupply:
                                    _14971 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _14971 + 68] = mem[idx + _14473 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14971 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14971 + -mem[64] + 100
                                if arg1 * stor11 / totalSupply < 0:
                                    revert with 0, 17
                                _16919 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16919] = 30
                                mem[_16919 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * stor25 / 100 * stor11 / totalSupply <= arg1 * stor11 / totalSupply:
                                    if arg1 * stor11 / totalSupply < arg1 * stor25 / 100 * stor11 / totalSupply:
                                        revert with 0, 17
                                    return (arg1 * stor11 / totalSupply)
                                _17716 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _17716 + 68] = mem[idx + _16919 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_17716 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _17716 + -mem[64] + 100
                            if arg1 * stor19 / 100 and stor11 / totalSupply > -1 / arg1 * stor19 / 100:
                                revert with 0, 17
                            if not arg1 * stor19 / 100:
                                revert with 0, 18
                            if arg1 * stor19 / 100 * stor11 / totalSupply / arg1 * stor19 / 100 != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * stor25 / 100:
                                _14472 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14472] = 30
                                mem[_14472 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * stor19 / 100 * stor11 / totalSupply > arg1 * stor11 / totalSupply:
                                    _14970 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _14970 + 68] = mem[idx + _14472 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14970 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14970 + -mem[64] + 100
                                if arg1 * stor11 / totalSupply < arg1 * stor19 / 100 * stor11 / totalSupply:
                                    revert with 0, 17
                                _16917 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16917] = 30
                                mem[_16917 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply):
                                    if (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply) < 0:
                                        revert with 0, 17
                                    return (arg1 * stor11 / totalSupply)
                                _17715 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _17715 + 68] = mem[idx + _16917 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_17715 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _17715 + -mem[64] + 100
                            if arg1 * stor25 / 100 and stor11 / totalSupply > -1 / arg1 * stor25 / 100:
                                revert with 0, 17
                            if not arg1 * stor25 / 100:
                                revert with 0, 18
                            if arg1 * stor25 / 100 * stor11 / totalSupply / arg1 * stor25 / 100 != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _16124 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_16124] = 30
                            mem[_16124 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor19 / 100 * stor11 / totalSupply > arg1 * stor11 / totalSupply:
                                _16916 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _16916 + 68] = mem[idx + _16124 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_16916 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _16916 + -mem[64] + 100
                            if arg1 * stor11 / totalSupply < arg1 * stor19 / 100 * stor11 / totalSupply:
                                revert with 0, 17
                            _19216 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_19216] = 30
                            mem[_19216 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor25 / 100 * stor11 / totalSupply <= (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply):
                                if (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply) < arg1 * stor25 / 100 * stor11 / totalSupply:
                                    revert with 0, 17
                                return (arg1 * stor11 / totalSupply)
                            _19968 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _19968 + 68] = mem[idx + _19216 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19968 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _19968 + -mem[64] + 100
                        if idx >= stor9.length:
                            revert with 0, 50
                        mem[0] = stor9[idx]
                        mem[32] = 2
                        if stor2[stor9[idx]] <= s:
                            if idx >= stor9.length:
                                revert with 0, 50
                            mem[0] = stor9[idx]
                            mem[32] = 1
                            _11815 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11815] = 30
                            mem[_11815 + 32] = 'SafeMath: subtraction overflow'
                            if stor1[stor9[idx]] > t:
                                _11975 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11975 + 68] = mem[idx + _11815 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11975 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11975 + -mem[64] + 100
                            if t < stor1[stor9[idx]]:
                                revert with 0, 17
                            if idx >= stor9.length:
                                revert with 0, 50
                            mem[0] = stor9[idx]
                            mem[32] = 2
                            _12680 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12680] = 30
                            mem[_12680 + 32] = 'SafeMath: subtraction overflow'
                            if stor2[stor9[idx]] <= s:
                                if s < stor2[stor9[idx]]:
                                    revert with 0, 17
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s - stor2[stor9[idx]]
                                t = t - stor1[stor9[idx]]
                                continue 
                            _12776 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12776 + 68] = mem[idx + _12680 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12776 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12776 + -mem[64] + 100
                        _11816 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11816] = 26
                        mem[_11816 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _11976 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _11976 + 68] = mem[idx + _11816 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11976 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _11976 + -mem[64] + 100
                        if not arg1:
                            if not arg1 * stor19 / 100:
                                if not arg1 * stor25 / 100:
                                    return 0
                                if arg1 * stor25 / 100 and stor11 / totalSupply > -1 / arg1 * stor25 / 100:
                                    revert with 0, 17
                                if not arg1 * stor25 / 100:
                                    revert with 0, 18
                                if arg1 * stor25 / 100 * stor11 / totalSupply / arg1 * stor25 / 100 != stor11 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _13828 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13828] = 30
                                mem[_13828 + 32] = 'SafeMath: subtraction overflow'
                                _15528 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15528] = 30
                                mem[_15528 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * stor25 / 100 * stor11 / totalSupply <= 0:
                                    if 0 < arg1 * stor25 / 100 * stor11 / totalSupply:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _16128 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _16128 + 68] = mem[idx + _15528 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_16128 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _16128 + -mem[64] + 100
                            if arg1 * stor19 / 100 and stor11 / totalSupply > -1 / arg1 * stor19 / 100:
                                revert with 0, 17
                            if not arg1 * stor19 / 100:
                                revert with 0, 18
                            if arg1 * stor19 / 100 * stor11 / totalSupply / arg1 * stor19 / 100 != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * stor25 / 100:
                                _13827 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13827] = 30
                                mem[_13827 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * stor19 / 100 * stor11 / totalSupply > 0:
                                    _14057 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _14057 + 68] = mem[idx + _13827 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14057 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14057 + -mem[64] + 100
                                if 0 < arg1 * stor19 / 100 * stor11 / totalSupply:
                                    revert with 0, 17
                                _15526 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15526] = 30
                                mem[_15526 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * arg1 * stor19 / 100 * stor11 / totalSupply:
                                    if -1 * arg1 * stor19 / 100 * stor11 / totalSupply < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _16127 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _16127 + 68] = mem[idx + _15526 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_16127 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _16127 + -mem[64] + 100
                            if arg1 * stor25 / 100 and stor11 / totalSupply > -1 / arg1 * stor25 / 100:
                                revert with 0, 17
                            if not arg1 * stor25 / 100:
                                revert with 0, 18
                            if arg1 * stor25 / 100 * stor11 / totalSupply / arg1 * stor25 / 100 != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _14980 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14980] = 30
                            mem[_14980 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor19 / 100 * stor11 / totalSupply > 0:
                                _15525 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _15525 + 68] = mem[idx + _14980 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15525 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _15525 + -mem[64] + 100
                            if 0 < arg1 * stor19 / 100 * stor11 / totalSupply:
                                revert with 0, 17
                            _17726 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_17726] = 30
                            mem[_17726 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor25 / 100 * stor11 / totalSupply <= -1 * arg1 * stor19 / 100 * stor11 / totalSupply:
                                if -1 * arg1 * stor19 / 100 * stor11 / totalSupply < arg1 * stor25 / 100 * stor11 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _18384 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _18384 + 68] = mem[idx + _17726 + 32]
                                idx = idx + 32
                                continue 
                            mem[_18384 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _18384 + -mem[64] + 100
                        if arg1 and stor11 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor11 / totalSupply / arg1 != stor11 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor19 / 100:
                            if not arg1 * stor25 / 100:
                                _13826 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13826] = 30
                                mem[_13826 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor11 / totalSupply:
                                    _14056 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _14056 + 68] = mem[idx + _13826 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14056 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14056 + -mem[64] + 100
                                if arg1 * stor11 / totalSupply < 0:
                                    revert with 0, 17
                                _15523 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15523] = 30
                                mem[_15523 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= arg1 * stor11 / totalSupply:
                                    if arg1 * stor11 / totalSupply < 0:
                                        revert with 0, 17
                                    return (arg1 * stor11 / totalSupply)
                                _16126 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _16126 + 68] = mem[idx + _15523 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_16126 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _16126 + -mem[64] + 100
                            if arg1 * stor25 / 100 and stor11 / totalSupply > -1 / arg1 * stor25 / 100:
                                revert with 0, 17
                            if not arg1 * stor25 / 100:
                                revert with 0, 18
                            if arg1 * stor25 / 100 * stor11 / totalSupply / arg1 * stor25 / 100 != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _14979 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14979] = 30
                            mem[_14979 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor11 / totalSupply:
                                _15522 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _15522 + 68] = mem[idx + _14979 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15522 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _15522 + -mem[64] + 100
                            if arg1 * stor11 / totalSupply < 0:
                                revert with 0, 17
                            _17724 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_17724] = 30
                            mem[_17724 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor25 / 100 * stor11 / totalSupply <= arg1 * stor11 / totalSupply:
                                if arg1 * stor11 / totalSupply < arg1 * stor25 / 100 * stor11 / totalSupply:
                                    revert with 0, 17
                                return (arg1 * stor11 / totalSupply)
                            _18382 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _18382 + 68] = mem[idx + _17724 + 32]
                                idx = idx + 32
                                continue 
                            mem[_18382 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _18382 + -mem[64] + 100
                        if arg1 * stor19 / 100 and stor11 / totalSupply > -1 / arg1 * stor19 / 100:
                            revert with 0, 17
                        if not arg1 * stor19 / 100:
                            revert with 0, 18
                        if arg1 * stor19 / 100 * stor11 / totalSupply / arg1 * stor19 / 100 != stor11 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor25 / 100:
                            _14978 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14978] = 30
                            mem[_14978 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor19 / 100 * stor11 / totalSupply > arg1 * stor11 / totalSupply:
                                _15521 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _15521 + 68] = mem[idx + _14978 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15521 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _15521 + -mem[64] + 100
                            if arg1 * stor11 / totalSupply < arg1 * stor19 / 100 * stor11 / totalSupply:
                                revert with 0, 17
                            _17722 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_17722] = 30
                            mem[_17722 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply):
                                if (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor11 / totalSupply)
                            _18381 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _18381 + 68] = mem[idx + _17722 + 32]
                                idx = idx + 32
                                continue 
                            mem[_18381 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _18381 + -mem[64] + 100
                        if arg1 * stor25 / 100 and stor11 / totalSupply > -1 / arg1 * stor25 / 100:
                            revert with 0, 17
                        if not arg1 * stor25 / 100:
                            revert with 0, 18
                        if arg1 * stor25 / 100 * stor11 / totalSupply / arg1 * stor25 / 100 != stor11 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _16924 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_16924] = 30
                        mem[_16924 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor19 / 100 * stor11 / totalSupply > arg1 * stor11 / totalSupply:
                            _17721 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _17721 + 68] = mem[idx + _16924 + 32]
                                idx = idx + 32
                                continue 
                            mem[_17721 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _17721 + -mem[64] + 100
                        if arg1 * stor11 / totalSupply < arg1 * stor19 / 100 * stor11 / totalSupply:
                            revert with 0, 17
                        _19972 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19972] = 30
                        mem[_19972 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor25 / 100 * stor11 / totalSupply <= (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply):
                            if (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply) < arg1 * stor25 / 100 * stor11 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor11 / totalSupply)
                        _20333 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _20333 + 68] = mem[idx + _19972 + 32]
                            idx = idx + 32
                            continue 
                        mem[_20333 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _20333 + -mem[64] + 100
                else:
                    if arg1 and stor35 > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor35 / arg1 != stor35:
                        revert with 0, 'SafeMath: multiplication overflow'
                    mem[288] = 26
                    mem[320] = 'SafeMath: division by zero'
                    if arg1 * stor25 / 100 > -1:
                        revert with 0, 17
                    if arg1 * stor25 / 100 < arg1 * stor25 / 100:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[352] = 30
                    mem[384] = 'SafeMath: subtraction overflow'
                    if arg1 * stor19 / 100 > arg1:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 < arg1 * stor19 / 100:
                        revert with 0, 17
                    mem[416] = 30
                    mem[448] = 'SafeMath: subtraction overflow'
                    if arg1 * stor25 / 100 > arg1 - (arg1 * stor19 / 100):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 - (arg1 * stor19 / 100) < arg1 * stor25 / 100:
                        revert with 0, 17
                    mem[64] = 544
                    mem[480] = 30
                    mem[512] = 'SafeMath: subtraction overflow'
                    if arg1 * stor35 / 100 > arg1 - (arg1 * stor19 / 100) - (arg1 * stor25 / 100):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 - (arg1 * stor19 / 100) - (arg1 * stor25 / 100) < arg1 * stor35 / 100:
                        revert with 0, 17
                    if arg1 * stor25 / 100 > -1:
                        revert with 0, 17
                    if arg1 * stor25 / 100 < arg1 * stor25 / 100:
                        revert with 0, 'SafeMath: addition overflow'
                    idx = 0
                    s = totalSupply
                    t = stor11
                    while idx < stor9.length:
                        mem[0] = stor9[idx]
                        mem[32] = 1
                        if stor1[stor9[idx]] > t:
                            _11647 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11647] = 26
                            mem[_11647 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                _11811 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _11811 + 68] = mem[idx + _11647 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11811 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _11811 + -mem[64] + 100
                            if not arg1:
                                if not arg1 * stor19 / 100:
                                    if not arg1 * stor25 / 100:
                                        return 0
                                    if arg1 * stor25 / 100 and stor11 / totalSupply > -1 / arg1 * stor25 / 100:
                                        revert with 0, 17
                                    if not arg1 * stor25 / 100:
                                        revert with 0, 18
                                    if arg1 * stor25 / 100 * stor11 / totalSupply / arg1 * stor25 / 100 != stor11 / totalSupply:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _13566 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13566] = 30
                                    mem[_13566 + 32] = 'SafeMath: subtraction overflow'
                                    _14960 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14960] = 30
                                    mem[_14960 + 32] = 'SafeMath: subtraction overflow'
                                    if arg1 * stor25 / 100 * stor11 / totalSupply <= 0:
                                        if 0 < arg1 * stor25 / 100 * stor11 / totalSupply:
                                            revert with 0, 17
                                        else:
                                            return 0
                                    _15504 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _15504 + 68] = mem[idx + _14960 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_15504 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _15504 + -mem[64] + 100
                                if arg1 * stor19 / 100 and stor11 / totalSupply > -1 / arg1 * stor19 / 100:
                                    revert with 0, 17
                                if not arg1 * stor19 / 100:
                                    revert with 0, 18
                                if arg1 * stor19 / 100 * stor11 / totalSupply / arg1 * stor19 / 100 != stor11 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not arg1 * stor25 / 100:
                                    _13565 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13565] = 30
                                    mem[_13565 + 32] = 'SafeMath: subtraction overflow'
                                    if arg1 * stor19 / 100 * stor11 / totalSupply > 0:
                                        _13816 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _13816 + 68] = mem[idx + _13565 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13816 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _13816 + -mem[64] + 100
                                    if 0 < arg1 * stor19 / 100 * stor11 / totalSupply:
                                        revert with 0, 17
                                    _14958 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14958] = 30
                                    mem[_14958 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= -1 * arg1 * stor19 / 100 * stor11 / totalSupply:
                                        if -1 * arg1 * stor19 / 100 * stor11 / totalSupply < 0:
                                            revert with 0, 17
                                        else:
                                            return 0
                                    _15503 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _15503 + 68] = mem[idx + _14958 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_15503 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _15503 + -mem[64] + 100
                                if arg1 * stor25 / 100 and stor11 / totalSupply > -1 / arg1 * stor25 / 100:
                                    revert with 0, 17
                                if not arg1 * stor25 / 100:
                                    revert with 0, 18
                                if arg1 * stor25 / 100 * stor11 / totalSupply / arg1 * stor25 / 100 != stor11 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _14461 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14461] = 30
                                mem[_14461 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * stor19 / 100 * stor11 / totalSupply > 0:
                                    _14957 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _14957 + 68] = mem[idx + _14461 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14957 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14957 + -mem[64] + 100
                                if 0 < arg1 * stor19 / 100 * stor11 / totalSupply:
                                    revert with 0, 17
                                _16896 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16896] = 30
                                mem[_16896 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * stor25 / 100 * stor11 / totalSupply <= -1 * arg1 * stor19 / 100 * stor11 / totalSupply:
                                    if -1 * arg1 * stor19 / 100 * stor11 / totalSupply < arg1 * stor25 / 100 * stor11 / totalSupply:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _17696 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _17696 + 68] = mem[idx + _16896 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_17696 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _17696 + -mem[64] + 100
                            if arg1 and stor11 / totalSupply > -1 / arg1:
                                revert with 0, 17
                            if not arg1:
                                revert with 0, 18
                            if arg1 * stor11 / totalSupply / arg1 != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * stor19 / 100:
                                if not arg1 * stor25 / 100:
                                    _13564 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13564] = 30
                                    mem[_13564 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg1 * stor11 / totalSupply:
                                        _13815 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _13815 + 68] = mem[idx + _13564 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13815 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _13815 + -mem[64] + 100
                                    if arg1 * stor11 / totalSupply < 0:
                                        revert with 0, 17
                                    _14955 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14955] = 30
                                    mem[_14955 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= arg1 * stor11 / totalSupply:
                                        if arg1 * stor11 / totalSupply < 0:
                                            revert with 0, 17
                                        return (arg1 * stor11 / totalSupply)
                                    _15502 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _15502 + 68] = mem[idx + _14955 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_15502 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _15502 + -mem[64] + 100
                                if arg1 * stor25 / 100 and stor11 / totalSupply > -1 / arg1 * stor25 / 100:
                                    revert with 0, 17
                                if not arg1 * stor25 / 100:
                                    revert with 0, 18
                                if arg1 * stor25 / 100 * stor11 / totalSupply / arg1 * stor25 / 100 != stor11 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _14460 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14460] = 30
                                mem[_14460 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor11 / totalSupply:
                                    _14954 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _14954 + 68] = mem[idx + _14460 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14954 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14954 + -mem[64] + 100
                                if arg1 * stor11 / totalSupply < 0:
                                    revert with 0, 17
                                _16894 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16894] = 30
                                mem[_16894 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * stor25 / 100 * stor11 / totalSupply <= arg1 * stor11 / totalSupply:
                                    if arg1 * stor11 / totalSupply < arg1 * stor25 / 100 * stor11 / totalSupply:
                                        revert with 0, 17
                                    return (arg1 * stor11 / totalSupply)
                                _17694 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _17694 + 68] = mem[idx + _16894 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_17694 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _17694 + -mem[64] + 100
                            if arg1 * stor19 / 100 and stor11 / totalSupply > -1 / arg1 * stor19 / 100:
                                revert with 0, 17
                            if not arg1 * stor19 / 100:
                                revert with 0, 18
                            if arg1 * stor19 / 100 * stor11 / totalSupply / arg1 * stor19 / 100 != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * stor25 / 100:
                                _14459 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14459] = 30
                                mem[_14459 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * stor19 / 100 * stor11 / totalSupply > arg1 * stor11 / totalSupply:
                                    _14953 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _14953 + 68] = mem[idx + _14459 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14953 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14953 + -mem[64] + 100
                                if arg1 * stor11 / totalSupply < arg1 * stor19 / 100 * stor11 / totalSupply:
                                    revert with 0, 17
                                _16892 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16892] = 30
                                mem[_16892 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply):
                                    if (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply) < 0:
                                        revert with 0, 17
                                    return (arg1 * stor11 / totalSupply)
                                _17693 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _17693 + 68] = mem[idx + _16892 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_17693 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _17693 + -mem[64] + 100
                            if arg1 * stor25 / 100 and stor11 / totalSupply > -1 / arg1 * stor25 / 100:
                                revert with 0, 17
                            if not arg1 * stor25 / 100:
                                revert with 0, 18
                            if arg1 * stor25 / 100 * stor11 / totalSupply / arg1 * stor25 / 100 != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _16113 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_16113] = 30
                            mem[_16113 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor19 / 100 * stor11 / totalSupply > arg1 * stor11 / totalSupply:
                                _16891 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _16891 + 68] = mem[idx + _16113 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_16891 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _16891 + -mem[64] + 100
                            if arg1 * stor11 / totalSupply < arg1 * stor19 / 100 * stor11 / totalSupply:
                                revert with 0, 17
                            _19195 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_19195] = 30
                            mem[_19195 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor25 / 100 * stor11 / totalSupply <= (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply):
                                if (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply) < arg1 * stor25 / 100 * stor11 / totalSupply:
                                    revert with 0, 17
                                return (arg1 * stor11 / totalSupply)
                            _19947 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _19947 + 68] = mem[idx + _19195 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19947 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _19947 + -mem[64] + 100
                        if idx >= stor9.length:
                            revert with 0, 50
                        mem[0] = stor9[idx]
                        mem[32] = 2
                        if stor2[stor9[idx]] <= s:
                            if idx >= stor9.length:
                                revert with 0, 50
                            mem[0] = stor9[idx]
                            mem[32] = 1
                            _11812 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11812] = 30
                            mem[_11812 + 32] = 'SafeMath: subtraction overflow'
                            if stor1[stor9[idx]] > t:
                                _11972 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11972 + 68] = mem[idx + _11812 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11972 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11972 + -mem[64] + 100
                            if t < stor1[stor9[idx]]:
                                revert with 0, 17
                            if idx >= stor9.length:
                                revert with 0, 50
                            mem[0] = stor9[idx]
                            mem[32] = 2
                            _12677 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12677] = 30
                            mem[_12677 + 32] = 'SafeMath: subtraction overflow'
                            if stor2[stor9[idx]] <= s:
                                if s < stor2[stor9[idx]]:
                                    revert with 0, 17
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s - stor2[stor9[idx]]
                                t = t - stor1[stor9[idx]]
                                continue 
                            _12773 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12773 + 68] = mem[idx + _12677 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12773 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12773 + -mem[64] + 100
                        _11813 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11813] = 26
                        mem[_11813 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _11973 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _11973 + 68] = mem[idx + _11813 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11973 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _11973 + -mem[64] + 100
                        if not arg1:
                            if not arg1 * stor19 / 100:
                                if not arg1 * stor25 / 100:
                                    return 0
                                if arg1 * stor25 / 100 and stor11 / totalSupply > -1 / arg1 * stor25 / 100:
                                    revert with 0, 17
                                if not arg1 * stor25 / 100:
                                    revert with 0, 18
                                if arg1 * stor25 / 100 * stor11 / totalSupply / arg1 * stor25 / 100 != stor11 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _13821 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13821] = 30
                                mem[_13821 + 32] = 'SafeMath: subtraction overflow'
                                _15512 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15512] = 30
                                mem[_15512 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * stor25 / 100 * stor11 / totalSupply <= 0:
                                    if 0 < arg1 * stor25 / 100 * stor11 / totalSupply:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _16117 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _16117 + 68] = mem[idx + _15512 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_16117 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _16117 + -mem[64] + 100
                            if arg1 * stor19 / 100 and stor11 / totalSupply > -1 / arg1 * stor19 / 100:
                                revert with 0, 17
                            if not arg1 * stor19 / 100:
                                revert with 0, 18
                            if arg1 * stor19 / 100 * stor11 / totalSupply / arg1 * stor19 / 100 != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * stor25 / 100:
                                _13820 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13820] = 30
                                mem[_13820 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * stor19 / 100 * stor11 / totalSupply > 0:
                                    _14050 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _14050 + 68] = mem[idx + _13820 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14050 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14050 + -mem[64] + 100
                                if 0 < arg1 * stor19 / 100 * stor11 / totalSupply:
                                    revert with 0, 17
                                _15510 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15510] = 30
                                mem[_15510 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * arg1 * stor19 / 100 * stor11 / totalSupply:
                                    if -1 * arg1 * stor19 / 100 * stor11 / totalSupply < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _16116 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _16116 + 68] = mem[idx + _15510 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_16116 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _16116 + -mem[64] + 100
                            if arg1 * stor25 / 100 and stor11 / totalSupply > -1 / arg1 * stor25 / 100:
                                revert with 0, 17
                            if not arg1 * stor25 / 100:
                                revert with 0, 18
                            if arg1 * stor25 / 100 * stor11 / totalSupply / arg1 * stor25 / 100 != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _14963 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14963] = 30
                            mem[_14963 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor19 / 100 * stor11 / totalSupply > 0:
                                _15509 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _15509 + 68] = mem[idx + _14963 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15509 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _15509 + -mem[64] + 100
                            if 0 < arg1 * stor19 / 100 * stor11 / totalSupply:
                                revert with 0, 17
                            _17704 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_17704] = 30
                            mem[_17704 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor25 / 100 * stor11 / totalSupply <= -1 * arg1 * stor19 / 100 * stor11 / totalSupply:
                                if -1 * arg1 * stor19 / 100 * stor11 / totalSupply < arg1 * stor25 / 100 * stor11 / totalSupply:
                                    revert with 0, 17
                                else:
                                    return 0
                            _18376 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _18376 + 68] = mem[idx + _17704 + 32]
                                idx = idx + 32
                                continue 
                            mem[_18376 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _18376 + -mem[64] + 100
                        if arg1 and stor11 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor11 / totalSupply / arg1 != stor11 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor19 / 100:
                            if not arg1 * stor25 / 100:
                                _13819 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13819] = 30
                                mem[_13819 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor11 / totalSupply:
                                    _14049 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _14049 + 68] = mem[idx + _13819 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14049 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14049 + -mem[64] + 100
                                if arg1 * stor11 / totalSupply < 0:
                                    revert with 0, 17
                                _15507 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15507] = 30
                                mem[_15507 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= arg1 * stor11 / totalSupply:
                                    if arg1 * stor11 / totalSupply < 0:
                                        revert with 0, 17
                                    return (arg1 * stor11 / totalSupply)
                                _16115 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _16115 + 68] = mem[idx + _15507 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_16115 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _16115 + -mem[64] + 100
                            if arg1 * stor25 / 100 and stor11 / totalSupply > -1 / arg1 * stor25 / 100:
                                revert with 0, 17
                            if not arg1 * stor25 / 100:
                                revert with 0, 18
                            if arg1 * stor25 / 100 * stor11 / totalSupply / arg1 * stor25 / 100 != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _14962 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14962] = 30
                            mem[_14962 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor11 / totalSupply:
                                _15506 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _15506 + 68] = mem[idx + _14962 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15506 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _15506 + -mem[64] + 100
                            if arg1 * stor11 / totalSupply < 0:
                                revert with 0, 17
                            _17702 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_17702] = 30
                            mem[_17702 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor25 / 100 * stor11 / totalSupply <= arg1 * stor11 / totalSupply:
                                if arg1 * stor11 / totalSupply < arg1 * stor25 / 100 * stor11 / totalSupply:
                                    revert with 0, 17
                                return (arg1 * stor11 / totalSupply)
                            _18374 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _18374 + 68] = mem[idx + _17702 + 32]
                                idx = idx + 32
                                continue 
                            mem[_18374 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _18374 + -mem[64] + 100
                        if arg1 * stor19 / 100 and stor11 / totalSupply > -1 / arg1 * stor19 / 100:
                            revert with 0, 17
                        if not arg1 * stor19 / 100:
                            revert with 0, 18
                        if arg1 * stor19 / 100 * stor11 / totalSupply / arg1 * stor19 / 100 != stor11 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor25 / 100:
                            _14961 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14961] = 30
                            mem[_14961 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor19 / 100 * stor11 / totalSupply > arg1 * stor11 / totalSupply:
                                _15505 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _15505 + 68] = mem[idx + _14961 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15505 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _15505 + -mem[64] + 100
                            if arg1 * stor11 / totalSupply < arg1 * stor19 / 100 * stor11 / totalSupply:
                                revert with 0, 17
                            _17700 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_17700] = 30
                            mem[_17700 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply):
                                if (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor11 / totalSupply)
                            _18373 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _18373 + 68] = mem[idx + _17700 + 32]
                                idx = idx + 32
                                continue 
                            mem[_18373 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _18373 + -mem[64] + 100
                        if arg1 * stor25 / 100 and stor11 / totalSupply > -1 / arg1 * stor25 / 100:
                            revert with 0, 17
                        if not arg1 * stor25 / 100:
                            revert with 0, 18
                        if arg1 * stor25 / 100 * stor11 / totalSupply / arg1 * stor25 / 100 != stor11 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _16899 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_16899] = 30
                        mem[_16899 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor19 / 100 * stor11 / totalSupply > arg1 * stor11 / totalSupply:
                            _17699 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _17699 + 68] = mem[idx + _16899 + 32]
                                idx = idx + 32
                                continue 
                            mem[_17699 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _17699 + -mem[64] + 100
                        if arg1 * stor11 / totalSupply < arg1 * stor19 / 100 * stor11 / totalSupply:
                            revert with 0, 17
                        _19951 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19951] = 30
                        mem[_19951 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor25 / 100 * stor11 / totalSupply <= (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply):
                            if (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply) < arg1 * stor25 / 100 * stor11 / totalSupply:
                                revert with 0, 17
                            return (arg1 * stor11 / totalSupply)
                        _20329 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _20329 + 68] = mem[idx + _19951 + 32]
                            idx = idx + 32
                            continue 
                        mem[_20329 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _20329 + -mem[64] + 100
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if t >= stor11 / totalSupply:
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg1:
                        if not arg1 * stor19 / 100:
                            if arg1 * stor25 / 100:
                                if arg1 * stor25 / 100 and t / s > -1 / arg1 * stor25 / 100:
                                    revert with 0, 17
                                if not arg1 * stor25 / 100:
                                    revert with 0, 18
                                if arg1 * stor25 / 100 * t / s / arg1 * stor25 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * stor25 / 100 * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * stor25 / 100 * t / s:
                                    revert with 0, 17
                        else:
                            if arg1 * stor19 / 100 and t / s > -1 / arg1 * stor19 / 100:
                                revert with 0, 17
                            if not arg1 * stor19 / 100:
                                revert with 0, 18
                            if arg1 * stor19 / 100 * t / s / arg1 * stor19 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * stor25 / 100:
                                if arg1 * stor19 / 100 * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * stor19 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > -1 * arg1 * stor19 / 100 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * stor19 / 100 * t / s < 0:
                                    revert with 0, 17
                            else:
                                if arg1 * stor25 / 100 and t / s > -1 / arg1 * stor25 / 100:
                                    revert with 0, 17
                                if not arg1 * stor25 / 100:
                                    revert with 0, 18
                                if arg1 * stor25 / 100 * t / s / arg1 * stor25 / 100 != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * stor19 / 100 * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * stor19 / 100 * t / s:
                                    revert with 0, 17
                                if arg1 * stor25 / 100 * t / s > -1 * arg1 * stor19 / 100 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * stor19 / 100 * t / s < arg1 * stor25 / 100 * t / s:
                                    revert with 0, 17
                        return 0
                    if arg1 and t / s > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor19 / 100:
                        if not arg1 * stor25 / 100:
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                        else:
                            if arg1 * stor25 / 100 and t / s > -1 / arg1 * stor25 / 100:
                                revert with 0, 17
                            if not arg1 * stor25 / 100:
                                revert with 0, 18
                            if arg1 * stor25 / 100 * t / s / arg1 * stor25 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if arg1 * stor25 / 100 * t / s > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < arg1 * stor25 / 100 * t / s:
                                revert with 0, 17
                    else:
                        if arg1 * stor19 / 100 and t / s > -1 / arg1 * stor19 / 100:
                            revert with 0, 17
                        if not arg1 * stor19 / 100:
                            revert with 0, 18
                        if arg1 * stor19 / 100 * t / s / arg1 * stor19 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor25 / 100:
                            if arg1 * stor19 / 100 * t / s > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < arg1 * stor19 / 100 * t / s:
                                revert with 0, 17
                            if 0 > (arg1 * t / s) - (arg1 * stor19 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (arg1 * stor19 / 100 * t / s) < 0:
                                revert with 0, 17
                        else:
                            if arg1 * stor25 / 100 and t / s > -1 / arg1 * stor25 / 100:
                                revert with 0, 17
                            if not arg1 * stor25 / 100:
                                revert with 0, 18
                            if arg1 * stor25 / 100 * t / s / arg1 * stor25 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * stor19 / 100 * t / s > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < arg1 * stor19 / 100 * t / s:
                                revert with 0, 17
                            if arg1 * stor25 / 100 * t / s > (arg1 * t / s) - (arg1 * stor19 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (arg1 * stor19 / 100 * t / s) < arg1 * stor25 / 100 * t / s:
                                revert with 0, 17
                    return (arg1 * t / s)
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if not arg1 * stor19 / 100:
                        if arg1 * stor25 / 100:
                            if arg1 * stor25 / 100 and stor11 / totalSupply > -1 / arg1 * stor25 / 100:
                                revert with 0, 17
                            if not arg1 * stor25 / 100:
                                revert with 0, 18
                            if arg1 * stor25 / 100 * stor11 / totalSupply / arg1 * stor25 / 100 != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * stor25 / 100 * stor11 / totalSupply > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * stor25 / 100 * stor11 / totalSupply:
                                revert with 0, 17
                    else:
                        if arg1 * stor19 / 100 and stor11 / totalSupply > -1 / arg1 * stor19 / 100:
                            revert with 0, 17
                        if not arg1 * stor19 / 100:
                            revert with 0, 18
                        if arg1 * stor19 / 100 * stor11 / totalSupply / arg1 * stor19 / 100 != stor11 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor25 / 100:
                            if arg1 * stor19 / 100 * stor11 / totalSupply > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * stor19 / 100 * stor11 / totalSupply:
                                revert with 0, 17
                            if 0 > -1 * arg1 * stor19 / 100 * stor11 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * stor19 / 100 * stor11 / totalSupply < 0:
                                revert with 0, 17
                        else:
                            if arg1 * stor25 / 100 and stor11 / totalSupply > -1 / arg1 * stor25 / 100:
                                revert with 0, 17
                            if not arg1 * stor25 / 100:
                                revert with 0, 18
                            if arg1 * stor25 / 100 * stor11 / totalSupply / arg1 * stor25 / 100 != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * stor19 / 100 * stor11 / totalSupply > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * stor19 / 100 * stor11 / totalSupply:
                                revert with 0, 17
                            if arg1 * stor25 / 100 * stor11 / totalSupply > -1 * arg1 * stor19 / 100 * stor11 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * stor19 / 100 * stor11 / totalSupply < arg1 * stor25 / 100 * stor11 / totalSupply:
                                revert with 0, 17
                    return 0
                if arg1 and stor11 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor11 / totalSupply / arg1 != stor11 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor19 / 100:
                    if not arg1 * stor25 / 100:
                        if 0 > arg1 * stor11 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor11 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > arg1 * stor11 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor11 / totalSupply < 0:
                            revert with 0, 17
                    else:
                        if arg1 * stor25 / 100 and stor11 / totalSupply > -1 / arg1 * stor25 / 100:
                            revert with 0, 17
                        if not arg1 * stor25 / 100:
                            revert with 0, 18
                        if arg1 * stor25 / 100 * stor11 / totalSupply / arg1 * stor25 / 100 != stor11 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 > arg1 * stor11 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor11 / totalSupply < 0:
                            revert with 0, 17
                        if arg1 * stor25 / 100 * stor11 / totalSupply > arg1 * stor11 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor11 / totalSupply < arg1 * stor25 / 100 * stor11 / totalSupply:
                            revert with 0, 17
                else:
                    if arg1 * stor19 / 100 and stor11 / totalSupply > -1 / arg1 * stor19 / 100:
                        revert with 0, 17
                    if not arg1 * stor19 / 100:
                        revert with 0, 18
                    if arg1 * stor19 / 100 * stor11 / totalSupply / arg1 * stor19 / 100 != stor11 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor25 / 100:
                        if arg1 * stor19 / 100 * stor11 / totalSupply > arg1 * stor11 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor11 / totalSupply < arg1 * stor19 / 100 * stor11 / totalSupply:
                            revert with 0, 17
                        if 0 > (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply) < 0:
                            revert with 0, 17
                    else:
                        if arg1 * stor25 / 100 and stor11 / totalSupply > -1 / arg1 * stor25 / 100:
                            revert with 0, 17
                        if not arg1 * stor25 / 100:
                            revert with 0, 18
                        if arg1 * stor25 / 100 * stor11 / totalSupply / arg1 * stor25 / 100 != stor11 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * stor19 / 100 * stor11 / totalSupply > arg1 * stor11 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor11 / totalSupply < arg1 * stor19 / 100 * stor11 / totalSupply:
                            revert with 0, 17
                        if arg1 * stor25 / 100 * stor11 / totalSupply > (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply) < arg1 * stor25 / 100 * stor11 / totalSupply:
                            revert with 0, 17
            else:
                if arg1 and stor30 > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor30 / arg1 != stor30:
                    revert with 0, 'SafeMath: multiplication overflow'
                mem[224] = 26
                mem[256] = 'SafeMath: division by zero'
                if not arg1:
                    mem[288] = 26
                    mem[320] = 'SafeMath: division by zero'
                    if arg1 * stor25 / 100 > !(arg1 * stor30 / 100):
                        revert with 0, 17
                    if (arg1 * stor25 / 100) + (arg1 * stor30 / 100) < arg1 * stor25 / 100:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[352] = 30
                    mem[384] = 'SafeMath: subtraction overflow'
                    if arg1 * stor19 / 100 > arg1:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 < arg1 * stor19 / 100:
                        revert with 0, 17
                    mem[416] = 30
                    mem[448] = 'SafeMath: subtraction overflow'
                    if (arg1 * stor25 / 100) + (arg1 * stor30 / 100) > arg1 - (arg1 * stor19 / 100):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 - (arg1 * stor19 / 100) < (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                        revert with 0, 17
                    mem[64] = 544
                    mem[480] = 30
                    mem[512] = 'SafeMath: subtraction overflow'
                    if 0 > arg1 - (arg1 * stor19 / 100) - (arg1 * stor25 / 100) - (arg1 * stor30 / 100):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 - (arg1 * stor19 / 100) - (arg1 * stor25 / 100) - (arg1 * stor30 / 100) < 0:
                        revert with 0, 17
                    if arg1 * stor25 / 100 > !(arg1 * stor30 / 100):
                        revert with 0, 17
                    if (arg1 * stor25 / 100) + (arg1 * stor30 / 100) < arg1 * stor25 / 100:
                        revert with 0, 'SafeMath: addition overflow'
                    idx = 0
                    s = totalSupply
                    t = stor11
                    while idx < stor9.length:
                        mem[0] = stor9[idx]
                        mem[32] = 1
                        if stor1[stor9[idx]] > t:
                            _11646 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11646] = 26
                            mem[_11646 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                _11808 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _11808 + 68] = mem[idx + _11646 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11808 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _11808 + -mem[64] + 100
                            if not arg1:
                                if not arg1 * stor19 / 100:
                                    if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                                        return 0
                                    if (arg1 * stor25 / 100) + (arg1 * stor30 / 100) and stor11 / totalSupply > -1 / (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                                        revert with 0, 17
                                    if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                                        revert with 0, 18
                                    if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) / (arg1 * stor25 / 100) + (arg1 * stor30 / 100) != stor11 / totalSupply:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _13557 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13557] = 30
                                    mem[_13557 + 32] = 'SafeMath: subtraction overflow'
                                    _14943 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14943] = 30
                                    mem[_14943 + 32] = 'SafeMath: subtraction overflow'
                                    if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) <= 0:
                                        if 0 < (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply):
                                            revert with 0, 17
                                        else:
                                            return 0
                                    _15488 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _15488 + 68] = mem[idx + _14943 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_15488 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _15488 + -mem[64] + 100
                                if arg1 * stor19 / 100 and stor11 / totalSupply > -1 / arg1 * stor19 / 100:
                                    revert with 0, 17
                                if not arg1 * stor19 / 100:
                                    revert with 0, 18
                                if arg1 * stor19 / 100 * stor11 / totalSupply / arg1 * stor19 / 100 != stor11 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                                    _13556 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13556] = 30
                                    mem[_13556 + 32] = 'SafeMath: subtraction overflow'
                                    if arg1 * stor19 / 100 * stor11 / totalSupply > 0:
                                        _13809 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _13809 + 68] = mem[idx + _13556 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13809 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _13809 + -mem[64] + 100
                                    if 0 < arg1 * stor19 / 100 * stor11 / totalSupply:
                                        revert with 0, 17
                                    _14941 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14941] = 30
                                    mem[_14941 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= -1 * arg1 * stor19 / 100 * stor11 / totalSupply:
                                        if -1 * arg1 * stor19 / 100 * stor11 / totalSupply < 0:
                                            revert with 0, 17
                                        else:
                                            return 0
                                    _15487 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _15487 + 68] = mem[idx + _14941 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_15487 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _15487 + -mem[64] + 100
                                if (arg1 * stor25 / 100) + (arg1 * stor30 / 100) and stor11 / totalSupply > -1 / (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                                    revert with 0, 17
                                if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                                    revert with 0, 18
                                if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) / (arg1 * stor25 / 100) + (arg1 * stor30 / 100) != stor11 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _14448 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14448] = 30
                                mem[_14448 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * stor19 / 100 * stor11 / totalSupply > 0:
                                    _14940 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _14940 + 68] = mem[idx + _14448 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14940 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14940 + -mem[64] + 100
                                if 0 < arg1 * stor19 / 100 * stor11 / totalSupply:
                                    revert with 0, 17
                                _16871 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16871] = 30
                                mem[_16871 + 32] = 'SafeMath: subtraction overflow'
                                if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) <= -1 * arg1 * stor19 / 100 * stor11 / totalSupply:
                                    if -1 * arg1 * stor19 / 100 * stor11 / totalSupply < (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply):
                                        revert with 0, 17
                                    else:
                                        return 0
                                _17674 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _17674 + 68] = mem[idx + _16871 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_17674 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _17674 + -mem[64] + 100
                            if arg1 and stor11 / totalSupply > -1 / arg1:
                                revert with 0, 17
                            if not arg1:
                                revert with 0, 18
                            if arg1 * stor11 / totalSupply / arg1 != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * stor19 / 100:
                                if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                                    _13555 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13555] = 30
                                    mem[_13555 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg1 * stor11 / totalSupply:
                                        _13808 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _13808 + 68] = mem[idx + _13555 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13808 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _13808 + -mem[64] + 100
                                    if arg1 * stor11 / totalSupply < 0:
                                        revert with 0, 17
                                    _14938 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14938] = 30
                                    mem[_14938 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= arg1 * stor11 / totalSupply:
                                        if arg1 * stor11 / totalSupply < 0:
                                            revert with 0, 17
                                        return (arg1 * stor11 / totalSupply)
                                    _15486 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _15486 + 68] = mem[idx + _14938 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_15486 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _15486 + -mem[64] + 100
                                if (arg1 * stor25 / 100) + (arg1 * stor30 / 100) and stor11 / totalSupply > -1 / (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                                    revert with 0, 17
                                if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                                    revert with 0, 18
                                if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) / (arg1 * stor25 / 100) + (arg1 * stor30 / 100) != stor11 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _14447 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14447] = 30
                                mem[_14447 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor11 / totalSupply:
                                    _14937 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _14937 + 68] = mem[idx + _14447 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14937 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14937 + -mem[64] + 100
                                if arg1 * stor11 / totalSupply < 0:
                                    revert with 0, 17
                                _16869 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16869] = 30
                                mem[_16869 + 32] = 'SafeMath: subtraction overflow'
                                if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) <= arg1 * stor11 / totalSupply:
                                    if arg1 * stor11 / totalSupply < (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply):
                                        revert with 0, 17
                                    return (arg1 * stor11 / totalSupply)
                                _17672 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _17672 + 68] = mem[idx + _16869 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_17672 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _17672 + -mem[64] + 100
                            if arg1 * stor19 / 100 and stor11 / totalSupply > -1 / arg1 * stor19 / 100:
                                revert with 0, 17
                            if not arg1 * stor19 / 100:
                                revert with 0, 18
                            if arg1 * stor19 / 100 * stor11 / totalSupply / arg1 * stor19 / 100 != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                                _14446 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14446] = 30
                                mem[_14446 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * stor19 / 100 * stor11 / totalSupply > arg1 * stor11 / totalSupply:
                                    _14936 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _14936 + 68] = mem[idx + _14446 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14936 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14936 + -mem[64] + 100
                                if arg1 * stor11 / totalSupply < arg1 * stor19 / 100 * stor11 / totalSupply:
                                    revert with 0, 17
                                _16867 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16867] = 30
                                mem[_16867 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply):
                                    if (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply) < 0:
                                        revert with 0, 17
                                    return (arg1 * stor11 / totalSupply)
                                _17671 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _17671 + 68] = mem[idx + _16867 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_17671 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _17671 + -mem[64] + 100
                            if (arg1 * stor25 / 100) + (arg1 * stor30 / 100) and stor11 / totalSupply > -1 / (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                                revert with 0, 17
                            if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                                revert with 0, 18
                            if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) / (arg1 * stor25 / 100) + (arg1 * stor30 / 100) != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _16102 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_16102] = 30
                            mem[_16102 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor19 / 100 * stor11 / totalSupply > arg1 * stor11 / totalSupply:
                                _16866 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _16866 + 68] = mem[idx + _16102 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_16866 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _16866 + -mem[64] + 100
                            if arg1 * stor11 / totalSupply < arg1 * stor19 / 100 * stor11 / totalSupply:
                                revert with 0, 17
                            _19174 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_19174] = 30
                            mem[_19174 + 32] = 'SafeMath: subtraction overflow'
                            if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) <= (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply):
                                if (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply) < (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply):
                                    revert with 0, 17
                                return (arg1 * stor11 / totalSupply)
                            _19926 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _19926 + 68] = mem[idx + _19174 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19926 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _19926 + -mem[64] + 100
                        if idx >= stor9.length:
                            revert with 0, 50
                        mem[0] = stor9[idx]
                        mem[32] = 2
                        if stor2[stor9[idx]] <= s:
                            if idx >= stor9.length:
                                revert with 0, 50
                            mem[0] = stor9[idx]
                            mem[32] = 1
                            _11809 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11809] = 30
                            mem[_11809 + 32] = 'SafeMath: subtraction overflow'
                            if stor1[stor9[idx]] > t:
                                _11969 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11969 + 68] = mem[idx + _11809 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11969 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11969 + -mem[64] + 100
                            if t < stor1[stor9[idx]]:
                                revert with 0, 17
                            if idx >= stor9.length:
                                revert with 0, 50
                            mem[0] = stor9[idx]
                            mem[32] = 2
                            _12674 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12674] = 30
                            mem[_12674 + 32] = 'SafeMath: subtraction overflow'
                            if stor2[stor9[idx]] <= s:
                                if s < stor2[stor9[idx]]:
                                    revert with 0, 17
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s - stor2[stor9[idx]]
                                t = t - stor1[stor9[idx]]
                                continue 
                            _12770 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12770 + 68] = mem[idx + _12674 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12770 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12770 + -mem[64] + 100
                        _11810 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11810] = 26
                        mem[_11810 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _11970 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _11970 + 68] = mem[idx + _11810 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11970 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _11970 + -mem[64] + 100
                        if not arg1:
                            if not arg1 * stor19 / 100:
                                if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                                    return 0
                                if (arg1 * stor25 / 100) + (arg1 * stor30 / 100) and stor11 / totalSupply > -1 / (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                                    revert with 0, 17
                                if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                                    revert with 0, 18
                                if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) / (arg1 * stor25 / 100) + (arg1 * stor30 / 100) != stor11 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _13814 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13814] = 30
                                mem[_13814 + 32] = 'SafeMath: subtraction overflow'
                                _15496 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15496] = 30
                                mem[_15496 + 32] = 'SafeMath: subtraction overflow'
                                if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) <= 0:
                                    if 0 < (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply):
                                        revert with 0, 17
                                    else:
                                        return 0
                                _16106 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _16106 + 68] = mem[idx + _15496 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_16106 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _16106 + -mem[64] + 100
                            if arg1 * stor19 / 100 and stor11 / totalSupply > -1 / arg1 * stor19 / 100:
                                revert with 0, 17
                            if not arg1 * stor19 / 100:
                                revert with 0, 18
                            if arg1 * stor19 / 100 * stor11 / totalSupply / arg1 * stor19 / 100 != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                                _13813 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13813] = 30
                                mem[_13813 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * stor19 / 100 * stor11 / totalSupply > 0:
                                    _14043 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _14043 + 68] = mem[idx + _13813 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14043 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14043 + -mem[64] + 100
                                if 0 < arg1 * stor19 / 100 * stor11 / totalSupply:
                                    revert with 0, 17
                                _15494 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15494] = 30
                                mem[_15494 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * arg1 * stor19 / 100 * stor11 / totalSupply:
                                    if -1 * arg1 * stor19 / 100 * stor11 / totalSupply < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _16105 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _16105 + 68] = mem[idx + _15494 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_16105 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _16105 + -mem[64] + 100
                            if (arg1 * stor25 / 100) + (arg1 * stor30 / 100) and stor11 / totalSupply > -1 / (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                                revert with 0, 17
                            if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                                revert with 0, 18
                            if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) / (arg1 * stor25 / 100) + (arg1 * stor30 / 100) != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _14946 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14946] = 30
                            mem[_14946 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor19 / 100 * stor11 / totalSupply > 0:
                                _15493 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _15493 + 68] = mem[idx + _14946 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15493 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _15493 + -mem[64] + 100
                            if 0 < arg1 * stor19 / 100 * stor11 / totalSupply:
                                revert with 0, 17
                            _17682 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_17682] = 30
                            mem[_17682 + 32] = 'SafeMath: subtraction overflow'
                            if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) <= -1 * arg1 * stor19 / 100 * stor11 / totalSupply:
                                if -1 * arg1 * stor19 / 100 * stor11 / totalSupply < (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply):
                                    revert with 0, 17
                                else:
                                    return 0
                            _18368 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _18368 + 68] = mem[idx + _17682 + 32]
                                idx = idx + 32
                                continue 
                            mem[_18368 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _18368 + -mem[64] + 100
                        if arg1 and stor11 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor11 / totalSupply / arg1 != stor11 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor19 / 100:
                            if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                                _13812 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13812] = 30
                                mem[_13812 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor11 / totalSupply:
                                    _14042 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _14042 + 68] = mem[idx + _13812 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14042 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14042 + -mem[64] + 100
                                if arg1 * stor11 / totalSupply < 0:
                                    revert with 0, 17
                                _15491 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15491] = 30
                                mem[_15491 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= arg1 * stor11 / totalSupply:
                                    if arg1 * stor11 / totalSupply < 0:
                                        revert with 0, 17
                                    return (arg1 * stor11 / totalSupply)
                                _16104 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _16104 + 68] = mem[idx + _15491 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_16104 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _16104 + -mem[64] + 100
                            if (arg1 * stor25 / 100) + (arg1 * stor30 / 100) and stor11 / totalSupply > -1 / (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                                revert with 0, 17
                            if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                                revert with 0, 18
                            if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) / (arg1 * stor25 / 100) + (arg1 * stor30 / 100) != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _14945 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14945] = 30
                            mem[_14945 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor11 / totalSupply:
                                _15490 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _15490 + 68] = mem[idx + _14945 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15490 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _15490 + -mem[64] + 100
                            if arg1 * stor11 / totalSupply < 0:
                                revert with 0, 17
                            _17680 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_17680] = 30
                            mem[_17680 + 32] = 'SafeMath: subtraction overflow'
                            if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) <= arg1 * stor11 / totalSupply:
                                if arg1 * stor11 / totalSupply < (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply):
                                    revert with 0, 17
                                return (arg1 * stor11 / totalSupply)
                            _18366 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _18366 + 68] = mem[idx + _17680 + 32]
                                idx = idx + 32
                                continue 
                            mem[_18366 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _18366 + -mem[64] + 100
                        if arg1 * stor19 / 100 and stor11 / totalSupply > -1 / arg1 * stor19 / 100:
                            revert with 0, 17
                        if not arg1 * stor19 / 100:
                            revert with 0, 18
                        if arg1 * stor19 / 100 * stor11 / totalSupply / arg1 * stor19 / 100 != stor11 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                            _14944 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14944] = 30
                            mem[_14944 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor19 / 100 * stor11 / totalSupply > arg1 * stor11 / totalSupply:
                                _15489 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _15489 + 68] = mem[idx + _14944 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15489 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _15489 + -mem[64] + 100
                            if arg1 * stor11 / totalSupply < arg1 * stor19 / 100 * stor11 / totalSupply:
                                revert with 0, 17
                            _17678 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_17678] = 30
                            mem[_17678 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply):
                                if (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor11 / totalSupply)
                            _18365 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _18365 + 68] = mem[idx + _17678 + 32]
                                idx = idx + 32
                                continue 
                            mem[_18365 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _18365 + -mem[64] + 100
                        if (arg1 * stor25 / 100) + (arg1 * stor30 / 100) and stor11 / totalSupply > -1 / (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                            revert with 0, 17
                        if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                            revert with 0, 18
                        if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) / (arg1 * stor25 / 100) + (arg1 * stor30 / 100) != stor11 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _16874 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_16874] = 30
                        mem[_16874 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor19 / 100 * stor11 / totalSupply > arg1 * stor11 / totalSupply:
                            _17677 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _17677 + 68] = mem[idx + _16874 + 32]
                                idx = idx + 32
                                continue 
                            mem[_17677 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _17677 + -mem[64] + 100
                        if arg1 * stor11 / totalSupply < arg1 * stor19 / 100 * stor11 / totalSupply:
                            revert with 0, 17
                        _19930 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19930] = 30
                        mem[_19930 + 32] = 'SafeMath: subtraction overflow'
                        if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) <= (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply):
                            if (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply) < (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply):
                                revert with 0, 17
                            return (arg1 * stor11 / totalSupply)
                        _20325 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _20325 + 68] = mem[idx + _19930 + 32]
                            idx = idx + 32
                            continue 
                        mem[_20325 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _20325 + -mem[64] + 100
                else:
                    if arg1 and stor35 > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * stor35 / arg1 != stor35:
                        revert with 0, 'SafeMath: multiplication overflow'
                    mem[288] = 26
                    mem[320] = 'SafeMath: division by zero'
                    if arg1 * stor25 / 100 > !(arg1 * stor30 / 100):
                        revert with 0, 17
                    if (arg1 * stor25 / 100) + (arg1 * stor30 / 100) < arg1 * stor25 / 100:
                        revert with 0, 'SafeMath: addition overflow'
                    mem[352] = 30
                    mem[384] = 'SafeMath: subtraction overflow'
                    if arg1 * stor19 / 100 > arg1:
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 < arg1 * stor19 / 100:
                        revert with 0, 17
                    mem[416] = 30
                    mem[448] = 'SafeMath: subtraction overflow'
                    if (arg1 * stor25 / 100) + (arg1 * stor30 / 100) > arg1 - (arg1 * stor19 / 100):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 - (arg1 * stor19 / 100) < (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                        revert with 0, 17
                    mem[64] = 544
                    mem[480] = 30
                    mem[512] = 'SafeMath: subtraction overflow'
                    if arg1 * stor35 / 100 > arg1 - (arg1 * stor19 / 100) - (arg1 * stor25 / 100) - (arg1 * stor30 / 100):
                        revert with 0, 'SafeMath: subtraction overflow', 0
                    if arg1 - (arg1 * stor19 / 100) - (arg1 * stor25 / 100) - (arg1 * stor30 / 100) < arg1 * stor35 / 100:
                        revert with 0, 17
                    if arg1 * stor25 / 100 > !(arg1 * stor30 / 100):
                        revert with 0, 17
                    if (arg1 * stor25 / 100) + (arg1 * stor30 / 100) < arg1 * stor25 / 100:
                        revert with 0, 'SafeMath: addition overflow'
                    idx = 0
                    s = totalSupply
                    t = stor11
                    while idx < stor9.length:
                        mem[0] = stor9[idx]
                        mem[32] = 1
                        if stor1[stor9[idx]] > t:
                            _11645 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11645] = 26
                            mem[_11645 + 32] = 'SafeMath: division by zero'
                            if not totalSupply:
                                _11805 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 26
                                idx = 0
                                while idx < 26:
                                    mem[idx + _11805 + 68] = mem[idx + _11645 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11805 + 94] = 0
                                revert with memory
                                  from mem[64]
                                   len _11805 + -mem[64] + 100
                            if not arg1:
                                if not arg1 * stor19 / 100:
                                    if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                                        return 0
                                    if (arg1 * stor25 / 100) + (arg1 * stor30 / 100) and stor11 / totalSupply > -1 / (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                                        revert with 0, 17
                                    if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                                        revert with 0, 18
                                    if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) / (arg1 * stor25 / 100) + (arg1 * stor30 / 100) != stor11 / totalSupply:
                                        revert with 0, 'SafeMath: multiplication overflow'
                                    _13548 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13548] = 30
                                    mem[_13548 + 32] = 'SafeMath: subtraction overflow'
                                    _14926 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14926] = 30
                                    mem[_14926 + 32] = 'SafeMath: subtraction overflow'
                                    if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) <= 0:
                                        if 0 < (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply):
                                            revert with 0, 17
                                        else:
                                            return 0
                                    _15472 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _15472 + 68] = mem[idx + _14926 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_15472 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _15472 + -mem[64] + 100
                                if arg1 * stor19 / 100 and stor11 / totalSupply > -1 / arg1 * stor19 / 100:
                                    revert with 0, 17
                                if not arg1 * stor19 / 100:
                                    revert with 0, 18
                                if arg1 * stor19 / 100 * stor11 / totalSupply / arg1 * stor19 / 100 != stor11 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                                    _13547 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13547] = 30
                                    mem[_13547 + 32] = 'SafeMath: subtraction overflow'
                                    if arg1 * stor19 / 100 * stor11 / totalSupply > 0:
                                        _13802 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _13802 + 68] = mem[idx + _13547 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13802 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _13802 + -mem[64] + 100
                                    if 0 < arg1 * stor19 / 100 * stor11 / totalSupply:
                                        revert with 0, 17
                                    _14924 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14924] = 30
                                    mem[_14924 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= -1 * arg1 * stor19 / 100 * stor11 / totalSupply:
                                        if -1 * arg1 * stor19 / 100 * stor11 / totalSupply < 0:
                                            revert with 0, 17
                                        else:
                                            return 0
                                    _15471 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _15471 + 68] = mem[idx + _14924 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_15471 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _15471 + -mem[64] + 100
                                if (arg1 * stor25 / 100) + (arg1 * stor30 / 100) and stor11 / totalSupply > -1 / (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                                    revert with 0, 17
                                if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                                    revert with 0, 18
                                if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) / (arg1 * stor25 / 100) + (arg1 * stor30 / 100) != stor11 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _14435 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14435] = 30
                                mem[_14435 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * stor19 / 100 * stor11 / totalSupply > 0:
                                    _14923 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _14923 + 68] = mem[idx + _14435 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14923 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14923 + -mem[64] + 100
                                if 0 < arg1 * stor19 / 100 * stor11 / totalSupply:
                                    revert with 0, 17
                                _16846 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16846] = 30
                                mem[_16846 + 32] = 'SafeMath: subtraction overflow'
                                if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) <= -1 * arg1 * stor19 / 100 * stor11 / totalSupply:
                                    if -1 * arg1 * stor19 / 100 * stor11 / totalSupply < (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply):
                                        revert with 0, 17
                                    else:
                                        return 0
                                _17652 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _17652 + 68] = mem[idx + _16846 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_17652 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _17652 + -mem[64] + 100
                            if arg1 and stor11 / totalSupply > -1 / arg1:
                                revert with 0, 17
                            if not arg1:
                                revert with 0, 18
                            if arg1 * stor11 / totalSupply / arg1 != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not arg1 * stor19 / 100:
                                if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                                    _13546 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_13546] = 30
                                    mem[_13546 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 > arg1 * stor11 / totalSupply:
                                        _13801 = mem[64]
                                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                        mem[mem[64] + 4] = 32
                                        mem[mem[64] + 36] = 30
                                        idx = 0
                                        while idx < 30:
                                            mem[idx + _13801 + 68] = mem[idx + _13546 + 32]
                                            idx = idx + 32
                                            continue 
                                        mem[_13801 + 98] = 0
                                        revert with memory
                                          from mem[64]
                                           len _13801 + -mem[64] + 100
                                    if arg1 * stor11 / totalSupply < 0:
                                        revert with 0, 17
                                    _14921 = mem[64]
                                    mem[64] = mem[64] + 64
                                    mem[_14921] = 30
                                    mem[_14921 + 32] = 'SafeMath: subtraction overflow'
                                    if 0 <= arg1 * stor11 / totalSupply:
                                        if arg1 * stor11 / totalSupply < 0:
                                            revert with 0, 17
                                        return (arg1 * stor11 / totalSupply)
                                    _15470 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _15470 + 68] = mem[idx + _14921 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_15470 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _15470 + -mem[64] + 100
                                if (arg1 * stor25 / 100) + (arg1 * stor30 / 100) and stor11 / totalSupply > -1 / (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                                    revert with 0, 17
                                if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                                    revert with 0, 18
                                if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) / (arg1 * stor25 / 100) + (arg1 * stor30 / 100) != stor11 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _14434 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14434] = 30
                                mem[_14434 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor11 / totalSupply:
                                    _14920 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _14920 + 68] = mem[idx + _14434 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14920 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14920 + -mem[64] + 100
                                if arg1 * stor11 / totalSupply < 0:
                                    revert with 0, 17
                                _16844 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16844] = 30
                                mem[_16844 + 32] = 'SafeMath: subtraction overflow'
                                if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) <= arg1 * stor11 / totalSupply:
                                    if arg1 * stor11 / totalSupply < (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply):
                                        revert with 0, 17
                                    return (arg1 * stor11 / totalSupply)
                                _17650 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _17650 + 68] = mem[idx + _16844 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_17650 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _17650 + -mem[64] + 100
                            if arg1 * stor19 / 100 and stor11 / totalSupply > -1 / arg1 * stor19 / 100:
                                revert with 0, 17
                            if not arg1 * stor19 / 100:
                                revert with 0, 18
                            if arg1 * stor19 / 100 * stor11 / totalSupply / arg1 * stor19 / 100 != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                                _14433 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_14433] = 30
                                mem[_14433 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * stor19 / 100 * stor11 / totalSupply > arg1 * stor11 / totalSupply:
                                    _14919 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _14919 + 68] = mem[idx + _14433 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14919 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14919 + -mem[64] + 100
                                if arg1 * stor11 / totalSupply < arg1 * stor19 / 100 * stor11 / totalSupply:
                                    revert with 0, 17
                                _16842 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_16842] = 30
                                mem[_16842 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply):
                                    if (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply) < 0:
                                        revert with 0, 17
                                    return (arg1 * stor11 / totalSupply)
                                _17649 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _17649 + 68] = mem[idx + _16842 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_17649 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _17649 + -mem[64] + 100
                            if (arg1 * stor25 / 100) + (arg1 * stor30 / 100) and stor11 / totalSupply > -1 / (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                                revert with 0, 17
                            if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                                revert with 0, 18
                            if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) / (arg1 * stor25 / 100) + (arg1 * stor30 / 100) != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _16091 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_16091] = 30
                            mem[_16091 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor19 / 100 * stor11 / totalSupply > arg1 * stor11 / totalSupply:
                                _16841 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _16841 + 68] = mem[idx + _16091 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_16841 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _16841 + -mem[64] + 100
                            if arg1 * stor11 / totalSupply < arg1 * stor19 / 100 * stor11 / totalSupply:
                                revert with 0, 17
                            _19153 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_19153] = 30
                            mem[_19153 + 32] = 'SafeMath: subtraction overflow'
                            if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) <= (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply):
                                if (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply) < (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply):
                                    revert with 0, 17
                                return (arg1 * stor11 / totalSupply)
                            _19905 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _19905 + 68] = mem[idx + _19153 + 32]
                                idx = idx + 32
                                continue 
                            mem[_19905 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _19905 + -mem[64] + 100
                        if idx >= stor9.length:
                            revert with 0, 50
                        mem[0] = stor9[idx]
                        mem[32] = 2
                        if stor2[stor9[idx]] <= s:
                            if idx >= stor9.length:
                                revert with 0, 50
                            mem[0] = stor9[idx]
                            mem[32] = 1
                            _11806 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_11806] = 30
                            mem[_11806 + 32] = 'SafeMath: subtraction overflow'
                            if stor1[stor9[idx]] > t:
                                _11966 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _11966 + 68] = mem[idx + _11806 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_11966 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _11966 + -mem[64] + 100
                            if t < stor1[stor9[idx]]:
                                revert with 0, 17
                            if idx >= stor9.length:
                                revert with 0, 50
                            mem[0] = stor9[idx]
                            mem[32] = 2
                            _12671 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_12671] = 30
                            mem[_12671 + 32] = 'SafeMath: subtraction overflow'
                            if stor2[stor9[idx]] <= s:
                                if s < stor2[stor9[idx]]:
                                    revert with 0, 17
                                if idx == -1:
                                    revert with 0, 17
                                idx = idx + 1
                                s = s - stor2[stor9[idx]]
                                t = t - stor1[stor9[idx]]
                                continue 
                            _12767 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _12767 + 68] = mem[idx + _12671 + 32]
                                idx = idx + 32
                                continue 
                            mem[_12767 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _12767 + -mem[64] + 100
                        _11807 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_11807] = 26
                        mem[_11807 + 32] = 'SafeMath: division by zero'
                        if not totalSupply:
                            _11967 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 26
                            idx = 0
                            while idx < 26:
                                mem[idx + _11967 + 68] = mem[idx + _11807 + 32]
                                idx = idx + 32
                                continue 
                            mem[_11967 + 94] = 0
                            revert with memory
                              from mem[64]
                               len _11967 + -mem[64] + 100
                        if not arg1:
                            if not arg1 * stor19 / 100:
                                if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                                    return 0
                                if (arg1 * stor25 / 100) + (arg1 * stor30 / 100) and stor11 / totalSupply > -1 / (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                                    revert with 0, 17
                                if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                                    revert with 0, 18
                                if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) / (arg1 * stor25 / 100) + (arg1 * stor30 / 100) != stor11 / totalSupply:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                _13807 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13807] = 30
                                mem[_13807 + 32] = 'SafeMath: subtraction overflow'
                                _15480 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15480] = 30
                                mem[_15480 + 32] = 'SafeMath: subtraction overflow'
                                if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) <= 0:
                                    if 0 < (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply):
                                        revert with 0, 17
                                    else:
                                        return 0
                                _16095 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _16095 + 68] = mem[idx + _15480 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_16095 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _16095 + -mem[64] + 100
                            if arg1 * stor19 / 100 and stor11 / totalSupply > -1 / arg1 * stor19 / 100:
                                revert with 0, 17
                            if not arg1 * stor19 / 100:
                                revert with 0, 18
                            if arg1 * stor19 / 100 * stor11 / totalSupply / arg1 * stor19 / 100 != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                                _13806 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13806] = 30
                                mem[_13806 + 32] = 'SafeMath: subtraction overflow'
                                if arg1 * stor19 / 100 * stor11 / totalSupply > 0:
                                    _14036 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _14036 + 68] = mem[idx + _13806 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14036 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14036 + -mem[64] + 100
                                if 0 < arg1 * stor19 / 100 * stor11 / totalSupply:
                                    revert with 0, 17
                                _15478 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15478] = 30
                                mem[_15478 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= -1 * arg1 * stor19 / 100 * stor11 / totalSupply:
                                    if -1 * arg1 * stor19 / 100 * stor11 / totalSupply < 0:
                                        revert with 0, 17
                                    else:
                                        return 0
                                _16094 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _16094 + 68] = mem[idx + _15478 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_16094 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _16094 + -mem[64] + 100
                            if (arg1 * stor25 / 100) + (arg1 * stor30 / 100) and stor11 / totalSupply > -1 / (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                                revert with 0, 17
                            if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                                revert with 0, 18
                            if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) / (arg1 * stor25 / 100) + (arg1 * stor30 / 100) != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _14929 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14929] = 30
                            mem[_14929 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor19 / 100 * stor11 / totalSupply > 0:
                                _15477 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _15477 + 68] = mem[idx + _14929 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15477 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _15477 + -mem[64] + 100
                            if 0 < arg1 * stor19 / 100 * stor11 / totalSupply:
                                revert with 0, 17
                            _17660 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_17660] = 30
                            mem[_17660 + 32] = 'SafeMath: subtraction overflow'
                            if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) <= -1 * arg1 * stor19 / 100 * stor11 / totalSupply:
                                if -1 * arg1 * stor19 / 100 * stor11 / totalSupply < (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply):
                                    revert with 0, 17
                                else:
                                    return 0
                            _18360 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _18360 + 68] = mem[idx + _17660 + 32]
                                idx = idx + 32
                                continue 
                            mem[_18360 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _18360 + -mem[64] + 100
                        if arg1 and stor11 / totalSupply > -1 / arg1:
                            revert with 0, 17
                        if not arg1:
                            revert with 0, 18
                        if arg1 * stor11 / totalSupply / arg1 != stor11 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not arg1 * stor19 / 100:
                            if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                                _13805 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_13805] = 30
                                mem[_13805 + 32] = 'SafeMath: subtraction overflow'
                                if 0 > arg1 * stor11 / totalSupply:
                                    _14035 = mem[64]
                                    mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                    mem[mem[64] + 4] = 32
                                    mem[mem[64] + 36] = 30
                                    idx = 0
                                    while idx < 30:
                                        mem[idx + _14035 + 68] = mem[idx + _13805 + 32]
                                        idx = idx + 32
                                        continue 
                                    mem[_14035 + 98] = 0
                                    revert with memory
                                      from mem[64]
                                       len _14035 + -mem[64] + 100
                                if arg1 * stor11 / totalSupply < 0:
                                    revert with 0, 17
                                _15475 = mem[64]
                                mem[64] = mem[64] + 64
                                mem[_15475] = 30
                                mem[_15475 + 32] = 'SafeMath: subtraction overflow'
                                if 0 <= arg1 * stor11 / totalSupply:
                                    if arg1 * stor11 / totalSupply < 0:
                                        revert with 0, 17
                                    return (arg1 * stor11 / totalSupply)
                                _16093 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _16093 + 68] = mem[idx + _15475 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_16093 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _16093 + -mem[64] + 100
                            if (arg1 * stor25 / 100) + (arg1 * stor30 / 100) and stor11 / totalSupply > -1 / (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                                revert with 0, 17
                            if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                                revert with 0, 18
                            if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) / (arg1 * stor25 / 100) + (arg1 * stor30 / 100) != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            _14928 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14928] = 30
                            mem[_14928 + 32] = 'SafeMath: subtraction overflow'
                            if 0 > arg1 * stor11 / totalSupply:
                                _15474 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _15474 + 68] = mem[idx + _14928 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15474 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _15474 + -mem[64] + 100
                            if arg1 * stor11 / totalSupply < 0:
                                revert with 0, 17
                            _17658 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_17658] = 30
                            mem[_17658 + 32] = 'SafeMath: subtraction overflow'
                            if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) <= arg1 * stor11 / totalSupply:
                                if arg1 * stor11 / totalSupply < (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply):
                                    revert with 0, 17
                                return (arg1 * stor11 / totalSupply)
                            _18358 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _18358 + 68] = mem[idx + _17658 + 32]
                                idx = idx + 32
                                continue 
                            mem[_18358 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _18358 + -mem[64] + 100
                        if arg1 * stor19 / 100 and stor11 / totalSupply > -1 / arg1 * stor19 / 100:
                            revert with 0, 17
                        if not arg1 * stor19 / 100:
                            revert with 0, 18
                        if arg1 * stor19 / 100 * stor11 / totalSupply / arg1 * stor19 / 100 != stor11 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                            _14927 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_14927] = 30
                            mem[_14927 + 32] = 'SafeMath: subtraction overflow'
                            if arg1 * stor19 / 100 * stor11 / totalSupply > arg1 * stor11 / totalSupply:
                                _15473 = mem[64]
                                mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                                mem[mem[64] + 4] = 32
                                mem[mem[64] + 36] = 30
                                idx = 0
                                while idx < 30:
                                    mem[idx + _15473 + 68] = mem[idx + _14927 + 32]
                                    idx = idx + 32
                                    continue 
                                mem[_15473 + 98] = 0
                                revert with memory
                                  from mem[64]
                                   len _15473 + -mem[64] + 100
                            if arg1 * stor11 / totalSupply < arg1 * stor19 / 100 * stor11 / totalSupply:
                                revert with 0, 17
                            _17656 = mem[64]
                            mem[64] = mem[64] + 64
                            mem[_17656] = 30
                            mem[_17656 + 32] = 'SafeMath: subtraction overflow'
                            if 0 <= (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply):
                                if (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply) < 0:
                                    revert with 0, 17
                                return (arg1 * stor11 / totalSupply)
                            _18357 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _18357 + 68] = mem[idx + _17656 + 32]
                                idx = idx + 32
                                continue 
                            mem[_18357 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _18357 + -mem[64] + 100
                        if (arg1 * stor25 / 100) + (arg1 * stor30 / 100) and stor11 / totalSupply > -1 / (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                            revert with 0, 17
                        if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                            revert with 0, 18
                        if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) / (arg1 * stor25 / 100) + (arg1 * stor30 / 100) != stor11 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        _16849 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_16849] = 30
                        mem[_16849 + 32] = 'SafeMath: subtraction overflow'
                        if arg1 * stor19 / 100 * stor11 / totalSupply > arg1 * stor11 / totalSupply:
                            _17655 = mem[64]
                            mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                            mem[mem[64] + 4] = 32
                            mem[mem[64] + 36] = 30
                            idx = 0
                            while idx < 30:
                                mem[idx + _17655 + 68] = mem[idx + _16849 + 32]
                                idx = idx + 32
                                continue 
                            mem[_17655 + 98] = 0
                            revert with memory
                              from mem[64]
                               len _17655 + -mem[64] + 100
                        if arg1 * stor11 / totalSupply < arg1 * stor19 / 100 * stor11 / totalSupply:
                            revert with 0, 17
                        _19909 = mem[64]
                        mem[64] = mem[64] + 64
                        mem[_19909] = 30
                        mem[_19909 + 32] = 'SafeMath: subtraction overflow'
                        if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) <= (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply):
                            if (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply) < (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply):
                                revert with 0, 17
                            return (arg1 * stor11 / totalSupply)
                        _20321 = mem[64]
                        mem[mem[64]] = 0x8c379a000000000000000000000000000000000000000000000000000000000
                        mem[mem[64] + 4] = 32
                        mem[mem[64] + 36] = 30
                        idx = 0
                        while idx < 30:
                            mem[idx + _20321 + 68] = mem[idx + _19909 + 32]
                            idx = idx + 32
                            continue 
                        mem[_20321 + 98] = 0
                        revert with memory
                          from mem[64]
                           len _20321 + -mem[64] + 100
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if t >= stor11 / totalSupply:
                    if not s:
                        revert with 0, 'SafeMath: division by zero', 0
                    if not arg1:
                        if not arg1 * stor19 / 100:
                            if (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                                if (arg1 * stor25 / 100) + (arg1 * stor30 / 100) and t / s > -1 / (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                                    revert with 0, 17
                                if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                                    revert with 0, 18
                                if (arg1 * stor25 / 100 * t / s) + (arg1 * stor30 / 100 * t / s) / (arg1 * stor25 / 100) + (arg1 * stor30 / 100) != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if (arg1 * stor25 / 100 * t / s) + (arg1 * stor30 / 100 * t / s) > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < (arg1 * stor25 / 100 * t / s) + (arg1 * stor30 / 100 * t / s):
                                    revert with 0, 17
                        else:
                            if arg1 * stor19 / 100 and t / s > -1 / arg1 * stor19 / 100:
                                revert with 0, 17
                            if not arg1 * stor19 / 100:
                                revert with 0, 18
                            if arg1 * stor19 / 100 * t / s / arg1 * stor19 / 100 != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                                if arg1 * stor19 / 100 * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * stor19 / 100 * t / s:
                                    revert with 0, 17
                                if 0 > -1 * arg1 * stor19 / 100 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * stor19 / 100 * t / s < 0:
                                    revert with 0, 17
                            else:
                                if (arg1 * stor25 / 100) + (arg1 * stor30 / 100) and t / s > -1 / (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                                    revert with 0, 17
                                if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                                    revert with 0, 18
                                if (arg1 * stor25 / 100 * t / s) + (arg1 * stor30 / 100 * t / s) / (arg1 * stor25 / 100) + (arg1 * stor30 / 100) != t / s:
                                    revert with 0, 'SafeMath: multiplication overflow'
                                if arg1 * stor19 / 100 * t / s > 0:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if 0 < arg1 * stor19 / 100 * t / s:
                                    revert with 0, 17
                                if (arg1 * stor25 / 100 * t / s) + (arg1 * stor30 / 100 * t / s) > -1 * arg1 * stor19 / 100 * t / s:
                                    revert with 0, 'SafeMath: subtraction overflow', 0
                                if -1 * arg1 * stor19 / 100 * t / s < (arg1 * stor25 / 100 * t / s) + (arg1 * stor30 / 100 * t / s):
                                    revert with 0, 17
                        return 0
                    if arg1 and t / s > -1 / arg1:
                        revert with 0, 17
                    if not arg1:
                        revert with 0, 18
                    if arg1 * t / s / arg1 != t / s:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not arg1 * stor19 / 100:
                        if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                        else:
                            if (arg1 * stor25 / 100) + (arg1 * stor30 / 100) and t / s > -1 / (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                                revert with 0, 17
                            if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                                revert with 0, 18
                            if (arg1 * stor25 / 100 * t / s) + (arg1 * stor30 / 100 * t / s) / (arg1 * stor25 / 100) + (arg1 * stor30 / 100) != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if 0 > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < 0:
                                revert with 0, 17
                            if (arg1 * stor25 / 100 * t / s) + (arg1 * stor30 / 100 * t / s) > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < (arg1 * stor25 / 100 * t / s) + (arg1 * stor30 / 100 * t / s):
                                revert with 0, 17
                    else:
                        if arg1 * stor19 / 100 and t / s > -1 / arg1 * stor19 / 100:
                            revert with 0, 17
                        if not arg1 * stor19 / 100:
                            revert with 0, 18
                        if arg1 * stor19 / 100 * t / s / arg1 * stor19 / 100 != t / s:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                            if arg1 * stor19 / 100 * t / s > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < arg1 * stor19 / 100 * t / s:
                                revert with 0, 17
                            if 0 > (arg1 * t / s) - (arg1 * stor19 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (arg1 * stor19 / 100 * t / s) < 0:
                                revert with 0, 17
                        else:
                            if (arg1 * stor25 / 100) + (arg1 * stor30 / 100) and t / s > -1 / (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                                revert with 0, 17
                            if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                                revert with 0, 18
                            if (arg1 * stor25 / 100 * t / s) + (arg1 * stor30 / 100 * t / s) / (arg1 * stor25 / 100) + (arg1 * stor30 / 100) != t / s:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * stor19 / 100 * t / s > arg1 * t / s:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if arg1 * t / s < arg1 * stor19 / 100 * t / s:
                                revert with 0, 17
                            if (arg1 * stor25 / 100 * t / s) + (arg1 * stor30 / 100 * t / s) > (arg1 * t / s) - (arg1 * stor19 / 100 * t / s):
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if (arg1 * t / s) - (arg1 * stor19 / 100 * t / s) < (arg1 * stor25 / 100 * t / s) + (arg1 * stor30 / 100 * t / s):
                                revert with 0, 17
                    return (arg1 * t / s)
                if not totalSupply:
                    revert with 0, 'SafeMath: division by zero', 0
                if not arg1:
                    if not arg1 * stor19 / 100:
                        if (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                            if (arg1 * stor25 / 100) + (arg1 * stor30 / 100) and stor11 / totalSupply > -1 / (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                                revert with 0, 17
                            if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                                revert with 0, 18
                            if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) / (arg1 * stor25 / 100) + (arg1 * stor30 / 100) != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply):
                                revert with 0, 17
                    else:
                        if arg1 * stor19 / 100 and stor11 / totalSupply > -1 / arg1 * stor19 / 100:
                            revert with 0, 17
                        if not arg1 * stor19 / 100:
                            revert with 0, 18
                        if arg1 * stor19 / 100 * stor11 / totalSupply / arg1 * stor19 / 100 != stor11 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                            if arg1 * stor19 / 100 * stor11 / totalSupply > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * stor19 / 100 * stor11 / totalSupply:
                                revert with 0, 17
                            if 0 > -1 * arg1 * stor19 / 100 * stor11 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * stor19 / 100 * stor11 / totalSupply < 0:
                                revert with 0, 17
                        else:
                            if (arg1 * stor25 / 100) + (arg1 * stor30 / 100) and stor11 / totalSupply > -1 / (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                                revert with 0, 17
                            if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                                revert with 0, 18
                            if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) / (arg1 * stor25 / 100) + (arg1 * stor30 / 100) != stor11 / totalSupply:
                                revert with 0, 'SafeMath: multiplication overflow'
                            if arg1 * stor19 / 100 * stor11 / totalSupply > 0:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if 0 < arg1 * stor19 / 100 * stor11 / totalSupply:
                                revert with 0, 17
                            if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) > -1 * arg1 * stor19 / 100 * stor11 / totalSupply:
                                revert with 0, 'SafeMath: subtraction overflow', 0
                            if -1 * arg1 * stor19 / 100 * stor11 / totalSupply < (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply):
                                revert with 0, 17
                    return 0
                if arg1 and stor11 / totalSupply > -1 / arg1:
                    revert with 0, 17
                if not arg1:
                    revert with 0, 18
                if arg1 * stor11 / totalSupply / arg1 != stor11 / totalSupply:
                    revert with 0, 'SafeMath: multiplication overflow'
                if not arg1 * stor19 / 100:
                    if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                        if 0 > arg1 * stor11 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor11 / totalSupply < 0:
                            revert with 0, 17
                        if 0 > arg1 * stor11 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor11 / totalSupply < 0:
                            revert with 0, 17
                    else:
                        if (arg1 * stor25 / 100) + (arg1 * stor30 / 100) and stor11 / totalSupply > -1 / (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                            revert with 0, 17
                        if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                            revert with 0, 18
                        if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) / (arg1 * stor25 / 100) + (arg1 * stor30 / 100) != stor11 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if 0 > arg1 * stor11 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor11 / totalSupply < 0:
                            revert with 0, 17
                        if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) > arg1 * stor11 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor11 / totalSupply < (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply):
                            revert with 0, 17
                else:
                    if arg1 * stor19 / 100 and stor11 / totalSupply > -1 / arg1 * stor19 / 100:
                        revert with 0, 17
                    if not arg1 * stor19 / 100:
                        revert with 0, 18
                    if arg1 * stor19 / 100 * stor11 / totalSupply / arg1 * stor19 / 100 != stor11 / totalSupply:
                        revert with 0, 'SafeMath: multiplication overflow'
                    if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                        if arg1 * stor19 / 100 * stor11 / totalSupply > arg1 * stor11 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor11 / totalSupply < arg1 * stor19 / 100 * stor11 / totalSupply:
                            revert with 0, 17
                        if 0 > (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply) < 0:
                            revert with 0, 17
                    else:
                        if (arg1 * stor25 / 100) + (arg1 * stor30 / 100) and stor11 / totalSupply > -1 / (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                            revert with 0, 17
                        if not (arg1 * stor25 / 100) + (arg1 * stor30 / 100):
                            revert with 0, 18
                        if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) / (arg1 * stor25 / 100) + (arg1 * stor30 / 100) != stor11 / totalSupply:
                            revert with 0, 'SafeMath: multiplication overflow'
                        if arg1 * stor19 / 100 * stor11 / totalSupply > arg1 * stor11 / totalSupply:
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if arg1 * stor11 / totalSupply < arg1 * stor19 / 100 * stor11 / totalSupply:
                            revert with 0, 17
                        if (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply) > (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply):
                            revert with 0, 'SafeMath: subtraction overflow', 0
                        if (arg1 * stor11 / totalSupply) - (arg1 * stor19 / 100 * stor11 / totalSupply) < (arg1 * stor25 / 100 * stor11 / totalSupply) + (arg1 * stor30 / 100 * stor11 / totalSupply):
                            revert with 0, 17
    return (arg1 * stor11 / totalSupply)
}



}
